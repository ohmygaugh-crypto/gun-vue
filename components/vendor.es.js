var style = "";
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list3 = str.split(",");
  for (let i2 = 0; i2 < list3.length; i2++) {
    map2[list3[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$3(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$5(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$5(value)) {
    return value;
  } else if (isObject$4(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$5(value)) {
    res = value;
  } else if (isArray$3(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style: style2 } = props;
  if (klass && !isString$5(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style2) {
    props.style = normalizeStyle(style2);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
function looseCompareArrays(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a2.length; i2++) {
    equal = looseEqual(a2[i2], b2[i2]);
  }
  return equal;
}
function looseEqual(a2, b2) {
  if (a2 === b2)
    return true;
  let aValidType = isDate$1(a2);
  let bValidType = isDate$1(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol$1(a2);
  bValidType = isSymbol$1(b2);
  if (aValidType || bValidType) {
    return a2 === b2;
  }
  aValidType = isArray$3(a2);
  bValidType = isArray$3(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
  }
  aValidType = isObject$4(a2);
  bValidType = isObject$4(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a2) {
      const aHasKey = a2.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a2) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString$5(val) ? val : val == null ? "" : isArray$3(val) || isObject$4(val) && (val.toString === objectToString$1 || !isFunction$3(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$1(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$4(val) && !isArray$3(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$3 = Object.assign;
const remove$2 = (arr, el2) => {
  const i2 = arr.indexOf(el2);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty.call(val, key);
const isArray$3 = Array.isArray;
const isMap$1 = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate$1 = (val) => toTypeString(val) === "[object Date]";
const isFunction$3 = (val) => typeof val === "function";
const isString$5 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$4(val) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$5(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber$1 = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function warn$4(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else {
      warn$4(`cannot run an inactive effect scope.`);
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else {
    warn$4(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target2, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target2);
    if (!depsMap) {
      targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = { effect: activeEffect, target: target2, type, key };
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target2, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target2);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$3(target2)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$3(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$3(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$1(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$1(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = { target: target2, type, key, newValue, oldValue, oldTarget };
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0], eventInfo);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects), eventInfo);
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$3(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.onTrigger) {
      effect.onTrigger(extend$3({ effect }, debuggerEventExtraInfo));
    }
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1));
const get$4 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target2, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target2)) {
      return target2;
    }
    const targetIsArray = isArray$3(target2);
    if (!isReadonly2 && targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target2, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target2, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$5 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set3(target2, key, value, receiver) {
    let oldValue = target2[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow$1(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray$3(target2) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$3(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn$1(target2, key);
    const result = Reflect.set(target2, key, value, receiver);
    if (target2 === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target2, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target2, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target2, key) {
  const hadKey = hasOwn$1(target2, key);
  const oldValue = target2[key];
  const result = Reflect.deleteProperty(target2, key);
  if (result && hadKey) {
    trigger(target2, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target2, key) {
  const result = Reflect.has(target2, key);
  if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
    track(target2, "has", key);
  }
  return result;
}
function ownKeys$1(target2) {
  track(target2, "iterate", isArray$3(target2) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target2);
}
const mutableHandlers = {
  get: get$4,
  set: set$5,
  deleteProperty,
  has: has$1,
  ownKeys: ownKeys$1
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target2, key) {
    {
      warn$4(`Set operation on key "${String(key)}" failed: target is readonly.`, target2);
    }
    return true;
  },
  deleteProperty(target2, key) {
    {
      warn$4(`Delete operation on key "${String(key)}" failed: target is readonly.`, target2);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$3({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend$3({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1$2(target2, key, isReadonly2 = false, isShallow2 = false) {
  target2 = target2["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
  if (has2.call(rawTarget, key)) {
    return wrap2(target2.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target2.get(rawKey));
  } else if (target2 !== rawTarget) {
    target2.get(key);
  }
}
function has$1$1(key, isReadonly2 = false) {
  const target2 = this["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
}
function size$2(target2, isReadonly2 = false) {
  target2 = target2["__v_raw"];
  !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
  return Reflect.get(target2, "size", target2);
}
function add$5(value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const proto2 = getProto(target2);
  const hadKey = proto2.has.call(target2, value);
  if (!hadKey) {
    target2.add(value);
    trigger(target2, "add", value, value);
  }
  return this;
}
function set$1$2(key, value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  } else {
    checkIdentityKeys(target2, has2, key);
  }
  const oldValue = get2.call(target2, key);
  target2.set(key, value);
  if (!hadKey) {
    trigger(target2, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target2, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  } else {
    checkIdentityKeys(target2, has2, key);
  }
  const oldValue = get2 ? get2.call(target2, key) : void 0;
  const result = target2.delete(key);
  if (hadKey) {
    trigger(target2, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target2 = toRaw(this);
  const hadItems = target2.size !== 0;
  const oldTarget = isMap$1(target2) ? new Map(target2) : new Set(target2);
  const result = target2.clear();
  if (hadItems) {
    trigger(target2, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target2 = observed["__v_raw"];
    const rawTarget = toRaw(target2);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target2.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const targetIsMap = isMap$1(rawTarget);
    const isPair2 = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target2[method](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair2 ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$2(this, key);
    },
    get size() {
      return size$2(this);
    },
    has: has$1$1,
    add: add$5,
    set: set$1$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$2(this, key, false, true);
    },
    get size() {
      return size$2(this);
    },
    has: has$1$1,
    add: add$5,
    set: set$1$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$2(this, key, true);
    },
    get size() {
      return size$2(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$2(this, key, true, true);
    },
    get size() {
      return size$2(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target2, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target2;
    }
    return Reflect.get(hasOwn$1(instrumentations, key) && key in target2 ? instrumentations : target2, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target2, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target2, rawKey)) {
    const type = toRawType(target2);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target2) {
  if (isReadonly(target2)) {
    return target2;
  }
  return createReactiveObject(target2, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target2) {
  return createReactiveObject(target2, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target2) {
  return createReactiveObject(target2, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target2) {
  return createReactiveObject(target2, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target2)) {
    {
      console.warn(`value cannot be made reactive: ${String(target2)}`);
    }
    return target2;
  }
  if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
    return target2;
  }
  const existingProxy = proxyMap.get(target2);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target2);
  if (targetType === 0) {
    return target2;
  }
  const proxy = new Proxy(target2, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target2, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow$1(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive$1 = (value) => isObject$4(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive$1(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive$1(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target2, key, receiver) => unref(Reflect.get(target2, key, receiver)),
  set: (target2, key, value, receiver) => {
    const oldValue = target2[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target2, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  if (!isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray$3(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$3(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      console.warn("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$3(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
}
function formatProps(props) {
  const res = [];
  const keys2 = Object.keys(props);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$5(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$3(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$3(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings[type];
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$3(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start2 = flushIndex + 1;
  let end = queue.length;
  while (start2 < end) {
    const middle = start2 + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start2 = middle + 1 : end = middle;
  }
  return start2;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray$3(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
        continue;
      }
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  flushPreFlushCbs();
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  flushPreFlushCbs(seen);
  queue.sort((a2, b2) => getId(a2) - getId(b2));
  const check2 = (job) => checkRecursiveUpdates(seen, job);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (check2(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count2 = seen.get(fn);
    if (count2 > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn$3(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count2 + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
{
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map$4 = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id2 = instance.type.__hmrId;
  let record = map$4.get(id2);
  if (!record) {
    createRecord(id2, instance.type);
    record = map$4.get(id2);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map$4.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id2, initialDef) {
  if (map$4.has(id2)) {
    return false;
  }
  map$4.set(id2, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id2, newRender) {
  const record = map$4.get(id2);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id2, newComp) {
  const record = map$4.get(id2);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      queueJob(instance.parent.update);
      if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
        instance.parent.ceReload(newComp.styles);
      }
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend$3(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id2, arg) => {
    try {
      return fn(id2, arg);
    } catch (e2) {
      console.error(e2);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer$1 = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer$1.push({ event, args });
  }
}
function setDevtoolsHook(hook, target2) {
  var _a2, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer$1.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer$1 = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a2 = window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target2);
    });
    setTimeout(() => {
      if (!devtools) {
        target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer$1 = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer$1 = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit("app:init", app, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit("app:unmount", app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
const devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit("component:emit", component.appContext.app, component, event, params);
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  {
    const { emitsOptions, propsOptions: [propsOptions] } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn$3(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction$3(validator)) {
          const isValid2 = validator(...rawArgs);
          if (!isValid2) {
            warn$3(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a2) => a2.trim());
    }
    if (number) {
      args = rawArgs.map(toNumber$1);
    }
  }
  {
    devtoolsComponentEmit(instance, event, args);
  }
  {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn$3(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp2, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp2);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp2.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp2)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$3(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp2.extends) {
      extendEmits(comp2.extends);
    }
    if (comp2.mixins) {
      comp2.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache2.set(comp2, null);
    return null;
  }
  if (isArray$3(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$3(normalized, raw);
  }
  cache2.set(comp2, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render2, renderCache, data: data2, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data2, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if (attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render3.length > 1 ? render3(props, true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render3(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  let setRoot = void 0;
  if (result.patchFlag > 0 && result.patchFlag & 2048) {
    [root2, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      } else if (!accessedAttrs && root2.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
          const key = allAttrs[i2];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$3(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn$3(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if (!isElementRoot(root2)) {
      warn$3(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (!isElementRoot(root2)) {
      warn$3(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root2.transition = vnode.transition;
  }
  if (setRoot) {
    setRoot(root2);
  } else {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index2 = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index2] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children2) {
  let singleRoot;
  for (let i2 = 0; i2 < children2.length; i2++) {
    const child = children2[i2];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if ((prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$3(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance) {
    {
      warn$3(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else {
      warn$3(`injection "${String(key)}" not found.`);
    }
  } else {
    warn$3(`inject() can only be used inside setup() or functional components.`);
  }
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(effect, null, Object.assign(Object.assign({}, options), { flush: "post" }));
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (!isFunction$3(cb)) {
    warn$3(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  if (!cb) {
    if (immediate !== void 0) {
      warn$3(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn$3(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s2) => {
    warn$3(`Invalid watch source: `, s2, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow$1(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$3(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow$1(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$3(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else {
        warnInvalidSource(s2);
      }
    });
  } else if (isFunction$3(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => queuePreFlushCb(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  return () => {
    effect.stop();
    if (instance && instance.scope) {
      remove$2(instance.scope.effects, effect);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$5(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path2) {
  const segments = path2.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$4(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$3(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen);
    }
  } else if (isSet(value) || isMap$1(value)) {
    value.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children2 = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children2 || !children2.length) {
        return;
      }
      let child = children2[0];
      if (children2.length > 1) {
        let hasFound = false;
        for (const c2 of children2) {
          if (c2.type !== Comment) {
            if (hasFound) {
              warn$3("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            child = c2;
            hasFound = true;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
        warn$3(`invalid <transition> mode: ${mode}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el2._leaveCb = () => {
              earlyRemove();
              el2._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$3(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks2 = {
    mode,
    persisted,
    beforeEnter(el2) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el2._leaveCb) {
        el2._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el2]);
    },
    enter(el2) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el2._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el2]);
        } else {
          callHook2(afterHook, [el2]);
        }
        if (hooks2.delayedLeave) {
          hooks2.delayedLeave();
        }
        el2._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el2, done]);
      } else {
        done();
      }
    },
    leave(el2, remove2) {
      const key2 = String(vnode.key);
      if (el2._enterCb) {
        el2._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el2]);
      let called = false;
      const done = el2._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el2]);
        } else {
          callHook2(onAfterLeave, [el2]);
        }
        el2._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el2, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks2;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks2) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks2);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks2.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks2.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks2;
  }
}
function getTransitionRawChildren(children2, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children2.length; i2++) {
    let child = children2[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$3(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction$3(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout: timeout2,
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp2) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (!comp2) {
        warn$3(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
      }
      if (comp2 && (comp2.__esModule || comp2[Symbol.toStringTag] === "Module")) {
        comp2 = comp2.default;
      }
      if (comp2 && !isObject$4(comp2) && !isFunction$3(comp2)) {
        throw new Error(`Invalid async component load result: ${comp2}`);
      }
      resolvedComp = comp2;
      return comp2;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp2) => {
          return () => createInnerComp(comp2, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded2 = ref(false);
      const error2 = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout2 != null) {
        setTimeout(() => {
          if (!loaded2.value && !error2.value) {
            const err = new Error(`Async component timed out after ${timeout2}ms.`);
            onError(err);
            error2.value = err;
          }
        }, timeout2);
      }
      load().then(() => {
        loaded2.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error2.value = err;
      });
      return () => {
        if (loaded2.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error2.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error2.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp2, { vnode: { ref: ref2, props, children: children2, shapeFlag }, parent }) {
  const vnode = createVNode(comp2, props, children2);
  vnode.ref = ref2;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target2) {
  registerKeepAliveHook(hook, "a", target2);
}
function onDeactivated(hook, target2) {
  registerKeepAliveHook(hook, "da", target2);
}
function registerKeepAliveHook(hook, type, target2 = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target2;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target2);
  if (target2) {
    let current = target2.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target2, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target2, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove$2(keepAliveRoot[type], injected);
  }, target2);
}
function injectHook(type, hook, target2 = currentInstance, prepend = false) {
  if (target2) {
    const hooks2 = target2[type] || (target2[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target2.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target2);
      const res = callWithAsyncErrorHandling(hook, target2, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks2.unshift(wrappedHook);
    } else {
      hooks2.push(wrappedHook);
    }
    return wrappedHook;
  } else {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn$3(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const createHook = (lifecycle) => (hook, target2 = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target2);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target2 = currentInstance) {
  injectHook("ec", hook, target2);
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$3("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives2) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    warn$3(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings2 = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives2.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives2[i2];
    if (isFunction$3(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings2.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings2 = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings2.length; i2++) {
    const binding = bindings2[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$5(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$3(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else {
    warn$3(`resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`);
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray$3(source) || isString$5(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn$3(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$4(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot.length > 1) {
    warn$3(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$3(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => shallowReadonly(i2.props),
  $attrs: (i2) => shallowReadonly(i2.attrs),
  $slots: (i2) => shallowReadonly(i2.slots),
  $refs: (i2) => shallowReadonly(i2.refs),
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
  $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
  $watch: (i2) => instanceWatch.bind(i2)
});
const isReservedPrefix = (key) => key === "_" || key === "$";
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    if (setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn$1(setupState, key)) {
      return setupState[key];
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data2[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn$1(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
        accessCache[key] = 2;
        return data2[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
        markAttrsAccessed();
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString$5(key) || key.indexOf("__v") !== 0)) {
      if (data2 !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn$1(data2, key)) {
        warn$3(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn$3(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data: data2, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn$1(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
      data2[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      warn$3(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn$3(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data2 !== EMPTY_OBJ && hasOwn$1(data2, key) || setupState !== EMPTY_OBJ && hasOwn$1(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target2, key, descriptor) {
    if (descriptor.get != null) {
      target2._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target2, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target2, key, descriptor);
  }
};
{
  PublicInstanceProxyHandlers.ownKeys = (target2) => {
    warn$3(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target2);
  };
}
function createDevRenderContext(instance) {
  const target2 = {};
  Object.defineProperty(target2, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target2, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      set: NOOP
    });
  });
  return target2;
}
function exposePropsOnRenderContext(instance) {
  const { ctx, propsOptions: [propsOptions] } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$3(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function createDuplicateChecker() {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache2[key]) {
      warn$3(`${type} property "${key}" is already defined in ${cache2[key]}.`);
    } else {
      cache2[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives: directives2,
    filters
  } = options;
  const checkDuplicateProperties = createDuplicateChecker();
  {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$3(methodHandler)) {
        {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        }
        {
          checkDuplicateProperties("Methods", key);
        }
      } else {
        warn$3(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (!isFunction$3(dataOptions)) {
      warn$3(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data2 = dataOptions.call(publicThis, publicThis);
    if (isPromise(data2)) {
      warn$3(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject$4(data2)) {
      warn$3(`data() should return an object.`);
    } else {
      instance.data = reactive(data2);
      {
        for (const key in data2) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data2[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get2 === NOOP) {
        warn$3(`Computed property "${key}" has no getter.`);
      }
      const set3 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : () => {
        warn$3(`Write operation failed: computed property "${key}" is readonly.`);
      };
      const c2 = computed({
        get: get2,
        set: set3
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
      {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$3(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$3(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives2)
    instance.directives = directives2;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$3(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        {
          warn$3(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$5(raw)) {
    const handler = ctx[raw];
    if (isFunction$3(handler)) {
      watch(getter, handler);
    } else {
      warn$3(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction$3(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$4(raw)) {
    if (isArray$3(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$3(handler)) {
        watch(getter, handler, raw);
      } else {
        warn$3(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else {
    warn$3(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache2.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base2, optionMergeStrategies);
  }
  cache2.set(base2, resolved);
  return resolved;
}
function mergeOptions$1(to2, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions$1(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions$1(to2, m2, strats, true));
  }
  for (const key in from2) {
    if (asMixin && key === "expose") {
      warn$3(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from2) {
  if (!from2) {
    return to2;
  }
  if (!to2) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$3(isFunction$3(to2) ? to2.call(this, this) : to2, isFunction$3(from2) ? from2.call(this, this) : from2);
  };
}
function mergeInject(to2, from2) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$3(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from2) {
  return to2 ? [...new Set([].concat(to2, from2))] : from2;
}
function mergeObjectOptions(to2, from2) {
  return to2 ? extend$3(extend$3(/* @__PURE__ */ Object.create(null), to2), from2) : from2;
}
function mergeWatchOptions(to2, from2) {
  if (!to2)
    return from2;
  if (!from2)
    return to2;
  const merged = extend$3(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from2) {
    merged[key] = mergeAsArray(to2[key], from2[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (!(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn$1(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn$1(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp2, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp2);
  if (cached) {
    return cached;
  }
  const raw = comp2.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp2)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$3(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp2.extends) {
      extendProps(comp2.extends);
    }
    if (comp2.mixins) {
      comp2.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache2.set(comp2, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$3(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      if (!isString$5(raw[i2])) {
        warn$3(`props must be strings when using array syntax.`, raw[i2]);
      }
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (!isObject$4(raw)) {
      warn$3(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop2 = normalized[normalizedKey] = isArray$3(opt) || isFunction$3(opt) ? { type: opt } : opt;
        if (prop2) {
          const booleanIndex = getTypeIndex(Boolean, prop2.type);
          const stringIndex = getTypeIndex(String, prop2.type);
          prop2[0] = booleanIndex > -1;
          prop2[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$1(prop2, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache2.set(comp2, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else {
    warn$3(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match5 = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match5 ? match5[1] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$3(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$3(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn$1(rawProps, key) && !hasOwn$1(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop2, isAbsent) {
  const { type, required, validator } = prop2;
  if (required && isAbsent) {
    warn$3('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !prop2.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid2 = false;
    const types = isArray$3(type) ? type : [type];
    const expectedTypes = [];
    for (let i2 = 0; i2 < types.length && !isValid2; i2++) {
      const { valid, expectedType } = assertType(value, types[i2]);
      expectedTypes.push(expectedType || "");
      isValid2 = valid;
    }
    if (!isValid2) {
      warn$3(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn$3('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$4(value);
  } else if (expectedType === "Array") {
    valid = isArray$3(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue$1(value, expectedType);
  const receivedValue = styleValue$1(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$1(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue$1(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean$1(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$3(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (currentInstance) {
      warn$3(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$3(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      {
        warn$3(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children2) => {
  if (!isKeepAlive(instance.vnode) && true) {
    warn$3(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children2);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children2) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children2._;
    if (type) {
      instance.slots = toRaw(children2);
      def(children2, "_", type);
    } else {
      normalizeObjectSlots(children2, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children2) {
      normalizeVNodeSlots(instance, children2);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children2, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children2._;
    if (type) {
      if (isHmrUpdating) {
        extend$3(slots, children2);
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$3(slots, children2);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children2.$stable;
      normalizeObjectSlots(children2, slots);
    }
    deletionComparisonTarget = children2;
  } else if (children2) {
    normalizeVNodeSlots(instance, children2);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$2 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      warn$3(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$2++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
        {
          warn$3(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2)) {
          warn$3(`Plugin has already been applied to target app.`);
        } else if (plugin2 && isFunction$3(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction$3(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else {
          warn$3(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else {
            warn$3("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        }
        return app;
      },
      component(name, component) {
        {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (context.components[name]) {
          warn$3(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (context.directives[name]) {
          warn$3(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if (rootContainer.__vue_app__) {
            warn$3(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          {
            context.reload = () => {
              render2(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else {
          warn$3(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else {
          warn$3(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (key in context.provides) {
          warn$3(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$3(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (!owner) {
    warn$3(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$5(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$1(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$5(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$3(existing) && remove$2(existing, refValue);
          } else {
            if (!isArray$3(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn$1(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$1(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else {
          warn$3("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else {
      warn$3("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
let supported$1;
let perf$1;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf$1.mark(`vue-${type}-${instance.uid}`);
  }
  {
    devtoolsPerfStart(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf$1.mark(endTag);
    perf$1.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf$1.clearMarks(startTag);
    perf$1.clearMarks(endTag);
  }
  {
    devtoolsPerfEnd(instance, type, isSupported() ? perf$1.now() : Date.now());
  }
}
function isSupported() {
  if (supported$1 !== void 0) {
    return supported$1;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported$1 = true;
    perf$1 = window.performance;
  } else {
    supported$1 = false;
  }
  return supported$1;
}
function initFeatureFlags() {
  const needWarn = [];
  if (needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target2 = getGlobalThis();
  target2.__VUE__ = true;
  {
    setDevtoolsHook(target2.__VUE_DEVTOOLS_GLOBAL_HOOK__, target2);
  }
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else {
          warn$3("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el2 = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el2, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement2(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement2 = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    {
      el2 = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el2, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el2, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el2, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el2, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    {
      Object.defineProperty(el2, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el2, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el2, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el2, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i2 = start2; i2 < children2.length; i2++) {
      const child = children2[i2] = optimized ? cloneIfMounted(children2[i2]) : normalizeVNode(children2[i2]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el2, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(n1, n2, el2, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el2, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el2, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el2, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el2, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (isHmrUpdating || patchFlag & 2048) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (instance.type.__hmrId) {
      registerHMR(instance);
    }
    {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(el2, instance.subTree, instance, parentSuspense, null);
            {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          {
            startMeasure(instance, `patch`);
          }
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        {
          startMeasure(instance, `patch`);
        }
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        {
          devtoolsComponentUpdated(instance);
        }
        {
          popWarningContext();
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update3), instance.scope);
    const update3 = instance.update = () => effect.run();
    update3.id = instance.uid;
    toggleRecurse(instance, true);
    {
      effect.onTrack = instance.rtc ? (e2) => invokeArrayFns(instance.rtc, e2) : void 0;
      effect.onTrigger = instance.rtg ? (e2) => invokeArrayFns(instance.rtg, e2) : void 0;
      update3.ownerInstance = instance;
    }
    update3();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          if (keyToNewIndexMap.has(nextChild.key)) {
            warn$3(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children: children2, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el2, container, anchor);
      for (let i2 = 0; i2 < children2.length; i2++) {
        move(children2[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children: children2, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children2, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment) {
      if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el2, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, update: update3, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update3) {
      update3.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children2, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i2 = start2; i2 < children2.length; i2++) {
      unmount(children2[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect, update: update3 }, allowed) {
  effect.allowRecurse = update3.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$3(ch1) && isArray$3(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u2, v2, c2;
  const len2 = arr.length;
  for (i2 = 0; i2 < len2; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol("Fragment");
const Text = Symbol("Text");
const Comment = Symbol("Comment");
const Static = Symbol("Static");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children2, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children2, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children2, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children2, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$5(ref2) || isRef(ref2) || isFunction$3(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: children2,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children2);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children2) {
    vnode.shapeFlag |= isString$5(children2) ? 8 : 16;
  }
  if (vnode.key !== vnode.key) {
    warn$3(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (!type) {
      warn$3(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children2) {
      normalizeChildren(cloned, children2);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$5(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$4(style2)) {
      if (isProxy(style2) && !isArray$3(style2)) {
        style2 = extend$3({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$5(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$3(type) ? 2 : 0;
  if (shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn$3(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props, children2, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$3({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children: children2 } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$3(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: patchFlag === -1 && isArray$3(children2) ? children2.map(deepCloneVNode) : children2,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray$3(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text3 = " ", flag = 0) {
  return createVNode(Text, null, text3, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text3 = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text3)) : createVNode(Comment, null, text3);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$3(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children2) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children2 == null) {
    children2 = null;
  } else if (isArray$3(children2)) {
    type = 16;
  } else if (typeof children2 === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children2.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children2._;
      if (!slotFlag && !(InternalObjectKey in children2)) {
        children2._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children2._ = 1;
        } else {
          children2._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children2)) {
    children2 = { default: children2, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children2 = String(children2);
    if (shapeFlag & 64) {
      type = 16;
      children2 = [createTextVNode(children2)];
    } else {
      type = 8;
    }
  }
  vnode.children = children2;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = createDevRenderContext(instance);
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, config2) {
  const appIsNativeTag = config2.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn$3("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children: children2 } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children2);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a2;
  const Component = instance.type;
  {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateComponentName(names[i2], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateDirectiveName(names[i2]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$3(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  {
    exposePropsOnRenderContext(instance);
  }
  const { setup: setup2 } = Component;
  if (setup2) {
    const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup2, instance, 0, [shallowReadonly(instance.props), setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (!instance.suspense) {
          const name = (_a2 = Component.name) !== null && _a2 !== void 0 ? _a2 : "Anonymous";
          warn$3(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    if (isVNode(setupResult)) {
      warn$3(`setup() should not return VNodes directly - return a render function instead.`);
    }
    {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn$3(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile$1;
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template;
      if (template) {
        {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$3(extend$3({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template, finalCompilerOptions);
        {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (!Component.render && instance.render === NOOP && !isSSR) {
    if (Component.template) {
      warn$3(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
    } else {
      warn$3(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target2, key) {
      markAttrsAccessed();
      track(instance, "get", "$attrs");
      return target2[key];
    },
    set() {
      warn$3(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$3(`setupContext.attrs is readonly.`);
      return false;
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (instance.exposed) {
      warn$3(`expose() should be called only once per setup().`);
    }
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      get slots() {
        return shallowReadonly(instance.slots);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target2, key) {
        if (key in target2) {
          return target2[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match5 = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match5) {
      name = match5[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$3(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i2 = getCurrentInstance();
  if (!i2) {
    warn$3(`useContext() called without active instance.`);
  }
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function h$2(type, propsOrChildren, children2) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$4(propsOrChildren) && !isArray$3(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children2 = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children2)) {
      children2 = [children2];
    }
    return createVNode(type, propsOrChildren, children2);
  }
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function initCustomFormatter() {
  if (typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#0b1bc9" };
  const stringStyle = { style: "color:#b62e24" };
  const keywordStyle = { style: "color:#9d288c" };
  const formatter = {
    header(obj) {
      if (!isObject$4(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target2) {
    target2 = extend$3({}, target2);
    if (!Object.keys(target2).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target2).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target2[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v2, asRaw = true) {
    if (typeof v2 === "number") {
      return ["span", numberStyle, v2];
    } else if (typeof v2 === "string") {
      return ["span", stringStyle, JSON.stringify(v2)];
    } else if (typeof v2 === "boolean") {
      return ["span", keywordStyle, v2];
    } else if (isObject$4(v2)) {
      return ["object", { object: asRaw ? toRaw(v2) : v2 }];
    } else {
      return ["span", stringStyle, String(v2)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction$3(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray$3(opts) && opts.includes(key) || isObject$4(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m2) => isKeyOfType(m2, key, type))) {
      return true;
    }
  }
  function genRefFlag(v2) {
    if (isShallow(v2)) {
      return `ShallowRef`;
    }
    if (v2.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
const version = "3.2.37";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el2 = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text3) => doc.createTextNode(text3),
  createComment: (text3) => doc.createComment(text3),
  setText: (node, text3) => {
    node.nodeValue = text3;
  },
  setElementText: (el2, text3) => {
    el2.textContent = text3;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector2) => doc.querySelector(selector2),
  setScopeId(el2, id2) {
    el2.setAttribute(id2, "");
  },
  cloneNode(el2) {
    const cloned = el2.cloneNode(true);
    if (`_value` in el2) {
      cloned._value = el2._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG, start2, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
function patchStyle(el2, prev, next) {
  const style2 = el2.style;
  const isCssString = isString$5(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
    if (prev && !isString$5(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if ("_vod" in el2) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$3(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el2.tagName !== "PROGRESS" && !el2.tagName.includes("-")) {
    el2._value = value;
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue || el2.tagName === "OPTION") {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e2) {
    {
      warn$3(`Failed setting prop "${key}" on <${el2.tagName.toLowerCase()}>: value ${value} is invalid.`, e2);
    }
  }
  needRemove && el2.removeAttribute(key);
}
const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
  let _getNow2 = Date.now;
  let skipTimestampCheck2 = false;
  if (typeof window !== "undefined") {
    if (Date.now() > document.createEvent("Event").timeStamp) {
      _getNow2 = performance.now.bind(performance);
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  return [_getNow2, skipTimestampCheck2];
})();
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p$1.then(reset), cachedNow = _getNow());
function addEventListener(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2._vei || (el2._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el2, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el2, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    const timeStamp = e2.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$3(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn && fn(e3));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(el2, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction$3(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$5(value)) {
    return false;
  }
  return key in el2;
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    warn$3(`useCssVars is called without current active component instance.`);
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el: el2, anchor } = vnode;
    while (el2) {
      setVarsOnNode(el2, vars);
      if (el2 === anchor)
        break;
      el2 = el2.nextSibling;
    }
  }
}
function setVarsOnNode(el2, vars) {
  if (el2.nodeType === 1) {
    const style2 = el2.style;
    for (const key in vars) {
      style2.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition$1 = (props, { slots }) => h$2(BaseTransition, resolveTransitionProps(props), slots);
Transition$1.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition$1.props = /* @__PURE__ */ extend$3({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$3(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$3(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el2, isAppear, done) => {
    removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el2, done) => {
    el2._isLeaving = false;
    removeTransitionClass(el2, leaveFromClass);
    removeTransitionClass(el2, leaveToClass);
    removeTransitionClass(el2, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el2, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el2, isAppear, done);
      callHook(hook, [el2, resolve2]);
      nextFrame$2(() => {
        removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el2, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$3(baseProps, {
    onBeforeEnter(el2) {
      callHook(onBeforeEnter, [el2]);
      addTransitionClass(el2, enterFromClass);
      addTransitionClass(el2, enterActiveClass);
    },
    onBeforeAppear(el2) {
      callHook(onBeforeAppear, [el2]);
      addTransitionClass(el2, appearFromClass);
      addTransitionClass(el2, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el2, done) {
      el2._isLeaving = true;
      const resolve2 = () => finishLeave(el2, done);
      addTransitionClass(el2, leaveFromClass);
      forceReflow();
      addTransitionClass(el2, leaveActiveClass);
      nextFrame$2(() => {
        if (!el2._isLeaving) {
          return;
        }
        removeTransitionClass(el2, leaveFromClass);
        addTransitionClass(el2, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el2, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el2, resolve2]);
    },
    onEnterCancelled(el2) {
      finishEnter(el2, false);
      callHook(onEnterCancelled, [el2]);
    },
    onAppearCancelled(el2) {
      finishEnter(el2, true);
      callHook(onAppearCancelled, [el2]);
    },
    onLeaveCancelled(el2) {
      finishLeave(el2);
      callHook(onLeaveCancelled, [el2]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$4(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber$1(val);
  validateDuration(res);
  return res;
}
function validateDuration(val) {
  if (typeof val !== "number") {
    warn$3(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$3(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
  }
}
function addTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el2.classList.add(c2));
  (el2._vtc || (el2._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el2.classList.remove(c2));
  const { _vtc } = el2;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el2._vtc = void 0;
    }
  }
}
function nextFrame$2(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
  const id2 = el2._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el2._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout: timeout2, propCount } = getTransitionInfo(el2, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el2.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e2) => {
    if (e2.target === el2 && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout2 + 1);
  el2.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el2, expectedType) {
  const styles = window.getComputedStyle(el2);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout2 = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout2 = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout2 = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout2 = Math.max(transitionTimeout, animationTimeout);
    type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type,
    timeout: timeout2,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$3({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children2;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el2 = c2.el;
        const style2 = el2.style;
        addTransitionClass(el2, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb = el2._moveCb = (e2) => {
          if (e2 && e2.target !== el2) {
            return;
          }
          if (!e2 || /transform$/.test(e2.propertyName)) {
            el2.removeEventListener("transitionend", cb);
            el2._moveCb = null;
            removeTransitionClass(el2, moveClass);
          }
        };
        el2.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children2;
      children2 = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children2.length; i2++) {
        const child = children2[i2];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        } else {
          warn$3(`<TransitionGroup> children must be keyed.`);
        }
      }
      if (prevChildren) {
        for (let i2 = 0; i2 < prevChildren.length; i2++) {
          const child = prevChildren[i2];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children2);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el2 = c2.el;
  if (el2._moveCb) {
    el2._moveCb();
  }
  if (el2._enterCb) {
    el2._enterCb();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s2 = c2.el.style;
    s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
    s2.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el2, root2, moveClass) {
  const clone2 = el2.cloneNode();
  if (el2._vtc) {
    el2._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
  clone2.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$3(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  const target2 = e2.target;
  if (target2.composing) {
    target2.composing = false;
    target2.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el2, { modifiers: { lazy, trim, number } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el2, lazy ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el2.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = toNumber$1(domValue);
      }
      el2._assign(domValue);
    });
    if (trim) {
      addEventListener(el2, "change", () => {
        el2.value = el2.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el2, "compositionstart", onCompositionStart);
      addEventListener(el2, "compositionend", onCompositionEnd);
      addEventListener(el2, "change", onCompositionEnd);
    }
  },
  mounted(el2, { value }) {
    el2.value = value == null ? "" : value;
  },
  beforeUpdate(el2, { value, modifiers: { lazy, trim, number } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    if (el2.composing)
      return;
    if (document.activeElement === el2 && el2.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el2.value.trim() === value) {
        return;
      }
      if ((number || el2.type === "number") && toNumber$1(el2.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue) {
      el2.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el2, _2, vnode) {
    el2._assign = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      const modelValue = el2._modelValue;
      const elementValue = getValue(el2);
      const checked = el2.checked;
      const assign2 = el2._assign;
      if (isArray$3(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el2, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el2, binding, vnode) {
    el2._assign = getModelAssigner(vnode);
    setChecked(el2, binding, vnode);
  }
};
function setChecked(el2, { value, oldValue }, vnode) {
  el2._modelValue = value;
  if (isArray$3(value)) {
    el2.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el2.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el2.checked = looseEqual(value, getCheckboxValue(el2, true));
  }
}
const vModelRadio = {
  created(el2, { value }, vnode) {
    el2.checked = looseEqual(value, vnode.props.value);
    el2._assign = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      el2._assign(getValue(el2));
    });
  },
  beforeUpdate(el2, { value, oldValue }, vnode) {
    el2._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el2.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el2, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el2, "change", () => {
      const selectedVal = Array.prototype.filter.call(el2.options, (o2) => o2.selected).map((o2) => number ? toNumber$1(getValue(o2)) : getValue(o2));
      el2._assign(el2.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el2._assign = getModelAssigner(vnode);
  },
  mounted(el2, { value }) {
    setSelected(el2, value);
  },
  beforeUpdate(el2, _binding, vnode) {
    el2._assign = getModelAssigner(vnode);
  },
  updated(el2, { value }) {
    setSelected(el2, value);
  }
};
function setSelected(el2, value) {
  const isMultiple = el2.multiple;
  if (isMultiple && !isArray$3(value) && !isSet(value)) {
    warn$3(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
    return;
  }
  for (let i2 = 0, l2 = el2.options.length; i2 < l2; i2++) {
    const option = el2.options[i2];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$3(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el2.selectedIndex !== i2)
          el2.selectedIndex = i2;
        return;
      }
    }
  }
  if (!isMultiple && el2.selectedIndex !== -1) {
    el2.selectedIndex = -1;
  }
}
function getValue(el2) {
  return "_value" in el2 ? el2._value : el2.value;
}
function getCheckboxValue(el2, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el2 ? el2[key] : checked;
}
const vModelDynamic = {
  created(el2, binding, vnode) {
    callModelHook(el2, binding, vnode, null, "created");
  },
  mounted(el2, binding, vnode) {
    callModelHook(el2, binding, vnode, null, "mounted");
  },
  beforeUpdate(el2, binding, vnode, prevVNode) {
    callModelHook(el2, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el2, binding, vnode, prevVNode) {
    callModelHook(el2, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el2, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el2.tagName, vnode.props && vnode.props.type);
  const fn = modelToUse[hook];
  fn && fn(el2, binding, vnode, prevVNode);
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el2, { value }, { transition }) {
    el2._vod = el2.style.display === "none" ? "" : el2.style.display;
    if (transition && value) {
      transition.beforeEnter(el2);
    } else {
      setDisplay(el2, value);
    }
  },
  mounted(el2, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el2);
    }
  },
  updated(el2, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el2);
        setDisplay(el2, true);
        transition.enter(el2);
      } else {
        transition.leave(el2, () => {
          setDisplay(el2, false);
        });
      }
    } else {
      setDisplay(el2, value);
    }
  },
  beforeUnmount(el2, { value }) {
    setDisplay(el2, value);
  }
};
function setDisplay(el2, value) {
  el2.style.display = value ? el2._vod : "none";
}
const rendererOptions = /* @__PURE__ */ extend$3({ patchProp }, nodeOps);
let renderer$1;
function ensureRenderer() {
  return renderer$1 || (renderer$1 = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn$3(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn$3(msg);
        return compilerOptions;
      },
      set() {
        warn$3(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString$5(container)) {
    const res = document.querySelector(container);
    if (!res) {
      warn$3(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    warn$3(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}
function initDev() {
  {
    initCustomFormatter();
  }
}
{
  initDev();
}
var isVue2 = false;
function set$4(target2, key, val) {
  if (Array.isArray(target2)) {
    target2.length = Math.max(target2.length, key);
    target2.splice(key, 1, val);
    return val;
  }
  target2[key] = val;
  return val;
}
function del(target2, key) {
  if (Array.isArray(target2)) {
    target2.splice(key, 1);
    return;
  }
  delete target2[key];
}
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a2;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a2 = global.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now$5() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin2, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin2;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin2.settings) {
      for (const id2 in plugin2.settings) {
        const item = plugin2.settings[id2];
        defaultSettings[id2] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin2.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data2 = JSON.parse(raw);
      Object.assign(currentSettings, data2);
    } catch (e2) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e2) {
        }
        currentSettings = value;
      },
      now() {
        return now$5();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop2) => {
        if (this.target) {
          return this.target.on[prop2];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop2,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop2) => {
        if (this.target) {
          return this.target[prop2];
        } else if (prop2 === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop2)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop2,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop2](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop2,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target2) {
    this.target = target2;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target2 = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target2.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list3 = target2.__VUE_DEVTOOLS_PLUGINS__ = target2.__VUE_DEVTOOLS_PLUGINS__ || [];
    list3.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
  * pinia v2.0.14
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = Symbol("pinia");
function isPlainObject(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
const IS_CLIENT = typeof window !== "undefined";
const _global$2 = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
  if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
    return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
  }
  return blob;
}
function download(url, name, opts) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = "blob";
  xhr.onload = function() {
    saveAs(xhr.response, name, opts);
  };
  xhr.onerror = function() {
    console.error("could not download file");
  };
  xhr.send();
}
function corsEnabled(url) {
  const xhr = new XMLHttpRequest();
  xhr.open("HEAD", url, false);
  try {
    xhr.send();
  } catch (e2) {
  }
  return xhr.status >= 200 && xhr.status <= 299;
}
function click(node) {
  try {
    node.dispatchEvent(new MouseEvent("click"));
  } catch (e2) {
    const evt = document.createEvent("MouseEvents");
    evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
    node.dispatchEvent(evt);
  }
}
const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT ? () => {
} : typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : "msSaveOrOpenBlob" in _navigator ? msSaveAs : fileSaverSaveAs;
function downloadSaveAs(blob, name = "download", opts) {
  const a2 = document.createElement("a");
  a2.download = name;
  a2.rel = "noopener";
  if (typeof blob === "string") {
    a2.href = blob;
    if (a2.origin !== location.origin) {
      if (corsEnabled(a2.href)) {
        download(blob, name, opts);
      } else {
        a2.target = "_blank";
        click(a2);
      }
    } else {
      click(a2);
    }
  } else {
    a2.href = URL.createObjectURL(blob);
    setTimeout(function() {
      URL.revokeObjectURL(a2.href);
    }, 4e4);
    setTimeout(function() {
      click(a2);
    }, 0);
  }
}
function msSaveAs(blob, name = "download", opts) {
  if (typeof blob === "string") {
    if (corsEnabled(blob)) {
      download(blob, name, opts);
    } else {
      const a2 = document.createElement("a");
      a2.href = blob;
      a2.target = "_blank";
      setTimeout(function() {
        click(a2);
      });
    }
  } else {
    navigator.msSaveOrOpenBlob(bom(blob, opts), name);
  }
}
function fileSaverSaveAs(blob, name, opts, popup) {
  popup = popup || open("", "_blank");
  if (popup) {
    popup.document.title = popup.document.body.innerText = "downloading...";
  }
  if (typeof blob === "string")
    return download(blob, name, opts);
  const force = blob.type === "application/octet-stream";
  const isSafari = /constructor/i.test(String(_global$2.HTMLElement)) || "safari" in _global$2;
  const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
    const reader = new FileReader();
    reader.onloadend = function() {
      let url = reader.result;
      if (typeof url !== "string") {
        popup = null;
        throw new Error("Wrong reader.result type");
      }
      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
      if (popup) {
        popup.location.href = url;
      } else {
        location.assign(url);
      }
      popup = null;
    };
    reader.readAsDataURL(blob);
  } else {
    const url = URL.createObjectURL(blob);
    if (popup)
      popup.location.assign(url);
    else
      location.href = url;
    popup = null;
    setTimeout(function() {
      URL.revokeObjectURL(url);
    }, 4e4);
  }
}
function toastMessage(message, type) {
  const piniaMessage = "\u{1F34D} " + message;
  if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
  } else if (type === "error") {
    console.error(piniaMessage);
  } else if (type === "warn") {
    console.warn(piniaMessage);
  } else {
    console.log(piniaMessage);
  }
}
function isPinia(o2) {
  return "_a" in o2 && "install" in o2;
}
function checkClipboardAccess() {
  if (!("clipboard" in navigator)) {
    toastMessage(`Your browser doesn't support the Clipboard API`, "error");
    return true;
  }
}
function checkNotFocusedError(error2) {
  if (error2 instanceof Error && error2.message.toLowerCase().includes("document is not focused")) {
    toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
    return true;
  }
  return false;
}
async function actionGlobalCopyState(pinia) {
  if (checkClipboardAccess())
    return;
  try {
    await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
    toastMessage("Global state copied to clipboard.");
  } catch (error2) {
    if (checkNotFocusedError(error2))
      return;
    toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
    console.error(error2);
  }
}
async function actionGlobalPasteState(pinia) {
  if (checkClipboardAccess())
    return;
  try {
    pinia.state.value = JSON.parse(await navigator.clipboard.readText());
    toastMessage("Global state pasted from clipboard.");
  } catch (error2) {
    if (checkNotFocusedError(error2))
      return;
    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
    console.error(error2);
  }
}
async function actionGlobalSaveState(pinia) {
  try {
    saveAs(new Blob([JSON.stringify(pinia.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (error2) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error2);
  }
}
let fileInput;
function getFileOpener() {
  if (!fileInput) {
    fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".json";
  }
  function openFile() {
    return new Promise((resolve2, reject) => {
      fileInput.onchange = async () => {
        const files = fileInput.files;
        if (!files)
          return resolve2(null);
        const file = files.item(0);
        if (!file)
          return resolve2(null);
        return resolve2({ text: await file.text(), file });
      };
      fileInput.oncancel = () => resolve2(null);
      fileInput.onerror = reject;
      fileInput.click();
    });
  }
  return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
  try {
    const open2 = await getFileOpener();
    const result = await open2();
    if (!result)
      return;
    const { text: text3, file } = result;
    pinia.state.value = JSON.parse(text3);
    toastMessage(`Global state imported from "${file.name}".`);
  } catch (error2) {
    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
    console.error(error2);
  }
}
function formatDisplay$1(display) {
  return {
    _custom: {
      display
    }
  };
}
const PINIA_ROOT_LABEL = "\u{1F34D} Pinia (root)";
const PINIA_ROOT_ID = "_root";
function formatStoreForInspectorTree(store) {
  return isPinia(store) ? {
    id: PINIA_ROOT_ID,
    label: PINIA_ROOT_LABEL
  } : {
    id: store.$id,
    label: store.$id
  };
}
function formatStoreForInspectorState(store) {
  if (isPinia(store)) {
    const storeNames = Array.from(store._s.keys());
    const storeMap = store._s;
    const state2 = {
      state: storeNames.map((storeId) => ({
        editable: true,
        key: storeId,
        value: store.state.value[storeId]
      })),
      getters: storeNames.filter((id2) => storeMap.get(id2)._getters).map((id2) => {
        const store2 = storeMap.get(id2);
        return {
          editable: false,
          key: id2,
          value: store2._getters.reduce((getters, key) => {
            getters[key] = store2[key];
            return getters;
          }, {})
        };
      })
    };
    return state2;
  }
  const state = {
    state: Object.keys(store.$state).map((key) => ({
      editable: true,
      key,
      value: store.$state[key]
    }))
  };
  if (store._getters && store._getters.length) {
    state.getters = store._getters.map((getterName) => ({
      editable: false,
      key: getterName,
      value: store[getterName]
    }));
  }
  if (store._customProperties.size) {
    state.customProperties = Array.from(store._customProperties).map((key) => ({
      editable: true,
      key,
      value: store[key]
    }));
  }
  return state;
}
function formatEventData(events) {
  if (!events)
    return {};
  if (Array.isArray(events)) {
    return events.reduce((data2, event) => {
      data2.keys.push(event.key);
      data2.operations.push(event.type);
      data2.oldValue[event.key] = event.oldValue;
      data2.newValue[event.key] = event.newValue;
      return data2;
    }, {
      oldValue: {},
      keys: [],
      operations: [],
      newValue: {}
    });
  } else {
    return {
      operation: formatDisplay$1(events.type),
      key: formatDisplay$1(events.key),
      oldValue: events.oldValue,
      newValue: events.newValue
    };
  }
}
function formatMutationType(type) {
  switch (type) {
    case MutationType.direct:
      return "mutation";
    case MutationType.patchFunction:
      return "$patch";
    case MutationType.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = "pinia:mutations";
const INSPECTOR_ID = "pinia";
const getStoreType = (id2) => "\u{1F34D} " + id2;
function registerPiniaDevtools(app, pinia) {
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app
  }, (api) => {
    if (typeof api.now !== "function") {
      toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    }
    api.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: `Pinia \u{1F34D}`,
      color: 15064968
    });
    api.addInspector({
      id: INSPECTOR_ID,
      label: "Pinia \u{1F34D}",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            actionGlobalCopyState(pinia);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await actionGlobalPasteState(pinia);
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            actionGlobalSaveState(pinia);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await actionGlobalOpenStateFile(pinia);
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
          },
          tooltip: "Import the state from a JSON file"
        }
      ]
    });
    api.on.inspectComponent((payload, ctx) => {
      const proxy = payload.componentInstance && payload.componentInstance.proxy;
      if (proxy && proxy._pStores) {
        const piniaStores = payload.componentInstance.proxy._pStores;
        Object.values(piniaStores).forEach((store) => {
          payload.instanceData.state.push({
            type: getStoreType(store.$id),
            key: "state",
            editable: true,
            value: store._isOptionsAPI ? {
              _custom: {
                value: store.$state,
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => store.$reset()
                  }
                ]
              }
            } : store.$state
          });
          if (store._getters && store._getters.length) {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "getters",
              editable: false,
              value: store._getters.reduce((getters, key) => {
                try {
                  getters[key] = store[key];
                } catch (error2) {
                  getters[key] = error2;
                }
                return getters;
              }, {})
            });
          }
        });
      }
    });
    api.on.getInspectorTree((payload) => {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        let stores = [pinia];
        stores = stores.concat(Array.from(pinia._s.values()));
        payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
      }
    });
    api.on.getInspectorState((payload) => {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
        if (!inspectedStore) {
          return;
        }
        if (inspectedStore) {
          payload.state = formatStoreForInspectorState(inspectedStore);
        }
      }
    });
    api.on.editInspectorState((payload, ctx) => {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
        if (!inspectedStore) {
          return toastMessage(`store "${payload.nodeId}" not found`, "error");
        }
        const { path: path2 } = payload;
        if (!isPinia(inspectedStore)) {
          if (path2.length !== 1 || !inspectedStore._customProperties.has(path2[0]) || path2[0] in inspectedStore.$state) {
            path2.unshift("$state");
          }
        } else {
          path2.unshift("state");
        }
        isTimelineActive = false;
        payload.set(inspectedStore, path2, payload.state.value);
        isTimelineActive = true;
      }
    });
    api.on.editComponentState((payload) => {
      if (payload.type.startsWith("\u{1F34D}")) {
        const storeId = payload.type.replace(/^\s*/, "");
        const store = pinia._s.get(storeId);
        if (!store) {
          return toastMessage(`store "${storeId}" not found`, "error");
        }
        const { path: path2 } = payload;
        if (path2[0] !== "state") {
          return toastMessage(`Invalid path for store "${storeId}":
${path2}
Only state can be modified.`);
        }
        path2[0] = "$state";
        isTimelineActive = false;
        payload.set(store, path2, payload.state.value);
        isTimelineActive = true;
      }
    });
  });
}
function addStoreToDevtools(app, store) {
  if (!componentStateTypes.includes(getStoreType(store.$id))) {
    componentStateTypes.push(getStoreType(store.$id));
  }
  setupDevtoolsPlugin({
    id: "dev.esm.pinia",
    label: "Pinia \u{1F34D}",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes,
    app,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: true
      }
    }
  }, (api) => {
    const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
    store.$onAction(({ after, onError, name, args }) => {
      const groupId = runningActionId++;
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: "\u{1F6EB} " + name,
          subtitle: "start",
          data: {
            store: formatDisplay$1(store.$id),
            action: formatDisplay$1(name),
            args
          },
          groupId
        }
      });
      after((result) => {
        activeAction = void 0;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "\u{1F6EC} " + name,
            subtitle: "end",
            data: {
              store: formatDisplay$1(store.$id),
              action: formatDisplay$1(name),
              args,
              result
            },
            groupId
          }
        });
      });
      onError((error2) => {
        activeAction = void 0;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            logType: "error",
            title: "\u{1F4A5} " + name,
            subtitle: "end",
            data: {
              store: formatDisplay$1(store.$id),
              action: formatDisplay$1(name),
              args,
              error: error2
            },
            groupId
          }
        });
      });
    }, true);
    store._customProperties.forEach((name) => {
      watch(() => unref(store[name]), (newValue, oldValue) => {
        api.notifyComponentUpdate();
        api.sendInspectorState(INSPECTOR_ID);
        if (isTimelineActive) {
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "Change",
              subtitle: name,
              data: {
                newValue,
                oldValue
              },
              groupId: activeAction
            }
          });
        }
      }, { deep: true });
    });
    store.$subscribe(({ events, type }, state) => {
      api.notifyComponentUpdate();
      api.sendInspectorState(INSPECTOR_ID);
      if (!isTimelineActive)
        return;
      const eventData = {
        time: now2(),
        title: formatMutationType(type),
        data: {
          store: formatDisplay$1(store.$id),
          ...formatEventData(events)
        },
        groupId: activeAction
      };
      activeAction = void 0;
      if (type === MutationType.patchFunction) {
        eventData.subtitle = "\u2935\uFE0F";
      } else if (type === MutationType.patchObject) {
        eventData.subtitle = "\u{1F9E9}";
      } else if (events && !Array.isArray(events)) {
        eventData.subtitle = events.type;
      }
      if (events) {
        eventData.data["rawEvent(s)"] = {
          _custom: {
            display: "DebuggerEvent",
            type: "object",
            tooltip: "raw DebuggerEvent[]",
            value: events
          }
        };
      }
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: eventData
      });
    }, { detached: true, flush: "sync" });
    const hotUpdate = store._hotUpdate;
    store._hotUpdate = markRaw((newStore) => {
      hotUpdate(newStore);
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: now2(),
          title: "\u{1F525} " + store.$id,
          subtitle: "HMR update",
          data: {
            store: formatDisplay$1(store.$id),
            info: formatDisplay$1(`HMR update`)
          }
        }
      });
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
    });
    const { $dispose } = store;
    store.$dispose = () => {
      $dispose();
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store \u{1F5D1}`);
    };
    api.notifyComponentUpdate();
    api.sendInspectorTree(INSPECTOR_ID);
    api.sendInspectorState(INSPECTOR_ID);
    api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed \u{1F195}`);
  });
}
let runningActionId = 0;
let activeAction;
function patchActionForGrouping(store, actionNames) {
  const actions = actionNames.reduce((storeActions, actionName) => {
    storeActions[actionName] = toRaw(store)[actionName];
    return storeActions;
  }, {});
  for (const actionName in actions) {
    store[actionName] = function() {
      const _actionId = runningActionId;
      const trackedStore = new Proxy(store, {
        get(...args) {
          activeAction = _actionId;
          return Reflect.get(...args);
        },
        set(...args) {
          activeAction = _actionId;
          return Reflect.set(...args);
        }
      });
      return actions[actionName].apply(trackedStore, arguments);
    };
  }
}
function devtoolsPlugin({ app, store, options }) {
  if (store.$id.startsWith("__hot:")) {
    return;
  }
  if (options.state) {
    store._isOptionsAPI = true;
  }
  if (typeof options.state === "function") {
    patchActionForGrouping(store, Object.keys(options.actions));
    const originalHotUpdate = store._hotUpdate;
    toRaw(store)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions));
    };
  }
  addStoreToDevtools(app, store);
}
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      {
        pinia._a = app;
        app.provide(piniaSymbol, pinia);
        app.config.globalProperties.$pinia = pinia;
        if (IS_CLIENT) {
          registerPiniaDevtools(app, pinia);
        }
        toBeInstalled.forEach((plugin2) => _p.push(plugin2));
        toBeInstalled = [];
      }
    },
    use(plugin2) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin2);
      } else {
        _p.push(plugin2);
      }
      return this;
    },
    _p,
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  if (IS_CLIENT && true) {
    pinia.use(devtoolsPlugin);
  }
  return pinia;
}
function patchObject(newState, oldState) {
  for (const key in oldState) {
    const subPatch = oldState[key];
    if (!(key in newState)) {
      continue;
    }
    const targetValue = newState[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      newState[key] = patchObject(targetValue, subPatch);
    } else {
      {
        newState[key] = subPatch;
      }
    }
  }
  return newState;
}
const noop$4 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$4) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentInstance()) {
    onUnmounted(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
function mergeReactiveObjects(target2, patchToApply) {
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target2[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && target2.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target2[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target2[key] = subPatch;
    }
  }
  return target2;
}
const skipHydrateSymbol = Symbol("pinia:skipHydration");
function shouldHydrate(obj) {
  return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$4 } = Object;
function isComputed(o2) {
  return !!(isRef(o2) && o2.effect);
}
function createOptionsStore(id2, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id2];
  let store;
  function setup2() {
    if (!initialState && !hot) {
      {
        pinia.state.value[id2] = state ? state() : {};
      }
    }
    const localState = hot ? toRefs(ref(state ? state() : {}).value) : toRefs(pinia.state.value[id2]);
    return assign$4(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id2);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id2, setup2, options, pinia, hot, true);
  store.$reset = function $reset() {
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$4($state, newState);
    });
  };
  return store;
}
function createSetupStore($id, setup2, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$4({ actions: {} }, options);
  if (!pinia._e.active) {
    throw new Error("Pinia destroyed");
  }
  const $subscribeOptions = {
    deep: true
  };
  {
    $subscribeOptions.onTrigger = (event) => {
      if (isListening) {
        debuggerEvents = event;
      } else if (isListening == false && !store._hotUpdating) {
        if (Array.isArray(debuggerEvents)) {
          debuggerEvents.push(event);
        } else {
          console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug.");
        }
      }
    };
  }
  let isListening;
  let isSyncListening;
  let subscriptions = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && !hot) {
    {
      pinia.state.value[$id] = {};
    }
  }
  const hotState = ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    {
      debuggerEvents = [];
    }
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = () => {
    throw new Error(`\u{1F34D}: Store "${$id}" is build using the setup syntax and does not implement $reset().`);
  };
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error2) {
        triggerSubscriptions(onErrorCallbackList, error2);
        throw error2;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error2) => {
          triggerSubscriptions(onErrorCallbackList, error2);
          return Promise.reject(error2);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const _hmrPayload = /* @__PURE__ */ markRaw({
    actions: {},
    getters: {},
    state: [],
    hotState
  });
  const partialStore = {
    _p: pinia,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$4({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(assign$4(IS_CLIENT ? {
    _customProperties: markRaw(/* @__PURE__ */ new Set()),
    _hmrPayload
  } : {}, partialStore));
  pinia._s.set($id, store);
  const setupStore = pinia._e.run(() => {
    scope = effectScope();
    return scope.run(() => setup2());
  });
  for (const key in setupStore) {
    const prop2 = setupStore[key];
    if (isRef(prop2) && !isComputed(prop2) || isReactive(prop2)) {
      if (hot) {
        set$4(hotState.value, key, toRef(setupStore, key));
      } else if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop2)) {
          if (isRef(prop2)) {
            prop2.value = initialState[key];
          } else {
            mergeReactiveObjects(prop2, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop2;
        }
      }
      {
        _hmrPayload.state.push(key);
      }
    } else if (typeof prop2 === "function") {
      const actionValue = hot ? prop2 : wrapAction(key, prop2);
      {
        setupStore[key] = actionValue;
      }
      {
        _hmrPayload.actions[key] = prop2;
      }
      optionsForPlugin.actions[key] = prop2;
    } else {
      if (isComputed(prop2)) {
        _hmrPayload.getters[key] = isOptionsStore ? options.getters[key] : prop2;
        if (IS_CLIENT) {
          const getters = setupStore._getters || (setupStore._getters = markRaw([]));
          getters.push(key);
        }
      }
    }
  }
  {
    assign$4(store, setupStore);
    assign$4(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => hot ? hotState.value : pinia.state.value[$id],
    set: (state) => {
      if (hot) {
        throw new Error("cannot set hotState");
      }
      $patch(($state) => {
        assign$4($state, state);
      });
    }
  });
  {
    store._hotUpdate = markRaw((newStore) => {
      store._hotUpdating = true;
      newStore._hmrPayload.state.forEach((stateKey) => {
        if (stateKey in store.$state) {
          const newStateTarget = newStore.$state[stateKey];
          const oldStateSource = store.$state[stateKey];
          if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {
            patchObject(newStateTarget, oldStateSource);
          } else {
            newStore.$state[stateKey] = oldStateSource;
          }
        }
        set$4(store, stateKey, toRef(newStore.$state, stateKey));
      });
      Object.keys(store.$state).forEach((stateKey) => {
        if (!(stateKey in newStore.$state)) {
          del(store, stateKey);
        }
      });
      isListening = false;
      isSyncListening = false;
      pinia.state.value[$id] = toRef(newStore._hmrPayload, "hotState");
      isSyncListening = true;
      nextTick().then(() => {
        isListening = true;
      });
      for (const actionName in newStore._hmrPayload.actions) {
        const action = newStore[actionName];
        set$4(store, actionName, wrapAction(actionName, action));
      }
      for (const getterName in newStore._hmrPayload.getters) {
        const getter = newStore._hmrPayload.getters[getterName];
        const getterValue = isOptionsStore ? computed(() => {
          setActivePinia(pinia);
          return getter.call(store, store);
        }) : getter;
        set$4(store, getterName, getterValue);
      }
      Object.keys(store._hmrPayload.getters).forEach((key) => {
        if (!(key in newStore._hmrPayload.getters)) {
          del(store, key);
        }
      });
      Object.keys(store._hmrPayload.actions).forEach((key) => {
        if (!(key in newStore._hmrPayload.actions)) {
          del(store, key);
        }
      });
      store._hmrPayload = newStore._hmrPayload;
      store._getters = newStore._getters;
      store._hotUpdating = false;
    });
    const nonEnumerable = {
      writable: true,
      configurable: true,
      enumerable: false
    };
    if (IS_CLIENT) {
      ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
        Object.defineProperty(store, p2, {
          value: store[p2],
          ...nonEnumerable
        });
      });
    }
  }
  pinia._p.forEach((extender) => {
    if (IS_CLIENT) {
      const extensions = scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      }));
      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
      assign$4(store, extensions);
    } else {
      assign$4(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
    console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
  }
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup2, setupOptions) {
  let id2;
  let options;
  const isSetupStore = typeof setup2 === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options = isSetupStore ? setupOptions : setup2;
  } else {
    options = idOrOptions;
    id2 = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const currentInstance2 = getCurrentInstance();
    pinia = pinia || currentInstance2 && inject(piniaSymbol);
    if (pinia)
      setActivePinia(pinia);
    if (!activePinia) {
      throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);
    }
    pinia = activePinia;
    if (!pinia._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup2, options, pinia);
      } else {
        createOptionsStore(id2, options, pinia);
      }
      {
        useStore._pinia = pinia;
      }
    }
    const store = pinia._s.get(id2);
    if (hot) {
      const hotId = "__hot:" + id2;
      const newStore = isSetupStore ? createSetupStore(hotId, setup2, options, pinia, true) : createOptionsStore(hotId, assign$4({}, options), pinia, true);
      hot._hotUpdate(newStore);
      delete pinia.state.value[hotId];
      pinia._s.delete(hotId);
    }
    if (IS_CLIENT && currentInstance2 && currentInstance2.proxy && !hot) {
      const vm = currentInstance2.proxy;
      const cache2 = "_pStores" in vm ? vm._pStores : vm._pStores = {};
      cache2[id2] = store;
    }
    return store;
  }
  useStore.$id = id2;
  return useStore;
}
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
function getAlignment$1(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement$1(placement) {
  return ["top", "bottom"].includes(getBasePlacement$1(placement)) ? "x" : "y";
}
function getLengthFromAxis$1(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement$1(_ref) {
  let {
    reference: reference3,
    floating,
    placement
  } = _ref;
  const commonX = reference3.x + reference3.width / 2 - floating.width / 2;
  const commonY = reference3.y + reference3.height / 2 - floating.height / 2;
  let coords;
  switch (getBasePlacement$1(placement)) {
    case "top":
      coords = {
        x: commonX,
        y: reference3.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference3.y + reference3.height
      };
      break;
    case "right":
      coords = {
        x: reference3.x + reference3.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference3.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference3.x,
        y: reference3.y
      };
  }
  const mainAxis = getMainAxisFromPlacement$1(placement);
  const length = getLengthFromAxis$1(mainAxis);
  switch (getAlignment$1(placement)) {
    case "start":
      coords[mainAxis] = coords[mainAxis] - (reference3[length] / 2 - floating[length] / 2);
      break;
    case "end":
      coords[mainAxis] = coords[mainAxis] + (reference3[length] / 2 - floating[length] / 2);
      break;
  }
  return coords;
}
const computePosition$3 = async (reference3, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref) => {
      let {
        name
      } = _ref;
      return name === "autoPlacement" || name === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference: reference3,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement$1({
    ...rects,
    placement
  });
  let statefulPlacement = placement;
  let middlewareData = {};
  let _debug_loop_count_ = 0;
  for (let i2 = 0; i2 < middleware.length; i2++) {
    {
      _debug_loop_count_++;
      if (_debug_loop_count_ > 100) {
        throw new Error(["Floating UI: The middleware lifecycle appears to be", "running in an infinite loop. This is usually caused by a `reset`", "continually being returned without a break condition."].join(" "));
      }
    }
    const {
      name,
      fn
    } = middleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference3,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: data2 != null ? data2 : {}
    };
    if (reset2) {
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference: reference3,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement$1({
          ...rects,
          placement: statefulPlacement
        }));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject$1(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding$1(padding) {
  return typeof padding !== "number" ? expandPaddingObject$1(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect$1(rect2) {
  return {
    ...rect2,
    top: rect2.y,
    left: rect2.x,
    right: rect2.x + rect2.width,
    bottom: rect2.y + rect2.height
  };
}
async function detectOverflow$1(middlewareArguments, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingParents",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding$1(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = await platform2.getClippingClientRect({
    element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
      element: elements.floating
    }),
    boundary,
    rootBoundary
  });
  const elementClientRect = rectToClientRect$1(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x: x2,
      y: y2
    } : rects.reference,
    offsetParent: await platform2.getOffsetParent({
      element: elements.floating
    }),
    strategy
  }));
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$5 = Math.min;
const max$5 = Math.max;
function within$1(min$12, value, max$12) {
  return max$5(min$12, min$5(value, max$12));
}
const arrow$1 = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding$1(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const basePlacement = getBasePlacement$1(placement);
    const axis = getMainAxisFromPlacement$1(basePlacement);
    const length = getLengthFromAxis$1(axis);
    const arrowDimensions = await platform2.getDimensions({
      element
    });
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await platform2.getOffsetParent({
      element
    });
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within$1(min2, center, max2);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1$1[matched]);
}
function getAlignmentSides$1(placement, rects) {
  const isStart = getAlignment$1(placement) === "start";
  const mainAxis = getMainAxisFromPlacement$1(placement);
  const length = getLengthFromAxis$1(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement$1(mainAlignmentSide)
  };
}
const hash$2 = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement$1(placement) {
  return placement.replace(/start|end/g, (matched) => hash$2[matched]);
}
const basePlacements$1 = ["top", "right", "bottom", "left"];
const allPlacements$1 = /* @__PURE__ */ basePlacements$1.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
function getPlacementList$1(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment$1(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment$1(placement) !== alignment)] : allowedPlacements.filter((placement) => getBasePlacement$1(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment$1(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement$1(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;
      const {
        x: x2,
        y: y2,
        rects,
        middlewareData,
        placement
      } = middlewareArguments;
      const {
        alignment = null,
        allowedPlacements = allPlacements$1,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {
        return {};
      }
      const placements2 = getPlacementList$1(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;
      const currentPlacement = placements2[currentIndex];
      const {
        main: main2,
        cross: cross2
      } = getAlignmentSides$1(currentPlacement, rects);
      if (placement !== currentPlacement) {
        return {
          x: x2,
          y: y2,
          reset: {
            placement: placements2[0]
          }
        };
      }
      const currentOverflows = [overflow[getBasePlacement$1(currentPlacement)], overflow[main2], overflow[cross2]];
      const allOverflows = [...(_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements2[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a2, b2) => a2.overflows[0] - b2.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      return {
        data: {
          skip: true
        },
        reset: {
          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement
        }
      };
    }
  };
};
function getExpandedPlacements$1(placement) {
  const oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeAlignmentPlacement$1(placement), oppositePlacement, getOppositeAlignmentPlacement$1(oppositePlacement)];
}
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip, _middlewareData$flip2;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement
      } = middlewareArguments;
      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
        return {};
      }
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const basePlacement = getBasePlacement$1(placement);
      const isBasePlacement = basePlacement === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements$1(initialPlacement));
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[basePlacement]);
      }
      if (checkCrossAxis) {
        const {
          main: main2,
          cross: cross2
        } = getAlignmentSides$1(placement, rects);
        overflows.push(overflow[main2], overflow[cross2]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side) => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip3;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a2, b2) => a2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          data: {
            skip: true
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords$1(_ref) {
  let {
    placement,
    rects,
    value
  } = _ref;
  const basePlacement = getBasePlacement$1(placement);
  const multiplier = ["left", "top"].includes(basePlacement) ? -1 : 1;
  const rawValue = typeof value === "function" ? value({
    ...rects,
    placement
  }) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : {
    mainAxis: 0,
    crossAxis: 0,
    ...rawValue
  };
  return getMainAxisFromPlacement$1(basePlacement) === "x" ? {
    x: crossAxis,
    y: mainAxis * multiplier
  } : {
    x: mainAxis * multiplier,
    y: crossAxis
  };
}
const offset$2 = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement,
        rects
      } = middlewareArguments;
      const diffCoords = convertValueToCoords$1({
        placement,
        rects,
        value
      });
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis$1(axis) {
  return axis === "x" ? "y" : "x";
}
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement$1(getBasePlacement$1(placement));
      const crossAxis = getCrossAxis$1(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
const size$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$size;
      const {
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const {
        apply,
        ...detectOverflowOptions
      } = options;
      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {
        return {};
      }
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const basePlacement = getBasePlacement$1(placement);
      const isEnd = getAlignment$1(placement) === "end";
      let heightSide;
      let widthSide;
      if (basePlacement === "top" || basePlacement === "bottom") {
        heightSide = basePlacement;
        widthSide = isEnd ? "left" : "right";
      } else {
        widthSide = basePlacement;
        heightSide = isEnd ? "top" : "bottom";
      }
      const xMin = max$5(overflow.left, 0);
      const xMax = max$5(overflow.right, 0);
      const yMin = max$5(overflow.top, 0);
      const yMax = max$5(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$5(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$5(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply == null ? void 0 : apply({
        ...dimensions,
        ...rects
      });
      return {
        data: {
          skip: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
};
function isWindow$1(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow$1(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeName$1(node) {
  return isWindow$1(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement$1(value) {
  return value instanceof getWindow$1(value).HTMLElement;
}
function isElement$1(value) {
  return value instanceof getWindow$1(value).Element;
}
function isNode$2(value) {
  return value instanceof getWindow$1(value).Node;
}
function isShadowRoot$1(node) {
  const OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isScrollParent$1(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].includes(getNodeName$1(element));
}
function isContainingBlock$1(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
const min$4 = Math.min;
const max$4 = Math.max;
const round$2 = Math.round;
function getBoundingClientRect$1(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$2(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$2(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement$1(node) {
  return ((isNode$2(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll$1(element) {
  if (isWindow$1(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getNodeScroll$1(element).scrollLeft;
}
function isScaled$1(element) {
  const rect2 = getBoundingClientRect$1(element);
  return round$2(rect2.width) !== element.offsetWidth || round$2(rect2.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent$1(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  const rect2 = getBoundingClientRect$1(element, isOffsetParentAnElement && isScaled$1(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect2.left + scroll.scrollLeft - offsets.x,
    y: rect2.top + scroll.scrollTop - offsets.y,
    width: rect2.width,
    height: rect2.height
  };
}
function getParentNode$1(node) {
  if (getNodeName$1(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot$1(node) ? node.host : null) || getDocumentElement$1(node);
}
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock$1(element) {
  let currentNode = getParentNode$1(element);
  while (isHTMLElement$1(currentNode) && !["html", "body"].includes(getNodeName$1(currentNode))) {
    if (isContainingBlock$1(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent$1(element) {
  const window2 = getWindow$1(element);
  let offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock$1(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
function getDimensions$1(element) {
  return {
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect$1(_ref) {
  let {
    rect: rect2,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  if (offsetParent === documentElement) {
    return rect2;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect2,
    x: rect2.x - scroll.scrollLeft + offsets.x,
    y: rect2.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect$1(element) {
  const win = getWindow$1(element);
  const html = getDocumentElement$1(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement$1(element);
  const scroll = getNodeScroll$1(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max$4(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max$4(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX$1(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1$1(body || html).direction === "rtl") {
    x2 += max$4(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getScrollParent$1(node) {
  if (["html", "body", "#document"].includes(getNodeName$1(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement$1(node) && isScrollParent$1(node)) {
    return node;
  }
  return getScrollParent$1(getParentNode$1(node));
}
function getScrollParents$1(node, list3) {
  var _node$ownerDocument;
  if (list3 === void 0) {
    list3 = [];
  }
  const scrollParent = getScrollParent$1(node);
  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow$1(scrollParent);
  const target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent$1(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list3.concat(target2);
  return isBody ? updatedList : updatedList.concat(getScrollParents$1(getParentNode$1(target2)));
}
function contains$1(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect$1(element) {
  const clientRect = getBoundingClientRect$1(element);
  const top2 = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top: top2,
    left,
    x: left,
    y: top2,
    right: left + element.clientWidth,
    bottom: top2 + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingParent$1(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect$1(getViewportRect$1(element));
  }
  if (isElement$1(clippingParent)) {
    return getInnerBoundingClientRect$1(clippingParent);
  }
  return rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
function getClippingParents$1(element) {
  const clippingParents = getScrollParents$1(getParentNode$1(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents.filter((clippingParent) => isElement$1(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body");
}
function getClippingClientRect$1(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents$1(element) : [].concat(boundary);
  const clippingParents = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents[0];
  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {
    const rect2 = getClientRectFromClippingParent$1(element, clippingParent);
    accRect.top = max$4(rect2.top, accRect.top);
    accRect.right = min$4(rect2.right, accRect.right);
    accRect.bottom = min$4(rect2.bottom, accRect.bottom);
    accRect.left = max$4(rect2.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingParent$1(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
const platform$1 = {
  getElementRects: (_ref) => {
    let {
      reference: reference3,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent$1(reference3, getOffsetParent$1(floating), strategy),
      floating: {
        ...getDimensions$1(floating),
        x: 0,
        y: 0
      }
    };
  },
  convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect$1(args),
  getOffsetParent: (_ref2) => {
    let {
      element
    } = _ref2;
    return getOffsetParent$1(element);
  },
  isElement: (value) => isElement$1(value),
  getDocumentElement: (_ref3) => {
    let {
      element
    } = _ref3;
    return getDocumentElement$1(element);
  },
  getClippingClientRect: (args) => getClippingClientRect$1(args),
  getDimensions: (_ref4) => {
    let {
      element
    } = _ref4;
    return getDimensions$1(element);
  },
  getClientRects: (_ref5) => {
    let {
      element
    } = _ref5;
    return element.getClientRects();
  }
};
const computePosition$2 = (reference3, floating, options) => computePosition$3(reference3, floating, {
  platform: platform$1,
  ...options
});
var __defProp$4 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$4.call(b2, prop2))
      __defNormalProp$4(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$4)
    for (var prop2 of __getOwnPropSymbols$4(b2)) {
      if (__propIsEnum$4.call(b2, prop2))
        __defNormalProp$4(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps$1 = (a2, b2) => __defProps$1(a2, __getOwnPropDescs$1(b2));
function assign$3(to2, from2) {
  for (const key in from2) {
    if (Object.prototype.hasOwnProperty.call(from2, key)) {
      if (typeof from2[key] === "object" && to2[key]) {
        assign$3(to2[key], from2[key]);
      } else {
        to2[key] = from2[key];
      }
    }
  }
}
const config$4 = {
  disabled: false,
  distance: 5,
  skidding: 0,
  container: "body",
  boundary: void 0,
  instantMove: false,
  disposeTimeout: 5e3,
  popperTriggers: [],
  strategy: "absolute",
  preventOverflow: true,
  flip: true,
  shift: true,
  overflowPadding: 0,
  arrowPadding: 0,
  arrowOverflow: true,
  themes: {
    tooltip: {
      placement: "top",
      triggers: ["hover", "focus", "touch"],
      hideTriggers: (events) => [...events, "click"],
      delay: {
        show: 200,
        hide: 0
      },
      handleResize: false,
      html: false,
      loadingContent: "..."
    },
    dropdown: {
      placement: "bottom",
      triggers: ["click"],
      delay: 0,
      handleResize: true,
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function getDefaultConfig$1(theme, key) {
  let themeConfig = config$4.themes[theme] || {};
  let value;
  do {
    value = themeConfig[key];
    if (typeof value === "undefined") {
      if (themeConfig.$extend) {
        themeConfig = config$4.themes[themeConfig.$extend] || {};
      } else {
        themeConfig = null;
        value = config$4[key];
      }
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return value;
}
function getThemeClasses$1(theme) {
  const result = [theme];
  let themeConfig = config$4.themes[theme] || {};
  do {
    if (themeConfig.$extend && !themeConfig.$resetCss) {
      result.push(themeConfig.$extend);
      themeConfig = config$4.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result.map((c2) => `v-popper--theme-${c2}`);
}
let supportsPassive$1 = false;
if (typeof window !== "undefined") {
  supportsPassive$1 = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive$1 = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e2) {
  }
}
let isIOS$1 = false;
if (typeof window !== "undefined" && typeof navigator !== "undefined") {
  isIOS$1 = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
const placements$1 = ["auto", "top", "bottom", "left", "right"].reduce((acc, base2) => acc.concat([
  base2,
  `${base2}-start`,
  `${base2}-end`
]), []);
const SHOW_EVENT_MAP$1 = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart"
};
const HIDE_EVENT_MAP$1 = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend"
};
function removeFromArray$1(array2, item) {
  const index2 = array2.indexOf(item);
  if (index2 !== -1) {
    array2.splice(index2, 1);
  }
}
function nextFrame$1() {
  return new Promise((resolve2) => requestAnimationFrame(() => {
    requestAnimationFrame(resolve2);
  }));
}
const shownPoppers$1 = [];
let hidingPopper$1 = null;
let Element$3 = function() {
};
if (typeof window !== "undefined") {
  Element$3 = window.Element;
}
function defaultPropFactory$1(prop2) {
  return function(props) {
    return getDefaultConfig$1(props.theme, prop2);
  };
}
var PrivatePopper$1 = () => defineComponent({
  name: "VPopper",
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      required: true
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: defaultPropFactory$1("disabled")
    },
    placement: {
      type: String,
      default: defaultPropFactory$1("placement"),
      validator: (value) => placements$1.includes(value)
    },
    delay: {
      type: [String, Number, Object],
      default: defaultPropFactory$1("delay")
    },
    distance: {
      type: [Number, String],
      default: defaultPropFactory$1("distance")
    },
    skidding: {
      type: [Number, String],
      default: defaultPropFactory$1("skidding")
    },
    triggers: {
      type: Array,
      default: defaultPropFactory$1("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: defaultPropFactory$1("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory$1("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: defaultPropFactory$1("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: defaultPropFactory$1("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory$1("popperHideTriggers")
    },
    container: {
      type: [String, Object, Element$3, Boolean],
      default: defaultPropFactory$1("container")
    },
    boundary: {
      type: [String, Element$3],
      default: defaultPropFactory$1("boundary")
    },
    strategy: {
      type: String,
      validator: (value) => ["absolute", "fixed"].includes(value),
      default: defaultPropFactory$1("strategy")
    },
    autoHide: {
      type: Boolean,
      default: defaultPropFactory$1("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: defaultPropFactory$1("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: defaultPropFactory$1("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: defaultPropFactory$1("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: defaultPropFactory$1("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: defaultPropFactory$1("computeTransformOrigin")
    },
    autoMinSize: {
      type: Boolean,
      default: defaultPropFactory$1("autoMinSize")
    },
    autoMaxSize: {
      type: Boolean,
      default: defaultPropFactory$1("autoMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: defaultPropFactory$1("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: defaultPropFactory$1("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: defaultPropFactory$1("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: defaultPropFactory$1("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: defaultPropFactory$1("flip")
    },
    shift: {
      type: Boolean,
      default: defaultPropFactory$1("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: defaultPropFactory$1("shiftCrossAxis")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      }
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: __spreadProps$1(__spreadValues$4({}, this.classes), {
          popperClass: this.popperClass
        }),
        result: this.result
      };
    }
  },
  watch: __spreadValues$4({
    shown: "$_autoShowHide",
    disabled(value) {
      if (value) {
        this.dispose();
      } else {
        this.init();
      }
    },
    async container() {
      if (this.isShown) {
        this.$_ensureTeleport();
        await this.$_computePosition();
      }
    },
    triggers() {
      if (!this.$_isDisposed) {
        this.$_removeEventListeners();
        this.$_addEventListeners();
      }
    }
  }, [
    "placement",
    "distance",
    "skidding",
    "boundary",
    "strategy",
    "overflowPadding",
    "arrowPadding",
    "preventOverflow",
    "shift",
    "shiftCrossAxis",
    "flip"
  ].reduce((acc, prop2) => {
    acc[prop2] = "$_computePosition";
    return acc;
  }, {})),
  created() {
    this.$_isDisposed = true;
    this.randomId = `popper_${[Math.random(), Date.now()].map((n2) => n2.toString(36).substring(2, 10)).join("_")}`;
  },
  mounted() {
    this.init();
    this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event = null, skipDelay = false, force = false } = {}) {
      if (force || !this.disabled) {
        this.$_scheduleShow(event, skipDelay);
        this.$emit("show");
        this.$_showFrameLocked = true;
        requestAnimationFrame(() => {
          this.$_showFrameLocked = false;
        });
      }
      this.$emit("update:shown", true);
    },
    hide({ event = null, skipDelay = false } = {}) {
      this.$_scheduleHide(event, skipDelay);
      this.$emit("hide");
      this.$emit("update:shown", false);
    },
    init() {
      if (!this.$_isDisposed)
        return;
      this.$_isDisposed = false;
      this.isMounted = false;
      this.$_events = [];
      this.$_preventShow = false;
      this.$_referenceNode = this.referenceNode();
      this.$_targetNodes = this.targetNodes().filter((e2) => e2.nodeType === e2.ELEMENT_NODE);
      this.$_popperNode = this.popperNode();
      this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
      this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
      this.$_swapTargetAttrs("title", "data-original-title");
      this.$_detachPopperNode();
      if (this.triggers.length) {
        this.$_addEventListeners();
      }
      if (this.shown) {
        this.show();
      }
    },
    dispose() {
      if (this.$_isDisposed)
        return;
      this.$_isDisposed = true;
      this.$_removeEventListeners();
      this.hide({ skipDelay: true });
      this.$_detachPopperNode();
      this.isMounted = false;
      this.isShown = false;
      this.$_swapTargetAttrs("data-original-title", "title");
      this.$emit("dispose");
    },
    async onResize() {
      if (this.isShown) {
        await this.$_computePosition();
        this.$emit("resize");
      }
    },
    async $_computePosition() {
      var _a2;
      if (this.$_isDisposed)
        return;
      const options2 = {
        strategy: this.strategy,
        middleware: []
      };
      if (this.distance || this.skidding) {
        options2.middleware.push(offset$2({
          mainAxis: this.distance,
          crossAxis: this.skidding
        }));
      }
      const isPlacementAuto = this.placement.startsWith("auto");
      if (isPlacementAuto) {
        options2.middleware.push(autoPlacement$1({
          alignment: (_a2 = this.placement.split("-")[1]) != null ? _a2 : ""
        }));
      } else {
        options2.placement = this.placement;
      }
      if (this.preventOverflow) {
        if (this.shift) {
          options2.middleware.push(shift$1({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          }));
        }
        if (!isPlacementAuto && this.flip) {
          options2.middleware.push(flip$1({
            padding: this.overflowPadding,
            boundary: this.boundary
          }));
        }
      }
      options2.middleware.push(arrow$1({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      }));
      if (this.arrowOverflow) {
        options2.middleware.push({
          name: "arrowOverflow",
          fn: ({ placement, rects, middlewareData }) => {
            let overflow;
            const { centerOffset } = middlewareData.arrow;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              overflow = Math.abs(centerOffset) > rects.reference.width / 2;
            } else {
              overflow = Math.abs(centerOffset) > rects.reference.height / 2;
            }
            return {
              data: {
                overflow
              }
            };
          }
        });
      }
      if (this.autoMinSize) {
        options2.middleware.push({
          name: "autoMinSize",
          fn: ({ rects, placement, middlewareData }) => {
            var _a22;
            if ((_a22 = middlewareData.autoMinSize) == null ? void 0 : _a22.skip) {
              return {};
            }
            let width;
            let height;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              width = rects.reference.width;
            } else {
              height = rects.reference.height;
            }
            this.$_innerNode.style.minWidth = width != null ? `${width}px` : null;
            this.$_innerNode.style.minHeight = height != null ? `${height}px` : null;
            return {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      if (this.autoMaxSize) {
        options2.middleware.push(size$1({
          boundary: this.boundary,
          padding: this.overflowPadding,
          apply: ({ width, height }) => {
            this.$_innerNode.style.maxWidth = width != null ? `${width}px` : null;
            this.$_innerNode.style.maxHeight = height != null ? `${height}px` : null;
          }
        }));
      }
      const data2 = await computePosition$2(this.$_referenceNode, this.$_popperNode, options2);
      Object.assign(this.result, {
        x: data2.x,
        y: data2.y,
        placement: data2.placement,
        strategy: data2.strategy,
        arrow: __spreadValues$4(__spreadValues$4({}, data2.middlewareData.arrow), data2.middlewareData.arrowOverflow)
      });
    },
    $_scheduleShow(event = null, skipDelay = false) {
      this.$_hideInProgress = false;
      clearTimeout(this.$_scheduleTimer);
      if (hidingPopper$1 && this.instantMove && hidingPopper$1.instantMove) {
        hidingPopper$1.$_applyHide(true);
        this.$_applyShow(true);
        return;
      }
      if (skipDelay) {
        this.$_applyShow();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
      }
    },
    $_scheduleHide(event = null, skipDelay = false) {
      this.$_hideInProgress = true;
      clearTimeout(this.$_scheduleTimer);
      if (this.isShown) {
        hidingPopper$1 = this;
      }
      if (skipDelay) {
        this.$_applyHide();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
      }
    },
    $_computeDelay(type) {
      const delay = this.delay;
      return parseInt(delay && delay[type] || delay || 0);
    },
    async $_applyShow(skipTransition = false) {
      clearTimeout(this.$_disposeTimer);
      clearTimeout(this.$_scheduleTimer);
      this.skipTransition = skipTransition;
      if (this.isShown) {
        return;
      }
      this.$_ensureTeleport();
      await nextFrame$1();
      await this.$_computePosition();
      await this.$_applyShowEffect();
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const bounds = this.$_referenceNode.getBoundingClientRect();
        const popperWrapper = this.$_popperNode.querySelector(".v-popper__wrapper");
        const parentBounds = popperWrapper.parentNode.getBoundingClientRect();
        const x2 = bounds.x + bounds.width / 2 - (parentBounds.left + popperWrapper.offsetLeft);
        const y2 = bounds.y + bounds.height / 2 - (parentBounds.top + popperWrapper.offsetTop);
        this.result.transformOrigin = `${x2}px ${y2}px`;
      }
      this.isShown = true;
      this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const showGroup = this.showGroup;
      if (showGroup) {
        let popover;
        for (let i2 = 0; i2 < shownPoppers$1.length; i2++) {
          popover = shownPoppers$1[i2];
          if (popover.showGroup !== showGroup) {
            popover.hide();
            popover.$emit("close-group");
          }
        }
      }
      shownPoppers$1.push(this);
      this.$emit("apply-show");
      this.classes.showFrom = true;
      this.classes.showTo = false;
      this.classes.hideFrom = false;
      this.classes.hideTo = false;
      await nextFrame$1();
      this.classes.showFrom = false;
      this.classes.showTo = true;
    },
    async $_applyHide(skipTransition = false) {
      clearTimeout(this.$_scheduleTimer);
      if (!this.isShown) {
        return;
      }
      this.skipTransition = skipTransition;
      removeFromArray$1(shownPoppers$1, this);
      if (hidingPopper$1 === this) {
        hidingPopper$1 = null;
      }
      this.isShown = false;
      this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      });
      clearTimeout(this.$_disposeTimer);
      const disposeTime = getDefaultConfig$1(this.theme, "disposeTimeout");
      if (disposeTime !== null) {
        this.$_disposeTimer = setTimeout(() => {
          if (this.$_popperNode) {
            this.$_detachPopperNode();
            this.isMounted = false;
          }
        }, disposeTime);
      }
      this.$emit("apply-hide");
      this.classes.showFrom = false;
      this.classes.showTo = false;
      this.classes.hideFrom = true;
      this.classes.hideTo = false;
      await nextFrame$1();
      this.classes.hideFrom = false;
      this.classes.hideTo = true;
    },
    $_autoShowHide() {
      if (this.shown) {
        this.show();
      } else {
        this.hide();
      }
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let container = this.container;
      if (typeof container === "string") {
        container = window.document.querySelector(container);
      } else if (container === false) {
        container = this.$_targetNodes[0].parentNode;
      }
      if (!container) {
        throw new Error("No container for popover: " + this.container);
      }
      container.appendChild(this.$_popperNode);
      this.isMounted = true;
    },
    $_addEventListeners() {
      const addListeners2 = (targetNodes, eventType, handler) => {
        this.$_events.push({ targetNodes, eventType, handler });
        targetNodes.forEach((node) => node.addEventListener(eventType, handler, supportsPassive$1 ? {
          passive: true
        } : void 0));
      };
      const addEvents = (targetNodes, eventMap, commonTriggers, customTrigger, handler) => {
        let triggers = commonTriggers;
        if (customTrigger != null) {
          triggers = typeof customTrigger === "function" ? customTrigger(triggers) : customTrigger;
        }
        triggers.forEach((trigger2) => {
          const eventType = eventMap[trigger2];
          if (eventType) {
            addListeners2(targetNodes, eventType, handler);
          }
        });
      };
      const handleShow = (event) => {
        if (this.isShown && !this.$_hideInProgress) {
          return;
        }
        event.usedByTooltip = true;
        !this.$_preventShow && this.show({ event });
      };
      addEvents(this.$_targetNodes, SHOW_EVENT_MAP$1, this.triggers, this.showTriggers, handleShow);
      addEvents([this.$_popperNode], SHOW_EVENT_MAP$1, this.popperTriggers, this.popperShowTriggers, handleShow);
      const handleHide = (event) => {
        if (event.usedByTooltip) {
          return;
        }
        this.hide({ event });
      };
      addEvents(this.$_targetNodes, HIDE_EVENT_MAP$1, this.triggers, this.hideTriggers, handleHide);
      addEvents([this.$_popperNode], HIDE_EVENT_MAP$1, this.popperTriggers, this.popperHideTriggers, handleHide);
      addListeners2([
        ...getScrollParents$1(this.$_referenceNode),
        ...getScrollParents$1(this.$_popperNode)
      ], "scroll", () => {
        this.$_computePosition();
      });
    },
    $_removeEventListeners() {
      this.$_events.forEach(({ targetNodes, eventType, handler }) => {
        targetNodes.forEach((node) => node.removeEventListener(eventType, handler));
      });
      this.$_events = [];
    },
    $_handleGlobalClose(event, touch = false) {
      if (this.$_showFrameLocked)
        return;
      this.hide({ event });
      if (event.closePopover) {
        this.$emit("close-directive");
      } else {
        this.$emit("auto-hide");
      }
      if (touch) {
        this.$_preventShow = true;
        setTimeout(() => {
          this.$_preventShow = false;
        }, 300);
      }
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(attrFrom, attrTo) {
      for (const el2 of this.$_targetNodes) {
        const value = el2.getAttribute(attrFrom);
        if (value) {
          el2.removeAttribute(attrFrom);
          el2.setAttribute(attrTo, value);
        }
      }
    },
    $_applyAttrsToTarget(attrs) {
      for (const el2 of this.$_targetNodes) {
        for (const n2 in attrs) {
          const value = attrs[n2];
          if (value == null) {
            el2.removeAttribute(n2);
          } else {
            el2.setAttribute(n2, value);
          }
        }
      }
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
if (typeof document !== "undefined" && typeof window !== "undefined") {
  if (isIOS$1) {
    document.addEventListener("touchstart", handleGlobalMousedown$1, supportsPassive$1 ? {
      passive: true,
      capture: true
    } : true);
    document.addEventListener("touchend", handleGlobalTouchend$1, supportsPassive$1 ? {
      passive: true,
      capture: true
    } : true);
  } else {
    window.addEventListener("mousedown", handleGlobalMousedown$1, true);
    window.addEventListener("click", handleGlobalClick$1, true);
  }
  window.addEventListener("resize", computePositionAllShownPoppers$1);
}
function handleGlobalMousedown$1(event) {
  for (let i2 = 0; i2 < shownPoppers$1.length; i2++) {
    const popper = shownPoppers$1[i2];
    const popperContent = popper.popperNode();
    popper.$_mouseDownContains = popperContent.contains(event.target);
  }
}
function handleGlobalClick$1(event) {
  handleGlobalClose$1(event);
}
function handleGlobalTouchend$1(event) {
  handleGlobalClose$1(event, true);
}
function handleGlobalClose$1(event, touch = false) {
  for (let i2 = 0; i2 < shownPoppers$1.length; i2++) {
    const popper = shownPoppers$1[i2];
    const popperContent = popper.popperNode();
    const contains2 = popper.$_mouseDownContains || popperContent.contains(event.target);
    requestAnimationFrame(() => {
      if (event.closeAllPopover || event.closePopover && contains2 || popper.autoHide && !contains2) {
        popper.$_handleGlobalClose(event, touch);
      }
    });
  }
}
function computePositionAllShownPoppers$1(event) {
  for (let i2 = 0; i2 < shownPoppers$1.length; i2++) {
    const popper = shownPoppers$1[i2];
    popper.$_computePosition(event);
  }
}
function getInternetExplorerVersion$1() {
  var ua2 = window.navigator.userAgent;
  var msie = ua2.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua2.substring(msie + 5, ua2.indexOf(".", msie)), 10);
  }
  var trident = ua2.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua2.indexOf("rv:");
    return parseInt(ua2.substring(rv + 3, ua2.indexOf(".", rv)), 10);
  }
  var edge = ua2.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua2.substring(edge + 5, ua2.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE$1;
function initCompat$1() {
  if (!initCompat$1.init) {
    initCompat$1.init = true;
    isIE$1 = getInternetExplorerVersion$1() !== -1;
  }
}
var script$1 = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat$1();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE$1) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE$1) {
      this.$el.appendChild(object);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE$1 && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId$1 = /* @__PURE__ */ withScopeId();
pushScopeId("data-v-b329ee4c");
const _hoisted_1$2$2 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render$3 = /* @__PURE__ */ _withId$1((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$2$2);
});
script$1.render = render$3;
script$1.__scopeId = "data-v-b329ee4c";
script$1.__file = "src/components/ResizeObserver.vue";
var PrivateThemeClass$1 = {
  computed: {
    themeClass() {
      return getThemeClasses$1(this.theme);
    }
  }
};
var _export_sfc$1 = (sfc, props) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target2[key] = val;
  }
  return target2;
};
const _sfc_main$5$2 = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: script$1
  },
  mixins: [
    PrivateThemeClass$1
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(value) {
      if (value != null && !isNaN(value)) {
        return `${value}px`;
      }
      return null;
    }
  }
});
const _hoisted_1$1$2 = ["id", "aria-hidden", "tabindex", "data-popper-placement"];
const _hoisted_2$1$2 = {
  ref: "inner",
  class: "v-popper__inner"
};
const _hoisted_3$8 = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1);
const _hoisted_4$6 = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1);
const _hoisted_5$4 = [
  _hoisted_3$8,
  _hoisted_4$6
];
function _sfc_render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: _ctx.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      _ctx.themeClass,
      _ctx.classes.popperClass,
      {
        "v-popper__popper--shown": _ctx.shown,
        "v-popper__popper--hidden": !_ctx.shown,
        "v-popper__popper--show-from": _ctx.classes.showFrom,
        "v-popper__popper--show-to": _ctx.classes.showTo,
        "v-popper__popper--hide-from": _ctx.classes.hideFrom,
        "v-popper__popper--hide-to": _ctx.classes.hideTo,
        "v-popper__popper--skip-transition": _ctx.skipTransition,
        "v-popper__popper--arrow-overflow": _ctx.result.arrow.overflow
      }
    ]]),
    style: normalizeStyle({
      position: _ctx.result.strategy,
      transform: `translate3d(${Math.round(_ctx.result.x)}px,${Math.round(_ctx.result.y)}px,0)`
    }),
    "aria-hidden": _ctx.shown ? "false" : "true",
    tabindex: _ctx.autoHide ? 0 : void 0,
    "data-popper-placement": _ctx.result.placement,
    onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.autoHide && _ctx.$emit("hide"), ["esc"]))
  }, [
    createBaseVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle({
        transformOrigin: _ctx.result.transformOrigin
      })
    }, [
      createBaseVNode("div", _hoisted_2$1$2, [
        _ctx.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", null, [
            renderSlot(_ctx.$slots, "default")
          ]),
          _ctx.handleResize ? (openBlock(), createBlock(_component_ResizeObserver, {
            key: 0,
            onNotify: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("resize", $event))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createBaseVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle({
          left: _ctx.toPx(_ctx.result.arrow.x),
          top: _ctx.toPx(_ctx.result.arrow.y)
        })
      }, _hoisted_5$4, 4)
    ], 4)
  ], 46, _hoisted_1$1$2);
}
var PrivatePopperContent$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$5$2, [["render", _sfc_render$2$1]]);
var PrivatePopperMethods$1 = {
  methods: {
    show(...args) {
      return this.$refs.popper.show(...args);
    },
    hide(...args) {
      return this.$refs.popper.hide(...args);
    },
    dispose(...args) {
      return this.$refs.popper.dispose(...args);
    },
    onResize(...args) {
      return this.$refs.popper.onResize(...args);
    }
  }
};
const _sfc_main$4$2 = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: PrivatePopper$1(),
    PopperContent: PrivatePopperContent$1
  },
  mixins: [
    PrivatePopperMethods$1,
    PrivateThemeClass$1
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      var _a2;
      return (_a2 = this.theme) != null ? _a2 : this.$options.vPopperTheme;
    },
    popperAttrs() {
      const result = __spreadValues$4({}, this.$attrs);
      delete result.class;
      delete result.style;
      return result;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$refs.reference.children).filter((node) => node !== this.$refs.popperContent.$el);
    }
  }
});
function _sfc_render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, mergeProps({ ref: "popper" }, _ctx.popperAttrs, {
    theme: _ctx.finalTheme,
    "target-nodes": _ctx.getTargetNodes,
    "reference-node": () => _ctx.$refs.reference,
    "popper-node": () => _ctx.$refs.popperContent.$el
  }), {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      show,
      hide,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      createBaseVNode("div", {
        ref: "reference",
        class: normalizeClass(["v-popper", [
          _ctx.$attrs.class,
          _ctx.themeClass,
          {
            "v-popper--shown": isShown
          }
        ]]),
        style: normalizeStyle(_ctx.$attrs.style)
      }, [
        renderSlot(_ctx.$slots, "default", {
          shown: isShown,
          show,
          hide
        }),
        createVNode(_component_PopperContent, {
          ref: "popperContent",
          "popper-id": popperId,
          theme: _ctx.finalTheme,
          shown: isShown,
          mounted: shouldMountContent,
          "skip-transition": skipTransition,
          "auto-hide": autoHide,
          "handle-resize": handleResize,
          classes,
          result,
          onHide: hide,
          onResize
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "popper", {
              shown: isShown,
              hide
            })
          ]),
          _: 2
        }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
      ], 6)
    ]),
    _: 3
  }, 16, ["theme", "target-nodes", "reference-node", "popper-node"]);
}
var PrivatePopperWrapper$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$4$2, [["render", _sfc_render$1$1]]);
const _sfc_main$3$3 = defineComponent(__spreadProps$1(__spreadValues$4({}, PrivatePopperWrapper$1), {
  name: "VDropdown",
  vPopperTheme: "dropdown"
}));
const _sfc_main$2$2 = defineComponent(__spreadProps$1(__spreadValues$4({}, PrivatePopperWrapper$1), {
  name: "VMenu",
  vPopperTheme: "menu"
}));
const _sfc_main$1$2 = defineComponent(__spreadProps$1(__spreadValues$4({}, PrivatePopperWrapper$1), {
  name: "VTooltip",
  vPopperTheme: "tooltip"
}));
const _sfc_main$f = defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: PrivatePopper$1(),
    PopperContent: PrivatePopperContent$1
  },
  mixins: [
    PrivatePopperMethods$1
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (props) => getDefaultConfig$1(props.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (props) => getDefaultConfig$1(props.theme, "loadingContent")
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content === "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      if (this.isContentAsync) {
        return this.loading ? this.loadingContent : this.asyncContent;
      }
      return this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick();
      this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(force) {
      if (typeof this.content === "function" && this.$_isShown && (force || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null;
        this.$_loading = true;
        const fetchId = ++this.$_fetchId;
        const result = this.content(this);
        if (result.then) {
          result.then((res) => this.onResult(fetchId, res));
        } else {
          this.onResult(fetchId, result);
        }
      }
    },
    onResult(fetchId, result) {
      if (fetchId !== this.$_fetchId)
        return;
      this.$_loading = false;
      this.asyncContent = result;
    },
    onShow() {
      this.$_isShown = true;
      this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
});
const _hoisted_1$b = ["innerHTML"];
const _hoisted_2$9 = ["textContent"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, mergeProps({ ref: "popper" }, _ctx.$attrs, {
    theme: _ctx.theme,
    "popper-node": () => _ctx.$refs.popperContent.$el,
    onApplyShow: _ctx.onShow,
    onApplyHide: _ctx.onHide
  }), {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      hide,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      createVNode(_component_PopperContent, {
        ref: "popperContent",
        class: normalizeClass({
          "v-popper--tooltip-loading": _ctx.loading
        }),
        "popper-id": popperId,
        theme: _ctx.theme,
        shown: isShown,
        mounted: shouldMountContent,
        "skip-transition": skipTransition,
        "auto-hide": autoHide,
        "handle-resize": handleResize,
        classes,
        result,
        onHide: hide,
        onResize
      }, {
        default: withCtx(() => [
          _ctx.html ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: _ctx.finalContent
          }, null, 8, _hoisted_1$b)) : (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(_ctx.finalContent)
          }, null, 8, _hoisted_2$9))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "popper-node", "onApplyShow", "onApplyHide"]);
}
var PrivateTooltipDirective$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$4]]);
const TARGET_CLASS$1 = "v-popper--has-tooltip";
function getPlacement$1(options2, modifiers) {
  let result = options2.placement;
  if (!result && modifiers) {
    for (const pos of placements$1) {
      if (modifiers[pos]) {
        result = pos;
      }
    }
  }
  if (!result) {
    result = getDefaultConfig$1(options2.theme || "tooltip", "placement");
  }
  return result;
}
function getOptions$2(el2, value, modifiers) {
  let options2;
  const type = typeof value;
  if (type === "string") {
    options2 = { content: value };
  } else if (value && type === "object") {
    options2 = value;
  } else {
    options2 = { content: false };
  }
  options2.placement = getPlacement$1(options2, modifiers);
  options2.targetNodes = () => [el2];
  options2.referenceNode = () => el2;
  return options2;
}
let directiveApp$1;
let directives$1;
let uid$1 = 0;
function ensureDirectiveApp$1() {
  if (directiveApp$1)
    return;
  directives$1 = ref([]);
  directiveApp$1 = createApp({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives: directives$1
      };
    },
    render() {
      return this.directives.map((directive) => {
        return h$2(PrivateTooltipDirective$1, __spreadProps$1(__spreadValues$4({}, directive.options), {
          shown: directive.shown.value || directive.options.shown,
          key: directive.id
        }));
      });
    },
    devtools: {
      hide: true
    }
  });
  const mountTarget = document.createElement("div");
  document.body.appendChild(mountTarget);
  directiveApp$1.mount(mountTarget);
}
function createTooltip$1(el2, value, modifiers) {
  ensureDirectiveApp$1();
  const options2 = ref(getOptions$2(el2, value, modifiers));
  const shown = ref(false);
  const item = {
    id: uid$1++,
    options: options2,
    shown
  };
  directives$1.value.push(item);
  if (el2.classList) {
    el2.classList.add(TARGET_CLASS$1);
  }
  const result = el2.$_popper = {
    options: options2,
    item,
    show() {
      shown.value = true;
    },
    hide() {
      shown.value = false;
    }
  };
  return result;
}
function destroyTooltip$1(el2) {
  if (el2.$_popper) {
    const index2 = directives$1.value.indexOf(el2.$_popper.item);
    if (index2 !== -1)
      directives$1.value.splice(index2, 1);
    delete el2.$_popper;
    delete el2.$_popperOldShown;
    delete el2.$_popperMountTarget;
  }
  if (el2.classList) {
    el2.classList.remove(TARGET_CLASS$1);
  }
}
function bind$1(el2, { value, oldValue, modifiers }) {
  const options2 = getOptions$2(el2, value, modifiers);
  if (!options2.content || getDefaultConfig$1(options2.theme || "tooltip", "disabled")) {
    destroyTooltip$1(el2);
  } else {
    let directive;
    if (el2.$_popper) {
      directive = el2.$_popper;
      directive.options.value = options2;
    } else {
      directive = createTooltip$1(el2, value, modifiers);
    }
    if (typeof value.shown !== "undefined" && value.shown !== el2.$_popperOldShown) {
      el2.$_popperOldShown = value.shown;
      value.shown ? directive.show() : directive.hide();
    }
  }
}
var PrivateVTooltip$1 = {
  beforeMount: bind$1,
  updated: bind$1,
  beforeUnmount(el2) {
    destroyTooltip$1(el2);
  }
};
function addListeners(el2) {
  el2.addEventListener("click", onClick);
  el2.addEventListener("touchstart", onTouchStart, supportsPassive$1 ? {
    passive: true
  } : false);
}
function removeListeners(el2) {
  el2.removeEventListener("click", onClick);
  el2.removeEventListener("touchstart", onTouchStart);
  el2.removeEventListener("touchend", onTouchEnd);
  el2.removeEventListener("touchcancel", onTouchCancel);
}
function onClick(event) {
  const el2 = event.currentTarget;
  event.closePopover = !el2.$_vclosepopover_touch;
  event.closeAllPopover = el2.$_closePopoverModifiers && !!el2.$_closePopoverModifiers.all;
}
function onTouchStart(event) {
  if (event.changedTouches.length === 1) {
    const el2 = event.currentTarget;
    el2.$_vclosepopover_touch = true;
    const touch = event.changedTouches[0];
    el2.$_vclosepopover_touchPoint = touch;
    el2.addEventListener("touchend", onTouchEnd);
    el2.addEventListener("touchcancel", onTouchCancel);
  }
}
function onTouchEnd(event) {
  const el2 = event.currentTarget;
  el2.$_vclosepopover_touch = false;
  if (event.changedTouches.length === 1) {
    const touch = event.changedTouches[0];
    const firstTouch = el2.$_vclosepopover_touchPoint;
    event.closePopover = Math.abs(touch.screenY - firstTouch.screenY) < 20 && Math.abs(touch.screenX - firstTouch.screenX) < 20;
    event.closeAllPopover = el2.$_closePopoverModifiers && !!el2.$_closePopoverModifiers.all;
  }
}
function onTouchCancel(event) {
  const el2 = event.currentTarget;
  el2.$_vclosepopover_touch = false;
}
var PrivateVClosePopper = {
  beforeMount(el2, { value, modifiers }) {
    el2.$_closePopoverModifiers = modifiers;
    if (typeof value === "undefined" || value) {
      addListeners(el2);
    }
  },
  updated(el2, { value, oldValue, modifiers }) {
    el2.$_closePopoverModifiers = modifiers;
    if (value !== oldValue) {
      if (typeof value === "undefined" || value) {
        addListeners(el2);
      } else {
        removeListeners(el2);
      }
    }
  },
  beforeUnmount(el2) {
    removeListeners(el2);
  }
};
const Dropdown$1 = _sfc_main$3$3;
function install(app, options2 = {}) {
  if (app.$_vTooltipInstalled)
    return;
  app.$_vTooltipInstalled = true;
  assign$3(config$4, options2);
  app.directive("tooltip", PrivateVTooltip$1);
  app.directive("close-popper", PrivateVClosePopper);
  app.component("v-tooltip", _sfc_main$1$2);
  app.component("VTooltip", _sfc_main$1$2);
  app.component("v-dropdown", _sfc_main$3$3);
  app.component("VDropdown", _sfc_main$3$3);
  app.component("v-menu", _sfc_main$2$2);
  app.component("VMenu", _sfc_main$2$2);
}
const plugin = {
  version: "2.0.0-y.0",
  install,
  options: config$4
};
function t$2(t2) {
  return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
}
function e$1(t2, e2) {
  return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
}
function n$1(t2, n2) {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    var r2 = getComputedStyle(t2, null);
    return e$1(r2.overflowY, n2) || e$1(r2.overflowX, n2) || function(t3) {
      var e2 = function(t4) {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      }(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    }(t2);
  }
  return false;
}
function r$1(t2, e2, n2, r2, i2, o2, l2, d2) {
  return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i2 : 0;
}
function compute(e2, i2) {
  var o2 = window, l2 = i2.scrollMode, d2 = i2.block, u2 = i2.inline, h2 = i2.boundary, a2 = i2.skipOverflowHiddenElements, c2 = "function" == typeof h2 ? h2 : function(t2) {
    return t2 !== h2;
  };
  if (!t$2(e2))
    throw new TypeError("Invalid target");
  for (var f2 = document.scrollingElement || document.documentElement, s2 = [], p2 = e2; t$2(p2) && c2(p2); ) {
    if ((p2 = p2.parentElement) === f2) {
      s2.push(p2);
      break;
    }
    null != p2 && p2 === document.body && n$1(p2) && !n$1(document.documentElement) || null != p2 && n$1(p2, a2) && s2.push(p2);
  }
  for (var m2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, g2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, w2 = window.scrollX || pageXOffset, v2 = window.scrollY || pageYOffset, W2 = e2.getBoundingClientRect(), b2 = W2.height, H2 = W2.width, y2 = W2.top, E2 = W2.right, M2 = W2.bottom, V2 = W2.left, x2 = "start" === d2 || "nearest" === d2 ? y2 : "end" === d2 ? M2 : y2 + b2 / 2, I2 = "center" === u2 ? V2 + H2 / 2 : "end" === u2 ? E2 : V2, C2 = [], T2 = 0; T2 < s2.length; T2++) {
    var k2 = s2[T2], B2 = k2.getBoundingClientRect(), D2 = B2.height, O2 = B2.width, R2 = B2.top, X2 = B2.right, Y2 = B2.bottom, L2 = B2.left;
    if ("if-needed" === l2 && y2 >= 0 && V2 >= 0 && M2 <= g2 && E2 <= m2 && y2 >= R2 && M2 <= Y2 && V2 >= L2 && E2 <= X2)
      return C2;
    var S2 = getComputedStyle(k2), j2 = parseInt(S2.borderLeftWidth, 10), q2 = parseInt(S2.borderTopWidth, 10), z2 = parseInt(S2.borderRightWidth, 10), A2 = parseInt(S2.borderBottomWidth, 10), F2 = 0, G2 = 0, J2 = "offsetWidth" in k2 ? k2.offsetWidth - k2.clientWidth - j2 - z2 : 0, K2 = "offsetHeight" in k2 ? k2.offsetHeight - k2.clientHeight - q2 - A2 : 0;
    if (f2 === k2)
      F2 = "start" === d2 ? x2 : "end" === d2 ? x2 - g2 : "nearest" === d2 ? r$1(v2, v2 + g2, g2, q2, A2, v2 + x2, v2 + x2 + b2, b2) : x2 - g2 / 2, G2 = "start" === u2 ? I2 : "center" === u2 ? I2 - m2 / 2 : "end" === u2 ? I2 - m2 : r$1(w2, w2 + m2, m2, j2, z2, w2 + I2, w2 + I2 + H2, H2), F2 = Math.max(0, F2 + v2), G2 = Math.max(0, G2 + w2);
    else {
      F2 = "start" === d2 ? x2 - R2 - q2 : "end" === d2 ? x2 - Y2 + A2 + K2 : "nearest" === d2 ? r$1(R2, Y2, D2, q2, A2 + K2, x2, x2 + b2, b2) : x2 - (R2 + D2 / 2) + K2 / 2, G2 = "start" === u2 ? I2 - L2 - j2 : "center" === u2 ? I2 - (L2 + O2 / 2) + J2 / 2 : "end" === u2 ? I2 - X2 + z2 + J2 : r$1(L2, X2, O2, j2, z2 + J2, I2, I2 + H2, H2);
      var N2 = k2.scrollLeft, P2 = k2.scrollTop;
      x2 += P2 - (F2 = Math.max(0, Math.min(P2 + F2, k2.scrollHeight - D2 + K2))), I2 += N2 - (G2 = Math.max(0, Math.min(N2 + G2, k2.scrollWidth - O2 + J2)));
    }
    C2.push({ el: k2, top: F2, left: G2 });
  }
  return C2;
}
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el2 = _ref.el, top2 = _ref.top, left = _ref.left;
    if (el2.scroll && canSmoothScroll) {
      el2.scroll({
        top: top2,
        left,
        behavior
      });
    } else {
      el2.scrollTop = top2;
      el2.scrollLeft = left;
    }
  });
}
function getOptions$1(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target2, options) {
  var isTargetAttached = target2.isConnected || target2.ownerDocument.documentElement.contains(target2);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? compute(target2, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions$1(options);
  return defaultBehavior(compute(target2, computeOptions), computeOptions.behavior);
}
var _a$1;
const isClient$1 = typeof window !== "undefined";
const isDef = (val) => typeof val !== "undefined";
const isFunction$2 = (val) => typeof val === "function";
const isString$4 = (val) => typeof val === "string";
const timestamp$1 = () => +Date.now();
const clamp = (n2, min2, max2) => Math.min(max2, Math.max(min2, n2));
const noop$3 = () => {
};
isClient$1 && ((_a$1 = window == null ? void 0 : window.navigator) == null ? void 0 : _a$1.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    filter2(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms2, options = {}) {
  let timer2;
  let maxTimer;
  const filter2 = (invoke) => {
    const duration = unref(ms2);
    const maxDuration = unref(options.maxWait);
    if (timer2)
      clearTimeout(timer2);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer2)
          clearTimeout(timer2);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer2 = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter2;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function tryOnScopeDispose$1(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p2, receiver) {
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(_2, p2, value) {
      if (isRef(objectRef.value[p2]) && !isRef(value))
        objectRef.value[p2].value = value;
      else
        objectRef.value[p2] = value;
      return true;
    },
    deleteProperty(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
function useDebounceFn(fn, ms2 = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms2, options), fn);
}
function refDebounced(value, ms2 = 200, options = {}) {
  if (ms2 <= 0)
    return value;
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms2, options);
  watch(value, () => updater());
  return debounced;
}
function tryOnBeforeMount(fn, sync = true) {
  if (getCurrentInstance())
    onBeforeMount(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useIntervalFn(cb, interval2 = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer2 = null;
  const isActive = ref(false);
  function clean() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (unref(interval2) <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer2 = setInterval(cb, unref(interval2));
  }
  if (immediate && isClient$1)
    resume();
  if (isRef(interval2)) {
    const stopWatch = watch(interval2, () => {
      if (isActive.value && isClient$1)
        resume();
    });
    tryOnScopeDispose$1(stopWatch);
  }
  tryOnScopeDispose$1(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useTimeoutFn$1(cb, interval2, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer2 = null;
  function clear2() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear2();
  }
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer2 = setTimeout(() => {
      isPending.value = false;
      timer2 = null;
      cb(...args);
    }, unref(interval2));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient$1)
      start2();
  }
  tryOnScopeDispose$1(stop);
  return {
    isPending,
    start: start2,
    stop
  };
}
function useToggle(initialValue = false, options = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options;
  const valueIsRef = isRef(initialValue);
  const innerValue = ref(initialValue);
  function toggle(value) {
    if (arguments.length) {
      innerValue.value = value;
      return innerValue.value;
    } else {
      innerValue.value = innerValue.value === unref(truthyValue) ? unref(falsyValue) : unref(truthyValue);
      return innerValue.value;
    }
  }
  if (valueIsRef)
    return toggle;
  else
    return [innerValue, toggle];
}
var __getOwnPropSymbols$6$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$6$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$6$1 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp$6$1.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols$6$1)
    for (var prop2 of __getOwnPropSymbols$6$1(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum$6$1.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
function watchWithFilter(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$3$1 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$3$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$3$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3$1 = (obj, key, value) => key in obj ? __defProp$3$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3$1 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$3$1.call(b2, prop2))
      __defNormalProp$3$1(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$3$1)
    for (var prop2 of __getOwnPropSymbols$3$1(b2)) {
      if (__propIsEnum$3$1.call(b2, prop2))
        __defNormalProp$3$1(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps$3 = (a2, b2) => __defProps$3(a2, __getOwnPropDescs$3(b2));
var __objRest$2$1 = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp$3$1.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols$3$1)
    for (var prop2 of __getOwnPropSymbols$3$1(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum$3$1.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
function watchIgnorable(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$2$1(_a2, [
    "eventFilter"
  ]);
  const filteredCb = createFilterWrapper(eventFilter, cb);
  let ignoreUpdates;
  let ignorePrevAsyncUpdates;
  let stop;
  if (watchOptions.flush === "sync") {
    const ignore = ref(false);
    ignorePrevAsyncUpdates = () => {
    };
    ignoreUpdates = (updater) => {
      ignore.value = true;
      updater();
      ignore.value = false;
    };
    stop = watch(source, (...args) => {
      if (!ignore.value)
        filteredCb(...args);
    }, watchOptions);
  } else {
    const disposables = [];
    const ignoreCounter = ref(0);
    const syncCounter = ref(0);
    ignorePrevAsyncUpdates = () => {
      ignoreCounter.value = syncCounter.value;
    };
    disposables.push(watch(source, () => {
      syncCounter.value++;
    }, __spreadProps$3(__spreadValues$3$1({}, watchOptions), { flush: "sync" })));
    ignoreUpdates = (updater) => {
      const syncCounterPrev = syncCounter.value;
      updater();
      ignoreCounter.value += syncCounter.value - syncCounterPrev;
    };
    disposables.push(watch(source, (...args) => {
      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
      ignoreCounter.value = 0;
      syncCounter.value = 0;
      if (ignore)
        return;
      filteredCb(...args);
    }, watchOptions));
    stop = () => {
      disposables.forEach((fn) => fn());
    };
  }
  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };
}
function watchOnce(source, cb, options) {
  const stop = watch(source, (...args) => {
    nextTick(() => stop());
    return cb(...args);
  }, options);
}
var __defProp$2$1 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2$1 = (obj, key, value) => key in obj ? __defProp$2$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2$1 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$2$1.call(b2, prop2))
      __defNormalProp$2$1(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$2$1)
    for (var prop2 of __getOwnPropSymbols$2$1(b2)) {
      if (__propIsEnum$2$1.call(b2, prop2))
        __defNormalProp$2$1(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps$2 = (a2, b2) => __defProps$2(a2, __getOwnPropDescs$2(b2));
var __objRest$1$1 = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp$2$1.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols$2$1)
    for (var prop2 of __getOwnPropSymbols$2$1(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum$2$1.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
function watchPausable(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter: filter2
  } = _a2, watchOptions = __objRest$1$1(_a2, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2$1({}, watchOptions), {
    eventFilter
  }));
  return { stop, pause, resume, isActive };
}
function computedAsync(evaluationCallback, initialState, optionsOrRef) {
  let options;
  if (isRef(optionsOrRef)) {
    options = {
      evaluating: optionsOrRef
    };
  } else {
    options = optionsOrRef || {};
  }
  const {
    lazy = false,
    evaluating = void 0,
    onError = noop$3
  } = options;
  const started = ref(!lazy);
  const current = ref(initialState);
  let counter2 = 0;
  watchEffect(async (onInvalidate) => {
    if (!started.value)
      return;
    counter2++;
    const counterAtBeginning = counter2;
    let hasFinished = false;
    if (evaluating) {
      Promise.resolve().then(() => {
        evaluating.value = true;
      });
    }
    try {
      const result = await evaluationCallback((cancelCallback) => {
        onInvalidate(() => {
          if (evaluating)
            evaluating.value = false;
          if (!hasFinished)
            cancelCallback();
        });
      });
      if (counterAtBeginning === counter2)
        current.value = result;
    } catch (e2) {
      onError(e2);
    } finally {
      if (evaluating && counterAtBeginning === counter2)
        evaluating.value = false;
      hasFinished = true;
    }
  });
  if (lazy) {
    return computed(() => {
      started.value = true;
      return current.value;
    });
  } else {
    return current;
  }
}
function unrefElement$1(elRef) {
  var _a2;
  const plain = unref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow$1 = isClient$1 ? window : void 0;
const defaultDocument = isClient$1 ? window.document : void 0;
const defaultNavigator$1 = isClient$1 ? window.navigator : void 0;
function useEventListener$1(...args) {
  let target2;
  let event;
  let listener;
  let options;
  if (isString$4(args[0])) {
    [event, listener, options] = args;
    target2 = defaultWindow$1;
  } else {
    [target2, event, listener, options] = args;
  }
  if (!target2)
    return noop$3;
  let cleanup = noop$3;
  const stopWatch = watch(() => unrefElement$1(target2), (el2) => {
    cleanup();
    if (!el2)
      return;
    el2.addEventListener(event, listener, options);
    cleanup = () => {
      el2.removeEventListener(event, listener, options);
      cleanup = noop$3;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose$1(stop);
  return stop;
}
function onClickOutside(target2, handler, options = {}) {
  const { window: window2 = defaultWindow$1, ignore, capture = true, detectIframe = false } = options;
  if (!window2)
    return;
  const shouldListen = ref(true);
  let fallback;
  const listener = (event) => {
    window2.clearTimeout(fallback);
    const el2 = unrefElement$1(target2);
    const composedPath = event.composedPath();
    if (!el2 || el2 === event.target || composedPath.includes(el2) || !shouldListen.value)
      return;
    if (ignore && ignore.length > 0) {
      if (ignore.some((target22) => {
        const el22 = unrefElement$1(target22);
        return el22 && (event.target === el22 || composedPath.includes(el22));
      }))
        return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener$1(window2, "click", listener, { passive: true, capture }),
    useEventListener$1(window2, "pointerdown", (e2) => {
      const el2 = unrefElement$1(target2);
      shouldListen.value = !!el2 && !e2.composedPath().includes(el2);
    }, { passive: true }),
    useEventListener$1(window2, "pointerup", (e2) => {
      if (e2.button === 0) {
        const path2 = e2.composedPath();
        e2.composedPath = () => path2;
        fallback = window2.setTimeout(() => listener(e2), 50);
      }
    }, { passive: true }),
    detectIframe && useEventListener$1(window2, "blur", (event) => {
      var _a2;
      const el2 = unrefElement$1(target2);
      if (((_a2 = document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el2 == null ? void 0 : el2.contains(document.activeElement)))
        handler(event);
    })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  return stop;
}
function useActiveElement(options = {}) {
  const { window: window2 = defaultWindow$1 } = options;
  const counter2 = ref(0);
  if (window2) {
    useEventListener$1(window2, "blur", () => counter2.value += 1, true);
    useEventListener$1(window2, "focus", () => counter2.value += 1, true);
  }
  return computed(() => {
    counter2.value;
    return window2 == null ? void 0 : window2.document.activeElement;
  });
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow$1 } = options;
  const isSupported2 = Boolean(window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches2 = ref(false);
  const update3 = () => {
    if (!isSupported2)
      return;
    if (!mediaQuery)
      mediaQuery = window2.matchMedia(query);
    matches2.value = mediaQuery.matches;
  };
  tryOnBeforeMount(() => {
    update3();
    if (!mediaQuery)
      return;
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", update3);
    else
      mediaQuery.addListener(update3);
    tryOnScopeDispose$1(() => {
      if ("removeEventListener" in mediaQuery)
        mediaQuery.removeEventListener("change", update3);
      else
        mediaQuery.removeListener(update3);
    });
  });
  return matches2;
}
function useClamp(value, min2, max2) {
  const _value = ref(value);
  return computed({
    get() {
      return _value.value = clamp(_value.value, unref(min2), unref(max2));
    },
    set(value2) {
      _value.value = clamp(value2, unref(min2), unref(max2));
    }
  });
}
function useClipboard$1(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator$1,
    read: read2 = false,
    source,
    copiedDuring = 1500
  } = options;
  const events = ["copy", "cut"];
  const isSupported2 = Boolean(navigator2 && "clipboard" in navigator2);
  const text3 = ref("");
  const copied = ref(false);
  const timeout2 = useTimeoutFn$1(() => copied.value = false, copiedDuring);
  function updateText() {
    navigator2.clipboard.readText().then((value) => {
      text3.value = value;
    });
  }
  if (isSupported2 && read2) {
    for (const event of events)
      useEventListener$1(event, updateText);
  }
  async function copy2(value = unref(source)) {
    if (isSupported2 && value != null) {
      await navigator2.clipboard.writeText(value);
      text3.value = value;
      copied.value = true;
      timeout2.start();
    }
  }
  return {
    isSupported: isSupported2,
    text: text3,
    copied,
    copy: copy2
  };
}
const _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey$1 = "__vueuse_ssr_handlers__";
_global$1[globalKey$1] = _global$1[globalKey$1] || {};
const handlers = _global$1[globalKey$1];
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
function useStorage(key, initialValue, storage2, options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window: window2 = defaultWindow$1,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options;
  const data2 = (shallow ? shallowRef : ref)(initialValue);
  if (!storage2) {
    try {
      storage2 = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow$1) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e2) {
      onError(e2);
    }
  }
  if (!storage2)
    return data2;
  const rawInit = unref(initialValue);
  const type = guessSerializerType(rawInit);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data2, () => write(data2.value), { flush, deep, eventFilter });
  if (window2 && listenToStorageChanges)
    useEventListener$1(window2, "storage", update3);
  update3();
  return data2;
  function write(v2) {
    try {
      if (v2 == null)
        storage2.removeItem(key);
      else
        storage2.setItem(key, serializer.write(v2));
    } catch (e2) {
      onError(e2);
    }
  }
  function read2(event) {
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      const rawValue = event ? event.newValue : storage2.getItem(key);
      if (rawValue == null) {
        if (writeDefaults && rawInit !== null)
          storage2.setItem(key, serializer.write(rawInit));
        return rawInit;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    } finally {
      resumeWatch();
    }
  }
  function update3(event) {
    if (event && event.key !== key)
      return;
    data2.value = read2(event);
  }
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
var __defProp$h = Object.defineProperty;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$h = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$j.call(b2, prop2))
      __defNormalProp$h(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$j)
    for (var prop2 of __getOwnPropSymbols$j(b2)) {
      if (__propIsEnum$j.call(b2, prop2))
        __defNormalProp$h(a2, prop2, b2[prop2]);
    }
  return a2;
};
function useColorMode(options = {}) {
  const {
    selector: selector2 = "html",
    attribute: attribute2 = "class",
    window: window2 = defaultWindow$1,
    storage: storage2,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef,
    emitAuto
  } = options;
  const modes = __spreadValues$h({
    auto: "",
    light: "light",
    dark: "dark"
  }, options.modes || {});
  const preferredDark = usePreferredDark({ window: window2 });
  const preferredMode = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? ref("auto") : useStorage(storageKey, "auto", storage2, { window: window2, listenToStorageChanges }));
  const state = computed({
    get() {
      return store.value === "auto" && !emitAuto ? preferredMode.value : store.value;
    },
    set(v2) {
      store.value = v2;
    }
  });
  const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector22, attribute22, value) => {
    const el2 = window2 == null ? void 0 : window2.document.querySelector(selector22);
    if (!el2)
      return;
    if (attribute22 === "class") {
      const current = value.split(/\s/g);
      Object.values(modes).flatMap((i2) => (i2 || "").split(/\s/g)).filter(Boolean).forEach((v2) => {
        if (current.includes(v2))
          el2.classList.add(v2);
        else
          el2.classList.remove(v2);
      });
    } else {
      el2.setAttribute(attribute22, value);
    }
  });
  function defaultOnChanged(mode) {
    var _a2;
    const resolvedMode = mode === "auto" ? preferredMode.value : mode;
    updateHTMLAttrs(selector2, attribute2, (_a2 = modes[resolvedMode]) != null ? _a2 : resolvedMode);
  }
  function onChanged(mode) {
    if (options.onChanged)
      options.onChanged(mode, defaultOnChanged);
    else
      defaultOnChanged(mode);
  }
  watch(state, onChanged, { flush: "post", immediate: true });
  tryOnMounted(() => onChanged(state.value));
  return state;
}
function useCycleList(list3, options) {
  var _a2;
  const state = shallowRef((_a2 = options == null ? void 0 : options.initialValue) != null ? _a2 : list3[0]);
  const index2 = computed({
    get() {
      var _a22;
      let index22 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list3) : list3.indexOf(state.value);
      if (index22 < 0)
        index22 = (_a22 = options == null ? void 0 : options.fallbackIndex) != null ? _a22 : 0;
      return index22;
    },
    set(v2) {
      set3(v2);
    }
  });
  function set3(i2) {
    const length = list3.length;
    const index22 = (i2 % length + length) % length;
    const value = list3[index22];
    state.value = value;
    return value;
  }
  function shift2(delta2 = 1) {
    return set3(index2.value + delta2);
  }
  function next(n2 = 1) {
    return shift2(n2);
  }
  function prev(n2 = 1) {
    return shift2(-n2);
  }
  return {
    state,
    index: index2,
    next,
    prev
  };
}
var __defProp$g = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$g = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$i.call(b2, prop2))
      __defNormalProp$g(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$i)
    for (var prop2 of __getOwnPropSymbols$i(b2)) {
      if (__propIsEnum$i.call(b2, prop2))
        __defNormalProp$g(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps$7 = (a2, b2) => __defProps$7(a2, __getOwnPropDescs$7(b2));
function useDark(options = {}) {
  const {
    valueDark = "dark",
    valueLight = "",
    window: window2 = defaultWindow$1
  } = options;
  const mode = useColorMode(__spreadProps$7(__spreadValues$g({}, options), {
    onChanged: (mode2, defaultHandler) => {
      var _a2;
      if (options.onChanged)
        (_a2 = options.onChanged) == null ? void 0 : _a2.call(options, mode2 === "dark");
      else
        defaultHandler(mode2);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  }));
  const preferredDark = usePreferredDark({ window: window2 });
  const isDark = computed({
    get() {
      return mode.value === "dark";
    },
    set(v2) {
      if (v2 === preferredDark.value)
        mode.value = "auto";
      else
        mode.value = v2 ? "dark" : "light";
    }
  });
  return isDark;
}
const fnClone = (v2) => JSON.parse(JSON.stringify(v2));
const fnBypass = (v2) => v2;
const fnSetSource = (source, value) => source.value = value;
function defaultDump(clone2) {
  return clone2 ? isFunction$2(clone2) ? clone2 : fnClone : fnBypass;
}
function defaultParse(clone2) {
  return clone2 ? isFunction$2(clone2) ? clone2 : fnClone : fnBypass;
}
function useManualRefHistory(source, options = {}) {
  const {
    clone: clone2 = false,
    dump = defaultDump(clone2),
    parse: parse2 = defaultParse(clone2),
    setSource = fnSetSource
  } = options;
  function _createHistoryRecord() {
    return markRaw({
      snapshot: dump(source.value),
      timestamp: timestamp$1()
    });
  }
  const last = ref(_createHistoryRecord());
  const undoStack = ref([]);
  const redoStack = ref([]);
  const _setSource = (record) => {
    setSource(source, parse2(record.snapshot));
    last.value = record;
  };
  const commit = () => {
    undoStack.value.unshift(last.value);
    last.value = _createHistoryRecord();
    if (options.capacity && undoStack.value.length > options.capacity)
      undoStack.value.splice(options.capacity, Infinity);
    if (redoStack.value.length)
      redoStack.value.splice(0, redoStack.value.length);
  };
  const clear2 = () => {
    undoStack.value.splice(0, undoStack.value.length);
    redoStack.value.splice(0, redoStack.value.length);
  };
  const undo2 = () => {
    const state = undoStack.value.shift();
    if (state) {
      redoStack.value.unshift(last.value);
      _setSource(state);
    }
  };
  const redo2 = () => {
    const state = redoStack.value.shift();
    if (state) {
      undoStack.value.unshift(last.value);
      _setSource(state);
    }
  };
  const reset2 = () => {
    _setSource(last.value);
  };
  const history2 = computed(() => [last.value, ...undoStack.value]);
  const canUndo = computed(() => undoStack.value.length > 0);
  const canRedo = computed(() => redoStack.value.length > 0);
  return {
    source,
    undoStack,
    redoStack,
    last,
    history: history2,
    canUndo,
    canRedo,
    clear: clear2,
    commit,
    reset: reset2,
    undo: undo2,
    redo: redo2
  };
}
var __defProp$f = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$f = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$h.call(b2, prop2))
      __defNormalProp$f(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$h)
    for (var prop2 of __getOwnPropSymbols$h(b2)) {
      if (__propIsEnum$h.call(b2, prop2))
        __defNormalProp$f(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps$6 = (a2, b2) => __defProps$6(a2, __getOwnPropDescs$6(b2));
function useRefHistory(source, options = {}) {
  const {
    deep = false,
    flush = "pre",
    eventFilter
  } = options;
  const {
    eventFilter: composedFilter,
    pause,
    resume: resumeTracking,
    isActive: isTracking
  } = pausableFilter(eventFilter);
  const {
    ignoreUpdates,
    ignorePrevAsyncUpdates,
    stop
  } = watchIgnorable(source, commit, { deep, flush, eventFilter: composedFilter });
  function setSource(source2, value) {
    ignorePrevAsyncUpdates();
    ignoreUpdates(() => {
      source2.value = value;
    });
  }
  const manualHistory = useManualRefHistory(source, __spreadProps$6(__spreadValues$f({}, options), { clone: options.clone || deep, setSource }));
  const { clear: clear2, commit: manualCommit } = manualHistory;
  function commit() {
    ignorePrevAsyncUpdates();
    manualCommit();
  }
  function resume(commitNow) {
    resumeTracking();
    if (commitNow)
      commit();
  }
  function batch(fn) {
    let canceled = false;
    const cancel = () => canceled = true;
    ignoreUpdates(() => {
      fn(cancel);
    });
    if (!canceled)
      commit();
  }
  function dispose() {
    stop();
    clear2();
  }
  return __spreadProps$6(__spreadValues$f({}, manualHistory), {
    isTracking,
    pause,
    resume,
    commit,
    batch,
    dispose
  });
}
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp$e.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols$e)
    for (var prop2 of __getOwnPropSymbols$e(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum$e.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
function useResizeObserver(target2, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported2 = window2 && "ResizeObserver" in window2;
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement$1(target2), (el2) => {
    cleanup();
    if (isSupported2 && window2 && el2) {
      observer = new ResizeObserver(callback);
      observer.observe(el2, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose$1(stop);
  return {
    isSupported: isSupported2,
    stop
  };
}
function useElementBounding(target2, options = {}) {
  const {
    reset: reset2 = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref(0);
  const bottom2 = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top2 = ref(0);
  const width = ref(0);
  const x2 = ref(0);
  const y2 = ref(0);
  function update3() {
    const el2 = unrefElement$1(target2);
    if (!el2) {
      if (reset2) {
        height.value = 0;
        bottom2.value = 0;
        left.value = 0;
        right.value = 0;
        top2.value = 0;
        width.value = 0;
        x2.value = 0;
        y2.value = 0;
      }
      return;
    }
    const rect2 = el2.getBoundingClientRect();
    height.value = rect2.height;
    bottom2.value = rect2.bottom;
    left.value = rect2.left;
    right.value = rect2.right;
    top2.value = rect2.top;
    width.value = rect2.width;
    x2.value = rect2.x;
    y2.value = rect2.y;
  }
  useResizeObserver(target2, update3);
  watch(() => unrefElement$1(target2), (ele) => !ele && update3());
  if (windowScroll)
    useEventListener$1("scroll", update3, { passive: true });
  if (windowResize)
    useEventListener$1("resize", update3, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update3();
  });
  return {
    height,
    bottom: bottom2,
    left,
    right,
    top: top2,
    width,
    x: x2,
    y: y2,
    update: update3
  };
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow$1
  } = options;
  const isActive = ref(false);
  let rafId = null;
  function loop() {
    if (!isActive.value || !window2)
      return;
    fn();
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      loop();
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose$1(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useFocus(target2, options = {}) {
  const { initialValue = false } = options;
  const activeElement = useActiveElement(options);
  const targetElement = computed(() => unrefElement$1(target2));
  const focused = computed({
    get() {
      return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;
    },
    set(value) {
      var _a2, _b;
      if (!value && focused.value)
        (_a2 = targetElement.value) == null ? void 0 : _a2.blur();
      if (value && !focused.value)
        (_b = targetElement.value) == null ? void 0 : _b.focus();
    }
  });
  watch(targetElement, () => {
    focused.value = initialValue;
  }, { immediate: true, flush: "post" });
  return { focused };
}
function useMouse(options = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow$1,
    eventFilter
  } = options;
  const x2 = ref(initialValue.x);
  const y2 = ref(initialValue.y);
  const sourceType = ref(null);
  const mouseHandler = (event) => {
    if (type === "page") {
      x2.value = event.pageX;
      y2.value = event.pageY;
    } else if (type === "client") {
      x2.value = event.clientX;
      y2.value = event.clientY;
    }
    sourceType.value = "mouse";
  };
  const reset2 = () => {
    x2.value = initialValue.x;
    y2.value = initialValue.y;
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const touch2 = event.touches[0];
      if (type === "page") {
        x2.value = touch2.pageX;
        y2.value = touch2.pageY;
      } else if (type === "client") {
        x2.value = touch2.clientX;
        y2.value = touch2.clientY;
      }
      sourceType.value = "touch";
    }
  };
  const mouseHandlerWrapper = (event) => {
    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});
  };
  const touchHandlerWrapper = (event) => {
    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});
  };
  if (window2) {
    useEventListener$1(window2, "mousemove", mouseHandlerWrapper, { passive: true });
    useEventListener$1(window2, "dragover", mouseHandlerWrapper, { passive: true });
    if (touch) {
      useEventListener$1(window2, "touchstart", touchHandlerWrapper, { passive: true });
      useEventListener$1(window2, "touchmove", touchHandlerWrapper, { passive: true });
      if (resetOnTouchEnds)
        useEventListener$1(window2, "touchend", reset2, { passive: true });
    }
  }
  return {
    x: x2,
    y: y2,
    sourceType
  };
}
function useMouseInElement(target2, options = {}) {
  const {
    handleOutside = true,
    window: window2 = defaultWindow$1
  } = options;
  const { x: x2, y: y2, sourceType } = useMouse(options);
  const targetRef = ref(target2 != null ? target2 : window2 == null ? void 0 : window2.document.body);
  const elementX = ref(0);
  const elementY = ref(0);
  const elementPositionX = ref(0);
  const elementPositionY = ref(0);
  const elementHeight = ref(0);
  const elementWidth = ref(0);
  const isOutside = ref(true);
  let stop = () => {
  };
  if (window2) {
    stop = watch([targetRef, x2, y2], () => {
      const el2 = unrefElement$1(targetRef);
      if (!el2)
        return;
      const {
        left,
        top: top2,
        width,
        height
      } = el2.getBoundingClientRect();
      elementPositionX.value = left + window2.pageXOffset;
      elementPositionY.value = top2 + window2.pageYOffset;
      elementHeight.value = height;
      elementWidth.value = width;
      const elX = x2.value - elementPositionX.value;
      const elY = y2.value - elementPositionY.value;
      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
      if (handleOutside || !isOutside.value) {
        elementX.value = elX;
        elementY.value = elY;
      }
    }, { immediate: true });
  }
  return {
    x: x2,
    y: y2,
    sourceType,
    elementX,
    elementY,
    elementPositionX,
    elementPositionY,
    elementHeight,
    elementWidth,
    isOutside,
    stop
  };
}
function useMousePressed(options = {}) {
  const {
    touch = true,
    drag: drag2 = true,
    initialValue = false,
    window: window2 = defaultWindow$1
  } = options;
  const pressed = ref(initialValue);
  const sourceType = ref(null);
  if (!window2) {
    return {
      pressed,
      sourceType
    };
  }
  const onPressed = (srcType) => () => {
    pressed.value = true;
    sourceType.value = srcType;
  };
  const onReleased = () => {
    pressed.value = false;
    sourceType.value = null;
  };
  const target2 = computed(() => unrefElement$1(options.target) || window2);
  useEventListener$1(target2, "mousedown", onPressed("mouse"), { passive: true });
  useEventListener$1(window2, "mouseleave", onReleased, { passive: true });
  useEventListener$1(window2, "mouseup", onReleased, { passive: true });
  if (drag2) {
    useEventListener$1(target2, "dragstart", onPressed("mouse"), { passive: true });
    useEventListener$1(window2, "drop", onReleased, { passive: true });
    useEventListener$1(window2, "dragend", onReleased, { passive: true });
  }
  if (touch) {
    useEventListener$1(target2, "touchstart", onPressed("touch"), { passive: true });
    useEventListener$1(window2, "touchend", onReleased, { passive: true });
    useEventListener$1(window2, "touchcancel", onReleased, { passive: true });
  }
  return {
    pressed,
    sourceType
  };
}
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$1 = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp$6.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop2 of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum$6.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
function useMutationObserver(target2, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
  let observer;
  const isSupported2 = window2 && "MutationObserver" in window2;
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement$1(target2), (el2) => {
    cleanup();
    if (isSupported2 && window2 && el2) {
      observer = new MutationObserver(callback);
      observer.observe(el2, mutationOptions);
    }
  }, { immediate: true });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose$1(stop);
  return {
    isSupported: isSupported2,
    stop
  };
}
var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$5.call(b2, prop2))
      __defNormalProp$5(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$5)
    for (var prop2 of __getOwnPropSymbols$5(b2)) {
      if (__propIsEnum$5.call(b2, prop2))
        __defNormalProp$5(a2, prop2, b2[prop2]);
    }
  return a2;
};
function useNow(options = {}) {
  const {
    controls: exposeControls = false,
    interval: interval2 = "requestAnimationFrame"
  } = options;
  const now2 = ref(new Date());
  const update3 = () => now2.value = new Date();
  const controls = interval2 === "requestAnimationFrame" ? useRafFn(update3, { immediate: true }) : useIntervalFn(update3, interval2, { immediate: true });
  if (exposeControls) {
    return __spreadValues$5({
      now: now2
    }, controls);
  } else {
    return now2;
  }
}
var SwipeDirection$1;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection$1 || (SwipeDirection$1 = {}));
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$3.call(b2, prop2))
      __defNormalProp$3(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$3)
    for (var prop2 of __getOwnPropSymbols$3(b2)) {
      if (__propIsEnum$3.call(b2, prop2))
        __defNormalProp$3(a2, prop2, b2[prop2]);
    }
  return a2;
};
function useShare(shareOptions = {}, options = {}) {
  const { navigator: navigator2 = defaultNavigator$1 } = options;
  const _navigator2 = navigator2;
  const isSupported2 = _navigator2 && "canShare" in _navigator2;
  const share = async (overrideOptions = {}) => {
    if (isSupported2) {
      const data2 = __spreadValues$3(__spreadValues$3({}, unref(shareOptions)), unref(overrideOptions));
      let granted = true;
      if (data2.files && _navigator2.canShare)
        granted = _navigator2.canShare({ files: data2.files });
      if (granted)
        return _navigator2.share(data2);
    }
  };
  return {
    isSupported: isSupported2,
    share
  };
}
var __defProp$1$1 = Object.defineProperty;
var __getOwnPropSymbols$1$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$1 = (obj, key, value) => key in obj ? __defProp$1$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$1 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$1$1.call(b2, prop2))
      __defNormalProp$1$1(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$1$1)
    for (var prop2 of __getOwnPropSymbols$1$1(b2)) {
      if (__propIsEnum$1$1.call(b2, prop2))
        __defNormalProp$1$1(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __objRest$3 = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp$1$1.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols$1$1)
    for (var prop2 of __getOwnPropSymbols$1$1(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum$1$1.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
const UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Infinity, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: (n2) => n2.match(/\d/) ? `${n2} ago` : n2,
  future: (n2) => n2.match(/\d/) ? `in ${n2}` : n2,
  month: (n2, past) => n2 === 1 ? past ? "last month" : "next month" : `${n2} month${n2 > 1 ? "s" : ""}`,
  year: (n2, past) => n2 === 1 ? past ? "last year" : "next year" : `${n2} year${n2 > 1 ? "s" : ""}`,
  day: (n2, past) => n2 === 1 ? past ? "yesterday" : "tomorrow" : `${n2} day${n2 > 1 ? "s" : ""}`,
  week: (n2, past) => n2 === 1 ? past ? "last week" : "next week" : `${n2} week${n2 > 1 ? "s" : ""}`,
  hour: (n2) => `${n2} hour${n2 > 1 ? "s" : ""}`,
  minute: (n2) => `${n2} minute${n2 > 1 ? "s" : ""}`,
  second: (n2) => `${n2} second${n2 > 1 ? "s" : ""}`
};
const DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);
function useTimeAgo(time, options = {}) {
  const {
    controls: exposeControls = false,
    max: max2,
    updateInterval = 3e4,
    messages = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER
  } = options;
  const { abs: abs2, round: round2 } = Math;
  const _a2 = useNow({ interval: updateInterval, controls: true }), { now: now2 } = _a2, controls = __objRest$3(_a2, ["now"]);
  function getTimeago(from2, now22) {
    var _a22;
    const diff2 = +now22 - +from2;
    const absDiff = abs2(diff2);
    if (absDiff < 6e4)
      return messages.justNow;
    if (typeof max2 === "number" && absDiff > max2)
      return fullDateFormatter(new Date(from2));
    if (typeof max2 === "string") {
      const unitMax = (_a22 = UNITS.find((i2) => i2.name === max2)) == null ? void 0 : _a22.max;
      if (unitMax && absDiff > unitMax)
        return fullDateFormatter(new Date(from2));
    }
    for (const unit of UNITS) {
      if (absDiff < unit.max)
        return format3(diff2, unit);
    }
  }
  function applyFormat(name, val, isPast) {
    const formatter = messages[name];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  function format3(diff2, unit) {
    const val = round2(abs2(diff2) / unit.value);
    const past = diff2 > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  const timeAgo = computed(() => getTimeago(new Date(unref(time)), unref(now2.value)));
  if (exposeControls) {
    return __spreadValues$1$1({
      timeAgo
    }, controls);
  } else {
    return timeAgo;
  }
}
function useTitle(newTitle = null, options = {}) {
  var _a2, _b;
  const {
    document: document2 = defaultDocument,
    observe = false,
    titleTemplate = "%s"
  } = options;
  const title = ref((_a2 = newTitle != null ? newTitle : document2 == null ? void 0 : document2.title) != null ? _a2 : null);
  watch(title, (t2, o2) => {
    if (isString$4(t2) && t2 !== o2 && document2)
      document2.title = titleTemplate.replace("%s", t2);
  }, { immediate: true });
  if (observe && document2) {
    useMutationObserver((_b = document2.head) == null ? void 0 : _b.querySelector("title"), () => {
      if (document2 && document2.title !== title.value)
        title.value = titleTemplate.replace("%s", document2.title);
    }, { childList: true });
  }
  return title;
}
const matchName$1 = /^[a-z0-9]+(-[a-z0-9]+)*$/;
const iconDefaults$1 = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16,
  rotate: 0,
  vFlip: false,
  hFlip: false
});
function fullIcon$1(data2) {
  return { ...iconDefaults$1, ...data2 };
}
const stringToIcon$1 = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIcon$1(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIcon$1(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIcon$1(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIcon$1 = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchName$1)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchName$1)) && icon.name.match(matchName$1));
};
function mergeIconData$1(icon, alias) {
  const result = { ...icon };
  for (const key in iconDefaults$1) {
    const prop2 = key;
    if (alias[prop2] !== void 0) {
      const value = alias[prop2];
      if (result[prop2] === void 0) {
        result[prop2] = value;
        continue;
      }
      switch (prop2) {
        case "rotate":
          result[prop2] = (result[prop2] + value) % 4;
          break;
        case "hFlip":
        case "vFlip":
          result[prop2] = value !== result[prop2];
          break;
        default:
          result[prop2] = value;
      }
    }
  }
  return result;
}
function getIconData$1$1(data2, name, full = false) {
  function getIcon(name2, iteration) {
    if (data2.icons[name2] !== void 0) {
      return Object.assign({}, data2.icons[name2]);
    }
    if (iteration > 5) {
      return null;
    }
    const aliases2 = data2.aliases;
    if (aliases2 && aliases2[name2] !== void 0) {
      const item = aliases2[name2];
      const result2 = getIcon(item.parent, iteration + 1);
      if (result2) {
        return mergeIconData$1(result2, item);
      }
      return result2;
    }
    const chars = data2.chars;
    if (!iteration && chars && chars[name2] !== void 0) {
      return getIcon(chars[name2], iteration + 1);
    }
    return null;
  }
  const result = getIcon(name, 0);
  if (result) {
    for (const key in iconDefaults$1) {
      if (result[key] === void 0 && data2[key] !== void 0) {
        result[key] = data2[key];
      }
    }
  }
  return result && full ? fullIcon$1(result) : result;
}
function isVariation$1(item) {
  for (const key in iconDefaults$1) {
    if (item[key] !== void 0) {
      return true;
    }
  }
  return false;
}
function parseIconSet$1(data2, callback, options) {
  options = options || {};
  const names = [];
  if (typeof data2 !== "object" || typeof data2.icons !== "object") {
    return names;
  }
  if (data2.not_found instanceof Array) {
    data2.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const icons = data2.icons;
  Object.keys(icons).forEach((name) => {
    const iconData = getIconData$1$1(data2, name, true);
    if (iconData) {
      callback(name, iconData);
      names.push(name);
    }
  });
  const parseAliases = options.aliases || "all";
  if (parseAliases !== "none" && typeof data2.aliases === "object") {
    const aliases2 = data2.aliases;
    Object.keys(aliases2).forEach((name) => {
      if (parseAliases === "variations" && isVariation$1(aliases2[name])) {
        return;
      }
      const iconData = getIconData$1$1(data2, name, true);
      if (iconData) {
        callback(name, iconData);
        names.push(name);
      }
    });
  }
  return names;
}
const optionalProperties$1 = {
  provider: "string",
  aliases: "object",
  not_found: "object"
};
for (const prop2 in iconDefaults$1) {
  optionalProperties$1[prop2] = typeof iconDefaults$1[prop2];
}
function quicklyValidateIconSet$1(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data2 = obj;
  if (typeof data2.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  for (const prop2 in optionalProperties$1) {
    if (obj[prop2] !== void 0 && typeof obj[prop2] !== optionalProperties$1[prop2]) {
      return null;
    }
  }
  const icons = data2.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (!name.match(matchName$1) || typeof icon.body !== "string") {
      return null;
    }
    for (const prop2 in iconDefaults$1) {
      if (icon[prop2] !== void 0 && typeof icon[prop2] !== typeof iconDefaults$1[prop2]) {
        return null;
      }
    }
  }
  const aliases2 = data2.aliases;
  if (aliases2) {
    for (const name in aliases2) {
      const icon = aliases2[name];
      const parent = icon.parent;
      if (!name.match(matchName$1) || typeof parent !== "string" || !icons[parent] && !aliases2[parent]) {
        return null;
      }
      for (const prop2 in iconDefaults$1) {
        if (icon[prop2] !== void 0 && typeof icon[prop2] !== typeof iconDefaults$1[prop2]) {
          return null;
        }
      }
    }
  }
  return data2;
}
const storageVersion$1 = 1;
let storage$1$1 = /* @__PURE__ */ Object.create(null);
try {
  const w2 = window || self;
  if (w2 && w2._iconifyStorage.version === storageVersion$1) {
    storage$1$1 = w2._iconifyStorage.storage;
  }
} catch (err) {
}
function newStorage$1(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ Object.create(null)
  };
}
function getStorage$1(provider, prefix) {
  if (storage$1$1[provider] === void 0) {
    storage$1$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerStorage = storage$1$1[provider];
  if (providerStorage[prefix] === void 0) {
    providerStorage[prefix] = newStorage$1(provider, prefix);
  }
  return providerStorage[prefix];
}
function addIconSet$1(storage2, data2) {
  if (!quicklyValidateIconSet$1(data2)) {
    return [];
  }
  const t2 = Date.now();
  return parseIconSet$1(data2, (name, icon) => {
    if (icon) {
      storage2.icons[name] = icon;
    } else {
      storage2.missing[name] = t2;
    }
  });
}
function addIconToStorage$1(storage2, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage2.icons[name] = Object.freeze(fullIcon$1(icon));
      return true;
    }
  } catch (err) {
  }
  return false;
}
function getIconFromStorage$1(storage2, name) {
  const value = storage2.icons[name];
  return value === void 0 ? null : value;
}
let simpleNames$1 = false;
function allowSimpleNames$1(allow) {
  if (typeof allow === "boolean") {
    simpleNames$1 = allow;
  }
  return simpleNames$1;
}
function getIconData$2(name) {
  const icon = typeof name === "string" ? stringToIcon$1(name, true, simpleNames$1) : name;
  return icon ? getIconFromStorage$1(getStorage$1(icon.provider, icon.prefix), icon.name) : null;
}
function addIcon$1(name, data2) {
  const icon = stringToIcon$1(name, true, simpleNames$1);
  if (!icon) {
    return false;
  }
  const storage2 = getStorage$1(icon.provider, icon.prefix);
  return addIconToStorage$1(storage2, icon.name, data2);
}
function addCollection$1(data2, provider) {
  if (typeof data2 !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = typeof data2.provider === "string" ? data2.provider : "";
  }
  if (simpleNames$1 && provider === "" && (typeof data2.prefix !== "string" || data2.prefix === "")) {
    let added = false;
    if (quicklyValidateIconSet$1(data2)) {
      data2.prefix = "";
      parseIconSet$1(data2, (name, icon) => {
        if (icon && addIcon$1(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  if (typeof data2.prefix !== "string" || !validateIcon$1({
    provider,
    prefix: data2.prefix,
    name: "a"
  })) {
    return false;
  }
  const storage2 = getStorage$1(provider, data2.prefix);
  return !!addIconSet$1(storage2, data2);
}
const defaults$2 = Object.freeze({
  inline: false,
  width: null,
  height: null,
  hAlign: "center",
  vAlign: "middle",
  slice: false,
  hFlip: false,
  vFlip: false,
  rotate: 0
});
function mergeCustomisations$1(defaults2, item) {
  const result = {};
  for (const key in defaults2) {
    const attr = key;
    result[attr] = defaults2[attr];
    if (item[attr] === void 0) {
      continue;
    }
    const value = item[attr];
    switch (attr) {
      case "inline":
      case "slice":
        if (typeof value === "boolean") {
          result[attr] = value;
        }
        break;
      case "hFlip":
      case "vFlip":
        if (value === true) {
          result[attr] = !result[attr];
        }
        break;
      case "hAlign":
      case "vAlign":
        if (typeof value === "string" && value !== "") {
          result[attr] = value;
        }
        break;
      case "width":
      case "height":
        if (typeof value === "string" && value !== "" || typeof value === "number" && value || value === null) {
          result[attr] = value;
        }
        break;
      case "rotate":
        if (typeof value === "number") {
          result[attr] += value;
        }
        break;
    }
  }
  return result;
}
const unitsSplit$1 = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest$1 = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize$1(size2, ratio2, precision) {
  if (ratio2 === 1) {
    return size2;
  }
  precision = precision === void 0 ? 100 : precision;
  if (typeof size2 === "number") {
    return Math.ceil(size2 * ratio2 * precision) / precision;
  }
  if (typeof size2 !== "string") {
    return size2;
  }
  const oldParts = size2.split(unitsSplit$1);
  if (oldParts === null || !oldParts.length) {
    return size2;
  }
  const newParts = [];
  let code3 = oldParts.shift();
  let isNumber2 = unitsTest$1.test(code3);
  while (true) {
    if (isNumber2) {
      const num2 = parseFloat(code3);
      if (isNaN(num2)) {
        newParts.push(code3);
      } else {
        newParts.push(Math.ceil(num2 * ratio2 * precision) / precision);
      }
    } else {
      newParts.push(code3);
    }
    code3 = oldParts.shift();
    if (code3 === void 0) {
      return newParts.join("");
    }
    isNumber2 = !isNumber2;
  }
}
function preserveAspectRatio$1(props) {
  let result = "";
  switch (props.hAlign) {
    case "left":
      result += "xMin";
      break;
    case "right":
      result += "xMax";
      break;
    default:
      result += "xMid";
  }
  switch (props.vAlign) {
    case "top":
      result += "YMin";
      break;
    case "bottom":
      result += "YMax";
      break;
    default:
      result += "YMid";
  }
  result += props.slice ? " slice" : " meet";
  return result;
}
function iconToSVG$1(icon, customisations) {
  const box = {
    left: icon.left,
    top: icon.top,
    width: icon.width,
    height: icon.height
  };
  let body = icon.body;
  [icon, customisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push("translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")");
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push("translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")");
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift("rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
      case 2:
        transformations.unshift("rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")");
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift("rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== 0 || box.top !== 0) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
    }
  });
  let width, height;
  if (customisations.width === null && customisations.height === null) {
    height = "1em";
    width = calculateSize$1(height, box.width / box.height);
  } else if (customisations.width !== null && customisations.height !== null) {
    width = customisations.width;
    height = customisations.height;
  } else if (customisations.height !== null) {
    height = customisations.height;
    width = calculateSize$1(height, box.width / box.height);
  } else {
    width = customisations.width;
    height = calculateSize$1(width, box.height / box.width);
  }
  if (width === "auto") {
    width = box.width;
  }
  if (height === "auto") {
    height = box.height;
  }
  width = typeof width === "string" ? width : width.toString() + "";
  height = typeof height === "string" ? height : height.toString() + "";
  const result = {
    attributes: {
      width,
      height,
      preserveAspectRatio: preserveAspectRatio$1(customisations),
      viewBox: box.left.toString() + " " + box.top.toString() + " " + box.width.toString() + " " + box.height.toString()
    },
    body
  };
  if (customisations.inline) {
    result.inline = true;
  }
  return result;
}
const regex$6 = /\sid="(\S+)"/g;
const randomPrefix$1 = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let counter$1 = 0;
function replaceIDs$1(body, prefix = randomPrefix$1) {
  const ids = [];
  let match5;
  while (match5 = regex$6.exec(body)) {
    ids.push(match5[1]);
  }
  if (!ids.length) {
    return body;
  }
  ids.forEach((id2) => {
    const newID = typeof prefix === "function" ? prefix(id2) : prefix + (counter$1++).toString();
    const escapedID = id2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"), "$1" + newID + "$3");
  });
  return body;
}
const storage$2 = /* @__PURE__ */ Object.create(null);
function setAPIModule$1(provider, item) {
  storage$2[provider] = item;
}
function getAPIModule$1(provider) {
  return storage$2[provider] || storage$2[""];
}
function createAPIConfig$1(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    resources,
    path: source.path === void 0 ? "/" : source.path,
    maxURL: source.maxURL ? source.maxURL : 500,
    rotate: source.rotate ? source.rotate : 750,
    timeout: source.timeout ? source.timeout : 5e3,
    random: source.random === true,
    index: source.index ? source.index : 0,
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
const configStorage$1 = /* @__PURE__ */ Object.create(null);
const fallBackAPISources$1 = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
const fallBackAPI$1 = [];
while (fallBackAPISources$1.length > 0) {
  if (fallBackAPISources$1.length === 1) {
    fallBackAPI$1.push(fallBackAPISources$1.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI$1.push(fallBackAPISources$1.shift());
    } else {
      fallBackAPI$1.push(fallBackAPISources$1.pop());
    }
  }
}
configStorage$1[""] = createAPIConfig$1({
  resources: ["https://api.iconify.design"].concat(fallBackAPI$1)
});
function addAPIProvider$1(provider, customConfig) {
  const config2 = createAPIConfig$1(customConfig);
  if (config2 === null) {
    return false;
  }
  configStorage$1[provider] = config2;
  return true;
}
function getAPIConfig$1(provider) {
  return configStorage$1[provider];
}
const mergeParams$1 = (base2, params) => {
  let result = base2, hasParams = result.indexOf("?") !== -1;
  function paramToString(value) {
    switch (typeof value) {
      case "boolean":
        return value ? "true" : "false";
      case "number":
        return encodeURIComponent(value);
      case "string":
        return encodeURIComponent(value);
      default:
        throw new Error("Invalid parameter");
    }
  }
  Object.keys(params).forEach((key) => {
    let value;
    try {
      value = paramToString(params[key]);
    } catch (err) {
      return;
    }
    result += (hasParams ? "&" : "?") + encodeURIComponent(key) + "=" + value;
    hasParams = true;
  });
  return result;
};
const maxLengthCache$1 = {};
const pathCache$1 = {};
const detectFetch$1 = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
  return null;
};
let fetchModule$1 = detectFetch$1();
function calculateMaxLength$1(provider, prefix) {
  const config2 = getAPIConfig$1(provider);
  if (!config2) {
    return 0;
  }
  let result;
  if (!config2.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config2.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = mergeParams$1(prefix + ".json", {
      icons: ""
    });
    result = config2.maxURL - maxHostLength - config2.path.length - url.length;
  }
  const cacheKey = provider + ":" + prefix;
  pathCache$1[provider] = config2.path;
  maxLengthCache$1[cacheKey] = result;
  return result;
}
function shouldAbort$1(status) {
  return status === 404;
}
const prepare$1 = (provider, prefix, icons) => {
  const results = [];
  let maxLength = maxLengthCache$1[prefix];
  if (maxLength === void 0) {
    maxLength = calculateMaxLength$1(provider, prefix);
  }
  const type = "icons";
  let item = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index2) => {
    length += name.length + 1;
    if (length >= maxLength && index2 > 0) {
      results.push(item);
      item = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath$1(provider) {
  if (typeof provider === "string") {
    if (pathCache$1[provider] === void 0) {
      const config2 = getAPIConfig$1(provider);
      if (!config2) {
        return "/";
      }
      pathCache$1[provider] = config2.path;
    }
    return pathCache$1[provider];
  }
  return "/";
}
const send$1 = (host, params, callback) => {
  if (!fetchModule$1) {
    callback("abort", 424);
    return;
  }
  let path2 = getPath$1(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      path2 += mergeParams$1(prefix + ".json", {
        icons: iconsList
      });
      break;
    }
    case "custom": {
      const uri = params.uri;
      path2 += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule$1(host + path2).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort$1(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data2) => {
    if (typeof data2 !== "object" || data2 === null) {
      setTimeout(() => {
        callback("next", defaultError);
      });
      return;
    }
    setTimeout(() => {
      callback("success", data2);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
const fetchAPIModule$1 = {
  prepare: prepare$1,
  send: send$1
};
function sortIcons$1(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage2 = /* @__PURE__ */ Object.create(null);
  icons.sort((a2, b2) => {
    if (a2.provider !== b2.provider) {
      return a2.provider.localeCompare(b2.provider);
    }
    if (a2.prefix !== b2.prefix) {
      return a2.prefix.localeCompare(b2.prefix);
    }
    return a2.name.localeCompare(b2.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    if (storage2[provider] === void 0) {
      storage2[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerStorage = storage2[provider];
    if (providerStorage[prefix] === void 0) {
      providerStorage[prefix] = getStorage$1(provider, prefix);
    }
    const localStorage2 = providerStorage[prefix];
    let list3;
    if (localStorage2.icons[name] !== void 0) {
      list3 = result.loaded;
    } else if (prefix === "" || localStorage2.missing[name] !== void 0) {
      list3 = result.missing;
    } else {
      list3 = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list3.push(item);
  });
  return result;
}
const callbacks$1 = /* @__PURE__ */ Object.create(null);
const pendingUpdates$1 = /* @__PURE__ */ Object.create(null);
function removeCallback$1(sources, id2) {
  sources.forEach((source) => {
    const provider = source.provider;
    if (callbacks$1[provider] === void 0) {
      return;
    }
    const providerCallbacks = callbacks$1[provider];
    const prefix = source.prefix;
    const items = providerCallbacks[prefix];
    if (items) {
      providerCallbacks[prefix] = items.filter((row) => row.id !== id2);
    }
  });
}
function updateCallbacks$1(provider, prefix) {
  if (pendingUpdates$1[provider] === void 0) {
    pendingUpdates$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerPendingUpdates = pendingUpdates$1[provider];
  if (!providerPendingUpdates[prefix]) {
    providerPendingUpdates[prefix] = true;
    setTimeout(() => {
      providerPendingUpdates[prefix] = false;
      if (callbacks$1[provider] === void 0 || callbacks$1[provider][prefix] === void 0) {
        return;
      }
      const items = callbacks$1[provider][prefix].slice(0);
      if (!items.length) {
        return;
      }
      const storage2 = getStorage$1(provider, prefix);
      let hasPending = false;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage2.icons[name] !== void 0) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage2.missing[name] !== void 0) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback$1([
              {
                provider,
                prefix
              }
            ], item.id);
          }
          item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);
        }
      });
    });
  }
}
let idCounter$1 = 0;
function storeCallback$1(callback, icons, pendingSources) {
  const id2 = idCounter$1++;
  const abort = removeCallback$1.bind(null, pendingSources, id2);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id: id2,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((source) => {
    const provider = source.provider;
    const prefix = source.prefix;
    if (callbacks$1[provider] === void 0) {
      callbacks$1[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerCallbacks = callbacks$1[provider];
    if (providerCallbacks[prefix] === void 0) {
      providerCallbacks[prefix] = [];
    }
    providerCallbacks[prefix].push(item);
  });
  return abort;
}
function listToIcons$1(list3, validate = true, simpleNames2 = false) {
  const result = [];
  list3.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon$1(item, false, simpleNames2) : item;
    if (!validate || validateIcon$1(icon, simpleNames2)) {
      result.push({
        provider: icon.provider,
        prefix: icon.prefix,
        name: icon.name
      });
    }
  });
  return result;
}
var defaultConfig$1 = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function sendQuery$1(config2, payload, query, done) {
  const resourcesCount = config2.resources.length;
  const startIndex = config2.random ? Math.floor(Math.random() * resourcesCount) : config2.index;
  let resources;
  if (config2.random) {
    let list3 = config2.resources.slice(0);
    resources = [];
    while (list3.length > 1) {
      const nextIndex = Math.floor(Math.random() * list3.length);
      resources.push(list3[nextIndex]);
      list3 = list3.slice(0, nextIndex).concat(list3.slice(nextIndex + 1));
    }
    resources = resources.concat(list3);
  } else {
    resources = config2.resources.slice(startIndex).concat(config2.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer2 = null;
  let queue2 = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function subscribe2(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue2.length,
      subscribe: subscribe2,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function moduleResponse(item, response, data2) {
    const isError = response !== "success";
    queue2 = queue2.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config2.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data2;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data2;
      if (!queue2.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config2.random) {
      const index2 = config2.resources.indexOf(item.resource);
      if (index2 !== -1 && index2 !== config2.index) {
        config2.index = index2;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data2);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue2.length) {
        timer2 = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config2.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data2) => {
        moduleResponse(item, status2, data2);
      }
    };
    queue2.push(item);
    queriesSent++;
    timer2 = setTimeout(execNext, config2.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}
function setConfig$1(config2) {
  if (typeof config2 !== "object" || typeof config2.resources !== "object" || !(config2.resources instanceof Array) || !config2.resources.length) {
    throw new Error("Invalid Reduncancy configuration");
  }
  const newConfig = /* @__PURE__ */ Object.create(null);
  let key;
  for (key in defaultConfig$1) {
    if (config2[key] !== void 0) {
      newConfig[key] = config2[key];
    } else {
      newConfig[key] = defaultConfig$1[key];
    }
  }
  return newConfig;
}
function initRedundancy$1(cfg) {
  const config2 = setConfig$1(cfg);
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery$1(config2, payload, queryCallback, (data2, error2) => {
      cleanup();
      if (doneCallback) {
        doneCallback(data2, error2);
      }
    });
    queries.push(query2);
    return query2;
  }
  function find2(callback) {
    const result = queries.find((value) => {
      return callback(value);
    });
    return result !== void 0 ? result : null;
  }
  const instance = {
    query,
    find: find2,
    setIndex: (index2) => {
      config2.index = index2;
    },
    getIndex: () => config2.index,
    cleanup
  };
  return instance;
}
function emptyCallback$1$1() {
}
const redundancyCache$1 = /* @__PURE__ */ Object.create(null);
function getRedundancyCache$1(provider) {
  if (redundancyCache$1[provider] === void 0) {
    const config2 = getAPIConfig$1(provider);
    if (!config2) {
      return;
    }
    const redundancy = initRedundancy$1(config2);
    const cachedReundancy = {
      config: config2,
      redundancy
    };
    redundancyCache$1[provider] = cachedReundancy;
  }
  return redundancyCache$1[provider];
}
function sendAPIQuery$1(target2, query, callback) {
  let redundancy;
  let send2;
  if (typeof target2 === "string") {
    const api = getAPIModule$1(target2);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1$1;
    }
    send2 = api.send;
    const cached = getRedundancyCache$1(target2);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config2 = createAPIConfig$1(target2);
    if (config2) {
      redundancy = initRedundancy$1(config2);
      const moduleKey = target2.resources ? target2.resources[0] : "";
      const api = getAPIModule$1(moduleKey);
      if (api) {
        send2 = api.send;
      }
    }
  }
  if (!redundancy || !send2) {
    callback(void 0, 424);
    return emptyCallback$1$1;
  }
  return redundancy.query(query, send2, callback)().abort;
}
const cache$2 = {};
function emptyCallback$2() {
}
const pendingIcons$1 = /* @__PURE__ */ Object.create(null);
const iconsToLoad$1 = /* @__PURE__ */ Object.create(null);
const loaderFlags$1 = /* @__PURE__ */ Object.create(null);
const queueFlags$1 = /* @__PURE__ */ Object.create(null);
function loadedNewIcons$1(provider, prefix) {
  if (loaderFlags$1[provider] === void 0) {
    loaderFlags$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerLoaderFlags = loaderFlags$1[provider];
  if (!providerLoaderFlags[prefix]) {
    providerLoaderFlags[prefix] = true;
    setTimeout(() => {
      providerLoaderFlags[prefix] = false;
      updateCallbacks$1(provider, prefix);
    });
  }
}
const errorsCache$1 = /* @__PURE__ */ Object.create(null);
function loadNewIcons$1(provider, prefix, icons) {
  function err() {
    const key = (provider === "" ? "" : "@" + provider + ":") + prefix;
    const time = Math.floor(Date.now() / 6e4);
    if (errorsCache$1[key] < time) {
      errorsCache$1[key] = time;
      console.error('Unable to retrieve icons for "' + key + '" because API is not configured properly.');
    }
  }
  if (iconsToLoad$1[provider] === void 0) {
    iconsToLoad$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerIconsToLoad = iconsToLoad$1[provider];
  if (queueFlags$1[provider] === void 0) {
    queueFlags$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerQueueFlags = queueFlags$1[provider];
  if (pendingIcons$1[provider] === void 0) {
    pendingIcons$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerPendingIcons = pendingIcons$1[provider];
  if (providerIconsToLoad[prefix] === void 0) {
    providerIconsToLoad[prefix] = icons;
  } else {
    providerIconsToLoad[prefix] = providerIconsToLoad[prefix].concat(icons).sort();
  }
  if (!providerQueueFlags[prefix]) {
    providerQueueFlags[prefix] = true;
    setTimeout(() => {
      providerQueueFlags[prefix] = false;
      const icons2 = providerIconsToLoad[prefix];
      delete providerIconsToLoad[prefix];
      const api = getAPIModule$1(provider);
      if (!api) {
        err();
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item) => {
        sendAPIQuery$1(provider, item, (data2, error2) => {
          const storage2 = getStorage$1(provider, prefix);
          if (typeof data2 !== "object") {
            if (error2 !== 404) {
              return;
            }
            const t2 = Date.now();
            item.icons.forEach((name) => {
              storage2.missing[name] = t2;
            });
          } else {
            try {
              const parsed = addIconSet$1(storage2, data2);
              if (!parsed.length) {
                return;
              }
              const pending = providerPendingIcons[prefix];
              parsed.forEach((name) => {
                delete pending[name];
              });
              if (cache$2.store) {
                cache$2.store(provider, data2);
              }
            } catch (err2) {
              console.error(err2);
            }
          }
          loadedNewIcons$1(provider, prefix);
        });
      });
    });
  }
}
const loadIcons$1 = (icons, callback) => {
  const cleanedIcons = listToIcons$1(icons, true, allowSimpleNames$1());
  const sortedIcons = sortIcons$1(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback$2);
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const provider = icon.provider;
    const prefix = icon.prefix;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push({
      provider,
      prefix
    });
    if (pendingIcons$1[provider] === void 0) {
      pendingIcons$1[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerPendingIcons = pendingIcons$1[provider];
    if (providerPendingIcons[prefix] === void 0) {
      providerPendingIcons[prefix] = /* @__PURE__ */ Object.create(null);
    }
    if (newIcons[provider] === void 0) {
      newIcons[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerNewIcons = newIcons[provider];
    if (providerNewIcons[prefix] === void 0) {
      providerNewIcons[prefix] = [];
    }
  });
  const time = Date.now();
  sortedIcons.pending.forEach((icon) => {
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const pendingQueue = pendingIcons$1[provider][prefix];
    if (pendingQueue[name] === void 0) {
      pendingQueue[name] = time;
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((source) => {
    const provider = source.provider;
    const prefix = source.prefix;
    if (newIcons[provider][prefix].length) {
      loadNewIcons$1(provider, prefix, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback$1(callback, sortedIcons, sources) : emptyCallback$2;
};
const cacheVersion$1 = "iconify2";
const cachePrefix$1 = "iconify";
const countKey$1 = cachePrefix$1 + "-count";
const versionKey$1 = cachePrefix$1 + "-version";
const hour$1 = 36e5;
const cacheExpiration$1 = 168;
const config$3 = {
  local: true,
  session: true
};
let loaded$1 = false;
const count$1 = {
  local: 0,
  session: 0
};
const emptyList$1 = {
  local: [],
  session: []
};
let _window$1 = typeof window === "undefined" ? {} : window;
function getGlobal$1(key) {
  const attr = key + "Storage";
  try {
    if (_window$1 && _window$1[attr] && typeof _window$1[attr].length === "number") {
      return _window$1[attr];
    }
  } catch (err) {
  }
  config$3[key] = false;
  return null;
}
function setCount$1(storage2, key, value) {
  try {
    storage2.setItem(countKey$1, value.toString());
    count$1[key] = value;
    return true;
  } catch (err) {
    return false;
  }
}
function getCount$1(storage2) {
  const count2 = storage2.getItem(countKey$1);
  if (count2) {
    const total = parseInt(count2);
    return total ? total : 0;
  }
  return 0;
}
function initCache$1(storage2, key) {
  try {
    storage2.setItem(versionKey$1, cacheVersion$1);
  } catch (err) {
  }
  setCount$1(storage2, key, 0);
}
function destroyCache$1(storage2) {
  try {
    const total = getCount$1(storage2);
    for (let i2 = 0; i2 < total; i2++) {
      storage2.removeItem(cachePrefix$1 + i2.toString());
    }
  } catch (err) {
  }
}
const loadCache$1 = () => {
  if (loaded$1) {
    return;
  }
  loaded$1 = true;
  const minTime = Math.floor(Date.now() / hour$1) - cacheExpiration$1;
  function load(key) {
    const func = getGlobal$1(key);
    if (!func) {
      return;
    }
    const getItem = (index2) => {
      const name = cachePrefix$1 + index2.toString();
      const item = func.getItem(name);
      if (typeof item !== "string") {
        return false;
      }
      let valid = true;
      try {
        const data2 = JSON.parse(item);
        if (typeof data2 !== "object" || typeof data2.cached !== "number" || data2.cached < minTime || typeof data2.provider !== "string" || typeof data2.data !== "object" || typeof data2.data.prefix !== "string") {
          valid = false;
        } else {
          const provider = data2.provider;
          const prefix = data2.data.prefix;
          const storage2 = getStorage$1(provider, prefix);
          valid = addIconSet$1(storage2, data2.data).length > 0;
        }
      } catch (err) {
        valid = false;
      }
      if (!valid) {
        func.removeItem(name);
      }
      return valid;
    };
    try {
      const version2 = func.getItem(versionKey$1);
      if (version2 !== cacheVersion$1) {
        if (version2) {
          destroyCache$1(func);
        }
        initCache$1(func, key);
        return;
      }
      let total = getCount$1(func);
      for (let i2 = total - 1; i2 >= 0; i2--) {
        if (!getItem(i2)) {
          if (i2 === total - 1) {
            total--;
          } else {
            emptyList$1[key].push(i2);
          }
        }
      }
      setCount$1(func, key, total);
    } catch (err) {
    }
  }
  for (const key in config$3) {
    load(key);
  }
};
const storeCache$1 = (provider, data2) => {
  if (!loaded$1) {
    loadCache$1();
  }
  function store(key) {
    if (!config$3[key]) {
      return false;
    }
    const func = getGlobal$1(key);
    if (!func) {
      return false;
    }
    let index2 = emptyList$1[key].shift();
    if (index2 === void 0) {
      index2 = count$1[key];
      if (!setCount$1(func, key, index2 + 1)) {
        return false;
      }
    }
    try {
      const item = {
        cached: Math.floor(Date.now() / hour$1),
        provider,
        data: data2
      };
      func.setItem(cachePrefix$1 + index2.toString(), JSON.stringify(item));
    } catch (err) {
      return false;
    }
    return true;
  }
  if (!Object.keys(data2.icons).length) {
    return;
  }
  if (data2.not_found) {
    data2 = Object.assign({}, data2);
    delete data2.not_found;
  }
  if (!store("local")) {
    store("session");
  }
};
const separator$1 = /[\s,]+/;
function flipFromString$1(custom, flip2) {
  flip2.split(separator$1).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}
function alignmentFromString$1(custom, align) {
  align.split(separator$1).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "left":
      case "center":
      case "right":
        custom.hAlign = value;
        break;
      case "top":
      case "middle":
      case "bottom":
        custom.vAlign = value;
        break;
      case "slice":
      case "crop":
        custom.slice = true;
        break;
      case "meet":
        custom.slice = false;
    }
  });
}
function rotateFromString$1(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num2 = parseInt(value);
    return isNaN(num2) ? 0 : cleanup(num2);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num2 = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num2)) {
        return 0;
      }
      num2 = num2 / split;
      return num2 % 1 === 0 ? cleanup(num2) : 0;
    }
  }
  return defaultValue;
}
const svgDefaults$1 = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  "role": "img"
};
let customisationAliases$1 = {};
["horizontal", "vertical"].forEach((prefix) => {
  ["Align", "Flip"].forEach((suffix) => {
    const attr = prefix.slice(0, 1) + suffix;
    const value = {
      attr,
      boolean: suffix === "Flip"
    };
    customisationAliases$1[prefix + "-" + suffix.toLowerCase()] = value;
    customisationAliases$1[prefix.slice(0, 1) + "-" + suffix.toLowerCase()] = value;
    customisationAliases$1[prefix + suffix] = value;
  });
});
const render$2 = (icon, props) => {
  const customisations = mergeCustomisations$1(defaults$2, props);
  const componentProps = { ...svgDefaults$1 };
  let style2 = typeof props.style === "object" && !(props.style instanceof Array) ? { ...props.style } : {};
  for (let key in props) {
    const value = props[key];
    if (value === void 0) {
      continue;
    }
    switch (key) {
      case "icon":
      case "style":
      case "onLoad":
        break;
      case "inline":
      case "hFlip":
      case "vFlip":
        customisations[key] = value === true || value === "true" || value === 1;
        break;
      case "flip":
        if (typeof value === "string") {
          flipFromString$1(customisations, value);
        }
        break;
      case "align":
        if (typeof value === "string") {
          alignmentFromString$1(customisations, value);
        }
        break;
      case "color":
        style2.color = value;
        break;
      case "rotate":
        if (typeof value === "string") {
          customisations[key] = rotateFromString$1(value);
        } else if (typeof value === "number") {
          customisations[key] = value;
        }
        break;
      case "ariaHidden":
      case "aria-hidden":
        if (value !== true && value !== "true") {
          delete componentProps["aria-hidden"];
        }
        break;
      default:
        if (customisationAliases$1[key] !== void 0) {
          if (customisationAliases$1[key].boolean && (value === true || value === "true" || value === 1)) {
            customisations[customisationAliases$1[key].attr] = true;
          } else if (!customisationAliases$1[key].boolean && typeof value === "string" && value !== "") {
            customisations[customisationAliases$1[key].attr] = value;
          }
        } else if (defaults$2[key] === void 0) {
          componentProps[key] = value;
        }
    }
  }
  const item = iconToSVG$1(icon, customisations);
  for (let key in item.attributes) {
    componentProps[key] = item.attributes[key];
  }
  if (item.inline && style2.verticalAlign === void 0 && style2["vertical-align"] === void 0) {
    style2.verticalAlign = "-0.125em";
  }
  let localCounter = 0;
  let id2 = props.id;
  if (typeof id2 === "string") {
    id2 = id2.replace(/-/g, "_");
  }
  componentProps["innerHTML"] = replaceIDs$1(item.body, id2 ? () => id2 + "ID" + localCounter++ : "iconifyVue");
  if (Object.keys(style2).length > 0) {
    componentProps["style"] = style2;
  }
  return h$2("svg", componentProps);
};
allowSimpleNames$1(true);
setAPIModule$1("", fetchAPIModule$1);
if (typeof document !== "undefined" && typeof window !== "undefined") {
  cache$2.store = storeCache$1;
  loadCache$1();
  const _window2 = window;
  if (_window2.IconifyPreload !== void 0) {
    const preload = _window2.IconifyPreload;
    const err = "Invalid IconifyPreload syntax.";
    if (typeof preload === "object" && preload !== null) {
      (preload instanceof Array ? preload : [preload]).forEach((item) => {
        try {
          if (typeof item !== "object" || item === null || item instanceof Array || typeof item.icons !== "object" || typeof item.prefix !== "string" || !addCollection$1(item)) {
            console.error(err);
          }
        } catch (e2) {
          console.error(err);
        }
      });
    }
  }
  if (_window2.IconifyProviders !== void 0) {
    const providers = _window2.IconifyProviders;
    if (typeof providers === "object" && providers !== null) {
      for (let key in providers) {
        const err = "IconifyProviders[" + key + "] is invalid.";
        try {
          const value = providers[key];
          if (typeof value !== "object" || !value || value.resources === void 0) {
            continue;
          }
          if (!addAPIProvider$1(key, value)) {
            console.error(err);
          }
        } catch (e2) {
          console.error(err);
        }
      }
    }
  }
}
const emptyIcon$1 = fullIcon$1({
  body: ""
});
const Icon$1 = defineComponent({
  inheritAttrs: false,
  data() {
    return {
      iconMounted: false,
      counter: 0
    };
  },
  mounted() {
    this._name = "";
    this._loadingIcon = null;
    this.iconMounted = true;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      if (this._loadingIcon) {
        this._loadingIcon.abort();
        this._loadingIcon = null;
      }
    },
    getIcon(icon, onload) {
      if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
        this._name = "";
        this.abortLoading();
        return {
          data: fullIcon$1(icon)
        };
      }
      let iconName;
      if (typeof icon !== "string" || (iconName = stringToIcon$1(icon, false, true)) === null) {
        this.abortLoading();
        return null;
      }
      const data2 = getIconData$2(iconName);
      if (data2 === null) {
        if (!this._loadingIcon || this._loadingIcon.name !== icon) {
          this.abortLoading();
          this._name = "";
          this._loadingIcon = {
            name: icon,
            abort: loadIcons$1([iconName], () => {
              this.counter++;
            })
          };
        }
        return null;
      }
      this.abortLoading();
      if (this._name !== icon) {
        this._name = icon;
        if (onload) {
          onload(icon);
        }
      }
      const classes = ["iconify"];
      if (iconName.prefix !== "") {
        classes.push("iconify--" + iconName.prefix);
      }
      if (iconName.provider !== "") {
        classes.push("iconify--" + iconName.provider);
      }
      return { data: data2, classes };
    }
  },
  render() {
    this.counter;
    const props = this.$attrs;
    const icon = this.iconMounted ? this.getIcon(props.icon, props.onLoad) : null;
    if (!icon) {
      return render$2(emptyIcon$1, props);
    }
    let newProps = props;
    if (icon.classes) {
      newProps = {
        ...props,
        class: (typeof props["class"] === "string" ? props["class"] + " " : "") + icon.classes.join(" ")
      };
    }
    return render$2(icon.data, newProps);
  }
});
/*!
  * vue-router v4.1.1
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser$1 = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign$2 = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$2(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop$2 = () => {
};
const isArray$2 = Array.isArray;
function warn$2(msg) {
  const args = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + msg].concat(args));
}
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path2) => path2.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path2, query = {}, searchString = "", hash2 = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path2 = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path2 = path2 || location2.slice(0, hashPos);
    hash2 = location2.slice(hashPos, location2.length);
  }
  path2 = resolveRelativePath(path2 != null ? path2 : location2, currentLocation);
  return {
    fullPath: path2 + (searchString && "?") + searchString + hash2,
    path: path2,
    query,
    hash: hash2
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base2) {
  if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
    return pathname;
  return pathname.slice(base2.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (const key in a2) {
    if (!isSameRouteLocationParamsValue(a2[key], b2[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return isArray$2(a2) ? isEquivalentArray(a2, b2) : isArray$2(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
}
function isEquivalentArray(a2, b2) {
  return isArray$2(b2) ? a2.length === b2.length && a2.every((value, i2) => value === b2[i2]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to2, from2) {
  if (to2.startsWith("/"))
    return to2;
  if (!from2.startsWith("/")) {
    warn$2(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to2}" from "${from2}". It should look like "/${from2}".`);
    return to2;
  }
  if (!to2)
    return from2;
  const fromSegments = from2.split("/");
  const toSegments = to2.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base2) {
  if (!base2) {
    if (isBrowser$1) {
      const baseEl = document.querySelector("base");
      base2 = baseEl && baseEl.getAttribute("href") || "/";
      base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base2 = "/";
    }
  }
  if (base2[0] !== "/" && base2[0] !== "#")
    base2 = "/" + base2;
  return removeTrailingSlash(base2);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base2, location2) {
  return base2.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el2, offset2) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el2.getBoundingClientRect();
  return {
    behavior: offset2.behavior,
    left: elRect.left - docRect.left - (offset2.left || 0),
    top: elRect.top - docRect.top - (offset2.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    if (typeof position.el === "string") {
      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
        try {
          const foundEl = document.querySelector(position.el);
          if (isIdSelector && foundEl) {
            warn$2(`The selector "${position.el}" should be passed as "el: document.querySelector('${position.el}')" because it starts with "#".`);
            return;
          }
        } catch (err) {
          warn$2(`The selector "${position.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
          return;
        }
      }
    }
    const el2 = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el2) {
      warn$2(`Couldn't find element using selector "${position.el}" returned by scrollBehavior.`);
      return;
    }
    scrollToOptions = getElementPosition(el2, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path2, delta2) {
  const position = history.state ? history.state.position - delta2 : -1;
  return position + path2;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base2, location2) {
  const { pathname, search: search2, hash: hash2 } = location2;
  const hashPos = base2.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash2.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
    let pathFromHash = hash2.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path2 = stripBase(pathname, base2);
  return path2 + search2 + hash2;
}
function useHistoryListeners(base2, historyState, currentLocation, replace2) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to2 = createCurrentLocation(base2, location);
    const from2 = currentLocation.value;
    const fromState = historyState.value;
    let delta2 = 0;
    if (state) {
      currentLocation.value = to2;
      historyState.value = state;
      if (pauseState && pauseState === from2) {
        pauseState = null;
        return;
      }
      delta2 = fromState ? state.position - fromState.position : 0;
    } else {
      replace2(to2);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from2, {
        delta: delta2,
        type: NavigationType.pop,
        direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index2 = listeners.indexOf(callback);
      if (index2 > -1)
        listeners.splice(index2, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$2({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base2) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base2, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to2, state, replace3) {
    const hashIndex = base2.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to2 : createBaseLocation() + base2 + to2;
    try {
      history2[replace3 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        warn$2("Error with push/replace State", err);
      }
      location2[replace3 ? "replace" : "assign"](url);
    }
  }
  function replace2(to2, data2) {
    const state = assign$2({}, history2.state, buildState(historyState.value.back, to2, historyState.value.forward, true), data2, { position: historyState.value.position });
    changeLocation(to2, state, true);
    currentLocation.value = to2;
  }
  function push(to2, data2) {
    const currentState = assign$2({}, historyState.value, history2.state, {
      forward: to2,
      scroll: computeScrollPosition()
    });
    if (!history2.state) {
      warn$2(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
    }
    changeLocation(currentState.current, currentState, true);
    const state = assign$2({}, buildState(currentLocation.value, to2, null), { position: currentState.position + 1 }, data2);
    changeLocation(to2, state, false);
    currentLocation.value = to2;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace: replace2
  };
}
function createWebHistory(base2) {
  base2 = normalizeBase(base2);
  const historyNavigation = useHistoryStateNavigation(base2);
  const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta2, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta2);
  }
  const routerHistory = assign$2({
    location: "",
    base: base2,
    go,
    createHref: createHref.bind(null, base2)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base2) {
  base2 = location.host ? base2 || location.pathname + location.search : "";
  if (!base2.includes("#"))
    base2 += "#";
  if (!base2.endsWith("#/") && !base2.endsWith("#")) {
    warn$2(`A hash base must end with a "#":
"${base2}" should be "${base2.replace(/#.*$/, "#")}".`);
  }
  return createWebHistory(base2);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("navigation failure");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
const ErrorTypeMessages = {
  [1]({ location: location2, currentLocation }) {
    return `No match for
 ${JSON.stringify(location2)}${currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : ""}`;
  },
  [2]({ from: from2, to: to2 }) {
    return `Redirected from "${from2.fullPath}" to "${stringifyRoute(to2)}" via a navigation guard.`;
  },
  [4]({ from: from2, to: to2 }) {
    return `Navigation aborted from "${from2.fullPath}" to "${to2.fullPath}" via a navigation guard.`;
  },
  [8]({ from: from2, to: to2 }) {
    return `Navigation cancelled from "${from2.fullPath}" to "${to2.fullPath}" with a new navigation.`;
  },
  [16]({ from: from2, to: to2 }) {
    return `Avoided redundant navigation to current location: "${from2.fullPath}".`;
  }
};
function createRouterError(type, params) {
  {
    return assign$2(new Error(ErrorTypeMessages[type](params)), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error2, type) {
  return error2 instanceof Error && NavigationFailureSymbol in error2 && (type == null || !!(error2.type & type));
}
const propertiesToLog = ["params", "query", "hash"];
function stringifyRoute(to2) {
  if (typeof to2 === "string")
    return to2;
  if ("path" in to2)
    return to2.path;
  const location2 = {};
  for (const key of propertiesToLog) {
    if (key in to2)
      location2[key] = to2[key];
  }
  return JSON.stringify(location2, null, 2);
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign$2({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token2 = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token2.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token2.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token2.type === 1) {
        const { value, repeatable, optional, regexp } = token2;
        keys2.push({
          name: value,
          repeatable,
          optional
        });
        const re3 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re3 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re3})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re3}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re3})(?:/(?:${re3}))*)` : `(${re3})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re3 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path2) {
    const match5 = path2.match(re2);
    const params = {};
    if (!match5)
      return null;
    for (let i2 = 1; i2 < match5.length; i2++) {
      const value = match5[i2] || "";
      const key = keys2[i2 - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify2(params) {
    let path2 = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path2.endsWith("/"))
        path2 += "/";
      avoidDuplicatedSlash = false;
      for (const token2 of segment) {
        if (token2.type === 0) {
          path2 += token2.value;
        } else if (token2.type === 1) {
          const { value, repeatable, optional } = token2;
          const param = value in params ? params[value] : "";
          if (isArray$2(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text3 = isArray$2(param) ? param.join("/") : param;
          if (!text3) {
            if (optional) {
              if (segment.length < 2 && segments.length > 1) {
                if (path2.endsWith("/"))
                  path2 = path2.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path2 += text3;
        }
      }
    }
    return path2;
  }
  return {
    re: re2,
    score,
    keys: keys2,
    parse: parse2,
    stringify: stringify2
  };
}
function compareScoreArray(a2, b2) {
  let i2 = 0;
  while (i2 < a2.length && i2 < b2.length) {
    const diff2 = b2[i2] - a2[i2];
    if (diff2)
      return diff2;
    i2++;
  }
  if (a2.length < b2.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i2 = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp2 = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp2)
      return comp2;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path2) {
  if (!path2)
    return [[]];
  if (path2 === "/")
    return [[ROOT_TOKEN]];
  if (!path2.startsWith("/")) {
    throw new Error(`Route paths should start with a "/": "${path2}" should be "/${path2}".`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer2}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens2 = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens2.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  function addCharToBuffer() {
    buffer2 += char;
  }
  while (i2 < path2.length) {
    char = path2[i2++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens2;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  {
    const existingKeys = /* @__PURE__ */ new Set();
    for (const key of parser.keys) {
      if (existingKeys.has(key.name))
        warn$2(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
      existingKeys.add(key.name);
    }
  }
  const matcher2 = assign$2(parser, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher2.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher2);
  }
  return matcher2;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    {
      checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);
    }
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases2 = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases2) {
        normalizedRecords.push(assign$2({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher2;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path: path2 } = normalizedRecord;
      if (parent && path2[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path2 && connectingSlash + path2);
      }
      if (normalizedRecord.path === "*") {
        throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\nSee more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
      }
      matcher2 = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (parent && path2[0] === "/")
        checkMissingParamsInAbsolutePath(matcher2, parent);
      if (originalRecord) {
        originalRecord.alias.push(matcher2);
        {
          checkSameParams(originalRecord, matcher2);
        }
      } else {
        originalMatcher = originalMatcher || matcher2;
        if (originalMatcher !== matcher2)
          originalMatcher.alias.push(matcher2);
        if (isRootAdd && record.name && !isAliasRecord(matcher2))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children2 = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          addRoute(children2[i2], matcher2, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher2;
      insertMatcher(matcher2);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop$2;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher2 = matcherMap.get(matcherRef);
      if (matcher2) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher2), 1);
        matcher2.children.forEach(removeRoute);
        matcher2.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers.indexOf(matcherRef);
      if (index2 > -1) {
        matchers.splice(index2, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher2) {
    let i2 = 0;
    while (i2 < matchers.length && comparePathParserScore(matcher2, matchers[i2]) >= 0 && (matcher2.record.path !== matchers[i2].record.path || !isRecordChildOf(matcher2, matchers[i2])))
      i2++;
    matchers.splice(i2, 0, matcher2);
    if (matcher2.record.name && !isAliasRecord(matcher2))
      matcherMap.set(matcher2.record.name, matcher2);
  }
  function resolve2(location2, currentLocation) {
    let matcher2;
    let params = {};
    let path2;
    let name;
    if ("name" in location2 && location2.name) {
      matcher2 = matcherMap.get(location2.name);
      if (!matcher2)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher2.record.name;
      params = assign$2(paramsFromLocation(currentLocation.params, matcher2.keys.filter((k2) => !k2.optional).map((k2) => k2.name)), location2.params);
      path2 = matcher2.stringify(params);
    } else if ("path" in location2) {
      path2 = location2.path;
      if (!path2.startsWith("/")) {
        warn$2(`The Matcher cannot resolve relative paths but received "${path2}". Unless you directly called \`matcher.resolve("${path2}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);
      }
      matcher2 = matchers.find((m2) => m2.re.test(path2));
      if (matcher2) {
        params = matcher2.parse(path2);
        name = matcher2.record.name;
      }
    } else {
      matcher2 = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher2)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher2.record.name;
      params = assign$2({}, currentLocation.params, location2.params);
      path2 = matcher2.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher2;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path: path2,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key of keys2) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "boolean" ? props : props[name];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta2, record) => assign$2(meta2, record.meta), {});
}
function mergeOptions(defaults2, partialOptions) {
  const options = {};
  for (const key in defaults2) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
  }
  return options;
}
function isSameParam(a2, b2) {
  return a2.name === b2.name && a2.optional === b2.optional && a2.repeatable === b2.repeatable;
}
function checkSameParams(a2, b2) {
  for (const key of a2.keys) {
    if (!key.optional && !b2.keys.find(isSameParam.bind(null, key)))
      return warn$2(`Alias "${b2.record.path}" and the original record: "${a2.record.path}" should have the exact same param named "${key.name}"`);
  }
  for (const key of b2.keys) {
    if (!key.optional && !a2.keys.find(isSameParam.bind(null, key)))
      return warn$2(`Alias "${b2.record.path}" and the original record: "${a2.record.path}" should have the exact same param named "${key.name}"`);
  }
}
function checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {
  if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {
    warn$2(`The route named "${String(parent.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
  }
}
function checkMissingParamsInAbsolutePath(record, parent) {
  for (const key of parent.keys) {
    if (!record.keys.find(isSameParam.bind(null, key)))
      return warn$2(`Absolute path "${record.record.path}" should have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
  }
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text3) {
  return encodeURI("" + text3).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text3) {
  return commonEncode(text3).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text3) {
  return commonEncode(text3).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text3) {
  return encodeQueryValue(text3).replace(EQUAL_RE, "%3D");
}
function encodePath(text3) {
  return commonEncode(text3).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text3) {
  return text3 == null ? "" : encodePath(text3).replace(SLASH_RE, "%2F");
}
function decode$2(text3) {
  try {
    return decodeURIComponent("" + text3);
  } catch (err) {
    warn$2(`Error decoding "${text3}". Using original value`);
  }
  return "" + text3;
}
function parseQuery$1(search2) {
  const query = {};
  if (search2 === "" || search2 === "?")
    return query;
  const hasLeadingIM = search2[0] === "?";
  const searchParams = (hasLeadingIM ? search2.slice(1) : search2).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode$2(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode$2(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$2(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search2 = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search2 += (search2.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray$2(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search2 += (search2.length ? "&" : "") + key;
        if (value2 != null)
          search2 += "=" + value2;
      }
    });
  }
  return search2;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray$2(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("router view location matched");
const viewDepthKey = Symbol("router view depth");
const routerKey = Symbol("router");
const routeLocationKey = Symbol("route location");
const routerViewLocationKey = Symbol("router view location");
function useCallbacks() {
  let handlers2 = [];
  function add3(handler) {
    handlers2.push(handler);
    return () => {
      const i2 = handlers2.indexOf(handler);
      if (i2 > -1)
        handlers2.splice(i2, 1);
    };
  }
  function reset2() {
    handlers2 = [];
  }
  return {
    add: add3,
    list: () => handlers2,
    reset: reset2
  };
}
function guardToPromiseFn(guard, to2, from2, record, name) {
  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false)
        reject(createRouterError(4, {
          from: from2,
          to: to2
        }));
      else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to2,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function")
          enterCallbackArray.push(valid);
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to2, from2, canOnlyBeCalledOnce(next, to2, from2));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    if (guard.length > 2) {
      const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ""}:
${guard.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
      if (typeof guardReturn === "object" && "then" in guardReturn) {
        guardCall = guardCall.then((resolvedValue) => {
          if (!next._called) {
            warn$2(message);
            return Promise.reject(new Error("Invalid navigation guard"));
          }
          return resolvedValue;
        });
      } else if (guardReturn !== void 0) {
        if (!next._called) {
          warn$2(message);
          reject(new Error("Invalid navigation guard"));
          return;
        }
      }
    }
    guardCall.catch((err) => reject(err));
  });
}
function canOnlyBeCalledOnce(next, to2, from2) {
  let called = 0;
  return function() {
    if (called++ === 1)
      warn$2(`The "next" callback was called more than once in one navigation guard when going from "${from2.fullPath}" to "${to2.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
    next._called = true;
    if (called === 1)
      next.apply(null, arguments);
  };
}
function extractComponentsGuards(matched, guardType, to2, from2) {
  const guards = [];
  for (const record of matched) {
    if (!record.components && !record.children.length) {
      warn$2(`Record with path "${record.path}" is either missing a "component(s)" or "children" property.`);
    }
    for (const name in record.components) {
      let rawComponent = record.components[name];
      {
        if (!rawComponent || typeof rawComponent !== "object" && typeof rawComponent !== "function") {
          warn$2(`Component "${name}" in record with path "${record.path}" is not a valid component. Received "${String(rawComponent)}".`);
          throw new Error("Invalid route component");
        } else if ("then" in rawComponent) {
          warn$2(`Component "${name}" in record with path "${record.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
          const promise = rawComponent;
          rawComponent = () => promise;
        } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {
          rawComponent.__warnedDefineAsync = true;
          warn$2(`Component "${name}" in record with path "${record.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`);
        }
      }
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to2, from2, record, name));
      } else {
        let componentPromise = rawComponent();
        if (!("catch" in componentPromise)) {
          warn$2(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
          componentPromise = Promise.resolve(componentPromise);
        }
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to2, from2, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1)
      return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop$2);
    }
    return Promise.resolve();
  }
  if (isBrowser$1) {
    const instance = getCurrentInstance();
    if (instance) {
      const linkContextDevtools = {
        route: route.value,
        isActive: isActive.value,
        isExactActive: isExactActive.value
      };
      instance.__vrl_devtools = instance.__vrl_devtools || [];
      instance.__vrl_devtools.push(linkContextDevtools);
      watchEffect(() => {
        linkContextDevtools.route = route.value;
        linkContextDevtools.isActive = isActive.value;
        linkContextDevtools.isExactActive = isExactActive.value;
      }, { flush: "post" });
    }
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link3 = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link3.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link3.isExactActive
    }));
    return () => {
      const children2 = slots.default && slots.default(link3);
      return props.custom ? children2 : h$2("a", {
        "aria-current": link3.isExactActive ? props.ariaCurrentValue : null,
        href: link3.href,
        onClick: link3.navigate,
        class: elClass.value
      }, children2);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target2 = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target2))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$2(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    warnDeprecatedUsage();
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to2, name], [oldInstance, from2, oldName]) => {
      if (to2) {
        to2.instances[name] = instance;
        if (from2 && from2 !== to2 && instance && instance === oldInstance) {
          if (!to2.leaveGuards.size) {
            to2.leaveGuards = from2.leaveGuards;
          }
          if (!to2.updateGuards.size) {
            to2.updateGuards = from2.updateGuards;
          }
        }
      }
      if (instance && to2 && (!from2 || !isSameRouteRecord(to2, from2) || !oldInstance)) {
        (to2.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props.name];
      const currentName = props.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[props.name];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h$2(ViewComponent, assign$2({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      if (isBrowser$1 && component.ref) {
        const info = {
          depth: depth.value,
          name: matchedRoute.name,
          path: matchedRoute.path,
          meta: matchedRoute.meta
        };
        const internalInstances = isArray$2(component.ref) ? component.ref.map((r2) => r2.i) : [component.ref.i];
        internalInstances.forEach((instance) => {
          instance.__vrv_devtools = info;
        });
      }
      return normalizeSlot(slots.default, { Component: component, route }) || component;
    };
  }
});
function normalizeSlot(slot, data2) {
  if (!slot)
    return null;
  const slotContent = slot(data2);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function warnDeprecatedUsage() {
  const instance = getCurrentInstance();
  const parentName = instance.parent && instance.parent.type.name;
  if (parentName && (parentName === "KeepAlive" || parentName.includes("Transition"))) {
    const comp2 = parentName === "KeepAlive" ? "keep-alive" : "transition";
    warn$2(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${comp2}>
    <component :is="Component" />
  </${comp2}>
</router-view>`);
  }
}
function formatRouteLocation(routeLocation, tooltip) {
  const copy2 = assign$2({}, routeLocation, {
    matched: routeLocation.matched.map((matched) => omit$1(matched, ["instances", "children", "aliasOf"]))
  });
  return {
    _custom: {
      type: null,
      readOnly: true,
      display: routeLocation.fullPath,
      tooltip,
      value: copy2
    }
  };
}
function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
}
let routerId = 0;
function addDevtools(app, router, matcher2) {
  if (router.__hasDevtools)
    return;
  router.__hasDevtools = true;
  const id2 = routerId++;
  setupDevtoolsPlugin({
    id: "org.vuejs.router" + (id2 ? "." + id2 : ""),
    label: "Vue Router",
    packageName: "vue-router",
    homepage: "https://router.vuejs.org",
    logo: "https://router.vuejs.org/logo.png",
    componentStateTypes: ["Routing"],
    app
  }, (api) => {
    if (typeof api.now !== "function") {
      console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    }
    api.on.inspectComponent((payload, ctx) => {
      if (payload.instanceData) {
        payload.instanceData.state.push({
          type: "Routing",
          key: "$route",
          editable: false,
          value: formatRouteLocation(router.currentRoute.value, "Current Route")
        });
      }
    });
    api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {
      if (componentInstance.__vrv_devtools) {
        const info = componentInstance.__vrv_devtools;
        node.tags.push({
          label: (info.name ? `${info.name.toString()}: ` : "") + info.path,
          textColor: 0,
          tooltip: "This component is rendered by &lt;router-view&gt;",
          backgroundColor: PINK_500
        });
      }
      if (isArray$2(componentInstance.__vrl_devtools)) {
        componentInstance.__devtoolsApi = api;
        componentInstance.__vrl_devtools.forEach((devtoolsData) => {
          let backgroundColor = ORANGE_400;
          let tooltip = "";
          if (devtoolsData.isExactActive) {
            backgroundColor = LIME_500;
            tooltip = "This is exactly active";
          } else if (devtoolsData.isActive) {
            backgroundColor = BLUE_600;
            tooltip = "This link is active";
          }
          node.tags.push({
            label: devtoolsData.route.path,
            textColor: 0,
            tooltip,
            backgroundColor
          });
        });
      }
    });
    watch(router.currentRoute, () => {
      refreshRoutesView();
      api.notifyComponentUpdate();
      api.sendInspectorTree(routerInspectorId);
      api.sendInspectorState(routerInspectorId);
    });
    const navigationsLayerId = "router:navigations:" + id2;
    api.addTimelineLayer({
      id: navigationsLayerId,
      label: `Router${id2 ? " " + id2 : ""} Navigations`,
      color: 4237508
    });
    router.onError((error2, to2) => {
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: "Error during Navigation",
          subtitle: to2.fullPath,
          logType: "error",
          time: api.now(),
          data: { error: error2 },
          groupId: to2.meta.__navigationId
        }
      });
    });
    let navigationId = 0;
    router.beforeEach((to2, from2) => {
      const data2 = {
        guard: formatDisplay("beforeEach"),
        from: formatRouteLocation(from2, "Current Location during this navigation"),
        to: formatRouteLocation(to2, "Target location")
      };
      Object.defineProperty(to2.meta, "__navigationId", {
        value: navigationId++
      });
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          time: api.now(),
          title: "Start of navigation",
          subtitle: to2.fullPath,
          data: data2,
          groupId: to2.meta.__navigationId
        }
      });
    });
    router.afterEach((to2, from2, failure) => {
      const data2 = {
        guard: formatDisplay("afterEach")
      };
      if (failure) {
        data2.failure = {
          _custom: {
            type: Error,
            readOnly: true,
            display: failure ? failure.message : "",
            tooltip: "Navigation Failure",
            value: failure
          }
        };
        data2.status = formatDisplay("\u274C");
      } else {
        data2.status = formatDisplay("\u2705");
      }
      data2.from = formatRouteLocation(from2, "Current Location during this navigation");
      data2.to = formatRouteLocation(to2, "Target location");
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: "End of navigation",
          subtitle: to2.fullPath,
          time: api.now(),
          data: data2,
          logType: failure ? "warning" : "default",
          groupId: to2.meta.__navigationId
        }
      });
    });
    const routerInspectorId = "router-inspector:" + id2;
    api.addInspector({
      id: routerInspectorId,
      label: "Routes" + (id2 ? " " + id2 : ""),
      icon: "book",
      treeFilterPlaceholder: "Search routes"
    });
    function refreshRoutesView() {
      if (!activeRoutesPayload)
        return;
      const payload = activeRoutesPayload;
      let routes = matcher2.getRoutes().filter((route) => !route.parent);
      routes.forEach(resetMatchStateOnRouteRecord);
      if (payload.filter) {
        routes = routes.filter((route) => isRouteMatching(route, payload.filter.toLowerCase()));
      }
      routes.forEach((route) => markRouteRecordActive(route, router.currentRoute.value));
      payload.rootNodes = routes.map(formatRouteRecordForInspector);
    }
    let activeRoutesPayload;
    api.on.getInspectorTree((payload) => {
      activeRoutesPayload = payload;
      if (payload.app === app && payload.inspectorId === routerInspectorId) {
        refreshRoutesView();
      }
    });
    api.on.getInspectorState((payload) => {
      if (payload.app === app && payload.inspectorId === routerInspectorId) {
        const routes = matcher2.getRoutes();
        const route = routes.find((route2) => route2.record.__vd_id === payload.nodeId);
        if (route) {
          payload.state = {
            options: formatRouteRecordMatcherForStateInspector(route)
          };
        }
      }
    });
    api.sendInspectorTree(routerInspectorId);
    api.sendInspectorState(routerInspectorId);
  });
}
function modifierForKey(key) {
  if (key.optional) {
    return key.repeatable ? "*" : "?";
  } else {
    return key.repeatable ? "+" : "";
  }
}
function formatRouteRecordMatcherForStateInspector(route) {
  const { record } = route;
  const fields = [
    { editable: false, key: "path", value: record.path }
  ];
  if (record.name != null) {
    fields.push({
      editable: false,
      key: "name",
      value: record.name
    });
  }
  fields.push({ editable: false, key: "regexp", value: route.re });
  if (route.keys.length) {
    fields.push({
      editable: false,
      key: "keys",
      value: {
        _custom: {
          type: null,
          readOnly: true,
          display: route.keys.map((key) => `${key.name}${modifierForKey(key)}`).join(" "),
          tooltip: "Param keys",
          value: route.keys
        }
      }
    });
  }
  if (record.redirect != null) {
    fields.push({
      editable: false,
      key: "redirect",
      value: record.redirect
    });
  }
  if (route.alias.length) {
    fields.push({
      editable: false,
      key: "aliases",
      value: route.alias.map((alias) => alias.record.path)
    });
  }
  if (Object.keys(route.record.meta).length) {
    fields.push({
      editable: false,
      key: "meta",
      value: route.record.meta
    });
  }
  fields.push({
    key: "score",
    editable: false,
    value: {
      _custom: {
        type: null,
        readOnly: true,
        display: route.score.map((score) => score.join(", ")).join(" | "),
        tooltip: "Score used to sort routes",
        value: route.score
      }
    }
  });
  return fields;
}
const PINK_500 = 15485081;
const BLUE_600 = 2450411;
const LIME_500 = 8702998;
const CYAN_400 = 2282478;
const ORANGE_400 = 16486972;
const DARK = 6710886;
function formatRouteRecordForInspector(route) {
  const tags = [];
  const { record } = route;
  if (record.name != null) {
    tags.push({
      label: String(record.name),
      textColor: 0,
      backgroundColor: CYAN_400
    });
  }
  if (record.aliasOf) {
    tags.push({
      label: "alias",
      textColor: 0,
      backgroundColor: ORANGE_400
    });
  }
  if (route.__vd_match) {
    tags.push({
      label: "matches",
      textColor: 0,
      backgroundColor: PINK_500
    });
  }
  if (route.__vd_exactActive) {
    tags.push({
      label: "exact",
      textColor: 0,
      backgroundColor: LIME_500
    });
  }
  if (route.__vd_active) {
    tags.push({
      label: "active",
      textColor: 0,
      backgroundColor: BLUE_600
    });
  }
  if (record.redirect) {
    tags.push({
      label: typeof record.redirect === "string" ? `redirect: ${record.redirect}` : "redirects",
      textColor: 16777215,
      backgroundColor: DARK
    });
  }
  let id2 = record.__vd_id;
  if (id2 == null) {
    id2 = String(routeRecordId++);
    record.__vd_id = id2;
  }
  return {
    id: id2,
    label: record.path,
    tags,
    children: route.children.map(formatRouteRecordForInspector)
  };
}
let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
function markRouteRecordActive(route, currentRoute) {
  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
  route.__vd_exactActive = route.__vd_active = isExactActive;
  if (!isExactActive) {
    route.__vd_active = currentRoute.matched.some((match5) => isSameRouteRecord(match5, route.record));
  }
  route.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));
}
function resetMatchStateOnRouteRecord(route) {
  route.__vd_match = false;
  route.children.forEach(resetMatchStateOnRouteRecord);
}
function isRouteMatching(route, filter2) {
  const found = String(route.re).match(EXTRACT_REGEXP_RE);
  route.__vd_match = false;
  if (!found || found.length < 3) {
    return false;
  }
  const nonEndingRE = new RegExp(found[1].replace(/\$$/, ""), found[2]);
  if (nonEndingRE.test(filter2)) {
    route.children.forEach((child) => isRouteMatching(child, filter2));
    if (route.record.path !== "/" || filter2 === "/") {
      route.__vd_match = route.re.test(filter2);
      return true;
    }
    return false;
  }
  const path2 = route.record.path.toLowerCase();
  const decodedPath = decode$2(path2);
  if (!filter2.startsWith("/") && (decodedPath.includes(filter2) || path2.includes(filter2)))
    return true;
  if (decodedPath.startsWith(filter2) || path2.startsWith(filter2))
    return true;
  if (route.record.name && String(route.record.name).includes(filter2))
    return true;
  return route.children.some((child) => isRouteMatching(child, filter2));
}
function omit$1(obj, keys2) {
  const ret = {};
  for (const key in obj) {
    if (!keys2.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
function createRouter(options) {
  const matcher2 = createRouterMatcher(options.routes, options);
  const parseQuery$1$1 = options.parseQuery || parseQuery$1;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  if (!routerHistory)
    throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser$1 && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode$2);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher2.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher2.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher2.getRecordMatcher(name);
    if (recordMatcher) {
      matcher2.removeRoute(recordMatcher);
    } else {
      warn$2(`Cannot remove non-existent route "${String(name)}"`);
    }
  }
  function getRoutes() {
    return matcher2.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher2.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign$2({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher2.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      {
        if (href2.startsWith("//"))
          warn$2(`Location "${rawLocation}" resolved to "${href2}". A resolved location cannot start with multiple slashes.`);
        else if (!matchedRoute2.matched.length) {
          warn$2(`No match found for location with path "${rawLocation}"`);
        }
      }
      return assign$2(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode$2(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      if ("params" in rawLocation && !("name" in rawLocation) && Object.keys(rawLocation.params).length) {
        warn$2(`Path "${rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
      }
      matcherLocation = assign$2({}, rawLocation, {
        path: parseURL(parseQuery$1$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$2({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign$2({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher2.resolve(matcherLocation, currentLocation);
    const hash2 = rawLocation.hash || "";
    if (hash2 && !hash2.startsWith("#")) {
      warn$2(`A \`hash\` should always start with the character "#". Replace "${hash2}" with "#${hash2}".`);
    }
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$2({}, rawLocation, {
      hash: encodeHash(hash2),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    {
      if (href.startsWith("//")) {
        warn$2(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
      } else if (!matchedRoute.matched.length) {
        warn$2(`No match found for location with path "${"path" in rawLocation ? rawLocation.path : rawLocation}"`);
      }
    }
    return assign$2({
      fullPath,
      hash: hash2,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to2) {
    return typeof to2 === "string" ? parseURL(parseQuery$1$1, to2, currentRoute.value.path) : assign$2({}, to2);
  }
  function checkCanceledNavigation(to2, from2) {
    if (pendingLocation !== to2) {
      return createRouterError(8, {
        from: from2,
        to: to2
      });
    }
  }
  function push(to2) {
    return pushWithRedirect(to2);
  }
  function replace2(to2) {
    return push(assign$2(locationAsObject(to2), { replace: true }));
  }
  function handleRedirectRecord(to2) {
    const lastMatched = to2.matched[to2.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to2) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      if (!("path" in newTargetLocation) && !("name" in newTargetLocation)) {
        warn$2(`Invalid redirect found:
${JSON.stringify(newTargetLocation, null, 2)}
 when navigating to "${to2.fullPath}". A redirect must contain a name or path. This will break in production.`);
        throw new Error("Invalid redirect");
      }
      return assign$2({
        query: to2.query,
        hash: to2.hash,
        params: "path" in newTargetLocation ? {} : to2.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to2, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to2);
    const from2 = currentRoute.value;
    const data2 = to2.state;
    const force = to2.force;
    const replace3 = to2.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(assign$2(locationAsObject(shouldRedirect), {
        state: data2,
        force,
        replace: replace3
      }), redirectedFrom || targetLocation);
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from2, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from: from2 });
      handleScroll(from2, from2, true, false);
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from2)).catch((error2) => isNavigationFailure(error2) ? isNavigationFailure(error2, 2) ? error2 : markAsReady(error2) : triggerError(error2, toLocation, from2)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          if (isSameRouteLocation(stringifyQuery$1, resolve2(failure2.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 10) {
            warn$2(`Detected an infinite redirection in a navigation guard when going from "${from2.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
            return Promise.reject(new Error("Infinite redirect in navigation guard"));
          }
          return pushWithRedirect(assign$2(locationAsObject(failure2.to), {
            state: data2,
            force,
            replace: replace3
          }), redirectedFrom || toLocation);
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from2, true, replace3, data2);
      }
      triggerAfterEach(toLocation, from2, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to2, from2) {
    const error2 = checkCanceledNavigation(to2, from2);
    return error2 ? Promise.reject(error2) : Promise.resolve();
  }
  function navigate(to2, from2) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to2, from2);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to2, from2);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to2, from2));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to2, from2);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to2, from2);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to2, from2));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to2.matched) {
        if (record.beforeEnter && !from2.matched.includes(record)) {
          if (isArray$2(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to2, from2));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to2, from2));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to2.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to2, from2);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to2, from2, failure) {
    for (const guard of afterGuards.list())
      guard(to2, from2, failure);
  }
  function finalizeNavigation(toLocation, from2, isPush, replace3, data2) {
    const error2 = checkCanceledNavigation(toLocation, from2);
    if (error2)
      return error2;
    const isFirstNavigation = from2 === START_LOCATION_NORMALIZED;
    const state = !isBrowser$1 ? {} : history.state;
    if (isPush) {
      if (replace3 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$2({
          scroll: isFirstNavigation && state && state.scroll
        }, data2));
      else
        routerHistory.push(toLocation.fullPath, data2);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from2, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to2, _from, info) => {
      if (!router.listening)
        return;
      const toLocation = resolve2(to2);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$2(shouldRedirect, { replace: true }), toLocation).catch(noop$2);
        return;
      }
      pendingLocation = toLocation;
      const from2 = currentRoute.value;
      if (isBrowser$1) {
        saveScrollPosition(getScrollKey(from2.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from2).catch((error2) => {
        if (isNavigationFailure(error2, 4 | 8)) {
          return error2;
        }
        if (isNavigationFailure(error2, 2)) {
          pushWithRedirect(error2.to, toLocation).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop$2);
          return Promise.reject();
        }
        if (info.delta)
          routerHistory.go(-info.delta, false);
        return triggerError(error2, toLocation, from2);
      }).then((failure) => {
        failure = failure || finalizeNavigation(toLocation, from2, false);
        if (failure) {
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from2, failure);
      }).catch(noop$2);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error2, to2, from2) {
    markAsReady(error2);
    const list3 = errorHandlers.list();
    if (list3.length) {
      list3.forEach((handler) => handler(error2, to2, from2));
    } else {
      {
        warn$2("uncaught error during route navigation:");
      }
      console.error(error2);
    }
    return Promise.reject(error2);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to2, from2, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser$1 || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to2.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to2, from2, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to2, from2));
  }
  const go = (delta2) => routerHistory.go(delta2);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace: replace2,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser$1 && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
          warn$2("Unexpected error when starting the router:", err);
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, reactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
      if (isBrowser$1) {
        addDevtools(app, router2, matcher2);
      }
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to2, from2) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len2 = Math.max(from2.matched.length, to2.matched.length);
  for (let i2 = 0; i2 < len2; i2++) {
    const recordFrom = from2.matched[i2];
    if (recordFrom) {
      if (to2.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to2.matched[i2];
    if (recordTo) {
      if (!from2.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute() {
  return inject(routeLocationKey);
}
const voidElements = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
const KEY_ESCAPE_REG = /[\s-.:|#@$*%]/;
const MAX_SINGLE_LINE_ARRAY_LENGTH = 3;
function serializeJs(value) {
  const seen = /* @__PURE__ */ new Set();
  if (value === void 0) {
    return "undefined";
  }
  if (value === null) {
    return "null";
  }
  if (typeof value === "string") {
    return `'${value}'`;
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (Array.isArray(value)) {
    return printLines(arrayToSourceLines(value, seen));
  }
  if (typeof value === "object") {
    return printLines(objectToSourceLines(value, seen));
  }
  if (value == null ? void 0 : value.__autoBuildingObject) {
    return value;
  }
  if (typeof value === "function" && value.name) {
    return value.name;
  }
  return value.toString();
}
function printLines(lines) {
  return lines.map((line2) => "  ".repeat(line2.spaces) + line2.line).join("\n");
}
function objectToSourceLines(object, seen, indentCount = 0) {
  if (seen.has(object)) {
    object = {};
  } else {
    seen.add(object);
  }
  return createLines(indentCount, (lines) => {
    lines.push("{");
    lines.push(...createLines(1, (lines2) => {
      for (const key in object) {
        const value = object[key];
        let printedKey = key;
        if (KEY_ESCAPE_REG.test(key)) {
          printedKey = `'${printedKey}'`;
        }
        addLinesFromValue(lines2, value, `${printedKey}: `, ",", seen);
      }
    }));
    lines.push("}");
  });
}
function arrayToSourceLines(array2, seen, indentCount = 0) {
  if (seen.has(array2)) {
    array2 = [];
  } else {
    seen.add(array2);
  }
  return createLines(indentCount, (lines) => {
    const contentLines = createLines(1, (lines2) => {
      for (const value of array2) {
        addLinesFromValue(lines2, value, "", ",", seen);
      }
    });
    if (contentLines.length === 0) {
      lines.push("[]");
    } else if (contentLines.length <= MAX_SINGLE_LINE_ARRAY_LENGTH && !contentLines.some((line2) => line2.spaces > 1)) {
      const [first] = contentLines;
      first.line = contentLines.map(({ line: line2 }) => line2.substring(0, line2.length - 1)).join(", ");
      first.line = `[${first.line}]`;
      first.spaces--;
      lines.push(first);
    } else {
      lines.push("[", ...contentLines, "]");
    }
  });
}
function createLines(indentCount, handler) {
  const lines = [];
  handler(lines);
  return lines.map((line2) => {
    if (line2.spaces != null) {
      line2.spaces += indentCount;
      return line2;
    }
    return { spaces: indentCount, line: line2 };
  });
}
function addLinesFromValue(lines, value, before, after, seen) {
  let result;
  if (Array.isArray(value)) {
    lines.push(...wrap(arrayToSourceLines(value, seen), before, after));
    return;
  } else if (value && typeof value === "object") {
    lines.push(...wrap(objectToSourceLines(value, seen), before, after));
    return;
  } else if (typeof value === "string") {
    result = value.includes("'") ? `\`${value}\`` : `'${value}'`;
  } else if (typeof value === "undefined") {
    result = "undefined";
  } else if (value === null) {
    result = "null";
  } else if (typeof value === "boolean") {
    result = value ? "true" : "false";
  } else {
    result = value;
  }
  lines.push(before + result + after);
}
function wrap(lines, before, after) {
  lines[0].line = before + lines[0].line;
  lines[lines.length - 1].line += after;
  return lines;
}
function indent(lines, count2 = 1) {
  return lines.map((line2) => `${"  ".repeat(count2)}${line2}`);
}
function unindent(code3) {
  const lines = code3.split("\n");
  let indentLevel = -1;
  let indentText;
  const linesToAnalyze = lines.filter((line2) => line2.trim().length > 0);
  for (const line2 of linesToAnalyze) {
    const match5 = /^\s*/.exec(line2);
    if (match5 && (indentLevel === -1 || indentLevel > match5[0].length)) {
      indentLevel = match5[0].length;
      indentText = match5[0];
    }
  }
  const result = [];
  for (const line2 of lines) {
    result.push(line2.replace(indentText, ""));
  }
  return result.join("\n").trim();
}
function createAutoBuildingObject(format3, specialKeysHandler, key = "", depth = 0) {
  const cache2 = {};
  if (depth > 32)
    return { key, cache: cache2, target: {}, proxy: () => key };
  const target2 = () => {
    const k2 = key + "()";
    return format3 ? format3(k2) : k2;
  };
  const proxy = new Proxy(target2, {
    get(_2, p2) {
      if (p2 === "__autoBuildingObject") {
        return true;
      }
      if (p2 === "__autoBuildingObjectGetKey") {
        return key;
      }
      if (specialKeysHandler) {
        const fn = specialKeysHandler(target2, p2);
        if (fn) {
          return fn();
        }
      }
      if (p2 === "toString") {
        const k2 = key + ".toString()";
        return () => format3 ? format3(k2) : k2;
      }
      if (p2 === Symbol.toPrimitive) {
        return () => format3 ? format3(key) : key;
      }
      if (!cache2[p2]) {
        const childKey = key ? `${key}.${p2.toString()}` : p2.toString();
        const child = createAutoBuildingObject(format3, specialKeysHandler, childKey, depth + 1);
        cache2[p2] = { key: childKey, ...child };
      }
      return cache2[p2].proxy;
    },
    apply(_2, thisArg, args) {
      const k2 = `${key}(${args.join(", ")})`;
      return format3 ? format3(k2) : k2;
    }
  });
  return {
    key,
    cache: cache2,
    target: target2,
    proxy
  };
}
function clone$2(data2) {
  try {
    return structuredClone(data2);
  } catch (e2) {
    console.warn(e2, `Fallback to JSON cloning`);
    try {
      return JSON.parse(JSON.stringify(data2));
    } catch (e3) {
      console.error(e3);
    }
    return data2;
  }
}
function omit(data2, keys2) {
  const copy2 = {};
  for (const key in data2) {
    if (!keys2.includes(key)) {
      copy2[key] = data2[key];
    }
  }
  return copy2;
}
function applyStateToVariant(variant, state, override = false) {
  if (variant.state) {
    for (const key in state) {
      if (!override && variant.state[key] && !key.startsWith("_h") && typeof variant.state[key] === "object" && !Array.isArray(variant.state[key])) {
        Object.assign(variant.state[key], state[key]);
      } else {
        variant.state[key] = state[key];
      }
    }
  } else {
    variant.state = state;
  }
}
var __defProp$2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$2.call(b2, prop2))
      __defNormalProp$2(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$2)
    for (var prop2 of __getOwnPropSymbols$2(b2)) {
      if (__propIsEnum$2.call(b2, prop2))
        __defNormalProp$2(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp$2.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop2 of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum$2.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getBasePlacement(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref) {
  let {
    reference: reference3,
    floating,
    placement
  } = _ref;
  const commonX = reference3.x + reference3.width / 2 - floating.width / 2;
  const commonY = reference3.y + reference3.height / 2 - floating.height / 2;
  let coords;
  switch (getBasePlacement(placement)) {
    case "top":
      coords = {
        x: commonX,
        y: reference3.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference3.y + reference3.height
      };
      break;
    case "right":
      coords = {
        x: reference3.x + reference3.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference3.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference3.x,
        y: reference3.y
      };
  }
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] = coords[mainAxis] - (reference3[length] / 2 - floating[length] / 2);
      break;
    case "end":
      coords[mainAxis] = coords[mainAxis] + (reference3[length] / 2 - floating[length] / 2);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference3, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  let rects = await platform2.getElementRects({
    reference: reference3,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(__spreadProps(__spreadValues$2({}, rects), {
    placement
  }));
  let statefulPlacement = placement;
  let middlewareData = {};
  for (let i2 = 0; i2 < middleware.length; i2++) {
    const {
      name,
      fn
    } = middleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference3,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = __spreadProps(__spreadValues$2({}, middlewareData), {
      [name]: data2 != null ? data2 : {}
    });
    if (reset2) {
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference: reference3,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(__spreadProps(__spreadValues$2({}, rects), {
          placement: statefulPlacement
        })));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return __spreadValues$2({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect2) {
  return __spreadProps(__spreadValues$2({}, rect2), {
    top: rect2.y,
    left: rect2.x,
    right: rect2.x + rect2.width,
    bottom: rect2.y + rect2.height
  });
}
async function detectOverflow(middlewareArguments, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingParents",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = await platform2.getClippingClientRect({
    element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
      element: elements.floating
    }),
    boundary,
    rootBoundary
  });
  const elementClientRect = rectToClientRect(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? __spreadProps(__spreadValues$2({}, rects.floating), {
      x: x2,
      y: y2
    }) : rects.reference,
    offsetParent: await platform2.getOffsetParent({
      element: elements.floating
    }),
    strategy
  }));
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$1$1 = Math.min;
const max$1$1 = Math.max;
function within(min$1$1$1, value, max$1$1$1) {
  return max$1$1(min$1$1$1, min$1$1(value, max$1$1$1));
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const basePlacement = getBasePlacement(placement);
    const axis = getMainAxisFromPlacement(basePlacement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions({
      element
    });
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await platform2.getOffsetParent({
      element
    });
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min2, center, max2);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects) {
  const isStart = getAlignment(placement) === "start";
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
const hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
const basePlacements = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ basePlacements.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getBasePlacement(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;
      const {
        x: x2,
        y: y2,
        rects,
        middlewareData,
        placement
      } = middlewareArguments;
      const _a2 = options, {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true
      } = _a2, detectOverflowOptions = __objRest(_a2, [
        "alignment",
        "allowedPlacements",
        "autoAlignment"
      ]);
      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {
        return {};
      }
      const placements2 = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;
      const currentPlacement = placements2[currentIndex];
      const {
        main: main2,
        cross: cross2
      } = getAlignmentSides(currentPlacement, rects);
      if (placement !== currentPlacement) {
        return {
          x: x2,
          y: y2,
          reset: {
            placement: placements2[0]
          }
        };
      }
      const currentOverflows = [overflow[getBasePlacement(currentPlacement)], overflow[main2], overflow[cross2]];
      const allOverflows = [...(_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements2[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a2, b2) => a2.overflows[0] - b2.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      return {
        data: {
          skip: true
        },
        reset: {
          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement
        }
      };
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip, _middlewareData$flip2;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement
      } = middlewareArguments;
      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
        return {};
      }
      const _a2 = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true
      } = _a2, detectOverflowOptions = __objRest(_a2, [
        "mainAxis",
        "crossAxis",
        "fallbackPlacements",
        "fallbackStrategy",
        "flipAlignment"
      ]);
      const basePlacement = getBasePlacement(placement);
      const isBasePlacement = basePlacement === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[basePlacement]);
      }
      if (checkCrossAxis) {
        const {
          main: main2,
          cross: cross2
        } = getAlignmentSides(placement, rects);
        overflows.push(overflow[main2], overflow[cross2]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side) => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip3;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a2, b2) => a2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          data: {
            skip: true
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords(_ref) {
  let {
    placement,
    rects,
    value
  } = _ref;
  const basePlacement = getBasePlacement(placement);
  const multiplier = ["left", "top"].includes(basePlacement) ? -1 : 1;
  const rawValue = typeof value === "function" ? value(__spreadProps(__spreadValues$2({}, rects), {
    placement
  })) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : __spreadValues$2({
    mainAxis: 0,
    crossAxis: 0
  }, rawValue);
  return getMainAxisFromPlacement(basePlacement) === "x" ? {
    x: crossAxis,
    y: mainAxis * multiplier
  } : {
    x: mainAxis * multiplier,
    y: crossAxis
  };
}
const offset$1 = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement,
        rects
      } = middlewareArguments;
      const diffCoords = convertValueToCoords({
        placement,
        rects,
        value
      });
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const _a2 = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x22,
              y: y22
            } = _ref;
            return {
              x: x22,
              y: y22
            };
          }
        }
      } = _a2, detectOverflowOptions = __objRest(_a2, [
        "mainAxis",
        "crossAxis",
        "limiter"
      ]);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getBasePlacement(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn(__spreadProps(__spreadValues$2({}, middlewareArguments), {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return __spreadProps(__spreadValues$2({}, limitedCoords), {
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      });
    }
  };
};
const size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$size;
      const {
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const _a2 = options, {
        apply
      } = _a2, detectOverflowOptions = __objRest(_a2, [
        "apply"
      ]);
      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {
        return {};
      }
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const basePlacement = getBasePlacement(placement);
      const isEnd = getAlignment(placement) === "end";
      let heightSide;
      let widthSide;
      if (basePlacement === "top" || basePlacement === "bottom") {
        heightSide = basePlacement;
        widthSide = isEnd ? "left" : "right";
      } else {
        widthSide = basePlacement;
        heightSide = isEnd ? "top" : "bottom";
      }
      const xMin = max$1$1(overflow.left, 0);
      const xMax = max$1$1(overflow.right, 0);
      const yMin = max$1$1(overflow.top, 0);
      const yMax = max$1$1(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1$1(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1$1(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply == null ? void 0 : apply(__spreadValues$2(__spreadValues$2({}, dimensions), rects));
      return {
        data: {
          skip: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
};
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode$1(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isScrollParent(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
const min$3 = Math.min;
const max$3 = Math.max;
const round$1 = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement(node) {
  return ((isNode$1(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect2 = getBoundingClientRect(element);
  return round$1(rect2.width) !== element.offsetWidth || round$1(rect2.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect2 = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect2.left + scroll.scrollLeft - offsets.x,
    y: rect2.top + scroll.scrollTop - offsets.y,
    width: rect2.width,
    height: rect2.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  return {
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect: rect2,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect2;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return __spreadProps(__spreadValues$2({}, rect2), {
    x: rect2.x - scroll.scrollLeft + offsets.x,
    y: rect2.y - scroll.scrollTop + offsets.y
  });
}
function getViewportRect(element) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max$3(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max$3(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max$3(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getScrollParent(node) {
  if (["html", "body", "#document"].includes(getNodeName(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function getScrollParents(node, list3) {
  var _node$ownerDocument;
  if (list3 === void 0) {
    list3 = [];
  }
  const scrollParent = getScrollParent(node);
  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollParent);
  const target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list3.concat(target2);
  return isBody ? updatedList : updatedList.concat(getScrollParents(getParentNode(target2)));
}
function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element) {
  const clientRect = getBoundingClientRect(element);
  const top2 = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top: top2,
    left,
    x: left,
    y: top2,
    right: left + element.clientWidth,
    bottom: top2 + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingParent(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  const clippingParents = getScrollParents(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingClientRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents[0];
  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {
    const rect2 = getClientRectFromClippingParent(element, clippingParent);
    accRect.top = max$3(rect2.top, accRect.top);
    accRect.right = min$3(rect2.right, accRect.right);
    accRect.bottom = min$3(rect2.bottom, accRect.bottom);
    accRect.left = max$3(rect2.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingParent(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
const platform = {
  getElementRects: (_ref) => {
    let {
      reference: reference3,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference3, getOffsetParent(floating), strategy),
      floating: __spreadProps(__spreadValues$2({}, getDimensions(floating)), {
        x: 0,
        y: 0
      })
    };
  },
  convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect(args),
  getOffsetParent: (_ref2) => {
    let {
      element
    } = _ref2;
    return getOffsetParent(element);
  },
  isElement: (value) => isElement(value),
  getDocumentElement: (_ref3) => {
    let {
      element
    } = _ref3;
    return getDocumentElement(element);
  },
  getClippingClientRect: (args) => getClippingClientRect(args),
  getDimensions: (_ref4) => {
    let {
      element
    } = _ref4;
    return getDimensions(element);
  },
  getClientRects: (_ref5) => {
    let {
      element
    } = _ref5;
    return element.getClientRects();
  }
};
const computePosition = (reference3, floating, options) => computePosition$1(reference3, floating, __spreadValues$2({
  platform
}, options));
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop2))
      __defNormalProp2(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols2)
    for (var prop2 of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop2))
        __defNormalProp2(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
const config$1 = {
  disabled: false,
  distance: 5,
  skidding: 0,
  container: "body",
  boundary: void 0,
  instantMove: false,
  disposeTimeout: 5e3,
  popperTriggers: [],
  strategy: "absolute",
  preventOverflow: true,
  flip: true,
  shift: true,
  overflowPadding: 0,
  arrowPadding: 0,
  arrowOverflow: true,
  themes: {
    tooltip: {
      placement: "top",
      triggers: ["hover", "focus", "touch"],
      hideTriggers: (events) => [...events, "click"],
      delay: {
        show: 200,
        hide: 0
      },
      handleResize: false,
      html: false,
      loadingContent: "..."
    },
    dropdown: {
      placement: "bottom",
      triggers: ["click"],
      delay: 0,
      handleResize: true,
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function getDefaultConfig(theme, key) {
  let themeConfig = config$1.themes[theme] || {};
  let value;
  do {
    value = themeConfig[key];
    if (typeof value === "undefined") {
      if (themeConfig.$extend) {
        themeConfig = config$1.themes[themeConfig.$extend] || {};
      } else {
        themeConfig = null;
        value = config$1[key];
      }
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return value;
}
function getThemeClasses(theme) {
  const result = [theme];
  let themeConfig = config$1.themes[theme] || {};
  do {
    if (themeConfig.$extend && !themeConfig.$resetCss) {
      result.push(themeConfig.$extend);
      themeConfig = config$1.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result.map((c2) => `v-popper--theme-${c2}`);
}
function getAllParentThemes(theme) {
  const result = [theme];
  let themeConfig = config$1.themes[theme] || {};
  do {
    if (themeConfig.$extend) {
      result.push(themeConfig.$extend);
      themeConfig = config$1.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result;
}
let supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e2) {
  }
}
let isIOS = false;
if (typeof window !== "undefined" && typeof navigator !== "undefined") {
  isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
const placements = ["auto", "top", "bottom", "left", "right"].reduce((acc, base2) => acc.concat([
  base2,
  `${base2}-start`,
  `${base2}-end`
]), []);
const SHOW_EVENT_MAP = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart"
};
const HIDE_EVENT_MAP = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend"
};
function removeFromArray(array2, item) {
  const index2 = array2.indexOf(item);
  if (index2 !== -1) {
    array2.splice(index2, 1);
  }
}
function nextFrame() {
  return new Promise((resolve2) => requestAnimationFrame(() => {
    requestAnimationFrame(resolve2);
  }));
}
const shownPoppers = [];
let hidingPopper = null;
const shownPoppersByTheme = {};
function getShownPoppersByTheme(theme) {
  let list3 = shownPoppersByTheme[theme];
  if (!list3) {
    list3 = shownPoppersByTheme[theme] = [];
  }
  return list3;
}
let Element$2 = function() {
};
if (typeof window !== "undefined") {
  Element$2 = window.Element;
}
function defaultPropFactory(prop2) {
  return function(props) {
    return getDefaultConfig(props.theme, prop2);
  };
}
const PROVIDE_KEY = "__floating-vue__popper";
var PrivatePopper = () => defineComponent({
  name: "VPopper",
  provide() {
    return {
      [PROVIDE_KEY]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [PROVIDE_KEY]: { default: null }
  },
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      required: true
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: defaultPropFactory("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: defaultPropFactory("positioningDisabled")
    },
    placement: {
      type: String,
      default: defaultPropFactory("placement"),
      validator: (value) => placements.includes(value)
    },
    delay: {
      type: [String, Number, Object],
      default: defaultPropFactory("delay")
    },
    distance: {
      type: [Number, String],
      default: defaultPropFactory("distance")
    },
    skidding: {
      type: [Number, String],
      default: defaultPropFactory("skidding")
    },
    triggers: {
      type: Array,
      default: defaultPropFactory("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: defaultPropFactory("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperHideTriggers")
    },
    container: {
      type: [String, Object, Element$2, Boolean],
      default: defaultPropFactory("container")
    },
    boundary: {
      type: [String, Element$2],
      default: defaultPropFactory("boundary")
    },
    strategy: {
      type: String,
      validator: (value) => ["absolute", "fixed"].includes(value),
      default: defaultPropFactory("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: defaultPropFactory("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: defaultPropFactory("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: defaultPropFactory("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: defaultPropFactory("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: defaultPropFactory("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: defaultPropFactory("computeTransformOrigin")
    },
    autoMinSize: {
      type: Boolean,
      default: defaultPropFactory("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: defaultPropFactory("autoSize")
    },
    autoMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: defaultPropFactory("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: defaultPropFactory("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: defaultPropFactory("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: defaultPropFactory("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: defaultPropFactory("flip")
    },
    shift: {
      type: Boolean,
      default: defaultPropFactory("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: defaultPropFactory("shiftCrossAxis")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: true
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide === "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: __spreadProps2(__spreadValues2({}, this.classes), {
          popperClass: this.popperClass
        }),
        result: this.positioningDisabled ? null : this.result,
        attrs: this.$attrs
      };
    },
    parentPopper() {
      var _a2;
      return (_a2 = this[PROVIDE_KEY]) == null ? void 0 : _a2.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var _a2, _b;
      return ((_a2 = this.popperTriggers) == null ? void 0 : _a2.includes("hover")) || ((_b = this.popperShowTriggers) == null ? void 0 : _b.includes("hover"));
    }
  },
  watch: __spreadValues2(__spreadValues2({
    shown: "$_autoShowHide",
    disabled(value) {
      if (value) {
        this.dispose();
      } else {
        this.init();
      }
    },
    async container() {
      if (this.isShown) {
        this.$_ensureTeleport();
        await this.$_computePosition();
      }
    }
  }, [
    "triggers",
    "positioningDisabled"
  ].reduce((acc, prop2) => {
    acc[prop2] = "$_refreshListeners";
    return acc;
  }, {})), [
    "placement",
    "distance",
    "skidding",
    "boundary",
    "strategy",
    "overflowPadding",
    "arrowPadding",
    "preventOverflow",
    "shift",
    "shiftCrossAxis",
    "flip"
  ].reduce((acc, prop2) => {
    acc[prop2] = "$_computePosition";
    return acc;
  }, {})),
  created() {
    this.$_isDisposed = true;
    this.randomId = `popper_${[Math.random(), Date.now()].map((n2) => n2.toString(36).substring(2, 10)).join("_")}`;
    if (this.autoMinSize) {
      console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.');
    }
    if (this.autoMaxSize) {
      console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
    }
  },
  mounted() {
    this.init();
    this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event = null, skipDelay = false, force = false } = {}) {
      var _a2, _b;
      if (((_a2 = this.parentPopper) == null ? void 0 : _a2.lockedChild) && this.parentPopper.lockedChild !== this)
        return;
      this.$_pendingHide = false;
      if (force || !this.disabled) {
        if (((_b = this.parentPopper) == null ? void 0 : _b.lockedChild) === this) {
          this.parentPopper.lockedChild = null;
        }
        this.$_scheduleShow(event, skipDelay);
        this.$emit("show");
        this.$_showFrameLocked = true;
        requestAnimationFrame(() => {
          this.$_showFrameLocked = false;
        });
      }
      this.$emit("update:shown", true);
    },
    hide({ event = null, skipDelay = false } = {}) {
      var _a2;
      if (this.$_hideInProgress)
        return;
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
        if (this.parentPopper) {
          this.parentPopper.lockedChild = this;
          clearTimeout(this.parentPopper.lockedChildTimer);
          this.parentPopper.lockedChildTimer = setTimeout(() => {
            if (this.parentPopper.lockedChild === this) {
              this.parentPopper.lockedChild.hide({ skipDelay });
              this.parentPopper.lockedChild = null;
            }
          }, 1e3);
        }
        return;
      }
      if (((_a2 = this.parentPopper) == null ? void 0 : _a2.lockedChild) === this) {
        this.parentPopper.lockedChild = null;
      }
      this.$_pendingHide = false;
      this.$_scheduleHide(event, skipDelay);
      this.$emit("hide");
      this.$emit("update:shown", false);
    },
    init() {
      if (!this.$_isDisposed)
        return;
      this.$_isDisposed = false;
      this.isMounted = false;
      this.$_events = [];
      this.$_preventShow = false;
      this.$_referenceNode = this.referenceNode();
      this.$_targetNodes = this.targetNodes().filter((e2) => e2.nodeType === e2.ELEMENT_NODE);
      this.$_popperNode = this.popperNode();
      this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
      this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
      this.$_swapTargetAttrs("title", "data-original-title");
      this.$_detachPopperNode();
      if (this.triggers.length) {
        this.$_addEventListeners();
      }
      if (this.shown) {
        this.show();
      }
    },
    dispose() {
      if (this.$_isDisposed)
        return;
      this.$_isDisposed = true;
      this.$_removeEventListeners();
      this.hide({ skipDelay: true });
      this.$_detachPopperNode();
      this.isMounted = false;
      this.isShown = false;
      this.$_updateParentShownChildren(false);
      this.$_swapTargetAttrs("data-original-title", "title");
      this.$emit("dispose");
    },
    async onResize() {
      if (this.isShown) {
        await this.$_computePosition();
        this.$emit("resize");
      }
    },
    async $_computePosition() {
      var _a2;
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const options2 = {
        strategy: this.strategy,
        middleware: []
      };
      if (this.distance || this.skidding) {
        options2.middleware.push(offset$1({
          mainAxis: this.distance,
          crossAxis: this.skidding
        }));
      }
      const isPlacementAuto = this.placement.startsWith("auto");
      if (isPlacementAuto) {
        options2.middleware.push(autoPlacement({
          alignment: (_a2 = this.placement.split("-")[1]) != null ? _a2 : ""
        }));
      } else {
        options2.placement = this.placement;
      }
      if (this.preventOverflow) {
        if (this.shift) {
          options2.middleware.push(shift({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          }));
        }
        if (!isPlacementAuto && this.flip) {
          options2.middleware.push(flip({
            padding: this.overflowPadding,
            boundary: this.boundary
          }));
        }
      }
      options2.middleware.push(arrow({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      }));
      if (this.arrowOverflow) {
        options2.middleware.push({
          name: "arrowOverflow",
          fn: ({ placement, rects, middlewareData }) => {
            let overflow;
            const { centerOffset } = middlewareData.arrow;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              overflow = Math.abs(centerOffset) > rects.reference.width / 2;
            } else {
              overflow = Math.abs(centerOffset) > rects.reference.height / 2;
            }
            return {
              data: {
                overflow
              }
            };
          }
        });
      }
      if (this.autoMinSize || this.autoSize) {
        const autoSize = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        options2.middleware.push({
          name: "autoSize",
          fn: ({ rects, placement, middlewareData }) => {
            var _a22;
            if ((_a22 = middlewareData.autoSize) == null ? void 0 : _a22.skip) {
              return {};
            }
            let width;
            let height;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              width = rects.reference.width;
            } else {
              height = rects.reference.height;
            }
            this.$_innerNode.style[autoSize === "min" ? "minWidth" : autoSize === "max" ? "maxWidth" : "width"] = width != null ? `${width}px` : null;
            this.$_innerNode.style[autoSize === "min" ? "minHeight" : autoSize === "max" ? "maxHeight" : "height"] = height != null ? `${height}px` : null;
            return {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      if (this.autoMaxSize || this.autoBoundaryMaxSize) {
        this.$_innerNode.style.maxWidth = null;
        this.$_innerNode.style.maxHeight = null;
        options2.middleware.push(size({
          boundary: this.boundary,
          padding: this.overflowPadding,
          apply: ({ width, height }) => {
            this.$_innerNode.style.maxWidth = width != null ? `${width}px` : null;
            this.$_innerNode.style.maxHeight = height != null ? `${height}px` : null;
          }
        }));
      }
      const data2 = await computePosition(this.$_referenceNode, this.$_popperNode, options2);
      Object.assign(this.result, {
        x: data2.x,
        y: data2.y,
        placement: data2.placement,
        strategy: data2.strategy,
        arrow: __spreadValues2(__spreadValues2({}, data2.middlewareData.arrow), data2.middlewareData.arrowOverflow)
      });
    },
    $_scheduleShow(event = null, skipDelay = false) {
      this.$_updateParentShownChildren(true);
      this.$_hideInProgress = false;
      clearTimeout(this.$_scheduleTimer);
      if (hidingPopper && this.instantMove && hidingPopper.instantMove && hidingPopper !== this.parentPopper) {
        hidingPopper.$_applyHide(true);
        this.$_applyShow(true);
        return;
      }
      if (skipDelay) {
        this.$_applyShow();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
      }
    },
    $_scheduleHide(event = null, skipDelay = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      this.$_updateParentShownChildren(false);
      this.$_hideInProgress = true;
      clearTimeout(this.$_scheduleTimer);
      if (this.isShown) {
        hidingPopper = this;
      }
      if (skipDelay) {
        this.$_applyHide();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
      }
    },
    $_computeDelay(type) {
      const delay = this.delay;
      return parseInt(delay && delay[type] || delay || 0);
    },
    async $_applyShow(skipTransition = false) {
      clearTimeout(this.$_disposeTimer);
      clearTimeout(this.$_scheduleTimer);
      this.skipTransition = skipTransition;
      if (this.isShown) {
        return;
      }
      this.$_ensureTeleport();
      await nextFrame();
      await this.$_computePosition();
      await this.$_applyShowEffect();
      if (!this.positioningDisabled) {
        this.$_registerEventListeners([
          ...getScrollParents(this.$_referenceNode),
          ...getScrollParents(this.$_popperNode)
        ], "scroll", () => {
          this.$_computePosition();
        });
      }
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const bounds = this.$_referenceNode.getBoundingClientRect();
        const popperWrapper = this.$_popperNode.querySelector(".v-popper__wrapper");
        const parentBounds = popperWrapper.parentNode.getBoundingClientRect();
        const x2 = bounds.x + bounds.width / 2 - (parentBounds.left + popperWrapper.offsetLeft);
        const y2 = bounds.y + bounds.height / 2 - (parentBounds.top + popperWrapper.offsetTop);
        this.result.transformOrigin = `${x2}px ${y2}px`;
      }
      this.isShown = true;
      this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const showGroup = this.showGroup;
      if (showGroup) {
        let popover;
        for (let i2 = 0; i2 < shownPoppers.length; i2++) {
          popover = shownPoppers[i2];
          if (popover.showGroup !== showGroup) {
            popover.hide();
            popover.$emit("close-group");
          }
        }
      }
      shownPoppers.push(this);
      document.body.classList.add("v-popper--some-open");
      for (const theme of getAllParentThemes(this.theme)) {
        getShownPoppersByTheme(theme).push(this);
        document.body.classList.add(`v-popper--some-open--${theme}`);
      }
      this.$emit("apply-show");
      this.classes.showFrom = true;
      this.classes.showTo = false;
      this.classes.hideFrom = false;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.showFrom = false;
      this.classes.showTo = true;
      this.$_popperNode.focus();
    },
    async $_applyHide(skipTransition = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        this.$_hideInProgress = false;
        return;
      }
      clearTimeout(this.$_scheduleTimer);
      if (!this.isShown) {
        return;
      }
      this.skipTransition = skipTransition;
      removeFromArray(shownPoppers, this);
      if (shownPoppers.length === 0) {
        document.body.classList.remove("v-popper--some-open");
      }
      for (const theme of getAllParentThemes(this.theme)) {
        const list3 = getShownPoppersByTheme(theme);
        removeFromArray(list3, this);
        if (list3.length === 0) {
          document.body.classList.remove(`v-popper--some-open--${theme}`);
        }
      }
      if (hidingPopper === this) {
        hidingPopper = null;
      }
      this.isShown = false;
      this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      });
      clearTimeout(this.$_disposeTimer);
      const disposeTime = getDefaultConfig(this.theme, "disposeTimeout");
      if (disposeTime !== null) {
        this.$_disposeTimer = setTimeout(() => {
          if (this.$_popperNode) {
            this.$_detachPopperNode();
            this.isMounted = false;
          }
        }, disposeTime);
      }
      this.$_removeEventListeners("scroll");
      this.$emit("apply-hide");
      this.classes.showFrom = false;
      this.classes.showTo = false;
      this.classes.hideFrom = true;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.hideFrom = false;
      this.classes.hideTo = true;
    },
    $_autoShowHide() {
      if (this.shown) {
        this.show();
      } else {
        this.hide();
      }
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let container = this.container;
      if (typeof container === "string") {
        container = window.document.querySelector(container);
      } else if (container === false) {
        container = this.$_targetNodes[0].parentNode;
      }
      if (!container) {
        throw new Error("No container for popover: " + this.container);
      }
      container.appendChild(this.$_popperNode);
      this.isMounted = true;
    },
    $_addEventListeners() {
      const handleShow = (event) => {
        if (this.isShown && !this.$_hideInProgress) {
          return;
        }
        event.usedByTooltip = true;
        !this.$_preventShow && this.show({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, SHOW_EVENT_MAP, this.triggers, this.showTriggers, handleShow);
      this.$_registerTriggerListeners([this.$_popperNode], SHOW_EVENT_MAP, this.popperTriggers, this.popperShowTriggers, handleShow);
      const handleHide = (event) => {
        if (event.usedByTooltip) {
          return;
        }
        this.hide({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, HIDE_EVENT_MAP, this.triggers, this.hideTriggers, handleHide);
      this.$_registerTriggerListeners([this.$_popperNode], HIDE_EVENT_MAP, this.popperTriggers, this.popperHideTriggers, handleHide);
    },
    $_registerEventListeners(targetNodes, eventType, handler) {
      this.$_events.push({ targetNodes, eventType, handler });
      targetNodes.forEach((node) => node.addEventListener(eventType, handler, supportsPassive ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(targetNodes, eventMap, commonTriggers, customTrigger, handler) {
      let triggers = commonTriggers;
      if (customTrigger != null) {
        triggers = typeof customTrigger === "function" ? customTrigger(triggers) : customTrigger;
      }
      triggers.forEach((trigger2) => {
        const eventType = eventMap[trigger2];
        if (eventType) {
          this.$_registerEventListeners(targetNodes, eventType, handler);
        }
      });
    },
    $_removeEventListeners(filterEventType) {
      const newList = [];
      this.$_events.forEach((listener) => {
        const { targetNodes, eventType, handler } = listener;
        if (!filterEventType || filterEventType === eventType) {
          targetNodes.forEach((node) => node.removeEventListener(eventType, handler));
        } else {
          newList.push(listener);
        }
      });
      this.$_events = newList;
    },
    $_refreshListeners() {
      if (!this.$_isDisposed) {
        this.$_removeEventListeners();
        this.$_addEventListeners();
      }
    },
    $_handleGlobalClose(event, touch = false) {
      if (this.$_showFrameLocked)
        return;
      this.hide({ event });
      if (event.closePopover) {
        this.$emit("close-directive");
      } else {
        this.$emit("auto-hide");
      }
      if (touch) {
        this.$_preventShow = true;
        setTimeout(() => {
          this.$_preventShow = false;
        }, 300);
      }
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(attrFrom, attrTo) {
      for (const el2 of this.$_targetNodes) {
        const value = el2.getAttribute(attrFrom);
        if (value) {
          el2.removeAttribute(attrFrom);
          el2.setAttribute(attrTo, value);
        }
      }
    },
    $_applyAttrsToTarget(attrs) {
      for (const el2 of this.$_targetNodes) {
        for (const n2 in attrs) {
          const value = attrs[n2];
          if (value == null) {
            el2.removeAttribute(n2);
          } else {
            el2.setAttribute(n2, value);
          }
        }
      }
    },
    $_updateParentShownChildren(value) {
      let parent = this.parentPopper;
      while (parent) {
        if (value) {
          parent.shownChildren.add(this.randomId);
        } else {
          parent.shownChildren.delete(this.randomId);
          if (parent.$_pendingHide) {
            parent.hide();
          }
        }
        parent = parent.parentPopper;
      }
    },
    $_isAimingPopper() {
      const referenceBounds = this.$_referenceNode.getBoundingClientRect();
      if (mouseX >= referenceBounds.left && mouseX <= referenceBounds.right && mouseY >= referenceBounds.top && mouseY <= referenceBounds.bottom) {
        const popperBounds = this.$_popperNode.getBoundingClientRect();
        const vectorX = mouseX - mousePreviousX;
        const vectorY = mouseY - mousePreviousY;
        const distance = popperBounds.left + popperBounds.width / 2 - mousePreviousX + (popperBounds.top + popperBounds.height / 2) - mousePreviousY;
        const newVectorLength = distance + popperBounds.width + popperBounds.height;
        const edgeX = mousePreviousX + vectorX * newVectorLength;
        const edgeY = mousePreviousY + vectorY * newVectorLength;
        return lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.left, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.right, popperBounds.top) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.right, popperBounds.top, popperBounds.right, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.bottom, popperBounds.right, popperBounds.bottom);
      }
      return false;
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
if (typeof document !== "undefined" && typeof window !== "undefined") {
  if (isIOS) {
    document.addEventListener("touchstart", handleGlobalMousedown, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
    document.addEventListener("touchend", handleGlobalTouchend, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
  } else {
    window.addEventListener("mousedown", handleGlobalMousedown, true);
    window.addEventListener("click", handleGlobalClick, true);
  }
  window.addEventListener("resize", computePositionAllShownPoppers);
}
function handleGlobalMousedown(event) {
  for (let i2 = 0; i2 < shownPoppers.length; i2++) {
    const popper = shownPoppers[i2];
    try {
      const popperContent = popper.popperNode();
      popper.$_mouseDownContains = popperContent.contains(event.target);
    } catch (e2) {
    }
  }
}
function handleGlobalClick(event) {
  handleGlobalClose(event);
}
function handleGlobalTouchend(event) {
  handleGlobalClose(event, true);
}
function handleGlobalClose(event, touch = false) {
  const preventClose = {};
  for (let i2 = shownPoppers.length - 1; i2 >= 0; i2--) {
    const popper = shownPoppers[i2];
    try {
      const contains2 = popper.$_containsGlobalTarget = isContainingEventTarget(popper, event);
      popper.$_pendingHide = false;
      requestAnimationFrame(() => {
        popper.$_pendingHide = false;
        if (preventClose[popper.randomId])
          return;
        if (shouldAutoHide(popper, contains2, event)) {
          popper.$_handleGlobalClose(event, touch);
          if (!event.closeAllPopover && event.closePopover && contains2) {
            let parent2 = popper.parentPopper;
            while (parent2) {
              preventClose[parent2.randomId] = true;
              parent2 = parent2.parentPopper;
            }
            return;
          }
          let parent = popper.parentPopper;
          while (parent) {
            if (shouldAutoHide(parent, parent.$_containsGlobalTarget, event)) {
              parent.$_handleGlobalClose(event, touch);
            } else {
              break;
            }
            parent = parent.parentPopper;
          }
        }
      });
    } catch (e2) {
    }
  }
}
function isContainingEventTarget(popper, event) {
  const popperContent = popper.popperNode();
  return popper.$_mouseDownContains || popperContent.contains(event.target);
}
function shouldAutoHide(popper, contains2, event) {
  return event.closeAllPopover || event.closePopover && contains2 || getAutoHideResult(popper, event) && !contains2;
}
function getAutoHideResult(popper, event) {
  if (typeof popper.autoHide === "function") {
    const result = popper.autoHide(event);
    popper.lastAutoHide = result;
    return result;
  }
  return popper.autoHide;
}
function computePositionAllShownPoppers(event) {
  for (let i2 = 0; i2 < shownPoppers.length; i2++) {
    const popper = shownPoppers[i2];
    popper.$_computePosition(event);
  }
}
let mousePreviousX = 0;
let mousePreviousY = 0;
let mouseX = 0;
let mouseY = 0;
if (typeof window !== "undefined") {
  window.addEventListener("mousemove", (event) => {
    mousePreviousX = mouseX;
    mousePreviousY = mouseY;
    mouseX = event.clientX;
    mouseY = event.clientY;
  }, supportsPassive ? {
    passive: true
  } : void 0);
}
function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
  const uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  const uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  return uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1;
}
var _export_sfc = (sfc, props) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target2[key] = val;
  }
  return target2;
};
const _sfc_main$6$1 = {
  extends: PrivatePopper()
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "reference",
    class: "v-popper"
  }, _ctx.$attrs, {
    class: {
      "v-popper--shown": _ctx.slotData.isShown
    }
  }), [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)))
  ], 16);
}
var Popper$1 = /* @__PURE__ */ _export_sfc(_sfc_main$6$1, [["render", _sfc_render$3]]);
function getInternetExplorerVersion() {
  var ua2 = window.navigator.userAgent;
  var msie = ua2.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua2.substring(msie + 5, ua2.indexOf(".", msie)), 10);
  }
  var trident = ua2.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua2.indexOf("rv:");
    return parseInt(ua2.substring(rv + 3, ua2.indexOf(".", rv)), 10);
  }
  var edge = ua2.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua2.substring(edge + 5, ua2.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId = /* @__PURE__ */ withScopeId();
pushScopeId("data-v-b329ee4c");
const _hoisted_1$2$1 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render$1 = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$2$1);
});
script.render = render$1;
script.__scopeId = "data-v-b329ee4c";
script.__file = "src/components/ResizeObserver.vue";
var PrivateThemeClass = (prop2 = "theme") => ({
  computed: {
    themeClass() {
      return getThemeClasses(this[prop2]);
    }
  }
});
const _sfc_main$5$1 = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: script
  },
  mixins: [
    PrivateThemeClass()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(value) {
      if (value != null && !isNaN(value)) {
        return `${value}px`;
      }
      return null;
    }
  }
});
const _hoisted_1$1$1 = ["id", "aria-hidden", "tabindex", "data-popper-placement"];
const _hoisted_2$1$1 = {
  ref: "inner",
  class: "v-popper__inner"
};
const _hoisted_3$7 = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1);
const _hoisted_4$5 = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1);
const _hoisted_5$3 = [
  _hoisted_3$7,
  _hoisted_4$5
];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: _ctx.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      _ctx.themeClass,
      _ctx.classes.popperClass,
      {
        "v-popper__popper--shown": _ctx.shown,
        "v-popper__popper--hidden": !_ctx.shown,
        "v-popper__popper--show-from": _ctx.classes.showFrom,
        "v-popper__popper--show-to": _ctx.classes.showTo,
        "v-popper__popper--hide-from": _ctx.classes.hideFrom,
        "v-popper__popper--hide-to": _ctx.classes.hideTo,
        "v-popper__popper--skip-transition": _ctx.skipTransition,
        "v-popper__popper--arrow-overflow": _ctx.result && _ctx.result.arrow.overflow,
        "v-popper__popper--no-positioning": !_ctx.result
      }
    ]]),
    style: normalizeStyle(_ctx.result ? {
      position: _ctx.result.strategy,
      transform: `translate3d(${Math.round(_ctx.result.x)}px,${Math.round(_ctx.result.y)}px,0)`
    } : void 0),
    "aria-hidden": _ctx.shown ? "false" : "true",
    tabindex: _ctx.autoHide ? 0 : void 0,
    "data-popper-placement": _ctx.result ? _ctx.result.placement : void 0,
    onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.autoHide && _ctx.$emit("hide"), ["esc"]))
  }, [
    createBaseVNode("div", {
      class: "v-popper__backdrop",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.autoHide && _ctx.$emit("hide"))
    }),
    createBaseVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle(_ctx.result ? {
        transformOrigin: _ctx.result.transformOrigin
      } : void 0)
    }, [
      createBaseVNode("div", _hoisted_2$1$1, [
        _ctx.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", null, [
            renderSlot(_ctx.$slots, "default")
          ]),
          _ctx.handleResize ? (openBlock(), createBlock(_component_ResizeObserver, {
            key: 0,
            onNotify: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("resize", $event))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createBaseVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle(_ctx.result ? {
          left: _ctx.toPx(_ctx.result.arrow.x),
          top: _ctx.toPx(_ctx.result.arrow.y)
        } : void 0)
      }, _hoisted_5$3, 4)
    ], 4)
  ], 46, _hoisted_1$1$1);
}
var PrivatePopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$5$1, [["render", _sfc_render$2]]);
var PrivatePopperMethods = {
  methods: {
    show(...args) {
      return this.$refs.popper.show(...args);
    },
    hide(...args) {
      return this.$refs.popper.hide(...args);
    },
    dispose(...args) {
      return this.$refs.popper.dispose(...args);
    },
    onResize(...args) {
      return this.$refs.popper.onResize(...args);
    }
  }
};
const _sfc_main$4$1 = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: Popper$1,
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods,
    PrivateThemeClass("finalTheme")
  ],
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      var _a2;
      return (_a2 = this.theme) != null ? _a2 : this.$options.vPopperTheme;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$refs.popper.$el.children).filter((node) => node !== this.$refs.popperContent.$el);
    }
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, {
    ref: "popper",
    theme: _ctx.finalTheme,
    "target-nodes": _ctx.getTargetNodes,
    "reference-node": () => _ctx.$refs.popper.$el,
    "popper-node": () => _ctx.$refs.popperContent.$el,
    class: normalizeClass([
      _ctx.themeClass
    ])
  }, {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      show,
      hide,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      renderSlot(_ctx.$slots, "default", {
        shown: isShown,
        show,
        hide
      }),
      createVNode(_component_PopperContent, {
        ref: "popperContent",
        "popper-id": popperId,
        theme: _ctx.finalTheme,
        shown: isShown,
        mounted: shouldMountContent,
        "skip-transition": skipTransition,
        "auto-hide": autoHide,
        "handle-resize": handleResize,
        classes,
        result,
        onHide: hide,
        onResize
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "popper", {
            shown: isShown,
            hide
          })
        ]),
        _: 2
      }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 3
  }, 8, ["theme", "target-nodes", "reference-node", "popper-node", "class"]);
}
var PrivatePopperWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$4$1, [["render", _sfc_render$1]]);
const _sfc_main$3$1 = defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VDropdown",
  vPopperTheme: "dropdown"
}));
defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VMenu",
  vPopperTheme: "menu"
}));
defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VTooltip",
  vPopperTheme: "tooltip"
}));
const _sfc_main$d = defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: PrivatePopper(),
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (props) => getDefaultConfig(props.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (props) => getDefaultConfig(props.theme, "loadingContent")
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content === "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      if (this.isContentAsync) {
        return this.loading ? this.loadingContent : this.asyncContent;
      }
      return this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick();
      this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(force) {
      if (typeof this.content === "function" && this.$_isShown && (force || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null;
        this.$_loading = true;
        const fetchId = ++this.$_fetchId;
        const result = this.content(this);
        if (result.then) {
          result.then((res) => this.onResult(fetchId, res));
        } else {
          this.onResult(fetchId, result);
        }
      }
    },
    onResult(fetchId, result) {
      if (fetchId !== this.$_fetchId)
        return;
      this.$_loading = false;
      this.asyncContent = result;
    },
    onShow() {
      this.$_isShown = true;
      this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
});
const _hoisted_1$a = ["innerHTML"];
const _hoisted_2$8 = ["textContent"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, mergeProps({ ref: "popper" }, _ctx.$attrs, {
    theme: _ctx.theme,
    "popper-node": () => _ctx.$refs.popperContent.$el,
    onApplyShow: _ctx.onShow,
    onApplyHide: _ctx.onHide
  }), {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      hide,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      createVNode(_component_PopperContent, {
        ref: "popperContent",
        class: normalizeClass({
          "v-popper--tooltip-loading": _ctx.loading
        }),
        "popper-id": popperId,
        theme: _ctx.theme,
        shown: isShown,
        mounted: shouldMountContent,
        "skip-transition": skipTransition,
        "auto-hide": autoHide,
        "handle-resize": handleResize,
        classes,
        result,
        onHide: hide,
        onResize
      }, {
        default: withCtx(() => [
          _ctx.html ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: _ctx.finalContent
          }, null, 8, _hoisted_1$a)) : (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(_ctx.finalContent)
          }, null, 8, _hoisted_2$8))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "popper-node", "onApplyShow", "onApplyHide"]);
}
var PrivateTooltipDirective = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render]]);
const TARGET_CLASS = "v-popper--has-tooltip";
function getPlacement(options2, modifiers) {
  let result = options2.placement;
  if (!result && modifiers) {
    for (const pos of placements) {
      if (modifiers[pos]) {
        result = pos;
      }
    }
  }
  if (!result) {
    result = getDefaultConfig(options2.theme || "tooltip", "placement");
  }
  return result;
}
function getOptions(el2, value, modifiers) {
  let options2;
  const type = typeof value;
  if (type === "string") {
    options2 = { content: value };
  } else if (value && type === "object") {
    options2 = value;
  } else {
    options2 = { content: false };
  }
  options2.placement = getPlacement(options2, modifiers);
  options2.targetNodes = () => [el2];
  options2.referenceNode = () => el2;
  return options2;
}
let directiveApp;
let directives;
let uid = 0;
function ensureDirectiveApp() {
  if (directiveApp)
    return;
  directives = ref([]);
  directiveApp = createApp({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives
      };
    },
    render() {
      return this.directives.map((directive) => {
        return h$2(PrivateTooltipDirective, __spreadProps2(__spreadValues2({}, directive.options), {
          shown: directive.shown || directive.options.shown,
          key: directive.id
        }));
      });
    },
    devtools: {
      hide: true
    }
  });
  const mountTarget = document.createElement("div");
  document.body.appendChild(mountTarget);
  directiveApp.mount(mountTarget);
}
function createTooltip(el2, value, modifiers) {
  ensureDirectiveApp();
  const options2 = ref(getOptions(el2, value, modifiers));
  const shown = ref(false);
  const item = {
    id: uid++,
    options: options2,
    shown
  };
  directives.value.push(item);
  if (el2.classList) {
    el2.classList.add(TARGET_CLASS);
  }
  const result = el2.$_popper = {
    options: options2,
    item,
    show() {
      shown.value = true;
    },
    hide() {
      shown.value = false;
    }
  };
  return result;
}
function destroyTooltip(el2) {
  if (el2.$_popper) {
    const index2 = directives.value.indexOf(el2.$_popper.item);
    if (index2 !== -1)
      directives.value.splice(index2, 1);
    delete el2.$_popper;
    delete el2.$_popperOldShown;
    delete el2.$_popperMountTarget;
  }
  if (el2.classList) {
    el2.classList.remove(TARGET_CLASS);
  }
}
function bind(el2, { value, modifiers }) {
  const options2 = getOptions(el2, value, modifiers);
  if (!options2.content || getDefaultConfig(options2.theme || "tooltip", "disabled")) {
    destroyTooltip(el2);
  } else {
    let directive;
    if (el2.$_popper) {
      directive = el2.$_popper;
      directive.options.value = options2;
    } else {
      directive = createTooltip(el2, value, modifiers);
    }
    if (typeof value.shown !== "undefined" && value.shown !== el2.$_popperOldShown) {
      el2.$_popperOldShown = value.shown;
      value.shown ? directive.show() : directive.hide();
    }
  }
}
var PrivateVTooltip = {
  beforeMount: bind,
  updated: bind,
  beforeUnmount(el2) {
    destroyTooltip(el2);
  }
};
const VTooltip = PrivateVTooltip;
const Dropdown = _sfc_main$3$1;
const _hoisted_1$9 = { class: "htw-p-2 hover:htw-bg-primary-100 dark:hover:htw-bg-primary-800 htw-flex htw-gap-2 htw-flex-wrap" };
const _hoisted_2$7 = { class: "htw-w-28 htw-whitespace-nowrap htw-text-ellipsis htw-overflow-hidden htw-shrink-0" };
const _hoisted_3$6 = { class: "htw-grow htw-flex htw-items-center htw-gap-1" };
const _hoisted_4$4 = { class: "htw-block htw-grow" };
const __default__$c = {
  name: "HstWrapper"
};
const _sfc_main$c = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$c), {
  props: {
    title: null
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", _hoisted_1$9, [
        withDirectives((openBlock(), createElementBlock("span", _hoisted_2$7, [
          createTextVNode(toDisplayString(__props.title), 1)
        ])), [
          [unref(VTooltip), {
            content: __props.title,
            placement: "left",
            distance: 12
          }]
        ]),
        createBaseVNode("span", _hoisted_3$6, [
          createBaseVNode("span", _hoisted_4$4, [
            renderSlot(_ctx.$slots, "default")
          ]),
          renderSlot(_ctx.$slots, "actions")
        ])
      ]);
    };
  }
}));
const _hoisted_1$8 = { class: "htw-text-white htw-w-[16px] htw-h-[16px] htw-relative" };
const _hoisted_2$6 = {
  width: "16",
  height: "16",
  viewBox: "0 0 24 24",
  class: "htw-relative htw-z-10"
};
const _hoisted_3$5 = ["stroke-dasharray", "stroke-dashoffset"];
const __default__$b = {
  name: "HstCheckbox"
};
const _sfc_main$b = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$b), {
  props: {
    modelValue: { type: Boolean },
    title: null
  },
  emits: {
    "update:modelValue": (newValue) => true
  },
  setup(__props, { emit: emit2 }) {
    const props = __props;
    function toggle() {
      emit2("update:modelValue", !props.modelValue);
      animationEnabled.value = true;
    }
    const path2 = ref();
    const dasharray = ref(0);
    const progress = computed(() => props.modelValue ? 1 : 0);
    const dashoffset = computed(() => (1 - progress.value) * dasharray.value);
    const animationEnabled = ref(false);
    watch(path2, () => {
      var _a2, _b, _c;
      dasharray.value = (_c = (_b = (_a2 = path2.value).getTotalLength) == null ? void 0 : _b.call(_a2)) != null ? _c : 21.21;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        role: "checkbox",
        tabindex: "0",
        class: "htw-cursor-pointer htw-items-center",
        title: __props.title,
        onClick: _cache[0] || (_cache[0] = ($event) => toggle()),
        onKeydown: [
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => toggle(), ["prevent"]), ["enter"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => toggle(), ["prevent"]), ["space"]))
        ]
      }, {
        actions: withCtx(() => [
          renderSlot(_ctx.$slots, "actions")
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$8, [
            createBaseVNode("div", {
              class: normalizeClass(["htw-border htw-border-solid group-active:htw-bg-gray-500/20 htw-rounded-sm htw-box-border htw-absolute htw-inset-0 htw-transition-border htw-duration-150 htw-ease-out", [
                __props.modelValue ? "htw-border-primary-500 htw-border-8" : "htw-border-black/25 dark:htw-border-white/25 htw-delay-150"
              ]])
            }, null, 2),
            (openBlock(), createElementBlock("svg", _hoisted_2$6, [
              createBaseVNode("path", {
                ref_key: "path",
                ref: path2,
                d: "m 4 12 l 5 5 l 10 -10",
                fill: "none",
                class: normalizeClass(["htw-stroke-white htw-stroke-2 htw-duration-200 htw-ease-in-out", [
                  animationEnabled.value ? "htw-transition-all" : "htw-transition-none",
                  {
                    "htw-delay-150": __props.modelValue
                  }
                ]]),
                "stroke-dasharray": dasharray.value,
                "stroke-dashoffset": unref(dashoffset)
              }, null, 10, _hoisted_3$5)
            ]))
          ])
        ]),
        _: 3
      }, 8, ["title"]);
    };
  }
}));
const _hoisted_1$7 = ["value"];
const __default__$a = {
  name: "HstText"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$a), {
  props: {
    title: null,
    modelValue: null
  },
  emits: {
    "update:modelValue": (newValue) => true
  },
  setup(__props, { emit: emit2 }) {
    const input = ref();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        title: __props.title,
        class: normalizeClass(["htw-cursor-text htw-items-center", _ctx.$attrs.class]),
        style: normalizeStyle(_ctx.$attrs.style),
        onClick: _cache[1] || (_cache[1] = ($event) => input.value.focus())
      }, {
        actions: withCtx(() => [
          renderSlot(_ctx.$slots, "actions")
        ]),
        default: withCtx(() => [
          createBaseVNode("input", mergeProps({
            ref_key: "input",
            ref: input
          }, __spreadProps(__spreadValues$2({}, _ctx.$attrs), { class: null, style: null }), {
            type: "text",
            value: __props.modelValue,
            class: "htw-text-inherit htw-bg-transparent htw-w-full htw-outline-none htw-px-2 htw-py-1 -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 focus:htw-border-primary-500 dark:focus:htw-border-primary-500 htw-rounded-sm",
            onInput: _cache[0] || (_cache[0] = ($event) => emit2("update:modelValue", $event.target.value))
          }), null, 16, _hoisted_1$7)
        ]),
        _: 3
      }, 8, ["title", "class", "style"]);
    };
  }
}));
const __default__$9 = {
  name: "HstNumber",
  inheritAttrs: false
};
const _sfc_main$9 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$9), {
  props: {
    title: null,
    modelValue: null
  },
  emits: {
    "update:modelValue": (newValue) => true
  },
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const numberModel = computed({
      get: () => props.modelValue,
      set: (value) => {
        emit2("update:modelValue", value);
      }
    });
    const input = ref();
    function focusAndSelect() {
      input.value.focus();
      input.value.select();
    }
    const isDragging = ref(false);
    let startX;
    let startValue;
    function onMouseDown(event) {
      isDragging.value = true;
      startX = event.clientX;
      startValue = numberModel.value;
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", stopDragging);
    }
    function onMouseMove(event) {
      let step = parseFloat(input.value.step);
      if (isNaN(step)) {
        step = 1;
      }
      numberModel.value = startValue + Math.round((event.clientX - startX) / 10 / step) * step;
    }
    function stopDragging() {
      isDragging.value = false;
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", stopDragging);
    }
    onUnmounted(() => {
      stopDragging();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        class: normalizeClass(["htw-cursor-ew-resize htw-items-center", [
          _ctx.$attrs.class,
          { "htw-select-none": isDragging.value }
        ]]),
        title: __props.title,
        style: normalizeStyle(_ctx.$attrs.style),
        onClick: focusAndSelect,
        onMousedown: onMouseDown
      }, {
        actions: withCtx(() => [
          renderSlot(_ctx.$slots, "actions")
        ]),
        default: withCtx(() => [
          withDirectives(createBaseVNode("input", mergeProps({
            ref_key: "input",
            ref: input
          }, __spreadProps(__spreadValues$2({}, _ctx.$attrs), { class: null, style: null }), {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(numberModel) ? numberModel.value = $event : null),
            type: "number",
            class: [{
              "htw-select-none": isDragging.value
            }, "htw-text-inherit htw-bg-transparent htw-w-full htw-outline-none htw-pl-2 htw-py-1 -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 focus:htw-border-primary-500 dark:focus:htw-border-primary-500 htw-rounded-sm htw-cursor-ew-resize"]
          }), null, 16), [
            [
              vModelText,
              unref(numberModel),
              void 0,
              { number: true }
            ]
          ])
        ]),
        _: 3
      }, 8, ["title", "class", "style"]);
    };
  }
}));
const _hoisted_1$6 = { class: "htw-relative htw-w-full htw-flex htw-items-center" };
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("div", { class: "htw-absolute htw-inset-0 htw-flex htw-items-center" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "htw-border htw-border-black/25 dark:htw-border-white/25 htw-h-1 htw-w-full htw-rounded-full" })
], -1);
const __default__$8 = {
  name: "HstSlider",
  inheritAttrs: false
};
const _sfc_main$8 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$8), {
  props: {
    title: null,
    modelValue: null,
    min: null,
    max: null
  },
  emits: {
    "update:modelValue": (newValue) => true
  },
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const showTooltip = ref(false);
    const input = ref(null);
    const numberModel = computed({
      get: () => props.modelValue,
      set: (value) => {
        emit2("update:modelValue", value);
      }
    });
    const percentage = computed(() => {
      return (props.modelValue - props.min) / (props.max - props.min);
    });
    const tooltipStyle = computed(() => {
      const gap2 = 8;
      if (input.value) {
        const position = gap2 + (input.value.clientWidth - 2 * gap2) * percentage.value;
        return {
          left: position + "px"
        };
      }
      return {};
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        class: normalizeClass(["htw-items-center", _ctx.$attrs.class]),
        title: __props.title,
        style: normalizeStyle(_ctx.$attrs.style)
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$6, [
            _hoisted_2$5,
            withDirectives(createBaseVNode("input", mergeProps({
              ref_key: "input",
              ref: input,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(numberModel) ? numberModel.value = $event : null),
              class: "htw-range-input htw-appearance-none htw-border-0 htw-bg-transparent htw-cursor-pointer htw-relative htw-w-full htw-m-0 htw-text-gray-700",
              type: "range"
            }, __spreadProps(__spreadValues$2({}, _ctx.$attrs), { class: null, style: null }), {
              onMouseover: _cache[1] || (_cache[1] = ($event) => showTooltip.value = true),
              onMouseleave: _cache[2] || (_cache[2] = ($event) => showTooltip.value = false)
            }), null, 16), [
              [
                vModelText,
                unref(numberModel),
                void 0,
                { number: true }
              ]
            ]),
            showTooltip.value ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              class: "htw-absolute",
              style: normalizeStyle(unref(tooltipStyle))
            }, null, 4)), [
              [unref(VTooltip), { content: __props.modelValue.toString(), shown: true, distance: 16, delay: 0 }]
            ]) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }, 8, ["title", "class", "style"]);
    };
  }
}));
const _hoisted_1$5 = ["value"];
const __default__$7 = {
  name: "HstTextarea",
  inheritAttrs: false
};
const _sfc_main$7 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$7), {
  props: {
    title: null,
    modelValue: null
  },
  emits: {
    "update:modelValue": (newValue) => true
  },
  setup(__props, { emit: emit2 }) {
    const input = ref();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        title: __props.title,
        class: normalizeClass(["htw-cursor-text", _ctx.$attrs.class]),
        style: normalizeStyle(_ctx.$attrs.style),
        onClick: _cache[1] || (_cache[1] = ($event) => input.value.focus())
      }, {
        actions: withCtx(() => [
          renderSlot(_ctx.$slots, "actions")
        ]),
        default: withCtx(() => [
          createBaseVNode("textarea", mergeProps({
            ref_key: "input",
            ref: input
          }, __spreadProps(__spreadValues$2({}, _ctx.$attrs), { class: null, style: null }), {
            value: __props.modelValue,
            class: "htw-text-inherit htw-bg-transparent htw-w-full htw-outline-none htw-px-2 htw-py-1 -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 focus:htw-border-primary-500 dark:focus:htw-border-primary-500 htw-rounded-sm htw-box-border htw-resize-y htw-min-h-[26px]",
            onInput: _cache[0] || (_cache[0] = ($event) => emit2("update:modelValue", $event.target.value))
          }), null, 16, _hoisted_1$5)
        ]),
        _: 3
      }, 8, ["title", "class", "style"]);
    };
  }
}));
const matchName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
const iconDefaults = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16,
  rotate: 0,
  vFlip: false,
  hFlip: false
});
function fullIcon(data2) {
  return __spreadValues$2(__spreadValues$2({}, iconDefaults), data2);
}
const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIcon(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIcon(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIcon(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIcon = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchName)) && icon.name.match(matchName));
};
function mergeIconData(icon, alias) {
  const result = __spreadValues$2({}, icon);
  for (const key in iconDefaults) {
    const prop2 = key;
    if (alias[prop2] !== void 0) {
      const value = alias[prop2];
      if (result[prop2] === void 0) {
        result[prop2] = value;
        continue;
      }
      switch (prop2) {
        case "rotate":
          result[prop2] = (result[prop2] + value) % 4;
          break;
        case "hFlip":
        case "vFlip":
          result[prop2] = value !== result[prop2];
          break;
        default:
          result[prop2] = value;
      }
    }
  }
  return result;
}
function getIconData$1(data2, name, full = false) {
  function getIcon(name2, iteration) {
    if (data2.icons[name2] !== void 0) {
      return Object.assign({}, data2.icons[name2]);
    }
    if (iteration > 5) {
      return null;
    }
    const aliases2 = data2.aliases;
    if (aliases2 && aliases2[name2] !== void 0) {
      const item = aliases2[name2];
      const result2 = getIcon(item.parent, iteration + 1);
      if (result2) {
        return mergeIconData(result2, item);
      }
      return result2;
    }
    const chars = data2.chars;
    if (!iteration && chars && chars[name2] !== void 0) {
      return getIcon(chars[name2], iteration + 1);
    }
    return null;
  }
  const result = getIcon(name, 0);
  if (result) {
    for (const key in iconDefaults) {
      if (result[key] === void 0 && data2[key] !== void 0) {
        result[key] = data2[key];
      }
    }
  }
  return result && full ? fullIcon(result) : result;
}
function isVariation(item) {
  for (const key in iconDefaults) {
    if (item[key] !== void 0) {
      return true;
    }
  }
  return false;
}
function parseIconSet(data2, callback, options) {
  options = options || {};
  const names = [];
  if (typeof data2 !== "object" || typeof data2.icons !== "object") {
    return names;
  }
  if (data2.not_found instanceof Array) {
    data2.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const icons = data2.icons;
  Object.keys(icons).forEach((name) => {
    const iconData = getIconData$1(data2, name, true);
    if (iconData) {
      callback(name, iconData);
      names.push(name);
    }
  });
  const parseAliases = options.aliases || "all";
  if (parseAliases !== "none" && typeof data2.aliases === "object") {
    const aliases2 = data2.aliases;
    Object.keys(aliases2).forEach((name) => {
      if (parseAliases === "variations" && isVariation(aliases2[name])) {
        return;
      }
      const iconData = getIconData$1(data2, name, true);
      if (iconData) {
        callback(name, iconData);
        names.push(name);
      }
    });
  }
  return names;
}
const optionalProperties = {
  provider: "string",
  aliases: "object",
  not_found: "object"
};
for (const prop2 in iconDefaults) {
  optionalProperties[prop2] = typeof iconDefaults[prop2];
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data2 = obj;
  if (typeof data2.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  for (const prop2 in optionalProperties) {
    if (obj[prop2] !== void 0 && typeof obj[prop2] !== optionalProperties[prop2]) {
      return null;
    }
  }
  const icons = data2.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (!name.match(matchName) || typeof icon.body !== "string") {
      return null;
    }
    for (const prop2 in iconDefaults) {
      if (icon[prop2] !== void 0 && typeof icon[prop2] !== typeof iconDefaults[prop2]) {
        return null;
      }
    }
  }
  const aliases2 = data2.aliases;
  if (aliases2) {
    for (const name in aliases2) {
      const icon = aliases2[name];
      const parent = icon.parent;
      if (!name.match(matchName) || typeof parent !== "string" || !icons[parent] && !aliases2[parent]) {
        return null;
      }
      for (const prop2 in iconDefaults) {
        if (icon[prop2] !== void 0 && typeof icon[prop2] !== typeof iconDefaults[prop2]) {
          return null;
        }
      }
    }
  }
  return data2;
}
const storageVersion = 1;
let storage$1 = /* @__PURE__ */ Object.create(null);
try {
  const w2 = window || self;
  if (w2 && w2._iconifyStorage.version === storageVersion) {
    storage$1 = w2._iconifyStorage.storage;
  }
} catch (err) {
}
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ Object.create(null)
  };
}
function getStorage(provider, prefix) {
  if (storage$1[provider] === void 0) {
    storage$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerStorage = storage$1[provider];
  if (providerStorage[prefix] === void 0) {
    providerStorage[prefix] = newStorage(provider, prefix);
  }
  return providerStorage[prefix];
}
function addIconSet(storage2, data2) {
  if (!quicklyValidateIconSet(data2)) {
    return [];
  }
  const t2 = Date.now();
  return parseIconSet(data2, (name, icon) => {
    if (icon) {
      storage2.icons[name] = icon;
    } else {
      storage2.missing[name] = t2;
    }
  });
}
function addIconToStorage(storage2, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage2.icons[name] = Object.freeze(fullIcon(icon));
      return true;
    }
  } catch (err) {
  }
  return false;
}
function getIconFromStorage(storage2, name) {
  const value = storage2.icons[name];
  return value === void 0 ? null : value;
}
let simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  return icon ? getIconFromStorage(getStorage(icon.provider, icon.prefix), icon.name) : null;
}
function addIcon(name, data2) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage2 = getStorage(icon.provider, icon.prefix);
  return addIconToStorage(storage2, icon.name, data2);
}
function addCollection(data2, provider) {
  if (typeof data2 !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = typeof data2.provider === "string" ? data2.provider : "";
  }
  if (simpleNames && provider === "" && (typeof data2.prefix !== "string" || data2.prefix === "")) {
    let added = false;
    if (quicklyValidateIconSet(data2)) {
      data2.prefix = "";
      parseIconSet(data2, (name, icon) => {
        if (icon && addIcon(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  if (typeof data2.prefix !== "string" || !validateIcon({
    provider,
    prefix: data2.prefix,
    name: "a"
  })) {
    return false;
  }
  const storage2 = getStorage(provider, data2.prefix);
  return !!addIconSet(storage2, data2);
}
const defaults$1 = Object.freeze({
  inline: false,
  width: null,
  height: null,
  hAlign: "center",
  vAlign: "middle",
  slice: false,
  hFlip: false,
  vFlip: false,
  rotate: 0
});
function mergeCustomisations(defaults2, item) {
  const result = {};
  for (const key in defaults2) {
    const attr = key;
    result[attr] = defaults2[attr];
    if (item[attr] === void 0) {
      continue;
    }
    const value = item[attr];
    switch (attr) {
      case "inline":
      case "slice":
        if (typeof value === "boolean") {
          result[attr] = value;
        }
        break;
      case "hFlip":
      case "vFlip":
        if (value === true) {
          result[attr] = !result[attr];
        }
        break;
      case "hAlign":
      case "vAlign":
        if (typeof value === "string" && value !== "") {
          result[attr] = value;
        }
        break;
      case "width":
      case "height":
        if (typeof value === "string" && value !== "" || typeof value === "number" && value || value === null) {
          result[attr] = value;
        }
        break;
      case "rotate":
        if (typeof value === "number") {
          result[attr] += value;
        }
        break;
    }
  }
  return result;
}
const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size2, ratio2, precision) {
  if (ratio2 === 1) {
    return size2;
  }
  precision = precision === void 0 ? 100 : precision;
  if (typeof size2 === "number") {
    return Math.ceil(size2 * ratio2 * precision) / precision;
  }
  if (typeof size2 !== "string") {
    return size2;
  }
  const oldParts = size2.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size2;
  }
  const newParts = [];
  let code3 = oldParts.shift();
  let isNumber2 = unitsTest.test(code3);
  while (true) {
    if (isNumber2) {
      const num2 = parseFloat(code3);
      if (isNaN(num2)) {
        newParts.push(code3);
      } else {
        newParts.push(Math.ceil(num2 * ratio2 * precision) / precision);
      }
    } else {
      newParts.push(code3);
    }
    code3 = oldParts.shift();
    if (code3 === void 0) {
      return newParts.join("");
    }
    isNumber2 = !isNumber2;
  }
}
function preserveAspectRatio(props) {
  let result = "";
  switch (props.hAlign) {
    case "left":
      result += "xMin";
      break;
    case "right":
      result += "xMax";
      break;
    default:
      result += "xMid";
  }
  switch (props.vAlign) {
    case "top":
      result += "YMin";
      break;
    case "bottom":
      result += "YMax";
      break;
    default:
      result += "YMid";
  }
  result += props.slice ? " slice" : " meet";
  return result;
}
function iconToSVG(icon, customisations) {
  const box = {
    left: icon.left,
    top: icon.top,
    width: icon.width,
    height: icon.height
  };
  let body = icon.body;
  [icon, customisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push("translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")");
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push("translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")");
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift("rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
      case 2:
        transformations.unshift("rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")");
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift("rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== 0 || box.top !== 0) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
    }
  });
  let width, height;
  if (customisations.width === null && customisations.height === null) {
    height = "1em";
    width = calculateSize(height, box.width / box.height);
  } else if (customisations.width !== null && customisations.height !== null) {
    width = customisations.width;
    height = customisations.height;
  } else if (customisations.height !== null) {
    height = customisations.height;
    width = calculateSize(height, box.width / box.height);
  } else {
    width = customisations.width;
    height = calculateSize(width, box.height / box.width);
  }
  if (width === "auto") {
    width = box.width;
  }
  if (height === "auto") {
    height = box.height;
  }
  width = typeof width === "string" ? width : width.toString() + "";
  height = typeof height === "string" ? height : height.toString() + "";
  const result = {
    attributes: {
      width,
      height,
      preserveAspectRatio: preserveAspectRatio(customisations),
      viewBox: box.left.toString() + " " + box.top.toString() + " " + box.width.toString() + " " + box.height.toString()
    },
    body
  };
  if (customisations.inline) {
    result.inline = true;
  }
  return result;
}
const regex$5 = /\sid="(\S+)"/g;
const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match5;
  while (match5 = regex$5.exec(body)) {
    ids.push(match5[1]);
  }
  if (!ids.length) {
    return body;
  }
  ids.forEach((id2) => {
    const newID = typeof prefix === "function" ? prefix(id2) : prefix + (counter++).toString();
    const escapedID = id2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"), "$1" + newID + "$3");
  });
  return body;
}
const storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}
function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    resources,
    path: source.path === void 0 ? "/" : source.path,
    maxURL: source.maxURL ? source.maxURL : 500,
    rotate: source.rotate ? source.rotate : 750,
    timeout: source.timeout ? source.timeout : 5e3,
    random: source.random === true,
    index: source.index ? source.index : 0,
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
const configStorage = /* @__PURE__ */ Object.create(null);
const fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
const fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider(provider, customConfig) {
  const config2 = createAPIConfig(customConfig);
  if (config2 === null) {
    return false;
  }
  configStorage[provider] = config2;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
const mergeParams = (base2, params) => {
  let result = base2, hasParams = result.indexOf("?") !== -1;
  function paramToString(value) {
    switch (typeof value) {
      case "boolean":
        return value ? "true" : "false";
      case "number":
        return encodeURIComponent(value);
      case "string":
        return encodeURIComponent(value);
      default:
        throw new Error("Invalid parameter");
    }
  }
  Object.keys(params).forEach((key) => {
    let value;
    try {
      value = paramToString(params[key]);
    } catch (err) {
      return;
    }
    result += (hasParams ? "&" : "?") + encodeURIComponent(key) + "=" + value;
    hasParams = true;
  });
  return result;
};
const maxLengthCache = {};
const pathCache = {};
const detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
  return null;
};
let fetchModule = detectFetch();
function calculateMaxLength(provider, prefix) {
  const config2 = getAPIConfig(provider);
  if (!config2) {
    return 0;
  }
  let result;
  if (!config2.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config2.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = mergeParams(prefix + ".json", {
      icons: ""
    });
    result = config2.maxURL - maxHostLength - config2.path.length - url.length;
  }
  const cacheKey = provider + ":" + prefix;
  pathCache[provider] = config2.path;
  maxLengthCache[cacheKey] = result;
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
const prepare = (provider, prefix, icons) => {
  const results = [];
  let maxLength = maxLengthCache[prefix];
  if (maxLength === void 0) {
    maxLength = calculateMaxLength(provider, prefix);
  }
  const type = "icons";
  let item = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index2) => {
    length += name.length + 1;
    if (length >= maxLength && index2 > 0) {
      results.push(item);
      item = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    if (pathCache[provider] === void 0) {
      const config2 = getAPIConfig(provider);
      if (!config2) {
        return "/";
      }
      pathCache[provider] = config2.path;
    }
    return pathCache[provider];
  }
  return "/";
}
const send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path2 = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      path2 += mergeParams(prefix + ".json", {
        icons: iconsList
      });
      break;
    }
    case "custom": {
      const uri = params.uri;
      path2 += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path2).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data2) => {
    if (typeof data2 !== "object" || data2 === null) {
      setTimeout(() => {
        callback("next", defaultError);
      });
      return;
    }
    setTimeout(() => {
      callback("success", data2);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
const fetchAPIModule = {
  prepare,
  send
};
function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage2 = /* @__PURE__ */ Object.create(null);
  icons.sort((a2, b2) => {
    if (a2.provider !== b2.provider) {
      return a2.provider.localeCompare(b2.provider);
    }
    if (a2.prefix !== b2.prefix) {
      return a2.prefix.localeCompare(b2.prefix);
    }
    return a2.name.localeCompare(b2.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    if (storage2[provider] === void 0) {
      storage2[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerStorage = storage2[provider];
    if (providerStorage[prefix] === void 0) {
      providerStorage[prefix] = getStorage(provider, prefix);
    }
    const localStorage2 = providerStorage[prefix];
    let list3;
    if (localStorage2.icons[name] !== void 0) {
      list3 = result.loaded;
    } else if (prefix === "" || localStorage2.missing[name] !== void 0) {
      list3 = result.missing;
    } else {
      list3 = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list3.push(item);
  });
  return result;
}
const callbacks = /* @__PURE__ */ Object.create(null);
const pendingUpdates = /* @__PURE__ */ Object.create(null);
function removeCallback(sources, id2) {
  sources.forEach((source) => {
    const provider = source.provider;
    if (callbacks[provider] === void 0) {
      return;
    }
    const providerCallbacks = callbacks[provider];
    const prefix = source.prefix;
    const items = providerCallbacks[prefix];
    if (items) {
      providerCallbacks[prefix] = items.filter((row) => row.id !== id2);
    }
  });
}
function updateCallbacks(provider, prefix) {
  if (pendingUpdates[provider] === void 0) {
    pendingUpdates[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerPendingUpdates = pendingUpdates[provider];
  if (!providerPendingUpdates[prefix]) {
    providerPendingUpdates[prefix] = true;
    setTimeout(() => {
      providerPendingUpdates[prefix] = false;
      if (callbacks[provider] === void 0 || callbacks[provider][prefix] === void 0) {
        return;
      }
      const items = callbacks[provider][prefix].slice(0);
      if (!items.length) {
        return;
      }
      const storage2 = getStorage(provider, prefix);
      let hasPending = false;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage2.icons[name] !== void 0) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage2.missing[name] !== void 0) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([
              {
                provider,
                prefix
              }
            ], item.id);
          }
          item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);
        }
      });
    });
  }
}
let idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id2 = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id2);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id: id2,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((source) => {
    const provider = source.provider;
    const prefix = source.prefix;
    if (callbacks[provider] === void 0) {
      callbacks[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerCallbacks = callbacks[provider];
    if (providerCallbacks[prefix] === void 0) {
      providerCallbacks[prefix] = [];
    }
    providerCallbacks[prefix].push(item);
  });
  return abort;
}
function listToIcons(list3, validate = true, simpleNames2 = false) {
  const result = [];
  list3.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, false, simpleNames2) : item;
    if (!validate || validateIcon(icon, simpleNames2)) {
      result.push({
        provider: icon.provider,
        prefix: icon.prefix,
        name: icon.name
      });
    }
  });
  return result;
}
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function sendQuery(config2, payload, query, done) {
  const resourcesCount = config2.resources.length;
  const startIndex = config2.random ? Math.floor(Math.random() * resourcesCount) : config2.index;
  let resources;
  if (config2.random) {
    let list3 = config2.resources.slice(0);
    resources = [];
    while (list3.length > 1) {
      const nextIndex = Math.floor(Math.random() * list3.length);
      resources.push(list3[nextIndex]);
      list3 = list3.slice(0, nextIndex).concat(list3.slice(nextIndex + 1));
    }
    resources = resources.concat(list3);
  } else {
    resources = config2.resources.slice(startIndex).concat(config2.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer2 = null;
  let queue2 = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function subscribe2(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue2.length,
      subscribe: subscribe2,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function moduleResponse(item, response, data2) {
    const isError = response !== "success";
    queue2 = queue2.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config2.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data2;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data2;
      if (!queue2.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config2.random) {
      const index2 = config2.resources.indexOf(item.resource);
      if (index2 !== -1 && index2 !== config2.index) {
        config2.index = index2;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data2);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue2.length) {
        timer2 = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config2.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data2) => {
        moduleResponse(item, status2, data2);
      }
    };
    queue2.push(item);
    queriesSent++;
    timer2 = setTimeout(execNext, config2.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}
function setConfig(config2) {
  if (typeof config2 !== "object" || typeof config2.resources !== "object" || !(config2.resources instanceof Array) || !config2.resources.length) {
    throw new Error("Invalid Reduncancy configuration");
  }
  const newConfig = /* @__PURE__ */ Object.create(null);
  let key;
  for (key in defaultConfig) {
    if (config2[key] !== void 0) {
      newConfig[key] = config2[key];
    } else {
      newConfig[key] = defaultConfig[key];
    }
  }
  return newConfig;
}
function initRedundancy(cfg) {
  const config2 = setConfig(cfg);
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(config2, payload, queryCallback, (data2, error2) => {
      cleanup();
      if (doneCallback) {
        doneCallback(data2, error2);
      }
    });
    queries.push(query2);
    return query2;
  }
  function find2(callback) {
    const result = queries.find((value) => {
      return callback(value);
    });
    return result !== void 0 ? result : null;
  }
  const instance = {
    query,
    find: find2,
    setIndex: (index2) => {
      config2.index = index2;
    },
    getIndex: () => config2.index,
    cleanup
  };
  return instance;
}
function emptyCallback$1() {
}
const redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (redundancyCache[provider] === void 0) {
    const config2 = getAPIConfig(provider);
    if (!config2) {
      return;
    }
    const redundancy = initRedundancy(config2);
    const cachedReundancy = {
      config: config2,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target2, query, callback) {
  let redundancy;
  let send2;
  if (typeof target2 === "string") {
    const api = getAPIModule(target2);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send2 = api.send;
    const cached = getRedundancyCache(target2);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config2 = createAPIConfig(target2);
    if (config2) {
      redundancy = initRedundancy(config2);
      const moduleKey = target2.resources ? target2.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send2 = api.send;
      }
    }
  }
  if (!redundancy || !send2) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send2, callback)().abort;
}
const cache$1 = {};
function emptyCallback() {
}
const pendingIcons = /* @__PURE__ */ Object.create(null);
const iconsToLoad = /* @__PURE__ */ Object.create(null);
const loaderFlags = /* @__PURE__ */ Object.create(null);
const queueFlags = /* @__PURE__ */ Object.create(null);
function loadedNewIcons(provider, prefix) {
  if (loaderFlags[provider] === void 0) {
    loaderFlags[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerLoaderFlags = loaderFlags[provider];
  if (!providerLoaderFlags[prefix]) {
    providerLoaderFlags[prefix] = true;
    setTimeout(() => {
      providerLoaderFlags[prefix] = false;
      updateCallbacks(provider, prefix);
    });
  }
}
const errorsCache = /* @__PURE__ */ Object.create(null);
function loadNewIcons(provider, prefix, icons) {
  function err() {
    const key = (provider === "" ? "" : "@" + provider + ":") + prefix;
    const time = Math.floor(Date.now() / 6e4);
    if (errorsCache[key] < time) {
      errorsCache[key] = time;
      console.error('Unable to retrieve icons for "' + key + '" because API is not configured properly.');
    }
  }
  if (iconsToLoad[provider] === void 0) {
    iconsToLoad[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerIconsToLoad = iconsToLoad[provider];
  if (queueFlags[provider] === void 0) {
    queueFlags[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerQueueFlags = queueFlags[provider];
  if (pendingIcons[provider] === void 0) {
    pendingIcons[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerPendingIcons = pendingIcons[provider];
  if (providerIconsToLoad[prefix] === void 0) {
    providerIconsToLoad[prefix] = icons;
  } else {
    providerIconsToLoad[prefix] = providerIconsToLoad[prefix].concat(icons).sort();
  }
  if (!providerQueueFlags[prefix]) {
    providerQueueFlags[prefix] = true;
    setTimeout(() => {
      providerQueueFlags[prefix] = false;
      const icons2 = providerIconsToLoad[prefix];
      delete providerIconsToLoad[prefix];
      const api = getAPIModule(provider);
      if (!api) {
        err();
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data2, error2) => {
          const storage2 = getStorage(provider, prefix);
          if (typeof data2 !== "object") {
            if (error2 !== 404) {
              return;
            }
            const t2 = Date.now();
            item.icons.forEach((name) => {
              storage2.missing[name] = t2;
            });
          } else {
            try {
              const parsed = addIconSet(storage2, data2);
              if (!parsed.length) {
                return;
              }
              const pending = providerPendingIcons[prefix];
              parsed.forEach((name) => {
                delete pending[name];
              });
              if (cache$1.store) {
                cache$1.store(provider, data2);
              }
            } catch (err2) {
              console.error(err2);
            }
          }
          loadedNewIcons(provider, prefix);
        });
      });
    });
  }
}
const loadIcons = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const provider = icon.provider;
    const prefix = icon.prefix;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push({
      provider,
      prefix
    });
    if (pendingIcons[provider] === void 0) {
      pendingIcons[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerPendingIcons = pendingIcons[provider];
    if (providerPendingIcons[prefix] === void 0) {
      providerPendingIcons[prefix] = /* @__PURE__ */ Object.create(null);
    }
    if (newIcons[provider] === void 0) {
      newIcons[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerNewIcons = newIcons[provider];
    if (providerNewIcons[prefix] === void 0) {
      providerNewIcons[prefix] = [];
    }
  });
  const time = Date.now();
  sortedIcons.pending.forEach((icon) => {
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const pendingQueue = pendingIcons[provider][prefix];
    if (pendingQueue[name] === void 0) {
      pendingQueue[name] = time;
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((source) => {
    const provider = source.provider;
    const prefix = source.prefix;
    if (newIcons[provider][prefix].length) {
      loadNewIcons(provider, prefix, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};
const cacheVersion = "iconify2";
const cachePrefix = "iconify";
const countKey = cachePrefix + "-count";
const versionKey = cachePrefix + "-version";
const hour = 36e5;
const cacheExpiration = 168;
const config$2 = {
  local: true,
  session: true
};
let loaded = false;
const count = {
  local: 0,
  session: 0
};
const emptyList = {
  local: [],
  session: []
};
let _window = typeof window === "undefined" ? {} : window;
function getGlobal(key) {
  const attr = key + "Storage";
  try {
    if (_window && _window[attr] && typeof _window[attr].length === "number") {
      return _window[attr];
    }
  } catch (err) {
  }
  config$2[key] = false;
  return null;
}
function setCount(storage2, key, value) {
  try {
    storage2.setItem(countKey, value.toString());
    count[key] = value;
    return true;
  } catch (err) {
    return false;
  }
}
function getCount(storage2) {
  const count2 = storage2.getItem(countKey);
  if (count2) {
    const total = parseInt(count2);
    return total ? total : 0;
  }
  return 0;
}
function initCache(storage2, key) {
  try {
    storage2.setItem(versionKey, cacheVersion);
  } catch (err) {
  }
  setCount(storage2, key, 0);
}
function destroyCache(storage2) {
  try {
    const total = getCount(storage2);
    for (let i2 = 0; i2 < total; i2++) {
      storage2.removeItem(cachePrefix + i2.toString());
    }
  } catch (err) {
  }
}
const loadCache = () => {
  if (loaded) {
    return;
  }
  loaded = true;
  const minTime = Math.floor(Date.now() / hour) - cacheExpiration;
  function load(key) {
    const func = getGlobal(key);
    if (!func) {
      return;
    }
    const getItem = (index2) => {
      const name = cachePrefix + index2.toString();
      const item = func.getItem(name);
      if (typeof item !== "string") {
        return false;
      }
      let valid = true;
      try {
        const data2 = JSON.parse(item);
        if (typeof data2 !== "object" || typeof data2.cached !== "number" || data2.cached < minTime || typeof data2.provider !== "string" || typeof data2.data !== "object" || typeof data2.data.prefix !== "string") {
          valid = false;
        } else {
          const provider = data2.provider;
          const prefix = data2.data.prefix;
          const storage2 = getStorage(provider, prefix);
          valid = addIconSet(storage2, data2.data).length > 0;
        }
      } catch (err) {
        valid = false;
      }
      if (!valid) {
        func.removeItem(name);
      }
      return valid;
    };
    try {
      const version2 = func.getItem(versionKey);
      if (version2 !== cacheVersion) {
        if (version2) {
          destroyCache(func);
        }
        initCache(func, key);
        return;
      }
      let total = getCount(func);
      for (let i2 = total - 1; i2 >= 0; i2--) {
        if (!getItem(i2)) {
          if (i2 === total - 1) {
            total--;
          } else {
            emptyList[key].push(i2);
          }
        }
      }
      setCount(func, key, total);
    } catch (err) {
    }
  }
  for (const key in config$2) {
    load(key);
  }
};
const storeCache = (provider, data2) => {
  if (!loaded) {
    loadCache();
  }
  function store(key) {
    if (!config$2[key]) {
      return false;
    }
    const func = getGlobal(key);
    if (!func) {
      return false;
    }
    let index2 = emptyList[key].shift();
    if (index2 === void 0) {
      index2 = count[key];
      if (!setCount(func, key, index2 + 1)) {
        return false;
      }
    }
    try {
      const item = {
        cached: Math.floor(Date.now() / hour),
        provider,
        data: data2
      };
      func.setItem(cachePrefix + index2.toString(), JSON.stringify(item));
    } catch (err) {
      return false;
    }
    return true;
  }
  if (!Object.keys(data2.icons).length) {
    return;
  }
  if (data2.not_found) {
    data2 = Object.assign({}, data2);
    delete data2.not_found;
  }
  if (!store("local")) {
    store("session");
  }
};
const separator = /[\s,]+/;
function flipFromString(custom, flip2) {
  flip2.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}
function alignmentFromString(custom, align) {
  align.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "left":
      case "center":
      case "right":
        custom.hAlign = value;
        break;
      case "top":
      case "middle":
      case "bottom":
        custom.vAlign = value;
        break;
      case "slice":
      case "crop":
        custom.slice = true;
        break;
      case "meet":
        custom.slice = false;
    }
  });
}
function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num2 = parseInt(value);
    return isNaN(num2) ? 0 : cleanup(num2);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num2 = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num2)) {
        return 0;
      }
      num2 = num2 / split;
      return num2 % 1 === 0 ? cleanup(num2) : 0;
    }
  }
  return defaultValue;
}
const svgDefaults = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  "role": "img"
};
let customisationAliases = {};
["horizontal", "vertical"].forEach((prefix) => {
  ["Align", "Flip"].forEach((suffix) => {
    const attr = prefix.slice(0, 1) + suffix;
    const value = {
      attr,
      boolean: suffix === "Flip"
    };
    customisationAliases[prefix + "-" + suffix.toLowerCase()] = value;
    customisationAliases[prefix.slice(0, 1) + "-" + suffix.toLowerCase()] = value;
    customisationAliases[prefix + suffix] = value;
  });
});
const render = (icon, props) => {
  const customisations = mergeCustomisations(defaults$1, props);
  const componentProps = __spreadValues$2({}, svgDefaults);
  let style2 = typeof props.style === "object" && !(props.style instanceof Array) ? __spreadValues$2({}, props.style) : {};
  for (let key in props) {
    const value = props[key];
    if (value === void 0) {
      continue;
    }
    switch (key) {
      case "icon":
      case "style":
      case "onLoad":
        break;
      case "inline":
      case "hFlip":
      case "vFlip":
        customisations[key] = value === true || value === "true" || value === 1;
        break;
      case "flip":
        if (typeof value === "string") {
          flipFromString(customisations, value);
        }
        break;
      case "align":
        if (typeof value === "string") {
          alignmentFromString(customisations, value);
        }
        break;
      case "color":
        style2.color = value;
        break;
      case "rotate":
        if (typeof value === "string") {
          customisations[key] = rotateFromString(value);
        } else if (typeof value === "number") {
          customisations[key] = value;
        }
        break;
      case "ariaHidden":
      case "aria-hidden":
        if (value !== true && value !== "true") {
          delete componentProps["aria-hidden"];
        }
        break;
      default:
        if (customisationAliases[key] !== void 0) {
          if (customisationAliases[key].boolean && (value === true || value === "true" || value === 1)) {
            customisations[customisationAliases[key].attr] = true;
          } else if (!customisationAliases[key].boolean && typeof value === "string" && value !== "") {
            customisations[customisationAliases[key].attr] = value;
          }
        } else if (defaults$1[key] === void 0) {
          componentProps[key] = value;
        }
    }
  }
  const item = iconToSVG(icon, customisations);
  for (let key in item.attributes) {
    componentProps[key] = item.attributes[key];
  }
  if (item.inline && style2.verticalAlign === void 0 && style2["vertical-align"] === void 0) {
    style2.verticalAlign = "-0.125em";
  }
  let localCounter = 0;
  let id2 = props.id;
  if (typeof id2 === "string") {
    id2 = id2.replace(/-/g, "_");
  }
  componentProps["innerHTML"] = replaceIDs(item.body, id2 ? () => id2 + "ID" + localCounter++ : "iconifyVue");
  if (Object.keys(style2).length > 0) {
    componentProps["style"] = style2;
  }
  return h$2("svg", componentProps);
};
allowSimpleNames(true);
setAPIModule("", fetchAPIModule);
if (typeof document !== "undefined" && typeof window !== "undefined") {
  cache$1.store = storeCache;
  loadCache();
  const _window2 = window;
  if (_window2.IconifyPreload !== void 0) {
    const preload = _window2.IconifyPreload;
    const err = "Invalid IconifyPreload syntax.";
    if (typeof preload === "object" && preload !== null) {
      (preload instanceof Array ? preload : [preload]).forEach((item) => {
        try {
          if (typeof item !== "object" || item === null || item instanceof Array || typeof item.icons !== "object" || typeof item.prefix !== "string" || !addCollection(item)) {
            console.error(err);
          }
        } catch (e2) {
          console.error(err);
        }
      });
    }
  }
  if (_window2.IconifyProviders !== void 0) {
    const providers = _window2.IconifyProviders;
    if (typeof providers === "object" && providers !== null) {
      for (let key in providers) {
        const err = "IconifyProviders[" + key + "] is invalid.";
        try {
          const value = providers[key];
          if (typeof value !== "object" || !value || value.resources === void 0) {
            continue;
          }
          if (!addAPIProvider(key, value)) {
            console.error(err);
          }
        } catch (e2) {
          console.error(err);
        }
      }
    }
  }
}
const emptyIcon = fullIcon({
  body: ""
});
const Icon = defineComponent({
  inheritAttrs: false,
  data() {
    return {
      iconMounted: false,
      counter: 0
    };
  },
  mounted() {
    this._name = "";
    this._loadingIcon = null;
    this.iconMounted = true;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      if (this._loadingIcon) {
        this._loadingIcon.abort();
        this._loadingIcon = null;
      }
    },
    getIcon(icon, onload) {
      if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
        this._name = "";
        this.abortLoading();
        return {
          data: fullIcon(icon)
        };
      }
      let iconName;
      if (typeof icon !== "string" || (iconName = stringToIcon(icon, false, true)) === null) {
        this.abortLoading();
        return null;
      }
      const data2 = getIconData(iconName);
      if (data2 === null) {
        if (!this._loadingIcon || this._loadingIcon.name !== icon) {
          this.abortLoading();
          this._name = "";
          this._loadingIcon = {
            name: icon,
            abort: loadIcons([iconName], () => {
              this.counter++;
            })
          };
        }
        return null;
      }
      this.abortLoading();
      if (this._name !== icon) {
        this._name = icon;
        if (onload) {
          onload(icon);
        }
      }
      const classes = ["iconify"];
      if (iconName.prefix !== "") {
        classes.push("iconify--" + iconName.prefix);
      }
      if (iconName.provider !== "") {
        classes.push("iconify--" + iconName.provider);
      }
      return { data: data2, classes };
    }
  },
  render() {
    this.counter;
    const props = this.$attrs;
    const icon = this.iconMounted ? this.getIcon(props.icon, props.onLoad) : null;
    if (!icon) {
      return render(emptyIcon, props);
    }
    let newProps = props;
    if (icon.classes) {
      newProps = __spreadProps(__spreadValues$2({}, props), {
        class: (typeof props["class"] === "string" ? props["class"] + " " : "") + icon.classes.join(" ")
      });
    }
    return render(icon.data, newProps);
  }
});
const _hoisted_1$4 = { class: "htw-cursor-pointer htw-w-full htw-outline-none htw-px-2 htw-h-[27px] -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 hover:htw-border-primary-500 dark:hover:htw-border-primary-500 htw-rounded-sm htw-flex htw-gap-2 htw-items-center htw-leading-normal" };
const _hoisted_2$4 = { class: "htw-flex-1 htw-truncate" };
const _hoisted_3$4 = { class: "htw-flex htw-flex-col htw-bg-gray-50 dark:htw-bg-gray-700" };
const _hoisted_4$3 = ["onClick"];
const __default__$6 = {
  name: "CustomSelect"
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$6), {
  props: {
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const formattedOptions = computed(() => {
      if (Array.isArray(props.options)) {
        return Object.fromEntries(props.options.map((value) => {
          if (typeof value === "string") {
            return [value, value];
          } else {
            return [value.value, value.label];
          }
        }));
      }
      return props.options;
    });
    const selectedLabel = computed(() => formattedOptions.value[props.modelValue]);
    function selectValue(value, hide) {
      emits("update:modelValue", value);
      hide();
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Dropdown), { "auto-size": "" }, {
        popper: withCtx(({ hide }) => [
          createBaseVNode("div", _hoisted_3$4, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(formattedOptions), (label, value) => {
              return openBlock(), createElementBlock("div", mergeProps(__spreadProps(__spreadValues$2({}, _ctx.$attrs), { class: null, style: null }), {
                key: label,
                class: ["htw-px-2 htw-py-1 htw-cursor-pointer hover:htw-bg-primary-100 dark:hover:htw-bg-primary-700", {
                  "htw-bg-primary-200 dark:htw-bg-primary-800": props.modelValue === value
                }],
                onClick: ($event) => selectValue(value, hide)
              }), toDisplayString(label), 17, _hoisted_4$3);
            }), 128))
          ])
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$4, [
            createBaseVNode("div", _hoisted_2$4, [
              renderSlot(_ctx.$slots, "default", { label: unref(selectedLabel) }, () => [
                createTextVNode(toDisplayString(unref(selectedLabel)), 1)
              ])
            ]),
            createVNode(unref(Icon), {
              icon: "carbon:chevron-sort",
              class: "htw-w-4 htw-h-4 htw-flex-none htw-ml-auto"
            })
          ])
        ]),
        _: 3
      });
    };
  }
}));
const __default__$5 = {
  name: "HstSelect"
};
const _sfc_main$5 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$5), {
  props: {
    title: null,
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emits }) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        title: __props.title,
        class: normalizeClass(["htw-cursor-text htw-items-center", _ctx.$attrs.class]),
        style: normalizeStyle(_ctx.$attrs.style)
      }, {
        actions: withCtx(() => [
          renderSlot(_ctx.$slots, "actions")
        ]),
        default: withCtx(() => [
          createVNode(_sfc_main$6, {
            options: __props.options,
            "model-value": __props.modelValue,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => emits("update:modelValue", $event))
          }, null, 8, ["options", "model-value"])
        ]),
        _: 3
      }, 8, ["title", "class", "style"]);
    };
  }
}));
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
var _a;
const isClient = typeof window !== "undefined";
const isString$3 = (val) => typeof val === "string";
const noop$1 = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function useTimeoutFn(cb, interval2, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer2 = null;
  function clear2() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear2();
  }
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer2 = setTimeout(() => {
      isPending.value = false;
      timer2 = null;
      cb(...args);
    }, unref(interval2));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop);
  return {
    isPending,
    start: start2,
    stop
  };
}
function unrefElement(elRef) {
  var _a2;
  const plain = unref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
const defaultNavigator = isClient ? window.navigator : void 0;
function useEventListener(...args) {
  let target2;
  let event;
  let listener;
  let options;
  if (isString$3(args[0])) {
    [event, listener, options] = args;
    target2 = defaultWindow;
  } else {
    [target2, event, listener, options] = args;
  }
  if (!target2)
    return noop$1;
  let cleanup = noop$1;
  const stopWatch = watch(() => unrefElement(target2), (el2) => {
    cleanup();
    if (!el2)
      return;
    el2.addEventListener(event, listener, options);
    cleanup = () => {
      el2.removeEventListener(event, listener, options);
      cleanup = noop$1;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useClipboard(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read: read2 = false,
    source,
    copiedDuring = 1500
  } = options;
  const events = ["copy", "cut"];
  const isSupported2 = Boolean(navigator2 && "clipboard" in navigator2);
  const text3 = ref("");
  const copied = ref(false);
  const timeout2 = useTimeoutFn(() => copied.value = false, copiedDuring);
  function updateText() {
    navigator2.clipboard.readText().then((value) => {
      text3.value = value;
    });
  }
  if (isSupported2 && read2) {
    for (const event of events)
      useEventListener(event, updateText);
  }
  async function copy2(value = unref(source)) {
    if (isSupported2 && value != null) {
      await navigator2.clipboard.writeText(value);
      text3.value = value;
      copied.value = true;
      timeout2.start();
    }
  }
  return {
    isSupported: isSupported2,
    text: text3,
    copied,
    copy: copy2
  };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
_global[globalKey];
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
const __default__$4 = {
  name: "HstCopyIcon"
};
const _sfc_main$4 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$4), {
  props: {
    content: null
  },
  setup(__props) {
    const props = __props;
    const { copy: copy2, copied } = useClipboard();
    const action = () => copy2(props.content);
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createBlock(unref(Icon), {
        icon: "carbon:copy-file",
        class: "htw-w-4 htw-h-4 htw-opacity-50 hover:htw-opacity-100 hover:htw-text-primary-500 htw-cursor-pointer",
        onClick: _cache[0] || (_cache[0] = ($event) => action())
      }, null, 512)), [
        [unref(VTooltip), {
          content: "Copied!",
          triggers: [],
          shown: unref(copied),
          distance: 12,
          delay: 0
        }]
      ]);
    };
  }
}));
const _hoisted_1$3 = {
  key: 0,
  class: "htw-grid htw-gap-4 htw-grid-cols-[repeat(auto-fill,minmax(200px,1fr))] htw-m-4"
};
const _hoisted_2$3 = ["onMouseenter"];
const _hoisted_3$3 = { class: "htw-flex htw-gap-1" };
const _hoisted_4$2 = { class: "htw-my-0 htw-truncate htw-shrink" };
const _hoisted_5$2 = { class: "htw-flex htw-gap-1" };
const _hoisted_6$1 = { class: "htw-my-0 htw-opacity-50 htw-truncate htw-shrink" };
const __default__$3 = {
  name: "HstColorShades"
};
const _sfc_main$3$2 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$3), {
  props: {
    shades: null,
    getName: null,
    search: null
  },
  setup(__props) {
    const props = __props;
    const shadesWithName = computed(() => {
      const shades = props.shades;
      const getName = props.getName;
      return Object.entries(shades).map(([key, color2]) => {
        const name = getName ? getName(key, color2) : key;
        return {
          key,
          color: color2,
          name
        };
      });
    });
    const displayedShades = computed(() => {
      let list3 = shadesWithName.value;
      if (props.search) {
        const reg2 = new RegExp(props.search, "i");
        list3 = list3.filter(({ name }) => reg2.test(name));
      }
      return list3;
    });
    const hover = ref(null);
    return (_ctx, _cache) => {
      return unref(displayedShades).length ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(displayedShades), (shade) => {
          return openBlock(), createElementBlock("div", {
            key: shade.key,
            class: "htw-flex htw-flex-col htw-gap-2",
            onMouseenter: ($event) => hover.value = shade.key,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hover.value = null)
          }, [
            renderSlot(_ctx.$slots, "default", {
              color: shade.color
            }, () => [
              createBaseVNode("div", {
                class: "htw-rounded-full htw-w-16 htw-h-16",
                style: normalizeStyle({
                  backgroundColor: shade.color
                })
              }, null, 4)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_3$3, [
                withDirectives((openBlock(), createElementBlock("pre", _hoisted_4$2, [
                  createTextVNode(toDisplayString(shade.name), 1)
                ])), [
                  [unref(VTooltip), shade.name.length > 23 ? shade.name : ""]
                ]),
                hover.value === shade.key ? (openBlock(), createBlock(_sfc_main$4, {
                  key: 0,
                  content: shade.name,
                  class: "htw-flex-none"
                }, null, 8, ["content"])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_5$2, [
                withDirectives((openBlock(), createElementBlock("pre", _hoisted_6$1, [
                  createTextVNode(toDisplayString(shade.color), 1)
                ])), [
                  [unref(VTooltip), shade.color.length > 23 ? shade.color : ""]
                ]),
                hover.value === shade.key ? (openBlock(), createBlock(_sfc_main$4, {
                  key: 0,
                  content: shade.color,
                  class: "htw-flex-none"
                }, null, 8, ["content"])) : createCommentVNode("", true)
              ])
            ])
          ], 40, _hoisted_2$3);
        }), 128))
      ])) : createCommentVNode("", true);
    };
  }
}));
const _hoisted_1$2 = ["onMouseenter"];
const _hoisted_2$2 = { class: "htw-mx-4" };
const _hoisted_3$2 = { class: "htw-flex htw-gap-1" };
const _hoisted_4$1 = { class: "htw-my-0 htw-truncate htw-shrink" };
const _hoisted_5$1 = { class: "htw-flex htw-gap-1" };
const _hoisted_6 = { class: "htw-my-0 htw-opacity-50 htw-truncate htw-shrink" };
const __default__$2 = {
  name: "HstTokenList"
};
const _sfc_main$2$1 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$2), {
  props: {
    tokens: null,
    getName: null
  },
  setup(__props) {
    const props = __props;
    const processedTokens = computed(() => {
      const list3 = props.tokens;
      const getName = props.getName;
      return Object.entries(list3).map(([key, value]) => {
        const name = getName ? getName(key, value) : key;
        return {
          key,
          name,
          value: typeof value === "number" ? value.toString() : value
        };
      });
    });
    const hover = ref(null);
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(processedTokens), (token2) => {
        return openBlock(), createElementBlock("div", {
          key: token2.key,
          class: "htw-flex htw-flex-col htw-gap-2 htw-my-8",
          onMouseenter: ($event) => hover.value = token2.key,
          onMouseleave: _cache[0] || (_cache[0] = ($event) => hover.value = null)
        }, [
          renderSlot(_ctx.$slots, "default", { token: token2 }),
          createBaseVNode("div", _hoisted_2$2, [
            createBaseVNode("div", _hoisted_3$2, [
              createBaseVNode("pre", _hoisted_4$1, toDisplayString(token2.name), 1),
              hover.value === token2.key ? (openBlock(), createBlock(_sfc_main$4, {
                key: 0,
                content: token2.name,
                class: "htw-flex-none"
              }, null, 8, ["content"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_5$1, [
              createBaseVNode("pre", _hoisted_6, toDisplayString(token2.value), 1),
              hover.value === token2.key ? (openBlock(), createBlock(_sfc_main$4, {
                key: 0,
                content: typeof token2.value === "string" ? token2.value : JSON.stringify(token2.value),
                class: "htw-flex-none"
              }, null, 8, ["content"])) : createCommentVNode("", true)
            ])
          ])
        ], 40, _hoisted_1$2);
      }), 128);
    };
  }
}));
const _hoisted_1$1 = ["onMouseenter"];
const _hoisted_2$1 = { class: "htw-flex htw-gap-1" };
const _hoisted_3$1 = { class: "htw-my-0 htw-truncate htw-shrink" };
const _hoisted_4 = { class: "htw-flex htw-gap-1" };
const _hoisted_5 = { class: "htw-my-0 htw-opacity-50 htw-truncate htw-shrink" };
const __default__$1 = {
  name: "HstTokenGrid"
};
const _sfc_main$1$1 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__$1), {
  props: {
    tokens: null,
    colSize: { default: 180 },
    getName: { type: Function, default: null }
  },
  setup(__props) {
    const props = __props;
    const processedTokens = computed(() => {
      const list3 = props.tokens;
      const getName = props.getName;
      return Object.entries(list3).map(([key, value]) => {
        const name = getName ? getName(key, value) : key;
        return {
          key,
          name,
          value: typeof value === "number" ? value.toString() : value
        };
      });
    });
    const colSizePx = computed(() => `${props.colSize}px`);
    const hover = ref(null);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "htw-bind-col-size htw-grid htw-gap-4 htw-m-4",
        style: normalizeStyle({
          "--histoire-col-size": unref(colSizePx)
        })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(processedTokens), (token2) => {
          return openBlock(), createElementBlock("div", {
            key: token2.key,
            class: "htw-flex htw-flex-col htw-gap-2",
            onMouseenter: ($event) => hover.value = token2.key,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hover.value = null)
          }, [
            renderSlot(_ctx.$slots, "default", { token: token2 }),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_2$1, [
                withDirectives((openBlock(), createElementBlock("pre", _hoisted_3$1, [
                  createTextVNode(toDisplayString(token2.name), 1)
                ])), [
                  [unref(VTooltip), token2.name.length > __props.colSize / 8 ? token2.name : ""]
                ]),
                hover.value === token2.key ? (openBlock(), createBlock(_sfc_main$4, {
                  key: 0,
                  content: token2.name,
                  class: "htw-flex-none"
                }, null, 8, ["content"])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_4, [
                withDirectives((openBlock(), createElementBlock("pre", _hoisted_5, [
                  createTextVNode(toDisplayString(token2.value), 1)
                ])), [
                  [unref(VTooltip), token2.value.length > __props.colSize / 8 ? token2.value : ""]
                ]),
                hover.value === token2.key ? (openBlock(), createBlock(_sfc_main$4, {
                  key: 0,
                  content: typeof token2.value === "string" ? token2.value : JSON.stringify(token2.value),
                  class: "htw-flex-none"
                }, null, 8, ["content"])) : createCommentVNode("", true)
              ])
            ])
          ], 40, _hoisted_1$1);
        }), 128))
      ], 4);
    };
  }
}));
const _hoisted_1 = { class: "-htw-my-1" };
const _hoisted_2 = ["id", "name", "value", "checked", "onChange"];
const _hoisted_3 = ["for", "onKeydown"];
const __default__ = {
  name: "HstRadio"
};
const _sfc_main$e = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues$2({}, __default__), {
  props: {
    title: null,
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const formattedOptions = computed(() => {
      if (Array.isArray(props.options)) {
        return Object.fromEntries(props.options.map((value) => {
          if (typeof value === "string") {
            return [value, value];
          } else {
            return [value.value, value.label];
          }
        }));
      }
      return props.options;
    });
    ref();
    function selectOption(value) {
      emit2("update:modelValue", value);
      animationEnabled.value = true;
    }
    const animationEnabled = ref(false);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        role: "group",
        title: __props.title,
        class: normalizeClass(["htw-cursor-text", _ctx.$attrs.class]),
        style: normalizeStyle(_ctx.$attrs.style)
      }, {
        actions: withCtx(() => [
          renderSlot(_ctx.$slots, "actions")
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(formattedOptions), (label, value) => {
              return openBlock(), createElementBlock(Fragment, { key: value }, [
                createBaseVNode("input", {
                  id: `${value}-radio`,
                  type: "radio",
                  name: `${value}-radio`,
                  value,
                  checked: value === __props.modelValue,
                  class: "htw-hidden",
                  onChange: ($event) => selectOption(value)
                }, null, 40, _hoisted_2),
                createBaseVNode("label", {
                  tabindex: "0",
                  for: `${value}-radio`,
                  class: "htw-cursor-pointer htw-flex htw-items-center htw-relative htw-py-1 htw-group",
                  onKeydown: [
                    withKeys(withModifiers(($event) => selectOption(value), ["prevent"]), ["enter"]),
                    withKeys(withModifiers(($event) => selectOption(value), ["prevent"]), ["space"])
                  ]
                }, [
                  (openBlock(), createElementBlock("svg", {
                    width: "16",
                    height: "16",
                    viewBox: "-12 -12 24 24",
                    class: normalizeClass(["htw-relative htw-z-10 htw-border htw-border-solid htw-text-inherit htw-rounded-full htw-box-border htw-inset-0 htw-transition-border htw-duration-150 htw-ease-out htw-mr-2 group-hover:htw-border-primary-500", [
                      __props.modelValue === value ? "htw-border-primary-500" : "htw-border-black/25 dark:htw-border-white/25"
                    ]])
                  }, [
                    createBaseVNode("circle", {
                      r: "7",
                      class: normalizeClass(["htw-will-change-transform", [
                        animationEnabled.value ? "htw-transition-all" : "htw-transition-none",
                        {
                          "htw-delay-150": __props.modelValue === value
                        },
                        __props.modelValue === value ? "htw-fill-primary-500" : "htw-fill-transparent htw-scale-0"
                      ]])
                    }, null, 2)
                  ], 2)),
                  createTextVNode(" " + toDisplayString(label), 1)
                ], 40, _hoisted_3)
              ], 64);
            }), 128))
          ])
        ]),
        _: 3
      }, 8, ["title", "class", "style"]);
    };
  }
}));
const HstCheckbox = _sfc_main$b;
const HstText = _sfc_main$a;
const HstNumber = _sfc_main$9;
const HstTextarea = _sfc_main$7;
const HstCopyIcon = _sfc_main$4;
function registerVueComponents(app) {
  app.component("HstCheckbox", _sfc_main$b);
  app.component("HstText", _sfc_main$a);
  app.component("HstNumber", _sfc_main$9);
  app.component("HstSlider", _sfc_main$8);
  app.component("HstSelect", _sfc_main$5);
  app.component("HstTextarea", _sfc_main$7);
  app.component("HstColorShades", _sfc_main$3$2);
  app.component("HstTokenList", _sfc_main$2$1);
  app.component("HstTokenGrid", _sfc_main$1$1);
  app.component("HstRadio", _sfc_main$e);
}
var windi = "";
var index$4 = "";
var transitions = "";
var setup = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var generatedSetup = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop2))
      __defNormalProp$1(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols$1)
    for (var prop2 of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop2))
        __defNormalProp$1(a2, prop2, b2[prop2]);
    }
  return a2;
};
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var Case$1 = { exports: {} };
/*! Case - v1.6.2 - 2020-03-24
* Copyright (c) 2020 Nathan Bubna; Licensed MIT, GPL */
(function(module2) {
  (function() {
    var unicodes = function(s2, prefix) {
      prefix = prefix || "";
      return s2.replace(/(^|-)/g, "$1\\u" + prefix).replace(/,/g, "\\u" + prefix);
    }, basicSymbols = unicodes("20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7", "00"), baseLowerCase = "a-z" + unicodes("DF-F6,F8-FF", "00"), baseUpperCase = "A-Z" + unicodes("C0-D6,D8-DE", "00"), improperInTitle = "A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\.?|Via", regexps = function(symbols, lowers, uppers, impropers) {
      symbols = symbols || basicSymbols;
      lowers = lowers || baseLowerCase;
      uppers = uppers || baseUpperCase;
      impropers = impropers || improperInTitle;
      return {
        capitalize: new RegExp("(^|[" + symbols + "])([" + lowers + "])", "g"),
        pascal: new RegExp("(^|[" + symbols + "])+([" + lowers + uppers + "])", "g"),
        fill: new RegExp("[" + symbols + "]+(.|$)", "g"),
        sentence: new RegExp('(^\\s*|[\\?\\!\\.]+"?\\s+"?|,\\s+")([' + lowers + "])", "g"),
        improper: new RegExp("\\b(" + impropers + ")\\b", "g"),
        relax: new RegExp("([^" + uppers + "])([" + uppers + "]*)([" + uppers + "])(?=[^" + uppers + "]|$)", "g"),
        upper: new RegExp("^[^" + lowers + "]+$"),
        hole: /[^\s]\s[^\s]/,
        apostrophe: /'/g,
        room: new RegExp("[" + symbols + "]")
      };
    }, re2 = regexps(), _2 = {
      re: re2,
      unicodes,
      regexps,
      types: [],
      up: String.prototype.toUpperCase,
      low: String.prototype.toLowerCase,
      cap: function(s2) {
        return _2.up.call(s2.charAt(0)) + s2.slice(1);
      },
      decap: function(s2) {
        return _2.low.call(s2.charAt(0)) + s2.slice(1);
      },
      deapostrophe: function(s2) {
        return s2.replace(re2.apostrophe, "");
      },
      fill: function(s2, fill, deapostrophe) {
        if (fill != null) {
          s2 = s2.replace(re2.fill, function(m2, next) {
            return next ? fill + next : "";
          });
        }
        if (deapostrophe) {
          s2 = _2.deapostrophe(s2);
        }
        return s2;
      },
      prep: function(s2, fill, pascal, upper) {
        s2 = s2 == null ? "" : s2 + "";
        if (!upper && re2.upper.test(s2)) {
          s2 = _2.low.call(s2);
        }
        if (!fill && !re2.hole.test(s2)) {
          var holey = _2.fill(s2, " ");
          if (re2.hole.test(holey)) {
            s2 = holey;
          }
        }
        if (!pascal && !re2.room.test(s2)) {
          s2 = s2.replace(re2.relax, _2.relax);
        }
        return s2;
      },
      relax: function(m2, before, acronym, caps2) {
        return before + " " + (acronym ? acronym + " " : "") + caps2;
      }
    }, Case2 = {
      _: _2,
      of: function(s2) {
        for (var i2 = 0, m2 = _2.types.length; i2 < m2; i2++) {
          if (Case2[_2.types[i2]].apply(Case2, arguments) === s2) {
            return _2.types[i2];
          }
        }
      },
      flip: function(s2) {
        return s2.replace(/\w/g, function(l2) {
          return (l2 == _2.up.call(l2) ? _2.low : _2.up).call(l2);
        });
      },
      random: function(s2) {
        return s2.replace(/\w/g, function(l2) {
          return (Math.round(Math.random()) ? _2.up : _2.low).call(l2);
        });
      },
      type: function(type2, fn) {
        Case2[type2] = fn;
        _2.types.push(type2);
      }
    }, types = {
      lower: function(s2, fill, deapostrophe) {
        return _2.fill(_2.low.call(_2.prep(s2, fill)), fill, deapostrophe);
      },
      snake: function(s2) {
        return Case2.lower(s2, "_", true);
      },
      constant: function(s2) {
        return Case2.upper(s2, "_", true);
      },
      camel: function(s2) {
        return _2.decap(Case2.pascal(s2));
      },
      kebab: function(s2) {
        return Case2.lower(s2, "-", true);
      },
      upper: function(s2, fill, deapostrophe) {
        return _2.fill(_2.up.call(_2.prep(s2, fill, false, true)), fill, deapostrophe);
      },
      capital: function(s2, fill, deapostrophe) {
        return _2.fill(_2.prep(s2).replace(re2.capitalize, function(m2, border, letter) {
          return border + _2.up.call(letter);
        }), fill, deapostrophe);
      },
      header: function(s2) {
        return Case2.capital(s2, "-", true);
      },
      pascal: function(s2) {
        return _2.fill(_2.prep(s2, false, true).replace(re2.pascal, function(m2, border, letter) {
          return _2.up.call(letter);
        }), "", true);
      },
      title: function(s2) {
        return Case2.capital(s2).replace(re2.improper, function(small, p2, i2, s22) {
          return i2 > 0 && i2 < s22.lastIndexOf(" ") ? _2.low.call(small) : small;
        });
      },
      sentence: function(s2, names, abbreviations) {
        s2 = Case2.lower(s2).replace(re2.sentence, function(m2, prelude, letter) {
          return prelude + _2.up.call(letter);
        });
        if (names) {
          names.forEach(function(name) {
            s2 = s2.replace(new RegExp("\\b" + Case2.lower(name) + "\\b", "g"), _2.cap);
          });
        }
        if (abbreviations) {
          abbreviations.forEach(function(abbr) {
            s2 = s2.replace(new RegExp("(\\b" + Case2.lower(abbr) + "\\. +)(\\w)"), function(m2, abbrAndSpace, letter) {
              return abbrAndSpace + _2.low.call(letter);
            });
          });
        }
        return s2;
      }
    };
    types.squish = types.pascal;
    Case2.default = Case2;
    for (var type in types) {
      Case2.type(type, types[type]);
    }
    var define2 = typeof define2 === "function" ? define2 : function() {
    };
    define2(module2.exports ? module2.exports = Case2 : this.Case = Case2);
  }).call(commonjsGlobal$1);
})(Case$1);
Case$1.exports;
async function generateSourceCode(variant) {
  var _a2, _b, _c, _d, _e, _f2;
  const vnode = (_d = (_c = (_b = variant.slots()).default) == null ? void 0 : _c.call(_b, { state: (_a2 = variant.state) != null ? _a2 : {} })) != null ? _d : [];
  const list3 = Array.isArray(vnode) ? vnode : [vnode];
  const lines = [];
  for (const n2 in list3) {
    const vnode2 = list3[n2];
    lines.push(...(await printVNode(vnode2, (_f2 = (_e = variant.state) == null ? void 0 : _e._hPropState) == null ? void 0 : _f2[n2])).lines);
  }
  return lines.join("\n");
}
async function printVNode(vnode, propsOverrides = null) {
  var _a2, _b, _c;
  if (vnode.type === Text) {
    return {
      lines: [vnode.children],
      isText: true
    };
  }
  const lines = [];
  if (typeof vnode.type === "object" || typeof vnode.type === "string") {
    let genDirective = function(dirName, dir, valueCode = null) {
      var _a22;
      let modifiers = "";
      for (const key in dir.modifiers) {
        if (dir.modifiers[key]) {
          modifiers += `.${key}`;
        }
      }
      let arg = "";
      if (dir.arg) {
        arg = `:${dir.arg}`;
      }
      if (valueCode) {
        valueCode = valueCode.replace(/^\$(setup|props|data)\./g, "");
      }
      const valueLines = valueCode ? [valueCode] : serializeAndCleanJs(dir.value);
      const attr = [];
      const dirAttr = `v-${dirName}${arg}${modifiers}="`;
      if (valueLines.length > 1) {
        attr.push(`${dirAttr}${valueLines[0]}`);
        attr.push(...valueLines.slice(1, valueLines.length - 1));
        attr.push(`${valueLines[valueLines.length - 1]}"`);
        multilineAttrs = true;
      } else {
        attr.push(`${dirAttr}${(_a22 = valueLines[0]) != null ? _a22 : ""}"`);
      }
      attrs.push(attr);
    }, addAttr = function(prop2, value) {
      var _a22, _b2, _c2;
      if (typeof value !== "string" || ((_a22 = vnode.dynamicProps) == null ? void 0 : _a22.includes(prop2))) {
        let directive = ":";
        if (prop2.startsWith("on")) {
          directive = "@";
        }
        const arg = directive === "@" ? `${prop2[2].toLowerCase()}${prop2.slice(3)}` : prop2;
        const vmodelListener = `onUpdate:${prop2}`;
        if (directive === ":" && ((_b2 = vnode.dynamicProps) == null ? void 0 : _b2.includes(vmodelListener))) {
          skipProps.push(vmodelListener);
          const listener = vnode.props[vmodelListener];
          const listenerSource = listener.toString();
          let valueCode;
          const result = /\(\$event\) => (.*?) = \$event/.exec(listenerSource);
          if (result) {
            valueCode = result[1];
          }
          const modifiersKey = `${prop2 === "modelValue" ? "model" : prop2}Modifiers`;
          const modifiers = (_c2 = vnode.props[modifiersKey]) != null ? _c2 : {};
          skipProps.push(modifiersKey);
          genDirective("model", {
            arg: prop2 === "modelValue" ? null : prop2,
            modifiers,
            value
          }, valueCode);
          return;
        }
        let serialized;
        if (typeof value === "string" && value.startsWith("{{") && value.endsWith("}}")) {
          serialized = cleanupExpression(value.substring(2, value.length - 2).trim()).split("\n");
        } else if (typeof value === "function") {
          let code3 = cleanupExpression(value.toString().replace(/'/g, "\\'").replace(/"/g, "'"));
          const testResult = /function ([^\s]+)\(/.exec(code3);
          if (testResult) {
            serialized = [testResult[1]];
          } else {
            if (code3.startsWith("($event) => ")) {
              code3 = code3.substring("($event) => ".length);
            }
            serialized = code3.split("\n");
          }
        } else {
          serialized = serializeAndCleanJs(value);
        }
        if (serialized.length > 1) {
          multilineAttrs = true;
          const indented = [`${directive}${arg}="${serialized[0]}`];
          indented.push(...serialized.slice(1, serialized.length - 1));
          indented.push(`${serialized[serialized.length - 1]}"`);
          attrs.push(indented);
        } else {
          attrs.push([`${directive}${arg}="${serialized[0]}"`]);
        }
      } else {
        attrs.push([`${prop2}="${value}"`]);
      }
    };
    if (((_a2 = vnode.type) == null ? void 0 : _a2.__asyncLoader) && !vnode.type.__asyncResolved) {
      await vnode.type.__asyncLoader();
    }
    const attrs = [];
    let multilineAttrs = false;
    const skipProps = [
      "key"
    ];
    if (vnode.dirs) {
      for (const dir of vnode.dirs) {
        if (dir.dir === vModelText || dir.dir === vModelSelect || dir.dir === vModelRadio || dir.dir === vModelCheckbox || dir.dir === vModelDynamic) {
          const listenerKey = `onUpdate:${(_b = dir.arg) != null ? _b : "modelValue"}`;
          const listener = vnode.props[listenerKey];
          let valueCode = null;
          if (listener) {
            skipProps.push(listenerKey);
            const listenerSource = listener.toString();
            const result = /\(\$event\) => (.*?) = \$event/.exec(listenerSource);
            if (result) {
              valueCode = result[1];
            }
          }
          genDirective("model", dir, valueCode);
        } else if (dir.instance._ || dir.instance.$) {
          const target2 = (_c = dir.instance.$) != null ? _c : dir.instance._;
          let dirName;
          for (const directives2 of [target2.directives, target2.appContext.directives]) {
            for (const key in directives2) {
              if (target2.directives[key] === dir.dir) {
                dirName = key;
                break;
              }
            }
            if (dirName)
              break;
          }
          if (dirName) {
            genDirective(dirName, dir);
          }
        }
      }
    }
    for (const prop2 in vnode.props) {
      if (skipProps.includes(prop2) || propsOverrides && prop2 in propsOverrides) {
        continue;
      }
      const value = vnode.props[prop2];
      addAttr(prop2, value);
    }
    if (propsOverrides) {
      for (const prop2 in propsOverrides) {
        addAttr(prop2, propsOverrides[prop2]);
      }
    }
    if (attrs.length > 1) {
      multilineAttrs = true;
    }
    const tagName = getTagName(vnode);
    let isChildText = false;
    const childLines = [];
    if (typeof vnode.children === "string") {
      if (tagName === "pre") {
        childLines.push(vnode.children);
      } else {
        childLines.push(...vnode.children.split("\n"));
      }
      isChildText = true;
    } else if (Array.isArray(vnode.children)) {
      let isAllChildText;
      for (const child of vnode.children) {
        const result = await printVNode(child);
        if (result.isText) {
          if (isAllChildText === void 0) {
            isAllChildText = true;
          }
          const text3 = result.lines[0];
          if (!childLines.length || /^\s/.test(text3)) {
            childLines.push(text3.trim());
          } else {
            childLines[childLines.length - 1] += text3;
          }
        } else {
          if (isAllChildText === void 0) {
            isAllChildText = false;
          }
          childLines.push(...result.lines);
        }
      }
      if (isAllChildText !== void 0) {
        isChildText = isAllChildText;
      }
    }
    if (vnode.children && typeof vnode.children === "object" && !Array.isArray(vnode.children)) {
      for (const key in vnode.children) {
        if (typeof vnode.children[key] === "function") {
          const autoObject = createAutoBuildingObject((key2) => `{{ ${key2} }}`, (target2, p2) => {
            if (p2 === "__v_isRef") {
              return () => false;
            }
          });
          const children2 = vnode.children[key](autoObject.proxy);
          const slotLines = [];
          for (const child of children2) {
            slotLines.push(...(await printVNode(child)).lines);
          }
          const slotProps = Object.keys(autoObject.cache);
          if (slotProps.length) {
            childLines.push(`<template #${key}="{ ${slotProps.join(", ")} }">`);
            childLines.push(...indent(slotLines));
            childLines.push("</template>");
          } else if (key === "default") {
            childLines.push(...slotLines);
          } else {
            childLines.push(`<template #${key}>`);
            childLines.push(...indent(slotLines));
            childLines.push(`</template>`);
          }
        }
      }
    }
    const tag = [`<${tagName}`];
    if (multilineAttrs) {
      for (const attrLines of attrs) {
        tag.push(...indent(attrLines));
      }
      if (childLines.length > 0) {
        tag.push(">");
      }
    } else {
      if (attrs.length === 1) {
        tag[0] += ` ${attrs[0]}`;
      }
      if (childLines.length > 0) {
        tag[0] += ">";
      }
    }
    const isVoid = voidElements.includes(tagName.toLowerCase());
    if (childLines.length > 0) {
      if (childLines.length === 1 && tag.length === 1 && !attrs.length && isChildText) {
        lines.push(`${tag[0]}${childLines[0]}</${tagName}>`);
      } else {
        lines.push(...tag);
        lines.push(...indent(childLines));
        lines.push(`</${tagName}>`);
      }
    } else if (tag.length > 1) {
      lines.push(...tag);
      lines.push(isVoid ? ">" : "/>");
    } else {
      lines.push(`${tag[0]}${isVoid ? "" : " /"}>`);
    }
  } else if ((vnode == null ? void 0 : vnode.shapeFlag) & 1 << 4) {
    for (const child of vnode.children) {
      lines.push(...(await printVNode(child)).lines);
    }
  }
  return {
    lines
  };
}
function getTagName(vnode) {
  var _a2, _b, _c, _d, _e;
  if (typeof vnode.type === "string") {
    return vnode.type;
  } else if ((_a2 = vnode.type) == null ? void 0 : _a2.__asyncResolved) {
    const asyncComp = (_b = vnode.type) == null ? void 0 : _b.__asyncResolved;
    return (_c = asyncComp.name) != null ? _c : getNameFromFile(asyncComp.__file);
  } else if ((_d = vnode.type) == null ? void 0 : _d.name) {
    return vnode.type.name;
  } else if ((_e = vnode.type) == null ? void 0 : _e.__file) {
    return getNameFromFile(vnode.type.__file);
  }
  return "Anonymous";
}
function getNameFromFile(file) {
  const parts = /([^/]+)\.vue$/.exec(file);
  if (parts) {
    return Case$1.exports.pascal(parts[1]);
  }
  return "Anonymous";
}
function serializeAndCleanJs(value) {
  const isAutoBuildingObject = !!(value == null ? void 0 : value.__autoBuildingObject);
  const result = serializeJs(value);
  if (isAutoBuildingObject) {
    return [cleanupExpression(result.__autoBuildingObjectGetKey)];
  } else {
    return cleanupExpression(result).split("\n");
  }
}
function cleanupExpression(expr) {
  return expr.replace(/\$setup\./g, "");
}
const _sfc_main$3 = defineComponent({
  name: "Variant",
  __histoireType: "variant",
  props: {
    initState: {
      type: Function,
      default: null
    },
    source: {
      type: String,
      default: null
    },
    responsiveDisabled: {
      type: Boolean,
      default: false
    },
    setupApp: {
      type: Function,
      default: null
    }
  },
  setup(props) {
    const attrs = useAttrs();
    const vm = getCurrentInstance();
    const implicitState = inject("implicitState");
    watch(() => implicitState, (value) => {
      applyStateToVariant(attrs.variant, value(), true);
    }, {
      immediate: true
    });
    function updateVariant() {
      Object.assign(attrs.variant, {
        initState: async () => {
          if (typeof props.initState === "function") {
            const state = await props.initState();
            applyStateToVariant(attrs.variant, state);
          }
        },
        slots: () => vm.proxy.$slots,
        source: props.source,
        responsiveDisabled: props.responsiveDisabled,
        setupApp: props.setupApp,
        configReady: true
      });
    }
    updateVariant();
    return {
      updateVariant
    };
  },
  render() {
    this.updateVariant();
    return null;
  }
});
const _sfc_main$2 = defineComponent({
  name: "Story",
  __histoireType: "story",
  inheritAttrs: false,
  props: {
    initState: {
      type: Function,
      default: null
    }
  },
  setup() {
    const vm = getCurrentInstance();
    const attrs = useAttrs();
    const story = computed(() => attrs.story);
    provide("story", story);
    const storyComponent = vm.parent;
    const implicitState = {
      $data: storyComponent.data
    };
    function addImplicitState(key, value) {
      if (typeof value === "function" || (value == null ? void 0 : value.__file) || typeof (value == null ? void 0 : value.render) === "function" || typeof (value == null ? void 0 : value.setup) === "function") {
        return;
      }
      implicitState[key] = value;
    }
    for (const key in storyComponent.exposed) {
      addImplicitState(key, storyComponent.exposed[key]);
    }
    for (const key in storyComponent.devtoolsRawSetupState) {
      addImplicitState(key, storyComponent.devtoolsRawSetupState[key]);
    }
    provide("implicitState", () => __spreadValues$1({}, implicitState));
    function updateStory() {
      Object.assign(attrs.story, {
        slots: () => vm.proxy.$slots
      });
    }
    return {
      story,
      updateStory
    };
  },
  render() {
    this.updateStory();
    const [firstVariant] = this.story.variants;
    if (firstVariant.id === "_default") {
      return h$2(_sfc_main$3, __spreadValues$1({
        variant: firstVariant,
        initState: this.initState
      }, this.$attrs), this.$slots);
    }
    let index2 = 0;
    const applyAttrs = (vnodes2) => {
      var _a2, _b;
      for (const vnode of vnodes2) {
        if (((_a2 = vnode.type) == null ? void 0 : _a2.__histoireType) === "variant") {
          if (!vnode.props) {
            vnode.props = {};
          }
          vnode.props.variant = this.story.variants[index2];
          if (!vnode.props.initState && !vnode.props["init-state"]) {
            vnode.props.initState = this.initState;
          }
          for (const attr in this.$attrs) {
            if (typeof vnode.props[attr] === "undefined") {
              vnode.props[attr] = this.$attrs[attr];
            }
          }
          index2++;
        } else if ((_b = vnode.children) == null ? void 0 : _b.length) {
          applyAttrs(vnode.children);
        }
      }
    };
    const vnodes = this.$slots.default();
    applyAttrs(vnodes);
    return vnodes;
  }
});
function registerGlobalComponents(app) {
  app.component("Story", _sfc_main$2);
  app.component("Variant", _sfc_main$3);
  registerVueComponents(app);
}
const defaultRoute = {
  path: "/",
  name: void 0,
  redirectedFrom: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  href: "/"
};
const RouterLinkStub = defineComponent({
  name: "RouterLinkStub",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    custom: {
      type: Boolean,
      default: false
    }
  },
  render() {
    var _a2, _b;
    const route = computed(() => defaultRoute);
    const children2 = (_b = (_a2 = this.$slots) == null ? void 0 : _a2.default) == null ? void 0 : _b.call(_a2, {
      route,
      href: computed(() => route.value.href),
      isActive: computed(() => false),
      isExactActive: computed(() => false),
      navigate: async () => {
      }
    });
    return this.custom ? children2 : h$2("a", void 0, children2);
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  name: "SandboxVue3",
  props: {
    variant: {
      type: Object,
      required: true
    },
    story: {
      type: Object,
      required: true
    },
    slotName: {
      type: String,
      default: "default"
    }
  },
  emits: {
    ready: () => true
  },
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const sandbox = ref();
    let app;
    let mounting = false;
    function unmountVariant() {
      if (app) {
        app.unmount();
        app = null;
      }
    }
    async function mountVariant() {
      if (mounting)
        return;
      mounting = true;
      unmountVariant();
      await props.variant.initState();
      let lastPropsTypesSnapshot;
      app = createApp({
        name: "SandboxVue3",
        render: () => {
          var _a2, _b, _c, _d, _e, _f2, _g;
          const vnodes = (_g = (_c = (_a2 = props.variant.slots()) == null ? void 0 : _a2[props.slotName]) == null ? void 0 : _c.call(_a2, {
            state: (_b = props.variant.state) != null ? _b : {}
          })) != null ? _g : (_f2 = (_d = props.story.slots()) == null ? void 0 : _d[props.slotName]) == null ? void 0 : _f2.call(_d, {
            state: (_e = props.variant.state) != null ? _e : {}
          });
          if (props.slotName === "default") {
            const propsTypes = scanForAutoProps(vnodes);
            const snapshot = JSON.stringify(propsTypes);
            if (!lastPropsTypesSnapshot || lastPropsTypesSnapshot !== snapshot) {
              applyStateToVariant(props.variant, {
                _hPropDefs: propsTypes
              });
              if (!props.variant.state._hPropState) {
                applyStateToVariant(props.variant, {
                  _hPropState: {}
                });
              }
              lastPropsTypesSnapshot = snapshot;
            }
          }
          return vnodes;
        }
      });
      registerGlobalComponents(app);
      app.component("RouterLink", RouterLinkStub);
      if (typeof (generatedSetup == null ? void 0 : void 0) === "function") {
        await (void 0)({
          app,
          story: props.story,
          variant: props.variant
        });
      }
      if (typeof (setup == null ? void 0 : void 0) === "function") {
        await (void 0)({
          app,
          story: props.story,
          variant: props.variant
        });
      }
      if (typeof props.variant.setupApp === "function") {
        await props.variant.setupApp({
          app,
          story: props.story,
          variant: props.variant
        });
      }
      const target2 = document.createElement("div");
      sandbox.value.appendChild(target2);
      app.mount(target2);
      emit2("ready");
    }
    function scanForAutoProps(vnodes) {
      var _a2, _b, _c;
      const result = [];
      let index2 = 0;
      for (const vnode of vnodes) {
        if (typeof vnode.type === "object") {
          const propDefs = [];
          for (const key in vnode.type.props) {
            const prop2 = vnode.type.props[key];
            let types;
            let defaultValue;
            if (prop2) {
              const rawTypes = Array.isArray(prop2.type) ? prop2.type : [prop2.type];
              types = rawTypes.map((t2) => {
                switch (t2) {
                  case String:
                    return "string";
                  case Number:
                    return "number";
                  case Boolean:
                    return "boolean";
                  case Object:
                    return "object";
                  case Array:
                    return "array";
                  default:
                    return "unknown";
                }
              });
              defaultValue = typeof prop2.default === "function" ? prop2.default.toString() : prop2.default;
            }
            propDefs.push({
              name: key,
              types,
              required: prop2 == null ? void 0 : prop2.required,
              default: defaultValue
            });
            if ((_c = (_b = (_a2 = props.variant.state) == null ? void 0 : _a2._hPropState) == null ? void 0 : _b[index2]) == null ? void 0 : _c[key]) {
              if (!vnode.props) {
                vnode.props = {};
              }
              vnode.props[key] = props.variant.state._hPropState[index2][key];
              if (!vnode.dynamicProps) {
                vnode.dynamicProps = [];
              }
              if (!vnode.dynamicProps.includes(key)) {
                vnode.dynamicProps.push(key);
              }
            }
          }
          result.push({
            name: getTagName(vnode),
            index: index2,
            props: propDefs
          });
          index2++;
        }
        if (Array.isArray(vnode.children)) {
          result.push(...scanForAutoProps(vnode.children));
        }
      }
      return result.filter((def2) => def2.props.length);
    }
    onMounted(async () => {
      if (props.variant.initState) {
        await mountVariant();
      }
    });
    watch(() => props.variant.initState, async (value) => {
      if (value && !mounting) {
        await mountVariant();
      }
    });
    onBeforeUnmount(() => {
      unmountVariant();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "sandbox",
        ref: sandbox,
        class: "__histoire-sandbox htw-overflow-auto"
      }, null, 512);
    };
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  name: "MountStoryVue3",
  props: {
    story: null
  },
  setup(__props) {
    const props = __props;
    const el2 = ref();
    let app;
    async function mountStory() {
      app = createApp({
        name: "MountStoryVue3",
        render: () => {
          return h$2(props.story.file.component, {
            story: props.story
          });
        }
      });
      registerGlobalComponents(app);
      app.component("RouterLink", RouterLinkStub);
      const target2 = document.createElement("div");
      el2.value.appendChild(target2);
      app.mount(target2);
    }
    onMounted(async () => {
      await mountStory();
    });
    onUnmounted(() => {
      app == null ? void 0 : app.unmount();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "el",
        ref: el2
      }, null, 512);
    };
  }
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var main$1 = { exports: {} };
(function(module2, exports2) {
  !function(t2, n2) {
    module2.exports = n2();
  }(commonjsGlobal, function() {
    return t2 = { 770: function(t3, n3, e2) {
      var r2 = this && this.__importDefault || function(t4) {
        return t4 && t4.__esModule ? t4 : { default: t4 };
      };
      Object.defineProperty(n3, "__esModule", { value: true }), n3.setDefaultDebugCall = n3.createOnigScanner = n3.createOnigString = n3.loadWASM = n3.OnigScanner = n3.OnigString = void 0;
      const i2 = r2(e2(418));
      let o2 = null, a2 = false;
      class f2 {
        constructor(t4) {
          const n4 = t4.length, e3 = f2._utf8ByteLength(t4), r3 = e3 !== n4, i3 = r3 ? new Uint32Array(n4 + 1) : null;
          r3 && (i3[n4] = e3);
          const o3 = r3 ? new Uint32Array(e3 + 1) : null;
          r3 && (o3[e3] = n4);
          const a3 = new Uint8Array(e3);
          let s3 = 0;
          for (let e4 = 0; e4 < n4; e4++) {
            const f3 = t4.charCodeAt(e4);
            let u3 = f3, c3 = false;
            if (f3 >= 55296 && f3 <= 56319 && e4 + 1 < n4) {
              const n5 = t4.charCodeAt(e4 + 1);
              n5 >= 56320 && n5 <= 57343 && (u3 = 65536 + (f3 - 55296 << 10) | n5 - 56320, c3 = true);
            }
            r3 && (i3[e4] = s3, c3 && (i3[e4 + 1] = s3), u3 <= 127 ? o3[s3 + 0] = e4 : u3 <= 2047 ? (o3[s3 + 0] = e4, o3[s3 + 1] = e4) : u3 <= 65535 ? (o3[s3 + 0] = e4, o3[s3 + 1] = e4, o3[s3 + 2] = e4) : (o3[s3 + 0] = e4, o3[s3 + 1] = e4, o3[s3 + 2] = e4, o3[s3 + 3] = e4)), u3 <= 127 ? a3[s3++] = u3 : u3 <= 2047 ? (a3[s3++] = 192 | (1984 & u3) >>> 6, a3[s3++] = 128 | (63 & u3) >>> 0) : u3 <= 65535 ? (a3[s3++] = 224 | (61440 & u3) >>> 12, a3[s3++] = 128 | (4032 & u3) >>> 6, a3[s3++] = 128 | (63 & u3) >>> 0) : (a3[s3++] = 240 | (1835008 & u3) >>> 18, a3[s3++] = 128 | (258048 & u3) >>> 12, a3[s3++] = 128 | (4032 & u3) >>> 6, a3[s3++] = 128 | (63 & u3) >>> 0), c3 && e4++;
          }
          this.utf16Length = n4, this.utf8Length = e3, this.utf16Value = t4, this.utf8Value = a3, this.utf16OffsetToUtf8 = i3, this.utf8OffsetToUtf16 = o3;
        }
        static _utf8ByteLength(t4) {
          let n4 = 0;
          for (let e3 = 0, r3 = t4.length; e3 < r3; e3++) {
            const i3 = t4.charCodeAt(e3);
            let o3 = i3, a3 = false;
            if (i3 >= 55296 && i3 <= 56319 && e3 + 1 < r3) {
              const n5 = t4.charCodeAt(e3 + 1);
              n5 >= 56320 && n5 <= 57343 && (o3 = 65536 + (i3 - 55296 << 10) | n5 - 56320, a3 = true);
            }
            n4 += o3 <= 127 ? 1 : o3 <= 2047 ? 2 : o3 <= 65535 ? 3 : 4, a3 && e3++;
          }
          return n4;
        }
        createString(t4) {
          const n4 = t4._omalloc(this.utf8Length);
          return t4.HEAPU8.set(this.utf8Value, n4), n4;
        }
      }
      class s2 {
        constructor(t4) {
          if (this.id = ++s2.LAST_ID, !o2)
            throw new Error("Must invoke loadWASM first.");
          this._onigBinding = o2, this.content = t4;
          const n4 = new f2(t4);
          this.utf16Length = n4.utf16Length, this.utf8Length = n4.utf8Length, this.utf16OffsetToUtf8 = n4.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n4.utf8OffsetToUtf16, this.utf8Length < 1e4 && !s2._sharedPtrInUse ? (s2._sharedPtr || (s2._sharedPtr = o2._omalloc(1e4)), s2._sharedPtrInUse = true, o2.HEAPU8.set(n4.utf8Value, s2._sharedPtr), this.ptr = s2._sharedPtr) : this.ptr = n4.createString(o2);
        }
        convertUtf8OffsetToUtf16(t4) {
          return this.utf8OffsetToUtf16 ? t4 < 0 ? 0 : t4 > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t4] : t4;
        }
        convertUtf16OffsetToUtf8(t4) {
          return this.utf16OffsetToUtf8 ? t4 < 0 ? 0 : t4 > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t4] : t4;
        }
        dispose() {
          this.ptr === s2._sharedPtr ? s2._sharedPtrInUse = false : this._onigBinding._ofree(this.ptr);
        }
      }
      n3.OnigString = s2, s2.LAST_ID = 0, s2._sharedPtr = 0, s2._sharedPtrInUse = false;
      class u2 {
        constructor(t4) {
          if (!o2)
            throw new Error("Must invoke loadWASM first.");
          const n4 = [], e3 = [];
          for (let r4 = 0, i4 = t4.length; r4 < i4; r4++) {
            const i5 = new f2(t4[r4]);
            n4[r4] = i5.createString(o2), e3[r4] = i5.utf8Length;
          }
          const r3 = o2._omalloc(4 * t4.length);
          o2.HEAPU32.set(n4, r3 / 4);
          const i3 = o2._omalloc(4 * t4.length);
          o2.HEAPU32.set(e3, i3 / 4);
          const a3 = o2._createOnigScanner(r3, i3, t4.length);
          for (let e4 = 0, r4 = t4.length; e4 < r4; e4++)
            o2._ofree(n4[e4]);
          o2._ofree(i3), o2._ofree(r3), 0 === a3 && function(t5) {
            throw new Error(t5.UTF8ToString(t5._getLastOnigError()));
          }(o2), this._onigBinding = o2, this._ptr = a3;
        }
        dispose() {
          this._onigBinding._freeOnigScanner(this._ptr);
        }
        findNextMatchSync(t4, n4, e3) {
          let r3 = a2, i3 = 0;
          if ("number" == typeof e3 ? (8 & e3 && (r3 = true), i3 = e3) : "boolean" == typeof e3 && (r3 = e3), "string" == typeof t4) {
            t4 = new s2(t4);
            const e4 = this._findNextMatchSync(t4, n4, r3, i3);
            return t4.dispose(), e4;
          }
          return this._findNextMatchSync(t4, n4, r3, i3);
        }
        _findNextMatchSync(t4, n4, e3, r3) {
          const i3 = this._onigBinding;
          let o3;
          if (o3 = e3 ? i3._findNextOnigScannerMatchDbg(this._ptr, t4.id, t4.ptr, t4.utf8Length, t4.convertUtf16OffsetToUtf8(n4), r3) : i3._findNextOnigScannerMatch(this._ptr, t4.id, t4.ptr, t4.utf8Length, t4.convertUtf16OffsetToUtf8(n4), r3), 0 === o3)
            return null;
          const a3 = i3.HEAPU32;
          let f3 = o3 / 4;
          const s3 = a3[f3++], u3 = a3[f3++];
          let c3 = [];
          for (let n5 = 0; n5 < u3; n5++) {
            const e4 = t4.convertUtf8OffsetToUtf16(a3[f3++]), r4 = t4.convertUtf8OffsetToUtf16(a3[f3++]);
            c3[n5] = { start: e4, end: r4, length: r4 - e4 };
          }
          return { index: s3, captureIndices: c3 };
        }
      }
      n3.OnigScanner = u2;
      let c2 = false, l2 = null;
      n3.loadWASM = function(t4) {
        if (c2)
          return l2;
        let n4, e3, r3, a3;
        if (c2 = true, function(t5) {
          return "function" == typeof t5.instantiator;
        }(t4))
          n4 = t4.instantiator, e3 = t4.print;
        else {
          let r4;
          !function(t5) {
            return void 0 !== t5.data;
          }(t4) ? r4 = t4 : (r4 = t4.data, e3 = t4.print), n4 = function(t5) {
            return "undefined" != typeof Response && t5 instanceof Response;
          }(r4) ? "function" == typeof WebAssembly.instantiateStreaming ? function(t5) {
            return (n5) => WebAssembly.instantiateStreaming(t5, n5);
          }(r4) : function(t5) {
            return async (n5) => {
              const e4 = await t5.arrayBuffer();
              return WebAssembly.instantiate(e4, n5);
            };
          }(r4) : function(t5) {
            return (n5) => WebAssembly.instantiate(t5, n5);
          }(r4);
        }
        return l2 = new Promise((t5, n5) => {
          r3 = t5, a3 = n5;
        }), function(t5, n5, e4, r4) {
          i2.default({ print: n5, instantiateWasm: (n6, e5) => {
            if ("undefined" == typeof performance) {
              const t6 = () => Date.now();
              n6.env.emscripten_get_now = t6, n6.wasi_snapshot_preview1.emscripten_get_now = t6;
            }
            return t5(n6).then((t6) => e5(t6.instance), r4), {};
          } }).then((t6) => {
            o2 = t6, e4();
          });
        }(n4, e3, r3, a3), l2;
      }, n3.createOnigString = function(t4) {
        return new s2(t4);
      }, n3.createOnigScanner = function(t4) {
        return new u2(t4);
      }, n3.setDefaultDebugCall = function(t4) {
        a2 = t4;
      };
    }, 418: (t3) => {
      var n3 = ("undefined" != typeof document && document.currentScript && document.currentScript.src, function(t4) {
        var n4, e2, r2 = void 0 !== (t4 = t4 || {}) ? t4 : {};
        r2.ready = new Promise(function(t5, r3) {
          n4 = t5, e2 = r3;
        });
        var i2, o2 = {};
        for (i2 in r2)
          r2.hasOwnProperty(i2) && (o2[i2] = r2[i2]);
        var a2, u2 = false, l2 = "";
        function p2(t5) {
          return r2.locateFile ? r2.locateFile(t5, l2) : l2 + t5;
        }
        a2 = function(t5) {
          var n5;
          return "function" == typeof readbuffer ? new Uint8Array(readbuffer(t5)) : (v2("object" == typeof (n5 = read(t5, "binary"))), n5);
        }, "undefined" != typeof scriptArgs ? scriptArgs : void 0 !== arguments && arguments, "undefined" != typeof onig_print && ("undefined" == typeof console && (console = {}), console.log = onig_print, console.warn = console.error = "undefined" != typeof printErr ? printErr : onig_print);
        var h2 = r2.print || console.log.bind(console), d2 = r2.printErr || console.warn.bind(console);
        for (i2 in o2)
          o2.hasOwnProperty(i2) && (r2[i2] = o2[i2]);
        o2 = null, r2.arguments && r2.arguments, r2.thisProgram && r2.thisProgram, r2.quit && r2.quit;
        var g2, _2;
        r2.wasmBinary && (g2 = r2.wasmBinary), r2.noExitRuntime, "object" != typeof WebAssembly && z2("no native wasm support detected");
        var y2 = false;
        function v2(t5, n5) {
          t5 || z2("Assertion failed: " + n5);
        }
        var w2, S2, A2, b2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function O2(t5, n5, e3) {
          for (var r3 = n5 + e3, i3 = n5; t5[i3] && !(i3 >= r3); )
            ++i3;
          if (i3 - n5 > 16 && t5.subarray && b2)
            return b2.decode(t5.subarray(n5, i3));
          for (var o3 = ""; n5 < i3; ) {
            var a3 = t5[n5++];
            if (128 & a3) {
              var f2 = 63 & t5[n5++];
              if (192 != (224 & a3)) {
                var s2 = 63 & t5[n5++];
                if ((a3 = 224 == (240 & a3) ? (15 & a3) << 12 | f2 << 6 | s2 : (7 & a3) << 18 | f2 << 12 | s2 << 6 | 63 & t5[n5++]) < 65536)
                  o3 += String.fromCharCode(a3);
                else {
                  var u3 = a3 - 65536;
                  o3 += String.fromCharCode(55296 | u3 >> 10, 56320 | 1023 & u3);
                }
              } else
                o3 += String.fromCharCode((31 & a3) << 6 | f2);
            } else
              o3 += String.fromCharCode(a3);
          }
          return o3;
        }
        function U2(t5, n5) {
          return t5 ? O2(S2, t5, n5) : "";
        }
        function x2(t5, n5) {
          return t5 % n5 > 0 && (t5 += n5 - t5 % n5), t5;
        }
        function P2(t5) {
          w2 = t5, r2.HEAP8 = new Int8Array(t5), r2.HEAP16 = new Int16Array(t5), r2.HEAP32 = A2 = new Int32Array(t5), r2.HEAPU8 = S2 = new Uint8Array(t5), r2.HEAPU16 = new Uint16Array(t5), r2.HEAPU32 = new Uint32Array(t5), r2.HEAPF32 = new Float32Array(t5), r2.HEAPF64 = new Float64Array(t5);
        }
        "undefined" != typeof TextDecoder && new TextDecoder("utf-16le"), r2.INITIAL_MEMORY;
        var T2, R2 = [], E2 = [], M2 = [], L2 = [];
        function I2() {
          if (r2.preRun)
            for ("function" == typeof r2.preRun && (r2.preRun = [r2.preRun]); r2.preRun.length; )
              N2(r2.preRun.shift());
          $2(R2);
        }
        function D2() {
          $2(E2);
        }
        function W2() {
          $2(M2);
        }
        function C2() {
          if (r2.postRun)
            for ("function" == typeof r2.postRun && (r2.postRun = [r2.postRun]); r2.postRun.length; )
              k2(r2.postRun.shift());
          $2(L2);
        }
        function N2(t5) {
          R2.unshift(t5);
        }
        function k2(t5) {
          L2.unshift(t5);
        }
        E2.push({ func: function() {
          ut();
        } });
        var B2 = 0, j2 = null;
        function F2(t5) {
          B2++, r2.monitorRunDependencies && r2.monitorRunDependencies(B2);
        }
        function V2(t5) {
          if (B2--, r2.monitorRunDependencies && r2.monitorRunDependencies(B2), 0 == B2 && j2) {
            var n5 = j2;
            j2 = null, n5();
          }
        }
        function z2(t5) {
          r2.onAbort && r2.onAbort(t5), d2(t5 += ""), y2 = true, t5 = "abort(" + t5 + "). Build with -s ASSERTIONS=1 for more info.";
          var n5 = new WebAssembly.RuntimeError(t5);
          throw e2(n5), n5;
        }
        function q2(t5, n5) {
          return String.prototype.startsWith ? t5.startsWith(n5) : 0 === t5.indexOf(n5);
        }
        r2.preloadedImages = {}, r2.preloadedAudios = {};
        var Y2 = "data:application/octet-stream;base64,";
        function G2(t5) {
          return q2(t5, Y2);
        }
        var J2, K2 = "onig.wasm";
        function Q2(t5) {
          try {
            if (t5 == K2 && g2)
              return new Uint8Array(g2);
            if (a2)
              return a2(t5);
            throw "both async and sync fetching of the wasm failed";
          } catch (t6) {
            z2(t6);
          }
        }
        function X2() {
          return g2 || !u2 || "function" != typeof fetch ? Promise.resolve().then(function() {
            return Q2(K2);
          }) : fetch(K2, { credentials: "same-origin" }).then(function(t5) {
            if (!t5.ok)
              throw "failed to load wasm binary file at '" + K2 + "'";
            return t5.arrayBuffer();
          }).catch(function() {
            return Q2(K2);
          });
        }
        function Z2() {
          var t5 = { env: st, wasi_snapshot_preview1: st };
          function n5(t6, n6) {
            var e3 = t6.exports;
            r2.asm = e3, P2((_2 = r2.asm.memory).buffer), T2 = r2.asm.__indirect_function_table, V2();
          }
          function i3(t6) {
            n5(t6.instance);
          }
          function o3(n6) {
            return X2().then(function(n7) {
              return WebAssembly.instantiate(n7, t5);
            }).then(n6, function(t6) {
              d2("failed to asynchronously prepare wasm: " + t6), z2(t6);
            });
          }
          if (F2(), r2.instantiateWasm)
            try {
              return r2.instantiateWasm(t5, n5);
            } catch (t6) {
              return d2("Module.instantiateWasm callback failed with error: " + t6), false;
            }
          return (g2 || "function" != typeof WebAssembly.instantiateStreaming || G2(K2) || "function" != typeof fetch ? o3(i3) : fetch(K2, { credentials: "same-origin" }).then(function(n6) {
            return WebAssembly.instantiateStreaming(n6, t5).then(i3, function(t6) {
              return d2("wasm streaming compile failed: " + t6), d2("falling back to ArrayBuffer instantiation"), o3(i3);
            });
          })).catch(e2), {};
        }
        function $2(t5) {
          for (; t5.length > 0; ) {
            var n5 = t5.shift();
            if ("function" != typeof n5) {
              var e3 = n5.func;
              "number" == typeof e3 ? void 0 === n5.arg ? T2.get(e3)() : T2.get(e3)(n5.arg) : e3(void 0 === n5.arg ? null : n5.arg);
            } else
              n5(r2);
          }
        }
        function tt2(t5, n5, e3) {
          S2.copyWithin(t5, n5, n5 + e3);
        }
        function nt2() {
          return S2.length;
        }
        function et2(t5) {
          try {
            return _2.grow(t5 - w2.byteLength + 65535 >>> 16), P2(_2.buffer), 1;
          } catch (t6) {
          }
        }
        function rt2(t5) {
          var n5 = nt2(), e3 = 2147483648;
          if (t5 > e3)
            return false;
          for (var r3 = 1; r3 <= 4; r3 *= 2) {
            var i3 = n5 * (1 + 0.2 / r3);
            if (i3 = Math.min(i3, t5 + 100663296), et2(Math.min(e3, x2(Math.max(t5, i3), 65536))))
              return true;
          }
          return false;
        }
        G2(K2) || (K2 = p2(K2)), J2 = "undefined" != typeof dateNow ? dateNow : function() {
          return performance.now();
        };
        var it2 = { mappings: {}, buffers: [null, [], []], printChar: function(t5, n5) {
          var e3 = it2.buffers[t5];
          0 === n5 || 10 === n5 ? ((1 === t5 ? h2 : d2)(O2(e3, 0)), e3.length = 0) : e3.push(n5);
        }, varargs: void 0, get: function() {
          return it2.varargs += 4, A2[it2.varargs - 4 >> 2];
        }, getStr: function(t5) {
          return U2(t5);
        }, get64: function(t5, n5) {
          return t5;
        } };
        function ot2(t5, n5, e3, r3) {
          for (var i3 = 0, o3 = 0; o3 < e3; o3++) {
            for (var a3 = A2[n5 + 8 * o3 >> 2], f2 = A2[n5 + (8 * o3 + 4) >> 2], s2 = 0; s2 < f2; s2++)
              it2.printChar(t5, S2[a3 + s2]);
            i3 += f2;
          }
          return A2[r3 >> 2] = i3, 0;
        }
        function at2(t5) {
        }
        var ft, st = { emscripten_get_now: J2, emscripten_memcpy_big: tt2, emscripten_resize_heap: rt2, fd_write: ot2, setTempRet0: at2 }, ut = (Z2(), r2.___wasm_call_ctors = function() {
          return (ut = r2.___wasm_call_ctors = r2.asm.__wasm_call_ctors).apply(null, arguments);
        });
        function ct(t5) {
          function e3() {
            ft || (ft = true, r2.calledRun = true, y2 || (D2(), W2(), n4(r2), r2.onRuntimeInitialized && r2.onRuntimeInitialized(), C2()));
          }
          B2 > 0 || (I2(), B2 > 0 || (r2.setStatus ? (r2.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              r2.setStatus("");
            }, 1), e3();
          }, 1)) : e3()));
        }
        if (r2.___errno_location = function() {
          return (r2.___errno_location = r2.asm.__errno_location).apply(null, arguments);
        }, r2._omalloc = function() {
          return (r2._omalloc = r2.asm.omalloc).apply(null, arguments);
        }, r2._ofree = function() {
          return (r2._ofree = r2.asm.ofree).apply(null, arguments);
        }, r2._getLastOnigError = function() {
          return (r2._getLastOnigError = r2.asm.getLastOnigError).apply(null, arguments);
        }, r2._createOnigScanner = function() {
          return (r2._createOnigScanner = r2.asm.createOnigScanner).apply(null, arguments);
        }, r2._freeOnigScanner = function() {
          return (r2._freeOnigScanner = r2.asm.freeOnigScanner).apply(null, arguments);
        }, r2._findNextOnigScannerMatch = function() {
          return (r2._findNextOnigScannerMatch = r2.asm.findNextOnigScannerMatch).apply(null, arguments);
        }, r2._findNextOnigScannerMatchDbg = function() {
          return (r2._findNextOnigScannerMatchDbg = r2.asm.findNextOnigScannerMatchDbg).apply(null, arguments);
        }, r2.stackSave = function() {
          return (r2.stackSave = r2.asm.stackSave).apply(null, arguments);
        }, r2.stackRestore = function() {
          return (r2.stackRestore = r2.asm.stackRestore).apply(null, arguments);
        }, r2.stackAlloc = function() {
          return (r2.stackAlloc = r2.asm.stackAlloc).apply(null, arguments);
        }, r2.dynCall_jiji = function() {
          return (r2.dynCall_jiji = r2.asm.dynCall_jiji).apply(null, arguments);
        }, r2.UTF8ToString = U2, j2 = function t5() {
          ft || ct(), ft || (j2 = t5);
        }, r2.run = ct, r2.preInit)
          for ("function" == typeof r2.preInit && (r2.preInit = [r2.preInit]); r2.preInit.length > 0; )
            r2.preInit.pop()();
        return ct(), t4.ready;
      });
      t3.exports = n3;
    } }, n2 = {}, function e2(r2) {
      var i2 = n2[r2];
      if (void 0 !== i2)
        return i2.exports;
      var o2 = n2[r2] = { exports: {} };
      return t2[r2].call(o2.exports, o2, o2.exports, e2), o2.exports;
    }(770);
    var t2, n2;
  });
})(main$1);
var main = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2) {
      var t2 = {};
      function n2(r2) {
        if (t2[r2])
          return t2[r2].exports;
        var i2 = t2[r2] = { i: r2, l: false, exports: {} };
        return e2[r2].call(i2.exports, i2, i2.exports, n2), i2.l = true, i2.exports;
      }
      return n2.m = e2, n2.c = t2, n2.d = function(e3, t3, r2) {
        n2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: r2 });
      }, n2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, n2.t = function(e3, t3) {
        if (1 & t3 && (e3 = n2(e3)), 8 & t3)
          return e3;
        if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
          return e3;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
          for (var i2 in e3)
            n2.d(r2, i2, function(t4) {
              return e3[t4];
            }.bind(null, i2));
        return r2;
      }, n2.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return n2.d(t3, "a", t3), t3;
      }, n2.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, n2.p = "", n2(n2.s = 3);
    }([function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2 = n2(1), i2 = n2(5), o2 = n2(6), s2 = n2(2), a2 = "undefined" == typeof performance ? function() {
        return Date.now();
      } : function() {
        return performance.now();
      };
      t2.createGrammar = function(e3, t3, n3, r3, i3, o3) {
        return new v2(e3, t3, n3, r3, i3, o3);
      };
      var c2 = function(e3) {
        this.scopeName = e3;
      };
      t2.FullScopeDependency = c2;
      var u2 = function() {
        function e3(e4, t3) {
          this.scopeName = e4, this.include = t3;
        }
        return e3.prototype.toKey = function() {
          return this.scopeName + "#" + this.include;
        }, e3;
      }();
      t2.PartialScopeDependency = u2;
      var l2 = function() {
        function e3() {
          this.full = [], this.partial = [], this.visitedRule = /* @__PURE__ */ new Set(), this._seenFull = /* @__PURE__ */ new Set(), this._seenPartial = /* @__PURE__ */ new Set();
        }
        return e3.prototype.add = function(e4) {
          e4 instanceof c2 ? this._seenFull.has(e4.scopeName) || (this._seenFull.add(e4.scopeName), this.full.push(e4)) : this._seenPartial.has(e4.toKey()) || (this._seenPartial.add(e4.toKey()), this.partial.push(e4));
        }, e3;
      }();
      function h2(e3, t3, n3, i3, o3) {
        for (var s3 = 0, a3 = i3; s3 < a3.length; s3++) {
          var l3 = a3[s3];
          if (!e3.visitedRule.has(l3)) {
            e3.visitedRule.add(l3);
            var d3 = l3.repository ? r2.mergeObjects({}, o3, l3.repository) : o3;
            Array.isArray(l3.patterns) && h2(e3, t3, n3, l3.patterns, d3);
            var g3 = l3.include;
            if (g3)
              if ("$base" === g3 || g3 === t3.scopeName)
                f2(e3, t3, t3);
              else if ("$self" === g3 || g3 === n3.scopeName)
                f2(e3, t3, n3);
              else if ("#" === g3.charAt(0))
                p2(e3, t3, n3, g3.substring(1), d3);
              else {
                var m3 = g3.indexOf("#");
                if (m3 >= 0) {
                  var _3 = g3.substring(0, m3), y3 = g3.substring(m3 + 1);
                  _3 === t3.scopeName ? p2(e3, t3, t3, y3, d3) : _3 === n3.scopeName ? p2(e3, t3, n3, y3, d3) : e3.add(new u2(_3, g3.substring(m3 + 1)));
                } else
                  e3.add(new c2(g3));
              }
          }
        }
      }
      function p2(e3, t3, n3, r3, i3) {
        (void 0 === i3 && (i3 = n3.repository), i3 && i3[r3]) && h2(e3, t3, n3, [i3[r3]], i3);
      }
      function f2(e3, t3, n3) {
        if (n3.patterns && Array.isArray(n3.patterns) && h2(e3, t3, n3, n3.patterns, n3.repository), n3.injections) {
          var r3 = [];
          for (var i3 in n3.injections)
            r3.push(n3.injections[i3]);
          h2(e3, t3, n3, r3, n3.repository);
        }
      }
      function d2(e3, t3) {
        if (!e3)
          return false;
        if (e3 === t3)
          return true;
        var n3 = t3.length;
        return e3.length > n3 && e3.substr(0, n3) === t3 && "." === e3[n3];
      }
      function g2(e3, t3) {
        if (t3.length < e3.length)
          return false;
        var n3 = 0;
        return e3.every(function(e4) {
          for (var r3 = n3; r3 < t3.length; r3++)
            if (d2(t3[r3], e4))
              return n3 = r3 + 1, true;
          return false;
        });
      }
      function m2(e3, t3, n3, r3, s3) {
        for (var a3 = o2.createMatchers(t3, g2), c3 = i2.RuleFactory.getCompiledRuleId(n3, r3, s3.repository), u3 = 0, l3 = a3; u3 < l3.length; u3++) {
          var h3 = l3[u3];
          e3.push({ matcher: h3.matcher, ruleId: c3, grammar: s3, priority: h3.priority });
        }
      }
      t2.ScopeDependencyCollector = l2, t2.collectSpecificDependencies = p2, t2.collectDependencies = f2;
      var _2 = function(e3, t3, n3, r3) {
        this.scopeName = e3, this.languageId = t3, this.tokenType = n3, this.themeData = r3;
      };
      t2.ScopeMetadata = _2;
      var y2 = function() {
        function e3(t3, n3, r3) {
          if (this._initialLanguage = t3, this._themeProvider = n3, this._cache = /* @__PURE__ */ new Map(), this._defaultMetaData = new _2("", this._initialLanguage, 0, [this._themeProvider.getDefaults()]), this._embeddedLanguages = /* @__PURE__ */ Object.create(null), r3)
            for (var i3 = Object.keys(r3), o3 = 0, s3 = i3.length; o3 < s3; o3++) {
              var a3 = i3[o3], c3 = r3[a3];
              "number" == typeof c3 && 0 !== c3 ? this._embeddedLanguages[a3] = c3 : console.warn("Invalid embedded language found at scope " + a3 + ": <<" + c3 + ">>");
            }
          var u3 = Object.keys(this._embeddedLanguages).map(function(t4) {
            return e3._escapeRegExpCharacters(t4);
          });
          0 === u3.length ? this._embeddedLanguagesRegex = null : (u3.sort(), u3.reverse(), this._embeddedLanguagesRegex = new RegExp("^((" + u3.join(")|(") + "))($|\\.)", ""));
        }
        return e3.prototype.onDidChangeTheme = function() {
          this._cache = /* @__PURE__ */ new Map(), this._defaultMetaData = new _2("", this._initialLanguage, 0, [this._themeProvider.getDefaults()]);
        }, e3.prototype.getDefaultMetadata = function() {
          return this._defaultMetaData;
        }, e3._escapeRegExpCharacters = function(e4) {
          return e4.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
        }, e3.prototype.getMetadataForScope = function(t3) {
          if (null === t3)
            return e3._NULL_SCOPE_METADATA;
          var n3 = this._cache.get(t3);
          return n3 || (n3 = this._doGetMetadataForScope(t3), this._cache.set(t3, n3), n3);
        }, e3.prototype._doGetMetadataForScope = function(e4) {
          var t3 = this._scopeToLanguage(e4), n3 = this._toStandardTokenType(e4), r3 = this._themeProvider.themeMatch(e4);
          return new _2(e4, t3, n3, r3);
        }, e3.prototype._scopeToLanguage = function(e4) {
          if (!e4)
            return 0;
          if (!this._embeddedLanguagesRegex)
            return 0;
          var t3 = e4.match(this._embeddedLanguagesRegex);
          if (!t3)
            return 0;
          var n3 = this._embeddedLanguages[t3[1]] || 0;
          return n3 || 0;
        }, e3.prototype._toStandardTokenType = function(t3) {
          var n3 = t3.match(e3.STANDARD_TOKEN_TYPE_REGEXP);
          if (!n3)
            return 0;
          switch (n3[1]) {
            case "comment":
              return 1;
            case "string":
              return 2;
            case "regex":
              return 4;
            case "meta.embedded":
              return 8;
          }
          throw new Error("Unexpected match for standard token type!");
        }, e3._NULL_SCOPE_METADATA = new _2("", 0, 0, null), e3.STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/, e3;
      }(), v2 = function() {
        function e3(e4, t3, n3, r3, i3, s3) {
          if (this._scopeMetadataProvider = new y2(t3, i3, n3), this._onigLib = s3, this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = i3, this._grammar = C2(e4, null), this._injections = null, this._tokenTypeMatchers = [], r3)
            for (var a3 = 0, c3 = Object.keys(r3); a3 < c3.length; a3++)
              for (var u3 = c3[a3], l3 = 0, h3 = o2.createMatchers(u3, g2); l3 < h3.length; l3++) {
                var p3 = h3[l3];
                this._tokenTypeMatchers.push({ matcher: p3.matcher, type: r3[u3] });
              }
        }
        return e3.prototype.dispose = function() {
          for (var e4 = 0, t3 = this._ruleId2desc; e4 < t3.length; e4++) {
            var n3 = t3[e4];
            n3 && n3.dispose();
          }
        }, e3.prototype.createOnigScanner = function(e4) {
          return this._onigLib.createOnigScanner(e4);
        }, e3.prototype.createOnigString = function(e4) {
          return this._onigLib.createOnigString(e4);
        }, e3.prototype.onDidChangeTheme = function() {
          this._scopeMetadataProvider.onDidChangeTheme();
        }, e3.prototype.getMetadataForScope = function(e4) {
          return this._scopeMetadataProvider.getMetadataForScope(e4);
        }, e3.prototype.getInjections = function() {
          var e4 = this;
          if (null === this._injections) {
            this._injections = [];
            var t3 = this._grammar.injections;
            if (t3)
              for (var n3 in t3)
                m2(this._injections, n3, t3[n3], this, this._grammar);
            if (this._grammarRepository) {
              var r3 = this._grammarRepository.injections(this._grammar.scopeName);
              r3 && r3.forEach(function(t4) {
                var n4 = e4.getExternalGrammar(t4);
                if (n4) {
                  var r4 = n4.injectionSelector;
                  r4 && m2(e4._injections, r4, n4, e4, n4);
                }
              });
            }
            this._injections.sort(function(e5, t4) {
              return e5.priority - t4.priority;
            });
          }
          return this._injections;
        }, e3.prototype.registerRule = function(e4) {
          var t3 = ++this._lastRuleId, n3 = e4(t3);
          return this._ruleId2desc[t3] = n3, n3;
        }, e3.prototype.getRule = function(e4) {
          return this._ruleId2desc[e4];
        }, e3.prototype.getExternalGrammar = function(e4, t3) {
          if (this._includedGrammars[e4])
            return this._includedGrammars[e4];
          if (this._grammarRepository) {
            var n3 = this._grammarRepository.lookup(e4);
            if (n3)
              return this._includedGrammars[e4] = C2(n3, t3 && t3.$base), this._includedGrammars[e4];
          }
          return null;
        }, e3.prototype.tokenizeLine = function(e4, t3) {
          var n3 = this._tokenize(e4, t3, false);
          return { tokens: n3.lineTokens.getResult(n3.ruleStack, n3.lineLength), ruleStack: n3.ruleStack };
        }, e3.prototype.tokenizeLine2 = function(e4, t3) {
          var n3 = this._tokenize(e4, t3, true);
          return { tokens: n3.lineTokens.getBinaryResult(n3.ruleStack, n3.lineLength), ruleStack: n3.ruleStack };
        }, e3.prototype._tokenize = function(e4, t3, n3) {
          var r3;
          if (-1 === this._rootId && (this._rootId = i2.RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository)), t3 && t3 !== I2.NULL)
            r3 = false, t3.reset();
          else {
            r3 = true;
            var o3 = this._scopeMetadataProvider.getDefaultMetadata(), s3 = o3.themeData[0], a3 = P2.set(0, o3.languageId, o3.tokenType, s3.fontStyle, s3.foreground, s3.background), c3 = this.getRule(this._rootId).getName(null, null), u3 = this._scopeMetadataProvider.getMetadataForScope(c3), l3 = x2.mergeMetadata(a3, null, u3), h3 = new x2(null, null === c3 ? "unknown" : c3, l3);
            t3 = new I2(null, this._rootId, -1, -1, false, null, h3, h3);
          }
          e4 += "\n";
          var p3 = this.createOnigString(e4), f3 = p3.content.length, d3 = new T2(n3, e4, this._tokenTypeMatchers), g3 = S2(this, p3, r3, 0, t3, d3, true);
          return b2(p3), { lineLength: f3, lineTokens: d3, ruleStack: g3 };
        }, e3;
      }();
      function b2(e3) {
        "function" == typeof e3.dispose && e3.dispose();
      }
      function C2(e3, t3) {
        return (e3 = r2.clone(e3)).repository = e3.repository || {}, e3.repository.$self = { $vscodeTextmateLocation: e3.$vscodeTextmateLocation, patterns: e3.patterns, name: e3.scopeName }, e3.repository.$base = t3 || e3.repository.$self, e3;
      }
      function w2(e3, t3, n3, r3, i3, o3, s3) {
        if (0 !== o3.length) {
          for (var a3 = t3.content, c3 = Math.min(o3.length, s3.length), u3 = [], l3 = s3[0].end, h3 = 0; h3 < c3; h3++) {
            var p3 = o3[h3];
            if (null !== p3) {
              var f3 = s3[h3];
              if (0 !== f3.length) {
                if (f3.start > l3)
                  break;
                for (; u3.length > 0 && u3[u3.length - 1].endPos <= f3.start; )
                  i3.produceFromScopes(u3[u3.length - 1].scopes, u3[u3.length - 1].endPos), u3.pop();
                if (u3.length > 0 ? i3.produceFromScopes(u3[u3.length - 1].scopes, f3.start) : i3.produce(r3, f3.start), p3.retokenizeCapturedWithRuleId) {
                  var d3 = p3.getName(a3, s3), g3 = r3.contentNameScopesList.push(e3, d3), m3 = p3.getContentName(a3, s3), _3 = g3.push(e3, m3), y3 = r3.push(p3.retokenizeCapturedWithRuleId, f3.start, -1, false, null, g3, _3), v3 = e3.createOnigString(a3.substring(0, f3.end));
                  S2(e3, v3, n3 && 0 === f3.start, f3.start, y3, i3, false), b2(v3);
                } else {
                  var C3 = p3.getName(a3, s3);
                  if (null !== C3) {
                    var w3 = (u3.length > 0 ? u3[u3.length - 1].scopes : r3.contentNameScopesList).push(e3, C3);
                    u3.push(new A2(w3, f3.end));
                  }
                }
              }
            }
          }
          for (; u3.length > 0; )
            i3.produceFromScopes(u3[u3.length - 1].scopes, u3[u3.length - 1].endPos), u3.pop();
        }
      }
      function k2(e3) {
        for (var t3 = [], n3 = 0, r3 = e3.rules.length; n3 < r3; n3++)
          t3.push("   - " + e3.rules[n3] + ": " + e3.debugRegExps[n3]);
        return t3.join("\n");
      }
      function R2(e3, t3, n3, r3, i3, o3) {
        var c3 = function(e4, t4, n4, r4, i4, o4) {
          var c4 = i4.getRule(e4), u4 = c4.compile(e4, i4.endRule, n4, r4 === o4), l4 = 0;
          s2.DebugFlags.InDebugMode && (l4 = a2());
          var h4 = u4.scanner.findNextMatchSync(t4, r4);
          if (s2.DebugFlags.InDebugMode) {
            var p4 = a2() - l4;
            p4 > 5 && console.warn("Rule " + c4.debugName + " (" + c4.id + ") matching took " + p4 + " against '" + t4 + "'"), h4 && console.log("matched rule id: " + u4.rules[h4.index] + " from " + h4.captureIndices[0].start + " to " + h4.captureIndices[0].end);
          }
          return h4 ? { captureIndices: h4.captureIndices, matchedRuleId: u4.rules[h4.index] } : null;
        }(e3, t3, n3, r3, i3, o3), u3 = e3.getInjections();
        if (0 === u3.length)
          return c3;
        var l3 = function(e4, t4, n4, r4, i4, o4, a3) {
          for (var c4, u4 = Number.MAX_VALUE, l4 = null, h4 = 0, p4 = o4.contentNameScopesList.generateScopes(), f3 = 0, d3 = e4.length; f3 < d3; f3++) {
            var g3 = e4[f3];
            if (g3.matcher(p4)) {
              var m3 = t4.getRule(g3.ruleId).compile(t4, null, r4, i4 === a3), _3 = m3.scanner.findNextMatchSync(n4, i4);
              if (s2.DebugFlags.InDebugMode && (console.log("  scanning for injections"), console.log(k2(m3))), _3) {
                var y3 = _3.captureIndices[0].start;
                if (!(y3 >= u4) && (u4 = y3, l4 = _3.captureIndices, c4 = m3.rules[_3.index], h4 = g3.priority, u4 === i4))
                  break;
              }
            }
          }
          return l4 ? { priorityMatch: -1 === h4, captureIndices: l4, matchedRuleId: c4 } : null;
        }(u3, e3, t3, n3, r3, i3, o3);
        if (!l3)
          return c3;
        if (!c3)
          return l3;
        var h3 = c3.captureIndices[0].start, p3 = l3.captureIndices[0].start;
        return p3 < h3 || l3.priorityMatch && p3 === h3 ? l3 : c3;
      }
      function S2(e3, t3, n3, r3, o3, a3, c3) {
        var u3 = t3.content.length, l3 = false, h3 = -1;
        if (c3) {
          var p3 = function(e4, t4, n4, r4, o4, a4) {
            for (var c4 = o4.beginRuleCapturedEOL ? 0 : -1, u4 = [], l4 = o4; l4; l4 = l4.pop()) {
              var h4 = l4.getRule(e4);
              h4 instanceof i2.BeginWhileRule && u4.push({ rule: h4, stack: l4 });
            }
            for (var p4 = u4.pop(); p4; p4 = u4.pop()) {
              var f4 = p4.rule.compileWhile(e4, p4.stack.endRule, n4, c4 === r4), d3 = f4.scanner.findNextMatchSync(t4, r4);
              if (s2.DebugFlags.InDebugMode && (console.log("  scanning for while rule"), console.log(k2(f4))), !d3) {
                s2.DebugFlags.InDebugMode && console.log("  popping " + p4.rule.debugName + " - " + p4.rule.debugWhileRegExp), o4 = p4.stack.pop();
                break;
              }
              if (-2 !== f4.rules[d3.index]) {
                o4 = p4.stack.pop();
                break;
              }
              d3.captureIndices && d3.captureIndices.length && (a4.produce(p4.stack, d3.captureIndices[0].start), w2(e4, t4, n4, p4.stack, a4, p4.rule.whileCaptures, d3.captureIndices), a4.produce(p4.stack, d3.captureIndices[0].end), c4 = d3.captureIndices[0].end, d3.captureIndices[0].end > r4 && (r4 = d3.captureIndices[0].end, n4 = false));
            }
            return { stack: o4, linePos: r4, anchorPosition: c4, isFirstLine: n4 };
          }(e3, t3, n3, r3, o3, a3);
          o3 = p3.stack, r3 = p3.linePos, n3 = p3.isFirstLine, h3 = p3.anchorPosition;
        }
        for (; !l3; )
          f3();
        function f3() {
          s2.DebugFlags.InDebugMode && (console.log(""), console.log("@@scanNext " + r3 + ": |" + t3.content.substr(r3).replace(/\n$/, "\\n") + "|"));
          var c4 = R2(e3, t3, n3, r3, o3, h3);
          if (!c4)
            return s2.DebugFlags.InDebugMode && console.log("  no more matches."), a3.produce(o3, u3), void (l3 = true);
          var p4 = c4.captureIndices, f4 = c4.matchedRuleId, d3 = !!(p4 && p4.length > 0) && p4[0].end > r3;
          if (-1 === f4) {
            var g3 = o3.getRule(e3);
            s2.DebugFlags.InDebugMode && console.log("  popping " + g3.debugName + " - " + g3.debugEndRegExp), a3.produce(o3, p4[0].start), o3 = o3.setContentNameScopesList(o3.nameScopesList), w2(e3, t3, n3, o3, a3, g3.endCaptures, p4), a3.produce(o3, p4[0].end);
            var m3 = o3;
            if (o3 = o3.pop(), h3 = m3.getAnchorPos(), !d3 && m3.getEnterPos() === r3)
              return s2.DebugFlags.InDebugMode && console.error("[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing"), o3 = m3, a3.produce(o3, u3), void (l3 = true);
          } else {
            var _3 = e3.getRule(f4);
            a3.produce(o3, p4[0].start);
            var y3 = o3, v3 = _3.getName(t3.content, p4), b3 = o3.contentNameScopesList.push(e3, v3);
            if (o3 = o3.push(f4, r3, h3, p4[0].end === u3, null, b3, b3), _3 instanceof i2.BeginEndRule) {
              var C3 = _3;
              s2.DebugFlags.InDebugMode && console.log("  pushing " + C3.debugName + " - " + C3.debugBeginRegExp), w2(e3, t3, n3, o3, a3, C3.beginCaptures, p4), a3.produce(o3, p4[0].end), h3 = p4[0].end;
              var k3 = C3.getContentName(t3.content, p4), S3 = b3.push(e3, k3);
              if (o3 = o3.setContentNameScopesList(S3), C3.endHasBackReferences && (o3 = o3.setEndRule(C3.getEndWithResolvedBackReferences(t3.content, p4))), !d3 && y3.hasSameRuleAs(o3))
                return s2.DebugFlags.InDebugMode && console.error("[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), o3 = o3.pop(), a3.produce(o3, u3), void (l3 = true);
            } else if (_3 instanceof i2.BeginWhileRule) {
              C3 = _3;
              s2.DebugFlags.InDebugMode && console.log("  pushing " + C3.debugName), w2(e3, t3, n3, o3, a3, C3.beginCaptures, p4), a3.produce(o3, p4[0].end), h3 = p4[0].end;
              k3 = C3.getContentName(t3.content, p4), S3 = b3.push(e3, k3);
              if (o3 = o3.setContentNameScopesList(S3), C3.whileHasBackReferences && (o3 = o3.setEndRule(C3.getWhileWithResolvedBackReferences(t3.content, p4))), !d3 && y3.hasSameRuleAs(o3))
                return s2.DebugFlags.InDebugMode && console.error("[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), o3 = o3.pop(), a3.produce(o3, u3), void (l3 = true);
            } else {
              var P3 = _3;
              if (s2.DebugFlags.InDebugMode && console.log("  matched " + P3.debugName + " - " + P3.debugMatchRegExp), w2(e3, t3, n3, o3, a3, P3.captures, p4), a3.produce(o3, p4[0].end), o3 = o3.pop(), !d3)
                return s2.DebugFlags.InDebugMode && console.error("[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping"), o3 = o3.safePop(), a3.produce(o3, u3), void (l3 = true);
            }
          }
          p4[0].end > r3 && (r3 = p4[0].end, n3 = false);
        }
        return o3;
      }
      t2.Grammar = v2;
      var P2 = function() {
        function e3() {
        }
        return e3.toBinaryStr = function(e4) {
          for (var t3 = e4.toString(2); t3.length < 32; )
            t3 = "0" + t3;
          return t3;
        }, e3.printMetadata = function(t3) {
          var n3 = e3.getLanguageId(t3), r3 = e3.getTokenType(t3), i3 = e3.getFontStyle(t3), o3 = e3.getForeground(t3), s3 = e3.getBackground(t3);
          console.log({ languageId: n3, tokenType: r3, fontStyle: i3, foreground: o3, background: s3 });
        }, e3.getLanguageId = function(e4) {
          return (255 & e4) >>> 0;
        }, e3.getTokenType = function(e4) {
          return (1792 & e4) >>> 8;
        }, e3.getFontStyle = function(e4) {
          return (14336 & e4) >>> 11;
        }, e3.getForeground = function(e4) {
          return (8372224 & e4) >>> 14;
        }, e3.getBackground = function(e4) {
          return (4286578688 & e4) >>> 23;
        }, e3.set = function(t3, n3, r3, i3, o3, s3) {
          var a3 = e3.getLanguageId(t3), c3 = e3.getTokenType(t3), u3 = e3.getFontStyle(t3), l3 = e3.getForeground(t3), h3 = e3.getBackground(t3);
          return 0 !== n3 && (a3 = n3), 0 !== r3 && (c3 = 8 === r3 ? 0 : r3), -1 !== i3 && (u3 = i3), 0 !== o3 && (l3 = o3), 0 !== s3 && (h3 = s3), (a3 << 0 | c3 << 8 | u3 << 11 | l3 << 14 | h3 << 23) >>> 0;
        }, e3;
      }();
      t2.StackElementMetadata = P2;
      var x2 = function() {
        function e3(e4, t3, n3) {
          this.parent = e4, this.scope = t3, this.metadata = n3;
        }
        return e3._equals = function(e4, t3) {
          for (; ; ) {
            if (e4 === t3)
              return true;
            if (!e4 && !t3)
              return true;
            if (!e4 || !t3)
              return false;
            if (e4.scope !== t3.scope || e4.metadata !== t3.metadata)
              return false;
            e4 = e4.parent, t3 = t3.parent;
          }
        }, e3.prototype.equals = function(t3) {
          return e3._equals(this, t3);
        }, e3._matchesScope = function(e4, t3, n3) {
          return t3 === e4 || e4.substring(0, n3.length) === n3;
        }, e3._matches = function(e4, t3) {
          if (null === t3)
            return true;
          for (var n3 = t3.length, r3 = 0, i3 = t3[r3], o3 = i3 + "."; e4; ) {
            if (this._matchesScope(e4.scope, i3, o3)) {
              if (++r3 === n3)
                return true;
              o3 = (i3 = t3[r3]) + ".";
            }
            e4 = e4.parent;
          }
          return false;
        }, e3.mergeMetadata = function(e4, t3, n3) {
          if (null === n3)
            return e4;
          var r3 = -1, i3 = 0, o3 = 0;
          if (null !== n3.themeData)
            for (var s3 = 0, a3 = n3.themeData.length; s3 < a3; s3++) {
              var c3 = n3.themeData[s3];
              if (this._matches(t3, c3.parentScopes)) {
                r3 = c3.fontStyle, i3 = c3.foreground, o3 = c3.background;
                break;
              }
            }
          return P2.set(e4, n3.languageId, n3.tokenType, r3, i3, o3);
        }, e3._push = function(t3, n3, r3) {
          for (var i3 = 0, o3 = r3.length; i3 < o3; i3++) {
            var s3 = r3[i3], a3 = n3.getMetadataForScope(s3), c3 = e3.mergeMetadata(t3.metadata, t3, a3);
            t3 = new e3(t3, s3, c3);
          }
          return t3;
        }, e3.prototype.push = function(t3, n3) {
          return null === n3 ? this : n3.indexOf(" ") >= 0 ? e3._push(this, t3, n3.split(/ /g)) : e3._push(this, t3, [n3]);
        }, e3._generateScopes = function(e4) {
          for (var t3 = [], n3 = 0; e4; )
            t3[n3++] = e4.scope, e4 = e4.parent;
          return t3.reverse(), t3;
        }, e3.prototype.generateScopes = function() {
          return e3._generateScopes(this);
        }, e3;
      }();
      t2.ScopeListElement = x2;
      var I2 = function() {
        function e3(e4, t3, n3, r3, i3, o3, s3, a3) {
          this.parent = e4, this.depth = this.parent ? this.parent.depth + 1 : 1, this.ruleId = t3, this._enterPos = n3, this._anchorPos = r3, this.beginRuleCapturedEOL = i3, this.endRule = o3, this.nameScopesList = s3, this.contentNameScopesList = a3;
        }
        return e3._structuralEquals = function(e4, t3) {
          for (; ; ) {
            if (e4 === t3)
              return true;
            if (!e4 && !t3)
              return true;
            if (!e4 || !t3)
              return false;
            if (e4.depth !== t3.depth || e4.ruleId !== t3.ruleId || e4.endRule !== t3.endRule)
              return false;
            e4 = e4.parent, t3 = t3.parent;
          }
        }, e3._equals = function(e4, t3) {
          return e4 === t3 || !!this._structuralEquals(e4, t3) && e4.contentNameScopesList.equals(t3.contentNameScopesList);
        }, e3.prototype.clone = function() {
          return this;
        }, e3.prototype.equals = function(t3) {
          return null !== t3 && e3._equals(this, t3);
        }, e3._reset = function(e4) {
          for (; e4; )
            e4._enterPos = -1, e4._anchorPos = -1, e4 = e4.parent;
        }, e3.prototype.reset = function() {
          e3._reset(this);
        }, e3.prototype.pop = function() {
          return this.parent;
        }, e3.prototype.safePop = function() {
          return this.parent ? this.parent : this;
        }, e3.prototype.push = function(t3, n3, r3, i3, o3, s3, a3) {
          return new e3(this, t3, n3, r3, i3, o3, s3, a3);
        }, e3.prototype.getEnterPos = function() {
          return this._enterPos;
        }, e3.prototype.getAnchorPos = function() {
          return this._anchorPos;
        }, e3.prototype.getRule = function(e4) {
          return e4.getRule(this.ruleId);
        }, e3.prototype._writeString = function(e4, t3) {
          return this.parent && (t3 = this.parent._writeString(e4, t3)), e4[t3++] = "(" + this.ruleId + ", TODO-" + this.nameScopesList + ", TODO-" + this.contentNameScopesList + ")", t3;
        }, e3.prototype.toString = function() {
          var e4 = [];
          return this._writeString(e4, 0), "[" + e4.join(",") + "]";
        }, e3.prototype.setContentNameScopesList = function(e4) {
          return this.contentNameScopesList === e4 ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, e4);
        }, e3.prototype.setEndRule = function(t3) {
          return this.endRule === t3 ? this : new e3(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, t3, this.nameScopesList, this.contentNameScopesList);
        }, e3.prototype.hasSameRuleAs = function(e4) {
          return this.ruleId === e4.ruleId;
        }, e3.NULL = new e3(null, 0, 0, 0, false, null, null, null), e3;
      }();
      t2.StackElement = I2;
      var A2 = function(e3, t3) {
        this.scopes = e3, this.endPos = t3;
      };
      t2.LocalStackElement = A2;
      var T2 = function() {
        function e3(e4, t3, n3) {
          this._emitBinaryTokens = e4, this._tokenTypeOverrides = n3, s2.DebugFlags.InDebugMode ? this._lineText = t3 : this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
        }
        return e3.prototype.produce = function(e4, t3) {
          this.produceFromScopes(e4.contentNameScopesList, t3);
        }, e3.prototype.produceFromScopes = function(e4, t3) {
          if (!(this._lastTokenEndIndex >= t3)) {
            if (this._emitBinaryTokens) {
              for (var n3 = e4.metadata, r3 = 0, i3 = this._tokenTypeOverrides; r3 < i3.length; r3++) {
                var o3 = i3[r3];
                o3.matcher(e4.generateScopes()) && (n3 = P2.set(n3, 0, L2(o3.type), -1, 0, 0));
              }
              return this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === n3 || (this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(n3)), void (this._lastTokenEndIndex = t3);
            }
            var a3 = e4.generateScopes();
            if (s2.DebugFlags.InDebugMode) {
              console.log("  token: |" + this._lineText.substring(this._lastTokenEndIndex, t3).replace(/\n$/, "\\n") + "|");
              for (var c3 = 0; c3 < a3.length; c3++)
                console.log("      * " + a3[c3]);
            }
            this._tokens.push({ startIndex: this._lastTokenEndIndex, endIndex: t3, scopes: a3 }), this._lastTokenEndIndex = t3;
          }
        }, e3.prototype.getResult = function(e4, t3) {
          return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t3 - 1 && this._tokens.pop(), 0 === this._tokens.length && (this._lastTokenEndIndex = -1, this.produce(e4, t3), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
        }, e3.prototype.getBinaryResult = function(e4, t3) {
          this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t3 - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), 0 === this._binaryTokens.length && (this._lastTokenEndIndex = -1, this.produce(e4, t3), this._binaryTokens[this._binaryTokens.length - 2] = 0);
          for (var n3 = new Uint32Array(this._binaryTokens.length), r3 = 0, i3 = this._binaryTokens.length; r3 < i3; r3++)
            n3[r3] = this._binaryTokens[r3];
          return n3;
        }, e3;
      }();
      function L2(e3) {
        switch (e3) {
          case 4:
            return 4;
          case 2:
            return 2;
          case 1:
            return 1;
          case 0:
          default:
            return 8;
        }
      }
    }, function(e2, t2, n2) {
      function r2(e3) {
        return Array.isArray(e3) ? function(e4) {
          for (var t3 = [], n3 = 0, i3 = e4.length; n3 < i3; n3++)
            t3[n3] = r2(e4[n3]);
          return t3;
        }(e3) : "object" == typeof e3 ? function(e4) {
          var t3 = {};
          for (var n3 in e4)
            t3[n3] = r2(e4[n3]);
          return t3;
        }(e3) : e3;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = function(e3) {
        return r2(e3);
      }, t2.mergeObjects = function(e3) {
        for (var t3 = [], n3 = 1; n3 < arguments.length; n3++)
          t3[n3 - 1] = arguments[n3];
        return t3.forEach(function(t4) {
          for (var n4 in t4)
            e3[n4] = t4[n4];
        }), e3;
      }, t2.basename = function e3(t3) {
        var n3 = ~t3.lastIndexOf("/") || ~t3.lastIndexOf("\\");
        return 0 === n3 ? t3 : ~n3 == t3.length - 1 ? e3(t3.substring(0, t3.length - 1)) : t3.substr(1 + ~n3);
      };
      var i2 = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/, o2 = function() {
        function e3() {
        }
        return e3.hasCaptures = function(e4) {
          return null !== e4 && i2.test(e4);
        }, e3.replaceCaptures = function(e4, t3, n3) {
          return e4.replace(i2, function(e5, r3, i3, o3) {
            var s2 = n3[parseInt(r3 || i3, 10)];
            if (!s2)
              return e5;
            for (var a2 = t3.substring(s2.start, s2.end); "." === a2[0]; )
              a2 = a2.substring(1);
            switch (o3) {
              case "downcase":
                return a2.toLowerCase();
              case "upcase":
                return a2.toUpperCase();
              default:
                return a2;
            }
          });
        }, e3;
      }();
      t2.RegexSource = o2;
    }, function(e2, t2, n2) {
      (function(e3) {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DebugFlags = { InDebugMode: void 0 !== e3 && !!e3.env.VSCODE_TEXTMATE_DEBUG };
      }).call(this, n2(7));
    }, function(e2, t2, n2) {
      var r2 = this && this.__awaiter || function(e3, t3, n3, r3) {
        return new (n3 || (n3 = Promise))(function(i3, o3) {
          function s3(e4) {
            try {
              c3(r3.next(e4));
            } catch (e5) {
              o3(e5);
            }
          }
          function a3(e4) {
            try {
              c3(r3.throw(e4));
            } catch (e5) {
              o3(e5);
            }
          }
          function c3(e4) {
            var t4;
            e4.done ? i3(e4.value) : (t4 = e4.value, t4 instanceof n3 ? t4 : new n3(function(e5) {
              e5(t4);
            })).then(s3, a3);
          }
          c3((r3 = r3.apply(e3, t3 || [])).next());
        });
      }, i2 = this && this.__generator || function(e3, t3) {
        var n3, r3, i3, o3, s3 = { label: 0, sent: function() {
          if (1 & i3[0])
            throw i3[1];
          return i3[1];
        }, trys: [], ops: [] };
        return o3 = { next: a3(0), throw: a3(1), return: a3(2) }, "function" == typeof Symbol && (o3[Symbol.iterator] = function() {
          return this;
        }), o3;
        function a3(o4) {
          return function(a4) {
            return function(o5) {
              if (n3)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (n3 = 1, r3 && (i3 = 2 & o5[0] ? r3.return : o5[0] ? r3.throw || ((i3 = r3.return) && i3.call(r3), 0) : r3.next) && !(i3 = i3.call(r3, o5[1])).done)
                    return i3;
                  switch (r3 = 0, i3 && (o5 = [2 & o5[0], i3.value]), o5[0]) {
                    case 0:
                    case 1:
                      i3 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, r3 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(i3 = s3.trys, (i3 = i3.length > 0 && i3[i3.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!i3 || o5[1] > i3[0] && o5[1] < i3[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < i3[1]) {
                        s3.label = i3[1], i3 = o5;
                        break;
                      }
                      if (i3 && s3.label < i3[2]) {
                        s3.label = i3[2], s3.ops.push(o5);
                        break;
                      }
                      i3[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = t3.call(e3, s3);
                } catch (e4) {
                  o5 = [6, e4], r3 = 0;
                } finally {
                  n3 = i3 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o4, a4]);
          };
        }
      };
      Object.defineProperty(t2, "__esModule", { value: true });
      var o2 = n2(4), s2 = n2(8), a2 = n2(11), c2 = n2(0), u2 = function() {
        function e3(e4) {
          this._options = e4, this._syncRegistry = new o2.SyncRegistry(a2.Theme.createFromRawTheme(e4.theme, e4.colorMap), e4.onigLib), this._ensureGrammarCache = /* @__PURE__ */ new Map();
        }
        return e3.prototype.dispose = function() {
          this._syncRegistry.dispose();
        }, e3.prototype.setTheme = function(e4, t3) {
          this._syncRegistry.setTheme(a2.Theme.createFromRawTheme(e4, t3));
        }, e3.prototype.getColorMap = function() {
          return this._syncRegistry.getColorMap();
        }, e3.prototype.loadGrammarWithEmbeddedLanguages = function(e4, t3, n3) {
          return this.loadGrammarWithConfiguration(e4, t3, { embeddedLanguages: n3 });
        }, e3.prototype.loadGrammarWithConfiguration = function(e4, t3, n3) {
          return this._loadGrammar(e4, t3, n3.embeddedLanguages, n3.tokenTypes);
        }, e3.prototype.loadGrammar = function(e4) {
          return this._loadGrammar(e4, 0, null, null);
        }, e3.prototype._doLoadSingleGrammar = function(e4) {
          return r2(this, void 0, void 0, function() {
            var t3, n3;
            return i2(this, function(r3) {
              switch (r3.label) {
                case 0:
                  return [4, this._options.loadGrammar(e4)];
                case 1:
                  return (t3 = r3.sent()) && (n3 = "function" == typeof this._options.getInjections ? this._options.getInjections(e4) : void 0, this._syncRegistry.addGrammar(t3, n3)), [2];
              }
            });
          });
        }, e3.prototype._loadSingleGrammar = function(e4) {
          return r2(this, void 0, void 0, function() {
            return i2(this, function(t3) {
              return this._ensureGrammarCache.has(e4) || this._ensureGrammarCache.set(e4, this._doLoadSingleGrammar(e4)), [2, this._ensureGrammarCache.get(e4)];
            });
          });
        }, e3.prototype._collectDependenciesForDep = function(e4, t3, n3) {
          var r3 = this._syncRegistry.lookup(n3.scopeName);
          if (r3) {
            n3 instanceof c2.FullScopeDependency ? c2.collectDependencies(t3, this._syncRegistry.lookup(e4), r3) : c2.collectSpecificDependencies(t3, this._syncRegistry.lookup(e4), r3, n3.include);
            var i3 = this._syncRegistry.injections(n3.scopeName);
            if (i3)
              for (var o3 = 0, s3 = i3; o3 < s3.length; o3++) {
                var a3 = s3[o3];
                t3.add(new c2.FullScopeDependency(a3));
              }
          } else if (n3.scopeName === e4)
            throw new Error("No grammar provided for <" + e4 + ">");
        }, e3.prototype._loadGrammar = function(e4, t3, n3, o3) {
          return r2(this, void 0, void 0, function() {
            var r3, s3, a3, u3, l2, h2, p2, f2, d2, g2, m2, _2, y2 = this;
            return i2(this, function(i3) {
              switch (i3.label) {
                case 0:
                  r3 = /* @__PURE__ */ new Set(), s3 = /* @__PURE__ */ new Set(), r3.add(e4), a3 = [new c2.FullScopeDependency(e4)], i3.label = 1;
                case 1:
                  return a3.length > 0 ? (u3 = a3, a3 = [], [4, Promise.all(u3.map(function(e5) {
                    return y2._loadSingleGrammar(e5.scopeName);
                  }))]) : [3, 3];
                case 2:
                  for (i3.sent(), l2 = new c2.ScopeDependencyCollector(), h2 = 0, p2 = u3; h2 < p2.length; h2++)
                    _2 = p2[h2], this._collectDependenciesForDep(e4, l2, _2);
                  for (f2 = 0, d2 = l2.full; f2 < d2.length; f2++)
                    _2 = d2[f2], r3.has(_2.scopeName) || (r3.add(_2.scopeName), a3.push(_2));
                  for (g2 = 0, m2 = l2.partial; g2 < m2.length; g2++)
                    _2 = m2[g2], r3.has(_2.scopeName) || s3.has(_2.toKey()) || (s3.add(_2.toKey()), a3.push(_2));
                  return [3, 1];
                case 3:
                  return [2, this.grammarForScopeName(e4, t3, n3, o3)];
              }
            });
          });
        }, e3.prototype.addGrammar = function(e4, t3, n3, o3) {
          return void 0 === t3 && (t3 = []), void 0 === n3 && (n3 = 0), void 0 === o3 && (o3 = null), r2(this, void 0, void 0, function() {
            return i2(this, function(r3) {
              switch (r3.label) {
                case 0:
                  return this._syncRegistry.addGrammar(e4, t3), [4, this.grammarForScopeName(e4.scopeName, n3, o3)];
                case 1:
                  return [2, r3.sent()];
              }
            });
          });
        }, e3.prototype.grammarForScopeName = function(e4, t3, n3, r3) {
          return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = null), void 0 === r3 && (r3 = null), this._syncRegistry.grammarForScopeName(e4, t3, n3, r3);
        }, e3;
      }();
      t2.Registry = u2, t2.INITIAL = c2.StackElement.NULL, t2.parseRawGrammar = s2.parseRawGrammar;
    }, function(e2, t2, n2) {
      var r2 = this && this.__awaiter || function(e3, t3, n3, r3) {
        return new (n3 || (n3 = Promise))(function(i3, o3) {
          function s3(e4) {
            try {
              c2(r3.next(e4));
            } catch (e5) {
              o3(e5);
            }
          }
          function a2(e4) {
            try {
              c2(r3.throw(e4));
            } catch (e5) {
              o3(e5);
            }
          }
          function c2(e4) {
            var t4;
            e4.done ? i3(e4.value) : (t4 = e4.value, t4 instanceof n3 ? t4 : new n3(function(e5) {
              e5(t4);
            })).then(s3, a2);
          }
          c2((r3 = r3.apply(e3, t3 || [])).next());
        });
      }, i2 = this && this.__generator || function(e3, t3) {
        var n3, r3, i3, o3, s3 = { label: 0, sent: function() {
          if (1 & i3[0])
            throw i3[1];
          return i3[1];
        }, trys: [], ops: [] };
        return o3 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o3[Symbol.iterator] = function() {
          return this;
        }), o3;
        function a2(o4) {
          return function(a3) {
            return function(o5) {
              if (n3)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (n3 = 1, r3 && (i3 = 2 & o5[0] ? r3.return : o5[0] ? r3.throw || ((i3 = r3.return) && i3.call(r3), 0) : r3.next) && !(i3 = i3.call(r3, o5[1])).done)
                    return i3;
                  switch (r3 = 0, i3 && (o5 = [2 & o5[0], i3.value]), o5[0]) {
                    case 0:
                    case 1:
                      i3 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, r3 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(i3 = s3.trys, (i3 = i3.length > 0 && i3[i3.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!i3 || o5[1] > i3[0] && o5[1] < i3[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < i3[1]) {
                        s3.label = i3[1], i3 = o5;
                        break;
                      }
                      if (i3 && s3.label < i3[2]) {
                        s3.label = i3[2], s3.ops.push(o5);
                        break;
                      }
                      i3[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = t3.call(e3, s3);
                } catch (e4) {
                  o5 = [6, e4], r3 = 0;
                } finally {
                  n3 = i3 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o4, a3]);
          };
        }
      };
      Object.defineProperty(t2, "__esModule", { value: true });
      var o2 = n2(0), s2 = function() {
        function e3(e4, t3) {
          this._theme = e4, this._grammars = {}, this._rawGrammars = {}, this._injectionGrammars = {}, this._onigLibPromise = t3;
        }
        return e3.prototype.dispose = function() {
          for (var e4 in this._grammars)
            this._grammars.hasOwnProperty(e4) && this._grammars[e4].dispose();
        }, e3.prototype.setTheme = function(e4) {
          var t3 = this;
          this._theme = e4, Object.keys(this._grammars).forEach(function(e5) {
            t3._grammars[e5].onDidChangeTheme();
          });
        }, e3.prototype.getColorMap = function() {
          return this._theme.getColorMap();
        }, e3.prototype.addGrammar = function(e4, t3) {
          this._rawGrammars[e4.scopeName] = e4, t3 && (this._injectionGrammars[e4.scopeName] = t3);
        }, e3.prototype.lookup = function(e4) {
          return this._rawGrammars[e4];
        }, e3.prototype.injections = function(e4) {
          return this._injectionGrammars[e4];
        }, e3.prototype.getDefaults = function() {
          return this._theme.getDefaults();
        }, e3.prototype.themeMatch = function(e4) {
          return this._theme.match(e4);
        }, e3.prototype.grammarForScopeName = function(e4, t3, n3, s3) {
          return r2(this, void 0, void 0, function() {
            var r3, a2, c2, u2, l2;
            return i2(this, function(i3) {
              switch (i3.label) {
                case 0:
                  return this._grammars[e4] ? [3, 2] : (r3 = this._rawGrammars[e4]) ? (a2 = this._grammars, c2 = e4, u2 = o2.createGrammar, l2 = [r3, t3, n3, s3, this], [4, this._onigLibPromise]) : [2, null];
                case 1:
                  a2[c2] = u2.apply(void 0, l2.concat([i3.sent()])), i3.label = 2;
                case 2:
                  return [2, this._grammars[e4]];
              }
            });
          });
        }, e3;
      }();
      t2.SyncRegistry = s2;
    }, function(e2, t2, n2) {
      var r2, i2 = this && this.__extends || (r2 = function(e3, t3) {
        return (r2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
          e4.__proto__ = t4;
        } || function(e4, t4) {
          for (var n3 in t4)
            t4.hasOwnProperty(n3) && (e4[n3] = t4[n3]);
        })(e3, t3);
      }, function(e3, t3) {
        function n3() {
          this.constructor = e3;
        }
        r2(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (n3.prototype = t3.prototype, new n3());
      });
      Object.defineProperty(t2, "__esModule", { value: true });
      var o2 = n2(1), s2 = /\\(\d+)/, a2 = /\\(\d+)/g, c2 = function() {
        function e3(e4, t3, n3) {
          this.debugRegExps = t3, this.rules = n3, this.scanner = e4.createOnigScanner(t3);
        }
        return e3.prototype.dispose = function() {
          "function" == typeof this.scanner.dispose && this.scanner.dispose();
        }, e3;
      }();
      t2.CompiledRule = c2;
      var u2 = function() {
        function e3(e4, t3, n3, r3) {
          this.$location = e4, this.id = t3, this._name = n3 || null, this._nameIsCapturing = o2.RegexSource.hasCaptures(this._name), this._contentName = r3 || null, this._contentNameIsCapturing = o2.RegexSource.hasCaptures(this._contentName);
        }
        return Object.defineProperty(e3.prototype, "debugName", { get: function() {
          var e4 = this.$location ? o2.basename(this.$location.filename) + ":" + this.$location.line : "unknown";
          return this.constructor.name + "#" + this.id + " @ " + e4;
        }, enumerable: true, configurable: true }), e3.prototype.getName = function(e4, t3) {
          return this._nameIsCapturing && null !== this._name && null !== e4 && null !== t3 ? o2.RegexSource.replaceCaptures(this._name, e4, t3) : this._name;
        }, e3.prototype.getContentName = function(e4, t3) {
          return this._contentNameIsCapturing && null !== this._contentName ? o2.RegexSource.replaceCaptures(this._contentName, e4, t3) : this._contentName;
        }, e3;
      }();
      t2.Rule = u2;
      var l2 = function(e3) {
        function t3(t4, n3, r3, i3, o3) {
          var s3 = e3.call(this, t4, n3, r3, i3) || this;
          return s3.retokenizeCapturedWithRuleId = o3, s3;
        }
        return i2(t3, e3), t3.prototype.dispose = function() {
        }, t3.prototype.collectPatternsRecursive = function(e4, t4, n3) {
          throw new Error("Not supported!");
        }, t3.prototype.compile = function(e4, t4, n3, r3) {
          throw new Error("Not supported!");
        }, t3;
      }(u2);
      t2.CaptureRule = l2;
      var h2 = function() {
        function e3(e4, t3, n3) {
          if (void 0 === n3 && (n3 = true), n3)
            if (e4) {
              for (var r3 = e4.length, i3 = 0, o3 = [], a3 = false, c3 = 0; c3 < r3; c3++) {
                if ("\\" === e4.charAt(c3) && c3 + 1 < r3) {
                  var u3 = e4.charAt(c3 + 1);
                  "z" === u3 ? (o3.push(e4.substring(i3, c3)), o3.push("$(?!\\n)(?<!\\n)"), i3 = c3 + 2) : "A" !== u3 && "G" !== u3 || (a3 = true), c3++;
                }
              }
              this.hasAnchor = a3, 0 === i3 ? this.source = e4 : (o3.push(e4.substring(i3, r3)), this.source = o3.join(""));
            } else
              this.hasAnchor = false, this.source = e4;
          else
            this.hasAnchor = false, this.source = e4;
          this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = t3, this.hasBackReferences = s2.test(this.source);
        }
        return e3.prototype.clone = function() {
          return new e3(this.source, this.ruleId, true);
        }, e3.prototype.setSource = function(e4) {
          this.source !== e4 && (this.source = e4, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
        }, e3.prototype.resolveBackReferences = function(e4, t3) {
          var n3 = t3.map(function(t4) {
            return e4.substring(t4.start, t4.end);
          });
          return a2.lastIndex = 0, this.source.replace(a2, function(e5, t4) {
            return (n3[parseInt(t4, 10)] || "").replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
          });
        }, e3.prototype._buildAnchorCache = function() {
          var e4, t3, n3, r3, i3 = [], o3 = [], s3 = [], a3 = [];
          for (e4 = 0, t3 = this.source.length; e4 < t3; e4++)
            n3 = this.source.charAt(e4), i3[e4] = n3, o3[e4] = n3, s3[e4] = n3, a3[e4] = n3, "\\" === n3 && e4 + 1 < t3 && ("A" === (r3 = this.source.charAt(e4 + 1)) ? (i3[e4 + 1] = "\uFFFF", o3[e4 + 1] = "\uFFFF", s3[e4 + 1] = "A", a3[e4 + 1] = "A") : "G" === r3 ? (i3[e4 + 1] = "\uFFFF", o3[e4 + 1] = "G", s3[e4 + 1] = "\uFFFF", a3[e4 + 1] = "G") : (i3[e4 + 1] = r3, o3[e4 + 1] = r3, s3[e4 + 1] = r3, a3[e4 + 1] = r3), e4++);
          return { A0_G0: i3.join(""), A0_G1: o3.join(""), A1_G0: s3.join(""), A1_G1: a3.join("") };
        }, e3.prototype.resolveAnchors = function(e4, t3) {
          return this.hasAnchor && this._anchorCache ? e4 ? t3 ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : t3 ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0 : this.source;
        }, e3;
      }();
      t2.RegExpSource = h2;
      var p2 = function() {
        function e3() {
          this._items = [], this._hasAnchors = false, this._cached = null, this._anchorCache = { A0_G0: null, A0_G1: null, A1_G0: null, A1_G1: null };
        }
        return e3.prototype.dispose = function() {
          this._disposeCaches();
        }, e3.prototype._disposeCaches = function() {
          this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
        }, e3.prototype.push = function(e4) {
          this._items.push(e4), this._hasAnchors = this._hasAnchors || e4.hasAnchor;
        }, e3.prototype.unshift = function(e4) {
          this._items.unshift(e4), this._hasAnchors = this._hasAnchors || e4.hasAnchor;
        }, e3.prototype.length = function() {
          return this._items.length;
        }, e3.prototype.setSource = function(e4, t3) {
          this._items[e4].source !== t3 && (this._disposeCaches(), this._items[e4].setSource(t3));
        }, e3.prototype.compile = function(e4, t3, n3) {
          if (this._hasAnchors)
            return t3 ? n3 ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e4, t3, n3)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e4, t3, n3)), this._anchorCache.A1_G0) : n3 ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e4, t3, n3)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e4, t3, n3)), this._anchorCache.A0_G0);
          if (!this._cached) {
            var r3 = this._items.map(function(e5) {
              return e5.source;
            });
            this._cached = new c2(e4, r3, this._items.map(function(e5) {
              return e5.ruleId;
            }));
          }
          return this._cached;
        }, e3.prototype._resolveAnchors = function(e4, t3, n3) {
          var r3 = this._items.map(function(e5) {
            return e5.resolveAnchors(t3, n3);
          });
          return new c2(e4, r3, this._items.map(function(e5) {
            return e5.ruleId;
          }));
        }, e3;
      }();
      t2.RegExpSourceList = p2;
      var f2 = function(e3) {
        function t3(t4, n3, r3, i3, o3) {
          var s3 = e3.call(this, t4, n3, r3, null) || this;
          return s3._match = new h2(i3, s3.id), s3.captures = o3, s3._cachedCompiledPatterns = null, s3;
        }
        return i2(t3, e3), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
        }, Object.defineProperty(t3.prototype, "debugMatchRegExp", { get: function() {
          return "" + this._match.source;
        }, enumerable: true, configurable: true }), t3.prototype.collectPatternsRecursive = function(e4, t4, n3) {
          t4.push(this._match);
        }, t3.prototype.compile = function(e4, t4, n3, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e4, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e4, n3, r3);
        }, t3;
      }(u2);
      t2.MatchRule = f2;
      var d2 = function(e3) {
        function t3(t4, n3, r3, i3, o3) {
          var s3 = e3.call(this, t4, n3, r3, i3) || this;
          return s3.patterns = o3.patterns, s3.hasMissingPatterns = o3.hasMissingPatterns, s3._cachedCompiledPatterns = null, s3;
        }
        return i2(t3, e3), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
        }, t3.prototype.collectPatternsRecursive = function(e4, t4, n3) {
          var r3, i3;
          for (r3 = 0, i3 = this.patterns.length; r3 < i3; r3++)
            e4.getRule(this.patterns[r3]).collectPatternsRecursive(e4, t4, false);
        }, t3.prototype.compile = function(e4, t4, n3, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e4, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e4, n3, r3);
        }, t3;
      }(u2);
      t2.IncludeOnlyRule = d2;
      var g2 = function(e3) {
        function t3(t4, n3, r3, i3, o3, s3, a3, c3, u3, l3) {
          var p3 = e3.call(this, t4, n3, r3, i3) || this;
          return p3._begin = new h2(o3, p3.id), p3.beginCaptures = s3, p3._end = new h2(a3 || "\uFFFF", -1), p3.endHasBackReferences = p3._end.hasBackReferences, p3.endCaptures = c3, p3.applyEndPatternLast = u3 || false, p3.patterns = l3.patterns, p3.hasMissingPatterns = l3.hasMissingPatterns, p3._cachedCompiledPatterns = null, p3;
        }
        return i2(t3, e3), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
        }, Object.defineProperty(t3.prototype, "debugBeginRegExp", { get: function() {
          return "" + this._begin.source;
        }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "debugEndRegExp", { get: function() {
          return "" + this._end.source;
        }, enumerable: true, configurable: true }), t3.prototype.getEndWithResolvedBackReferences = function(e4, t4) {
          return this._end.resolveBackReferences(e4, t4);
        }, t3.prototype.collectPatternsRecursive = function(e4, t4, n3) {
          if (n3) {
            var r3, i3 = void 0;
            for (i3 = 0, r3 = this.patterns.length; i3 < r3; i3++)
              e4.getRule(this.patterns[i3]).collectPatternsRecursive(e4, t4, false);
          } else
            t4.push(this._begin);
        }, t3.prototype.compile = function(e4, t4, n3, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e4, this._cachedCompiledPatterns, true), this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end)), this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t4) : this._cachedCompiledPatterns.setSource(0, t4)), this._cachedCompiledPatterns.compile(e4, n3, r3);
        }, t3;
      }(u2);
      t2.BeginEndRule = g2;
      var m2 = function(e3) {
        function t3(t4, n3, r3, i3, o3, s3, a3, c3, u3) {
          var l3 = e3.call(this, t4, n3, r3, i3) || this;
          return l3._begin = new h2(o3, l3.id), l3.beginCaptures = s3, l3.whileCaptures = c3, l3._while = new h2(a3, -2), l3.whileHasBackReferences = l3._while.hasBackReferences, l3.patterns = u3.patterns, l3.hasMissingPatterns = u3.hasMissingPatterns, l3._cachedCompiledPatterns = null, l3._cachedCompiledWhilePatterns = null, l3;
        }
        return i2(t3, e3), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
        }, Object.defineProperty(t3.prototype, "debugBeginRegExp", { get: function() {
          return "" + this._begin.source;
        }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "debugWhileRegExp", { get: function() {
          return "" + this._while.source;
        }, enumerable: true, configurable: true }), t3.prototype.getWhileWithResolvedBackReferences = function(e4, t4) {
          return this._while.resolveBackReferences(e4, t4);
        }, t3.prototype.collectPatternsRecursive = function(e4, t4, n3) {
          if (n3) {
            var r3, i3 = void 0;
            for (i3 = 0, r3 = this.patterns.length; i3 < r3; i3++)
              e4.getRule(this.patterns[i3]).collectPatternsRecursive(e4, t4, false);
          } else
            t4.push(this._begin);
        }, t3.prototype.compile = function(e4, t4, n3, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e4, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e4, n3, r3);
        }, t3.prototype.compileWhile = function(e4, t4, n3, r3) {
          return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new p2(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t4 || "\uFFFF"), this._cachedCompiledWhilePatterns.compile(e4, n3, r3);
        }, t3;
      }(u2);
      t2.BeginWhileRule = m2;
      var _2 = function() {
        function e3() {
        }
        return e3.createCaptureRule = function(e4, t3, n3, r3, i3) {
          return e4.registerRule(function(e5) {
            return new l2(t3, e5, n3, r3, i3);
          });
        }, e3.getCompiledRuleId = function(t3, n3, r3) {
          return t3.id || n3.registerRule(function(i3) {
            if (t3.id = i3, t3.match)
              return new f2(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.match, e3._compileCaptures(t3.captures, n3, r3));
            if (void 0 === t3.begin) {
              t3.repository && (r3 = o2.mergeObjects({}, r3, t3.repository));
              var s3 = t3.patterns;
              return void 0 === s3 && t3.include && (s3 = [{ include: t3.include }]), new d2(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.contentName, e3._compilePatterns(s3, n3, r3));
            }
            return t3.while ? new m2(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.contentName, t3.begin, e3._compileCaptures(t3.beginCaptures || t3.captures, n3, r3), t3.while, e3._compileCaptures(t3.whileCaptures || t3.captures, n3, r3), e3._compilePatterns(t3.patterns, n3, r3)) : new g2(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.contentName, t3.begin, e3._compileCaptures(t3.beginCaptures || t3.captures, n3, r3), t3.end, e3._compileCaptures(t3.endCaptures || t3.captures, n3, r3), t3.applyEndPatternLast, e3._compilePatterns(t3.patterns, n3, r3));
          }), t3.id;
        }, e3._compileCaptures = function(t3, n3, r3) {
          var i3 = [];
          if (t3) {
            var o3 = 0;
            for (var s3 in t3) {
              if ("$vscodeTextmateLocation" !== s3)
                (c3 = parseInt(s3, 10)) > o3 && (o3 = c3);
            }
            for (var a3 = 0; a3 <= o3; a3++)
              i3[a3] = null;
            for (var s3 in t3)
              if ("$vscodeTextmateLocation" !== s3) {
                var c3 = parseInt(s3, 10), u3 = 0;
                t3[s3].patterns && (u3 = e3.getCompiledRuleId(t3[s3], n3, r3)), i3[c3] = e3.createCaptureRule(n3, t3[s3].$vscodeTextmateLocation, t3[s3].name, t3[s3].contentName, u3);
              }
          }
          return i3;
        }, e3._compilePatterns = function(t3, n3, r3) {
          var i3 = [];
          if (t3)
            for (var o3 = 0, s3 = t3.length; o3 < s3; o3++) {
              var a3 = t3[o3], c3 = -1;
              if (a3.include)
                if ("#" === a3.include.charAt(0)) {
                  var u3 = r3[a3.include.substr(1)];
                  u3 && (c3 = e3.getCompiledRuleId(u3, n3, r3));
                } else if ("$base" === a3.include || "$self" === a3.include)
                  c3 = e3.getCompiledRuleId(r3[a3.include], n3, r3);
                else {
                  var l3 = null, h3 = null, p3 = a3.include.indexOf("#");
                  p3 >= 0 ? (l3 = a3.include.substring(0, p3), h3 = a3.include.substring(p3 + 1)) : l3 = a3.include;
                  var f3 = n3.getExternalGrammar(l3, r3);
                  if (f3)
                    if (h3) {
                      var _3 = f3.repository[h3];
                      _3 && (c3 = e3.getCompiledRuleId(_3, n3, f3.repository));
                    } else
                      c3 = e3.getCompiledRuleId(f3.repository.$self, n3, f3.repository);
                }
              else
                c3 = e3.getCompiledRuleId(a3, n3, r3);
              if (-1 !== c3) {
                var y2 = n3.getRule(c3), v2 = false;
                if ((y2 instanceof d2 || y2 instanceof g2 || y2 instanceof m2) && y2.hasMissingPatterns && 0 === y2.patterns.length && (v2 = true), v2)
                  continue;
                i3.push(c3);
              }
            }
          return { patterns: i3, hasMissingPatterns: (t3 ? t3.length : 0) !== i3.length };
        }, e3;
      }();
      t2.RuleFactory = _2;
    }, function(e2, t2, n2) {
      function r2(e3) {
        return !!e3 && !!e3.match(/[\w\.:]+/);
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createMatchers = function(e3, t3) {
        for (var n3, i2, o2, s2 = [], a2 = (o2 = (i2 = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g).exec(n3 = e3), { next: function() {
          if (!o2)
            return null;
          var e4 = o2[0];
          return o2 = i2.exec(n3), e4;
        } }), c2 = a2.next(); null !== c2; ) {
          var u2 = 0;
          if (2 === c2.length && ":" === c2.charAt(1)) {
            switch (c2.charAt(0)) {
              case "R":
                u2 = 1;
                break;
              case "L":
                u2 = -1;
                break;
              default:
                console.log("Unknown priority " + c2 + " in scope selector");
            }
            c2 = a2.next();
          }
          var l2 = p2();
          if (s2.push({ matcher: l2, priority: u2 }), "," !== c2)
            break;
          c2 = a2.next();
        }
        return s2;
        function h2() {
          if ("-" === c2) {
            c2 = a2.next();
            var e4 = h2();
            return function(t4) {
              return !!e4 && !e4(t4);
            };
          }
          if ("(" === c2) {
            c2 = a2.next();
            var n4 = function() {
              var e5 = [], t4 = p2();
              for (; t4 && (e5.push(t4), "|" === c2 || "," === c2); ) {
                do {
                  c2 = a2.next();
                } while ("|" === c2 || "," === c2);
                t4 = p2();
              }
              return function(t5) {
                return e5.some(function(e6) {
                  return e6(t5);
                });
              };
            }();
            return ")" === c2 && (c2 = a2.next()), n4;
          }
          if (r2(c2)) {
            var i3 = [];
            do {
              i3.push(c2), c2 = a2.next();
            } while (r2(c2));
            return function(e5) {
              return t3(i3, e5);
            };
          }
          return null;
        }
        function p2() {
          for (var e4 = [], t4 = h2(); t4; )
            e4.push(t4), t4 = h2();
          return function(t5) {
            return e4.every(function(e5) {
              return e5(t5);
            });
          };
        }
      };
    }, function(e2, t2) {
      var n2, r2, i2 = e2.exports = {};
      function o2() {
        throw new Error("setTimeout has not been defined");
      }
      function s2() {
        throw new Error("clearTimeout has not been defined");
      }
      function a2(e3) {
        if (n2 === setTimeout)
          return setTimeout(e3, 0);
        if ((n2 === o2 || !n2) && setTimeout)
          return n2 = setTimeout, setTimeout(e3, 0);
        try {
          return n2(e3, 0);
        } catch (t3) {
          try {
            return n2.call(null, e3, 0);
          } catch (t4) {
            return n2.call(this, e3, 0);
          }
        }
      }
      !function() {
        try {
          n2 = "function" == typeof setTimeout ? setTimeout : o2;
        } catch (e3) {
          n2 = o2;
        }
        try {
          r2 = "function" == typeof clearTimeout ? clearTimeout : s2;
        } catch (e3) {
          r2 = s2;
        }
      }();
      var c2, u2 = [], l2 = false, h2 = -1;
      function p2() {
        l2 && c2 && (l2 = false, c2.length ? u2 = c2.concat(u2) : h2 = -1, u2.length && f2());
      }
      function f2() {
        if (!l2) {
          var e3 = a2(p2);
          l2 = true;
          for (var t3 = u2.length; t3; ) {
            for (c2 = u2, u2 = []; ++h2 < t3; )
              c2 && c2[h2].run();
            h2 = -1, t3 = u2.length;
          }
          c2 = null, l2 = false, function(e4) {
            if (r2 === clearTimeout)
              return clearTimeout(e4);
            if ((r2 === s2 || !r2) && clearTimeout)
              return r2 = clearTimeout, clearTimeout(e4);
            try {
              r2(e4);
            } catch (t4) {
              try {
                return r2.call(null, e4);
              } catch (t5) {
                return r2.call(this, e4);
              }
            }
          }(e3);
        }
      }
      function d2(e3, t3) {
        this.fun = e3, this.array = t3;
      }
      function g2() {
      }
      i2.nextTick = function(e3) {
        var t3 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n3 = 1; n3 < arguments.length; n3++)
            t3[n3 - 1] = arguments[n3];
        u2.push(new d2(e3, t3)), 1 !== u2.length || l2 || a2(f2);
      }, d2.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, i2.title = "browser", i2.browser = true, i2.env = {}, i2.argv = [], i2.version = "", i2.versions = {}, i2.on = g2, i2.addListener = g2, i2.once = g2, i2.off = g2, i2.removeListener = g2, i2.removeAllListeners = g2, i2.emit = g2, i2.prependListener = g2, i2.prependOnceListener = g2, i2.listeners = function(e3) {
        return [];
      }, i2.binding = function(e3) {
        throw new Error("process.binding is not supported");
      }, i2.cwd = function() {
        return "/";
      }, i2.chdir = function(e3) {
        throw new Error("process.chdir is not supported");
      }, i2.umask = function() {
        return 0;
      };
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2 = n2(9), i2 = n2(2), o2 = n2(10);
      t2.parseRawGrammar = function(e3, t3) {
        return void 0 === t3 && (t3 = null), null !== t3 && /\.json$/.test(t3) ? function(e4, t4) {
          if (i2.DebugFlags.InDebugMode)
            return o2.parse(e4, t4, true);
          return JSON.parse(e4);
        }(e3, t3) : function(e4, t4) {
          if (i2.DebugFlags.InDebugMode)
            return r2.parseWithLocation(e4, t4, "$vscodeTextmateLocation");
          return r2.parse(e4);
        }(e3, t3);
      };
    }, function(e2, t2, n2) {
      function r2(e3, t3, n3) {
        var r3 = e3.length, i2 = 0, o2 = 1, s2 = 0;
        function a2(t4) {
          if (null === n3)
            i2 += t4;
          else
            for (; t4 > 0; ) {
              10 === e3.charCodeAt(i2) ? (i2++, o2++, s2 = 0) : (i2++, s2++), t4--;
            }
        }
        function c2(e4) {
          null === n3 ? i2 = e4 : a2(e4 - i2);
        }
        function u2() {
          for (; i2 < r3; ) {
            var t4 = e3.charCodeAt(i2);
            if (32 !== t4 && 9 !== t4 && 13 !== t4 && 10 !== t4)
              break;
            a2(1);
          }
        }
        function l2(t4) {
          return e3.substr(i2, t4.length) === t4 && (a2(t4.length), true);
        }
        function h2(t4) {
          var n4 = e3.indexOf(t4, i2);
          c2(-1 !== n4 ? n4 + t4.length : r3);
        }
        function p2(t4) {
          var n4 = e3.indexOf(t4, i2);
          if (-1 !== n4) {
            var o3 = e3.substring(i2, n4);
            return c2(n4 + t4.length), o3;
          }
          o3 = e3.substr(i2);
          return c2(r3), o3;
        }
        r3 > 0 && 65279 === e3.charCodeAt(0) && (i2 = 1);
        var f2 = 0, d2 = null, g2 = [], m2 = [], _2 = null;
        function y2(e4, t4) {
          g2.push(f2), m2.push(d2), f2 = e4, d2 = t4;
        }
        function v2() {
          if (0 === g2.length)
            return b2("illegal state stack");
          f2 = g2.pop(), d2 = m2.pop();
        }
        function b2(t4) {
          throw new Error("Near offset " + i2 + ": " + t4 + " ~~~" + e3.substr(i2, 50) + "~~~");
        }
        var C2, w2, k2, R2 = function() {
          if (null === _2)
            return b2("missing <key>");
          var e4 = {};
          null !== n3 && (e4[n3] = { filename: t3, line: o2, char: s2 }), d2[_2] = e4, _2 = null, y2(1, e4);
        }, S2 = function() {
          if (null === _2)
            return b2("missing <key>");
          var e4 = [];
          d2[_2] = e4, _2 = null, y2(2, e4);
        }, P2 = function() {
          var e4 = {};
          null !== n3 && (e4[n3] = { filename: t3, line: o2, char: s2 }), d2.push(e4), y2(1, e4);
        }, x2 = function() {
          var e4 = [];
          d2.push(e4), y2(2, e4);
        };
        function I2() {
          if (1 !== f2)
            return b2("unexpected </dict>");
          v2();
        }
        function A2() {
          return 1 === f2 || 2 !== f2 ? b2("unexpected </array>") : void v2();
        }
        function T2(e4) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e4, _2 = null;
          } else
            2 === f2 ? d2.push(e4) : d2 = e4;
        }
        function L2(e4) {
          if (isNaN(e4))
            return b2("cannot parse float");
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e4, _2 = null;
          } else
            2 === f2 ? d2.push(e4) : d2 = e4;
        }
        function M2(e4) {
          if (isNaN(e4))
            return b2("cannot parse integer");
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e4, _2 = null;
          } else
            2 === f2 ? d2.push(e4) : d2 = e4;
        }
        function G2(e4) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e4, _2 = null;
          } else
            2 === f2 ? d2.push(e4) : d2 = e4;
        }
        function D2(e4) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e4, _2 = null;
          } else
            2 === f2 ? d2.push(e4) : d2 = e4;
        }
        function N2(e4) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e4, _2 = null;
          } else
            2 === f2 ? d2.push(e4) : d2 = e4;
        }
        function E2(e4) {
          if (e4.isClosed)
            return "";
          var t4 = p2("</");
          return h2(">"), t4.replace(/&#([0-9]+);/g, function(e5, t5) {
            return String.fromCodePoint(parseInt(t5, 10));
          }).replace(/&#x([0-9a-f]+);/g, function(e5, t5) {
            return String.fromCodePoint(parseInt(t5, 16));
          }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function(e5) {
            switch (e5) {
              case "&amp;":
                return "&";
              case "&lt;":
                return "<";
              case "&gt;":
                return ">";
              case "&quot;":
                return '"';
              case "&apos;":
                return "'";
            }
            return e5;
          });
        }
        for (; i2 < r3 && (u2(), !(i2 >= r3)); ) {
          var O2 = e3.charCodeAt(i2);
          if (a2(1), 60 !== O2)
            return b2("expected <");
          if (i2 >= r3)
            return b2("unexpected end of input");
          var j2 = e3.charCodeAt(i2);
          if (63 !== j2)
            if (33 !== j2) {
              if (47 === j2) {
                if (a2(1), u2(), l2("plist")) {
                  h2(">");
                  continue;
                }
                if (l2("dict")) {
                  h2(">"), I2();
                  continue;
                }
                if (l2("array")) {
                  h2(">"), A2();
                  continue;
                }
                return b2("unexpected closed tag");
              }
              var F2 = (w2 = void 0, k2 = void 0, w2 = p2(">"), k2 = false, 47 === w2.charCodeAt(w2.length - 1) && (k2 = true, w2 = w2.substring(0, w2.length - 1)), { name: w2.trim(), isClosed: k2 });
              switch (F2.name) {
                case "dict":
                  1 === f2 ? R2() : 2 === f2 ? P2() : (d2 = {}, null !== n3 && (d2[n3] = { filename: t3, line: o2, char: s2 }), y2(1, d2)), F2.isClosed && I2();
                  continue;
                case "array":
                  1 === f2 ? S2() : 2 === f2 ? x2() : y2(2, d2 = []), F2.isClosed && A2();
                  continue;
                case "key":
                  C2 = E2(F2), 1 !== f2 ? b2("unexpected <key>") : null !== _2 ? b2("too many <key>") : _2 = C2;
                  continue;
                case "string":
                  T2(E2(F2));
                  continue;
                case "real":
                  L2(parseFloat(E2(F2)));
                  continue;
                case "integer":
                  M2(parseInt(E2(F2), 10));
                  continue;
                case "date":
                  G2(new Date(E2(F2)));
                  continue;
                case "data":
                  D2(E2(F2));
                  continue;
                case "true":
                  E2(F2), N2(true);
                  continue;
                case "false":
                  E2(F2), N2(false);
                  continue;
              }
              if (!/^plist/.test(F2.name))
                return b2("unexpected opened tag " + F2.name);
            } else {
              if (a2(1), l2("--")) {
                h2("-->");
                continue;
              }
              h2(">");
            }
          else
            a2(1), h2("?>");
        }
        return d2;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.parseWithLocation = function(e3, t3, n3) {
        return r2(e3, t3, n3);
      }, t2.parse = function(e3) {
        return r2(e3, null, null);
      };
    }, function(e2, t2, n2) {
      function r2(e3, t3) {
        throw new Error("Near offset " + e3.pos + ": " + t3 + " ~~~" + e3.source.substr(e3.pos, 50) + "~~~");
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.parse = function(e3, t3, n3) {
        var a2 = new i2(e3), c2 = new o2(), u2 = 0, l2 = null, h2 = [], p2 = [];
        function f2() {
          h2.push(u2), p2.push(l2);
        }
        function d2() {
          u2 = h2.pop(), l2 = p2.pop();
        }
        function g2(e4) {
          r2(a2, e4);
        }
        for (; s2(a2, c2); ) {
          if (0 === u2) {
            if (null !== l2 && g2("too many constructs in root"), 3 === c2.type) {
              l2 = {}, n3 && (l2.$vscodeTextmateLocation = c2.toLocation(t3)), f2(), u2 = 1;
              continue;
            }
            if (2 === c2.type) {
              l2 = [], f2(), u2 = 4;
              continue;
            }
            g2("unexpected token in root");
          }
          if (2 === u2) {
            if (5 === c2.type) {
              d2();
              continue;
            }
            if (7 === c2.type) {
              u2 = 3;
              continue;
            }
            g2("expected , or }");
          }
          if (1 === u2 || 3 === u2) {
            if (1 === u2 && 5 === c2.type) {
              d2();
              continue;
            }
            if (1 === c2.type) {
              var m2 = c2.value;
              if (s2(a2, c2) && 6 === c2.type || g2("expected colon"), s2(a2, c2) || g2("expected value"), u2 = 2, 1 === c2.type) {
                l2[m2] = c2.value;
                continue;
              }
              if (8 === c2.type) {
                l2[m2] = null;
                continue;
              }
              if (9 === c2.type) {
                l2[m2] = true;
                continue;
              }
              if (10 === c2.type) {
                l2[m2] = false;
                continue;
              }
              if (11 === c2.type) {
                l2[m2] = parseFloat(c2.value);
                continue;
              }
              if (2 === c2.type) {
                var _2 = [];
                l2[m2] = _2, f2(), u2 = 4, l2 = _2;
                continue;
              }
              if (3 === c2.type) {
                var y2 = {};
                n3 && (y2.$vscodeTextmateLocation = c2.toLocation(t3)), l2[m2] = y2, f2(), u2 = 1, l2 = y2;
                continue;
              }
            }
            g2("unexpected token in dict");
          }
          if (5 === u2) {
            if (4 === c2.type) {
              d2();
              continue;
            }
            if (7 === c2.type) {
              u2 = 6;
              continue;
            }
            g2("expected , or ]");
          }
          if (4 === u2 || 6 === u2) {
            if (4 === u2 && 4 === c2.type) {
              d2();
              continue;
            }
            if (u2 = 5, 1 === c2.type) {
              l2.push(c2.value);
              continue;
            }
            if (8 === c2.type) {
              l2.push(null);
              continue;
            }
            if (9 === c2.type) {
              l2.push(true);
              continue;
            }
            if (10 === c2.type) {
              l2.push(false);
              continue;
            }
            if (11 === c2.type) {
              l2.push(parseFloat(c2.value));
              continue;
            }
            if (2 === c2.type) {
              _2 = [];
              l2.push(_2), f2(), u2 = 4, l2 = _2;
              continue;
            }
            if (3 === c2.type) {
              y2 = {};
              n3 && (y2.$vscodeTextmateLocation = c2.toLocation(t3)), l2.push(y2), f2(), u2 = 1, l2 = y2;
              continue;
            }
            g2("unexpected token in array");
          }
          g2("unknown state");
        }
        return 0 !== p2.length && g2("unclosed constructs"), l2;
      };
      var i2 = function(e3) {
        this.source = e3, this.pos = 0, this.len = e3.length, this.line = 1, this.char = 0;
      }, o2 = function() {
        function e3() {
          this.value = null, this.type = 0, this.offset = -1, this.len = -1, this.line = -1, this.char = -1;
        }
        return e3.prototype.toLocation = function(e4) {
          return { filename: e4, line: this.line, char: this.char };
        }, e3;
      }();
      function s2(e3, t3) {
        t3.value = null, t3.type = 0, t3.offset = -1, t3.len = -1, t3.line = -1, t3.char = -1;
        for (var n3, i3 = e3.source, o3 = e3.pos, s3 = e3.len, a2 = e3.line, c2 = e3.char; ; ) {
          if (o3 >= s3)
            return false;
          if (32 !== (n3 = i3.charCodeAt(o3)) && 9 !== n3 && 13 !== n3) {
            if (10 !== n3)
              break;
            o3++, a2++, c2 = 0;
          } else
            o3++, c2++;
        }
        if (t3.offset = o3, t3.line = a2, t3.char = c2, 34 === n3) {
          for (t3.type = 1, o3++, c2++; ; ) {
            if (o3 >= s3)
              return false;
            if (n3 = i3.charCodeAt(o3), o3++, c2++, 92 !== n3) {
              if (34 === n3)
                break;
            } else
              o3++, c2++;
          }
          t3.value = i3.substring(t3.offset + 1, o3 - 1).replace(/\\u([0-9A-Fa-f]{4})/g, function(e4, t4) {
            return String.fromCodePoint(parseInt(t4, 16));
          }).replace(/\\(.)/g, function(t4, n4) {
            switch (n4) {
              case '"':
                return '"';
              case "\\":
                return "\\";
              case "/":
                return "/";
              case "b":
                return "\b";
              case "f":
                return "\f";
              case "n":
                return "\n";
              case "r":
                return "\r";
              case "t":
                return "	";
              default:
                r2(e3, "invalid escape sequence");
            }
            throw new Error("unreachable");
          });
        } else if (91 === n3)
          t3.type = 2, o3++, c2++;
        else if (123 === n3)
          t3.type = 3, o3++, c2++;
        else if (93 === n3)
          t3.type = 4, o3++, c2++;
        else if (125 === n3)
          t3.type = 5, o3++, c2++;
        else if (58 === n3)
          t3.type = 6, o3++, c2++;
        else if (44 === n3)
          t3.type = 7, o3++, c2++;
        else if (110 === n3) {
          if (t3.type = 8, o3++, c2++, 117 !== (n3 = i3.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 108 !== (n3 = i3.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 108 !== (n3 = i3.charCodeAt(o3)))
            return false;
          o3++, c2++;
        } else if (116 === n3) {
          if (t3.type = 9, o3++, c2++, 114 !== (n3 = i3.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 117 !== (n3 = i3.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 101 !== (n3 = i3.charCodeAt(o3)))
            return false;
          o3++, c2++;
        } else if (102 === n3) {
          if (t3.type = 10, o3++, c2++, 97 !== (n3 = i3.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 108 !== (n3 = i3.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 115 !== (n3 = i3.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 101 !== (n3 = i3.charCodeAt(o3)))
            return false;
          o3++, c2++;
        } else
          for (t3.type = 11; ; ) {
            if (o3 >= s3)
              return false;
            if (!(46 === (n3 = i3.charCodeAt(o3)) || n3 >= 48 && n3 <= 57 || 101 === n3 || 69 === n3 || 45 === n3 || 43 === n3))
              break;
            o3++, c2++;
          }
        return t3.len = o3 - t3.offset, null === t3.value && (t3.value = i3.substr(t3.offset, t3.len)), e3.pos = o3, e3.line = a2, e3.char = c2, true;
      }
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2 = function(e3, t3, n3, r3, i3, o3) {
        this.scope = e3, this.parentScopes = t3, this.index = n3, this.fontStyle = r3, this.foreground = i3, this.background = o3;
      };
      function i2(e3) {
        return !!/^#[0-9a-f]{6}$/i.test(e3) || (!!/^#[0-9a-f]{8}$/i.test(e3) || (!!/^#[0-9a-f]{3}$/i.test(e3) || !!/^#[0-9a-f]{4}$/i.test(e3)));
      }
      function o2(e3) {
        if (!e3)
          return [];
        if (!e3.settings || !Array.isArray(e3.settings))
          return [];
        for (var t3 = e3.settings, n3 = [], o3 = 0, s3 = 0, a3 = t3.length; s3 < a3; s3++) {
          var c3 = t3[s3];
          if (c3.settings) {
            var u3 = void 0;
            if ("string" == typeof c3.scope)
              u3 = c3.scope.replace(/^[,]+/, "").replace(/[,]+$/, "").split(",");
            else
              u3 = Array.isArray(c3.scope) ? c3.scope : [""];
            var l3 = -1;
            if ("string" == typeof c3.settings.fontStyle) {
              l3 = 0;
              for (var h3 = 0, p3 = (g2 = c3.settings.fontStyle.split(" ")).length; h3 < p3; h3++) {
                switch (g2[h3]) {
                  case "italic":
                    l3 |= 1;
                    break;
                  case "bold":
                    l3 |= 2;
                    break;
                  case "underline":
                    l3 |= 4;
                }
              }
            }
            var f2 = null;
            "string" == typeof c3.settings.foreground && i2(c3.settings.foreground) && (f2 = c3.settings.foreground);
            var d2 = null;
            "string" == typeof c3.settings.background && i2(c3.settings.background) && (d2 = c3.settings.background);
            for (h3 = 0, p3 = u3.length; h3 < p3; h3++) {
              var g2, m2 = (g2 = u3[h3].trim().split(" "))[g2.length - 1], _2 = null;
              g2.length > 1 && (_2 = g2.slice(0, g2.length - 1)).reverse(), n3[o3++] = new r2(m2, _2, s3, l3, f2, d2);
            }
          }
        }
        return n3;
      }
      function s2(e3, t3) {
        e3.sort(function(e4, t4) {
          var n4 = u2(e4.scope, t4.scope);
          return 0 !== n4 || 0 !== (n4 = l2(e4.parentScopes, t4.parentScopes)) ? n4 : e4.index - t4.index;
        });
        for (var n3 = 0, r3 = "#000000", i3 = "#ffffff"; e3.length >= 1 && "" === e3[0].scope; ) {
          var o3 = e3.shift();
          -1 !== o3.fontStyle && (n3 = o3.fontStyle), null !== o3.foreground && (r3 = o3.foreground), null !== o3.background && (i3 = o3.background);
        }
        for (var s3 = new a2(t3), f2 = new h2(0, null, n3, s3.getId(r3), s3.getId(i3)), d2 = new p2(new h2(0, null, -1, 0, 0), []), g2 = 0, m2 = e3.length; g2 < m2; g2++) {
          var _2 = e3[g2];
          d2.insert(0, _2.scope, _2.parentScopes, _2.fontStyle, s3.getId(_2.foreground), s3.getId(_2.background));
        }
        return new c2(s3, f2, d2);
      }
      t2.ParsedThemeRule = r2, t2.parseTheme = o2;
      var a2 = function() {
        function e3(e4) {
          if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e4)) {
            this._isFrozen = true;
            for (var t3 = 0, n3 = e4.length; t3 < n3; t3++)
              this._color2id[e4[t3]] = t3, this._id2color[t3] = e4[t3];
          } else
            this._isFrozen = false;
        }
        return e3.prototype.getId = function(e4) {
          if (null === e4)
            return 0;
          e4 = e4.toUpperCase();
          var t3 = this._color2id[e4];
          if (t3)
            return t3;
          if (this._isFrozen)
            throw new Error("Missing color in color map - " + e4);
          return t3 = ++this._lastColorId, this._color2id[e4] = t3, this._id2color[t3] = e4, t3;
        }, e3.prototype.getColorMap = function() {
          return this._id2color.slice(0);
        }, e3;
      }();
      t2.ColorMap = a2;
      var c2 = function() {
        function e3(e4, t3, n3) {
          this._colorMap = e4, this._root = n3, this._defaults = t3, this._cache = {};
        }
        return e3.createFromRawTheme = function(e4, t3) {
          return this.createFromParsedTheme(o2(e4), t3);
        }, e3.createFromParsedTheme = function(e4, t3) {
          return s2(e4, t3);
        }, e3.prototype.getColorMap = function() {
          return this._colorMap.getColorMap();
        }, e3.prototype.getDefaults = function() {
          return this._defaults;
        }, e3.prototype.match = function(e4) {
          return this._cache.hasOwnProperty(e4) || (this._cache[e4] = this._root.match(e4)), this._cache[e4];
        }, e3;
      }();
      function u2(e3, t3) {
        return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
      }
      function l2(e3, t3) {
        if (null === e3 && null === t3)
          return 0;
        if (!e3)
          return -1;
        if (!t3)
          return 1;
        var n3 = e3.length, r3 = t3.length;
        if (n3 === r3) {
          for (var i3 = 0; i3 < n3; i3++) {
            var o3 = u2(e3[i3], t3[i3]);
            if (0 !== o3)
              return o3;
          }
          return 0;
        }
        return n3 - r3;
      }
      t2.Theme = c2, t2.strcmp = u2, t2.strArrCmp = l2;
      var h2 = function() {
        function e3(e4, t3, n3, r3, i3) {
          this.scopeDepth = e4, this.parentScopes = t3, this.fontStyle = n3, this.foreground = r3, this.background = i3;
        }
        return e3.prototype.clone = function() {
          return new e3(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
        }, e3.cloneArr = function(e4) {
          for (var t3 = [], n3 = 0, r3 = e4.length; n3 < r3; n3++)
            t3[n3] = e4[n3].clone();
          return t3;
        }, e3.prototype.acceptOverwrite = function(e4, t3, n3, r3) {
          this.scopeDepth > e4 ? console.log("how did this happen?") : this.scopeDepth = e4, -1 !== t3 && (this.fontStyle = t3), 0 !== n3 && (this.foreground = n3), 0 !== r3 && (this.background = r3);
        }, e3;
      }();
      t2.ThemeTrieElementRule = h2;
      var p2 = function() {
        function e3(e4, t3, n3) {
          void 0 === t3 && (t3 = []), void 0 === n3 && (n3 = {}), this._mainRule = e4, this._rulesWithParentScopes = t3, this._children = n3;
        }
        return e3._sortBySpecificity = function(e4) {
          return 1 === e4.length || e4.sort(this._cmpBySpecificity), e4;
        }, e3._cmpBySpecificity = function(e4, t3) {
          if (e4.scopeDepth === t3.scopeDepth) {
            var n3 = e4.parentScopes, r3 = t3.parentScopes, i3 = null === n3 ? 0 : n3.length, o3 = null === r3 ? 0 : r3.length;
            if (i3 === o3)
              for (var s3 = 0; s3 < i3; s3++) {
                var a3 = n3[s3].length, c3 = r3[s3].length;
                if (a3 !== c3)
                  return c3 - a3;
              }
            return o3 - i3;
          }
          return t3.scopeDepth - e4.scopeDepth;
        }, e3.prototype.match = function(t3) {
          if ("" === t3)
            return e3._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
          var n3, r3, i3 = t3.indexOf(".");
          return -1 === i3 ? (n3 = t3, r3 = "") : (n3 = t3.substring(0, i3), r3 = t3.substring(i3 + 1)), this._children.hasOwnProperty(n3) ? this._children[n3].match(r3) : e3._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
        }, e3.prototype.insert = function(t3, n3, r3, i3, o3, s3) {
          if ("" !== n3) {
            var a3, c3, u3, l3 = n3.indexOf(".");
            -1 === l3 ? (a3 = n3, c3 = "") : (a3 = n3.substring(0, l3), c3 = n3.substring(l3 + 1)), this._children.hasOwnProperty(a3) ? u3 = this._children[a3] : (u3 = new e3(this._mainRule.clone(), h2.cloneArr(this._rulesWithParentScopes)), this._children[a3] = u3), u3.insert(t3 + 1, c3, r3, i3, o3, s3);
          } else
            this._doInsertHere(t3, r3, i3, o3, s3);
        }, e3.prototype._doInsertHere = function(e4, t3, n3, r3, i3) {
          if (null !== t3) {
            for (var o3 = 0, s3 = this._rulesWithParentScopes.length; o3 < s3; o3++) {
              var a3 = this._rulesWithParentScopes[o3];
              if (0 === l2(a3.parentScopes, t3))
                return void a3.acceptOverwrite(e4, n3, r3, i3);
            }
            -1 === n3 && (n3 = this._mainRule.fontStyle), 0 === r3 && (r3 = this._mainRule.foreground), 0 === i3 && (i3 = this._mainRule.background), this._rulesWithParentScopes.push(new h2(e4, t3, n3, r3, i3));
          } else
            this._mainRule.acceptOverwrite(e4, n3, r3, i3);
        }, e3;
      }();
      t2.ThemeTrieElement = p2;
    }]);
  });
})(main);
const languages = [
  {
    id: "abap",
    scopeName: "source.abap",
    path: "abap.tmLanguage.json",
    samplePath: "abap.sample"
  },
  {
    id: "actionscript-3",
    scopeName: "source.actionscript.3",
    path: "actionscript-3.tmLanguage.json",
    samplePath: "actionscript-3.sample"
  },
  {
    id: "ada",
    scopeName: "source.ada",
    path: "ada.tmLanguage.json",
    samplePath: "ada.sample"
  },
  {
    id: "apache",
    scopeName: "source.apacheconf",
    path: "apache.tmLanguage.json"
  },
  {
    id: "apex",
    scopeName: "source.apex",
    path: "apex.tmLanguage.json",
    samplePath: "apex.sample"
  },
  {
    id: "apl",
    scopeName: "source.apl",
    path: "apl.tmLanguage.json",
    embeddedLangs: ["html", "xml", "css", "javascript", "json"]
  },
  {
    id: "applescript",
    scopeName: "source.applescript",
    path: "applescript.tmLanguage.json",
    samplePath: "applescript.sample"
  },
  {
    id: "asm",
    scopeName: "source.asm.x86_64",
    path: "asm.tmLanguage.json",
    samplePath: "asm.sample"
  },
  {
    id: "astro",
    scopeName: "text.html.astro",
    path: "astro.tmLanguage.json",
    samplePath: "astro.sample",
    embeddedLangs: ["css", "javascript", "less", "sass", "scss", "stylus", "typescript", "tsx"]
  },
  {
    id: "awk",
    scopeName: "source.awk",
    path: "awk.tmLanguage.json",
    samplePath: "awk.sample"
  },
  {
    id: "ballerina",
    scopeName: "source.ballerina",
    path: "ballerina.tmLanguage.json",
    samplePath: "ballerina.sample"
  },
  {
    id: "bat",
    scopeName: "source.batchfile",
    path: "bat.tmLanguage.json",
    samplePath: "bat.sample",
    aliases: ["batch"]
  },
  {
    id: "berry",
    scopeName: "source.berry",
    path: "berry.tmLanguage.json",
    samplePath: "berry.sample",
    aliases: ["be"]
  },
  {
    id: "bibtex",
    scopeName: "text.bibtex",
    path: "bibtex.tmLanguage.json"
  },
  {
    id: "bicep",
    scopeName: "source.bicep",
    path: "bicep.tmLanguage.json",
    samplePath: "bicep.sample"
  },
  {
    id: "c",
    scopeName: "source.c",
    path: "c.tmLanguage.json",
    samplePath: "c.sample"
  },
  {
    id: "clojure",
    scopeName: "source.clojure",
    path: "clojure.tmLanguage.json",
    samplePath: "clojure.sample",
    aliases: ["clj"]
  },
  {
    id: "cobol",
    scopeName: "source.cobol",
    path: "cobol.tmLanguage.json",
    samplePath: "cobol.sample",
    embeddedLangs: ["sql", "html", "java"]
  },
  {
    id: "codeql",
    scopeName: "source.ql",
    path: "codeql.tmLanguage.json",
    samplePath: "codeql.sample",
    aliases: ["ql"]
  },
  {
    id: "coffee",
    scopeName: "source.coffee",
    path: "coffee.tmLanguage.json",
    samplePath: "coffee.sample",
    embeddedLangs: ["javascript"]
  },
  {
    id: "cpp",
    scopeName: "source.cpp",
    path: "cpp.tmLanguage.json",
    samplePath: "cpp.sample",
    embeddedLangs: ["sql"]
  },
  {
    id: "crystal",
    scopeName: "source.crystal",
    path: "crystal.tmLanguage.json",
    samplePath: "crystal.sample",
    embeddedLangs: ["html", "sql", "css", "c", "javascript", "shellscript"]
  },
  {
    id: "csharp",
    scopeName: "source.cs",
    path: "csharp.tmLanguage.json",
    samplePath: "csharp.sample",
    aliases: ["c#"]
  },
  {
    id: "css",
    scopeName: "source.css",
    path: "css.tmLanguage.json",
    samplePath: "css.sample"
  },
  {
    id: "cue",
    scopeName: "source.cue",
    path: "cue.tmLanguage.json",
    samplePath: "cue.sample"
  },
  {
    id: "d",
    scopeName: "source.d",
    path: "d.tmLanguage.json",
    samplePath: "d.sample"
  },
  {
    id: "dart",
    scopeName: "source.dart",
    path: "dart.tmLanguage.json",
    samplePath: "dart.sample"
  },
  {
    id: "diff",
    scopeName: "source.diff",
    path: "diff.tmLanguage.json",
    samplePath: "diff.sample"
  },
  {
    id: "docker",
    scopeName: "source.dockerfile",
    path: "docker.tmLanguage.json",
    samplePath: "docker.sample"
  },
  {
    id: "dream-maker",
    scopeName: "source.dm",
    path: "dream-maker.tmLanguage.json"
  },
  {
    id: "elixir",
    scopeName: "source.elixir",
    path: "elixir.tmLanguage.json",
    samplePath: "elixir.sample",
    embeddedLangs: ["html"]
  },
  {
    id: "elm",
    scopeName: "source.elm",
    path: "elm.tmLanguage.json",
    samplePath: "elm.sample"
  },
  {
    id: "erb",
    scopeName: "text.html.erb",
    path: "erb.tmLanguage.json",
    samplePath: "erb.sample",
    embeddedLangs: ["html", "ruby"]
  },
  {
    id: "erlang",
    scopeName: "source.erlang",
    path: "erlang.tmLanguage.json",
    samplePath: "erlang.sample"
  },
  {
    id: "fish",
    scopeName: "source.fish",
    path: "fish.tmLanguage.json",
    samplePath: "fish.sample"
  },
  {
    id: "fsharp",
    scopeName: "source.fsharp",
    path: "fsharp.tmLanguage.json",
    samplePath: "fsharp.sample",
    aliases: ["f#"],
    embeddedLangs: ["markdown"]
  },
  {
    id: "gherkin",
    scopeName: "text.gherkin.feature",
    path: "gherkin.tmLanguage.json"
  },
  {
    id: "git-commit",
    scopeName: "text.git-commit",
    path: "git-commit.tmLanguage.json",
    embeddedLangs: ["diff"]
  },
  {
    id: "git-rebase",
    scopeName: "text.git-rebase",
    path: "git-rebase.tmLanguage.json",
    embeddedLangs: ["shellscript"]
  },
  {
    id: "gnuplot",
    scopeName: "source.gnuplot",
    path: "gnuplot.tmLanguage.json"
  },
  {
    id: "go",
    scopeName: "source.go",
    path: "go.tmLanguage.json",
    samplePath: "go.sample"
  },
  {
    id: "graphql",
    scopeName: "source.graphql",
    path: "graphql.tmLanguage.json",
    embeddedLangs: ["javascript", "typescript", "jsx", "tsx"]
  },
  {
    id: "groovy",
    scopeName: "source.groovy",
    path: "groovy.tmLanguage.json"
  },
  {
    id: "hack",
    scopeName: "source.hack",
    path: "hack.tmLanguage.json",
    embeddedLangs: ["html", "sql"]
  },
  {
    id: "haml",
    scopeName: "text.haml",
    path: "haml.tmLanguage.json",
    embeddedLangs: ["ruby", "javascript", "sass", "coffee", "markdown", "css"]
  },
  {
    id: "handlebars",
    scopeName: "text.html.handlebars",
    path: "handlebars.tmLanguage.json",
    aliases: ["hbs"],
    embeddedLangs: ["html", "css", "javascript", "yaml"]
  },
  {
    id: "haskell",
    scopeName: "source.haskell",
    path: "haskell.tmLanguage.json"
  },
  {
    id: "hcl",
    scopeName: "source.hcl",
    path: "hcl.tmLanguage.json"
  },
  {
    id: "hlsl",
    scopeName: "source.hlsl",
    path: "hlsl.tmLanguage.json"
  },
  {
    id: "html",
    scopeName: "text.html.basic",
    path: "html.tmLanguage.json",
    samplePath: "html.sample",
    embeddedLangs: ["javascript", "css"]
  },
  {
    id: "ini",
    scopeName: "source.ini",
    path: "ini.tmLanguage.json"
  },
  {
    id: "java",
    scopeName: "source.java",
    path: "java.tmLanguage.json",
    samplePath: "java.sample"
  },
  {
    id: "javascript",
    scopeName: "source.js",
    path: "javascript.tmLanguage.json",
    samplePath: "javascript.sample",
    aliases: ["js"]
  },
  {
    id: "jinja-html",
    scopeName: "text.html.jinja",
    path: "jinja-html.tmLanguage.json",
    embeddedLangs: ["html"]
  },
  {
    id: "json",
    scopeName: "source.json",
    path: "json.tmLanguage.json"
  },
  {
    id: "jsonc",
    scopeName: "source.json.comments",
    path: "jsonc.tmLanguage.json"
  },
  {
    id: "jsonnet",
    scopeName: "source.jsonnet",
    path: "jsonnet.tmLanguage.json"
  },
  {
    id: "jssm",
    scopeName: "source.jssm",
    path: "jssm.tmLanguage.json",
    samplePath: "jssm.sample",
    aliases: ["fsl"]
  },
  {
    id: "jsx",
    scopeName: "source.js.jsx",
    path: "jsx.tmLanguage.json"
  },
  {
    id: "julia",
    scopeName: "source.julia",
    path: "julia.tmLanguage.json",
    embeddedLangs: ["cpp", "python", "javascript", "r", "sql"]
  },
  {
    id: "jupyter",
    scopeName: "source.jupyter",
    path: "jupyter.tmLanguage.json",
    embeddedLangs: ["json"]
  },
  {
    id: "kotlin",
    scopeName: "source.kotlin",
    path: "kotlin.tmLanguage.json"
  },
  {
    id: "latex",
    scopeName: "text.tex.latex",
    path: "latex.tmLanguage.json",
    embeddedLangs: ["tex", "css", "html", "java", "javascript", "typescript", "lua", "python", "julia", "ruby", "xml", "yaml", "cpp", "haskell", "scala", "gnuplot"]
  },
  {
    id: "less",
    scopeName: "source.css.less",
    path: "less.tmLanguage.json",
    embeddedLangs: ["css"]
  },
  {
    id: "lisp",
    scopeName: "source.lisp",
    path: "lisp.tmLanguage.json"
  },
  {
    id: "logo",
    scopeName: "source.logo",
    path: "logo.tmLanguage.json"
  },
  {
    id: "lua",
    scopeName: "source.lua",
    path: "lua.tmLanguage.json",
    embeddedLangs: ["c"]
  },
  {
    id: "make",
    scopeName: "source.makefile",
    path: "make.tmLanguage.json",
    aliases: ["makefile"]
  },
  {
    id: "markdown",
    scopeName: "text.html.markdown",
    path: "markdown.tmLanguage.json",
    aliases: ["md"],
    embeddedLangs: ["css", "html", "ini", "java", "lua", "make", "perl", "r", "ruby", "php", "sql", "vb", "xml", "xsl", "yaml", "bat", "clojure", "coffee", "c", "cpp", "diff", "docker", "git-commit", "git-rebase", "go", "groovy", "pug", "javascript", "json", "jsonc", "less", "objective-c", "swift", "scss", "raku", "powershell", "python", "rust", "scala", "shellscript", "typescript", "tsx", "csharp", "fsharp", "dart", "handlebars", "erlang", "elixir", "latex", "bibtex"]
  },
  {
    id: "marko",
    scopeName: "text.marko",
    path: "marko.tmLanguage.json",
    samplePath: "marko.sample",
    embeddedLangs: ["css", "less", "scss", "javascript"]
  },
  {
    id: "matlab",
    scopeName: "source.matlab",
    path: "matlab.tmLanguage.json"
  },
  {
    id: "mdx",
    scopeName: "text.html.markdown.jsx",
    path: "mdx.tmLanguage.json",
    embeddedLangs: ["jsx", "markdown"]
  },
  {
    id: "nginx",
    scopeName: "source.nginx",
    path: "nginx.tmLanguage.json",
    embeddedLangs: ["lua"]
  },
  {
    id: "nim",
    scopeName: "source.nim",
    path: "nim.tmLanguage.json",
    embeddedLangs: ["c", "html", "xml", "javascript", "css", "markdown"]
  },
  {
    id: "nix",
    scopeName: "source.nix",
    path: "nix.tmLanguage.json"
  },
  {
    id: "objective-c",
    scopeName: "source.objc",
    path: "objective-c.tmLanguage.json",
    aliases: ["objc"]
  },
  {
    id: "objective-cpp",
    scopeName: "source.objcpp",
    path: "objective-cpp.tmLanguage.json"
  },
  {
    id: "ocaml",
    scopeName: "source.ocaml",
    path: "ocaml.tmLanguage.json"
  },
  {
    id: "pascal",
    scopeName: "source.pascal",
    path: "pascal.tmLanguage.json"
  },
  {
    id: "perl",
    scopeName: "source.perl",
    path: "perl.tmLanguage.json",
    embeddedLangs: ["html", "xml", "css", "javascript", "sql"]
  },
  {
    id: "php",
    scopeName: "source.php",
    path: "php.tmLanguage.json",
    embeddedLangs: ["html", "xml", "sql", "javascript", "json", "css"]
  },
  {
    id: "plsql",
    scopeName: "source.plsql.oracle",
    path: "plsql.tmLanguage.json"
  },
  {
    id: "postcss",
    scopeName: "source.css.postcss",
    path: "postcss.tmLanguage.json"
  },
  {
    id: "powershell",
    scopeName: "source.powershell",
    path: "powershell.tmLanguage.json",
    aliases: ["ps", "ps1"]
  },
  {
    id: "prisma",
    scopeName: "source.prisma",
    path: "prisma.tmLanguage.json",
    samplePath: "prisma.sample"
  },
  {
    id: "prolog",
    scopeName: "source.prolog",
    path: "prolog.tmLanguage.json"
  },
  {
    id: "pug",
    scopeName: "text.pug",
    path: "pug.tmLanguage.json",
    aliases: ["jade"],
    embeddedLangs: ["javascript", "css", "sass", "stylus", "coffee", "html"]
  },
  {
    id: "puppet",
    scopeName: "source.puppet",
    path: "puppet.tmLanguage.json"
  },
  {
    id: "purescript",
    scopeName: "source.purescript",
    path: "purescript.tmLanguage.json"
  },
  {
    id: "python",
    scopeName: "source.python",
    path: "python.tmLanguage.json",
    samplePath: "python.sample",
    aliases: ["py"]
  },
  {
    id: "r",
    scopeName: "source.r",
    path: "r.tmLanguage.json"
  },
  {
    id: "raku",
    scopeName: "source.perl.6",
    path: "raku.tmLanguage.json",
    aliases: ["perl6"]
  },
  {
    id: "razor",
    scopeName: "text.aspnetcorerazor",
    path: "razor.tmLanguage.json",
    embeddedLangs: ["html", "csharp"]
  },
  {
    id: "rel",
    scopeName: "source.rel",
    path: "rel.tmLanguage.json",
    samplePath: "rel.sample"
  },
  {
    id: "riscv",
    scopeName: "source.riscv",
    path: "riscv.tmLanguage.json"
  },
  {
    id: "ruby",
    scopeName: "source.ruby",
    path: "ruby.tmLanguage.json",
    samplePath: "ruby.sample",
    aliases: ["rb"],
    embeddedLangs: ["html", "xml", "sql", "css", "c", "javascript", "shellscript", "lua"]
  },
  {
    id: "rust",
    scopeName: "source.rust",
    path: "rust.tmLanguage.json",
    aliases: ["rs"]
  },
  {
    id: "sas",
    scopeName: "source.sas",
    path: "sas.tmLanguage.json",
    embeddedLangs: ["sql"]
  },
  {
    id: "sass",
    scopeName: "source.sass",
    path: "sass.tmLanguage.json"
  },
  {
    id: "scala",
    scopeName: "source.scala",
    path: "scala.tmLanguage.json"
  },
  {
    id: "scheme",
    scopeName: "source.scheme",
    path: "scheme.tmLanguage.json"
  },
  {
    id: "scss",
    scopeName: "source.css.scss",
    path: "scss.tmLanguage.json",
    embeddedLangs: ["css"]
  },
  {
    id: "shaderlab",
    scopeName: "source.shaderlab",
    path: "shaderlab.tmLanguage.json",
    aliases: ["shader"],
    embeddedLangs: ["hlsl"]
  },
  {
    id: "shellscript",
    scopeName: "source.shell",
    path: "shellscript.tmLanguage.json",
    aliases: ["shell", "bash", "sh", "zsh"],
    embeddedLangs: ["ruby", "python", "applescript", "html", "markdown"]
  },
  {
    id: "smalltalk",
    scopeName: "source.smalltalk",
    path: "smalltalk.tmLanguage.json"
  },
  {
    id: "solidity",
    scopeName: "source.solidity",
    path: "solidity.tmLanguage.json"
  },
  {
    id: "sparql",
    scopeName: "source.sparql",
    path: "sparql.tmLanguage.json",
    samplePath: "sparql.sample",
    embeddedLangs: ["turtle"]
  },
  {
    id: "sql",
    scopeName: "source.sql",
    path: "sql.tmLanguage.json"
  },
  {
    id: "ssh-config",
    scopeName: "source.ssh-config",
    path: "ssh-config.tmLanguage.json"
  },
  {
    id: "stata",
    scopeName: "source.stata",
    path: "stata.tmLanguage.json",
    samplePath: "stata.sample",
    embeddedLangs: ["sql"]
  },
  {
    id: "stylus",
    scopeName: "source.stylus",
    path: "stylus.tmLanguage.json",
    aliases: ["styl"]
  },
  {
    id: "svelte",
    scopeName: "source.svelte",
    path: "svelte.tmLanguage.json",
    embeddedLangs: ["javascript", "typescript", "coffee", "stylus", "sass", "css", "scss", "less", "postcss", "pug", "markdown"]
  },
  {
    id: "swift",
    scopeName: "source.swift",
    path: "swift.tmLanguage.json"
  },
  {
    id: "system-verilog",
    scopeName: "source.systemverilog",
    path: "system-verilog.tmLanguage.json"
  },
  {
    id: "tasl",
    scopeName: "source.tasl",
    path: "tasl.tmLanguage.json",
    samplePath: "tasl.sample"
  },
  {
    id: "tcl",
    scopeName: "source.tcl",
    path: "tcl.tmLanguage.json"
  },
  {
    id: "tex",
    scopeName: "text.tex",
    path: "tex.tmLanguage.json",
    embeddedLangs: ["r"]
  },
  {
    id: "toml",
    scopeName: "source.toml",
    path: "toml.tmLanguage.json"
  },
  {
    id: "tsx",
    scopeName: "source.tsx",
    path: "tsx.tmLanguage.json",
    samplePath: "tsx.sample"
  },
  {
    id: "turtle",
    scopeName: "source.turtle",
    path: "turtle.tmLanguage.json",
    samplePath: "turtle.sample"
  },
  {
    id: "twig",
    scopeName: "text.html.twig",
    path: "twig.tmLanguage.json",
    embeddedLangs: ["css", "javascript", "php", "python", "ruby"]
  },
  {
    id: "typescript",
    scopeName: "source.ts",
    path: "typescript.tmLanguage.json",
    aliases: ["ts"]
  },
  {
    id: "vb",
    scopeName: "source.asp.vb.net",
    path: "vb.tmLanguage.json",
    aliases: ["cmd"]
  },
  {
    id: "verilog",
    scopeName: "source.verilog",
    path: "verilog.tmLanguage.json"
  },
  {
    id: "vhdl",
    scopeName: "source.vhdl",
    path: "vhdl.tmLanguage.json"
  },
  {
    id: "viml",
    scopeName: "source.viml",
    path: "viml.tmLanguage.json",
    aliases: ["vim", "vimscript"]
  },
  {
    id: "vue-html",
    scopeName: "text.html.vue-html",
    path: "vue-html.tmLanguage.json",
    embeddedLangs: ["vue", "javascript"]
  },
  {
    id: "vue",
    scopeName: "source.vue",
    path: "vue.tmLanguage.json",
    embeddedLangs: ["json", "markdown", "pug", "haml", "vue-html", "sass", "scss", "less", "stylus", "postcss", "css", "typescript", "coffee", "javascript"]
  },
  {
    id: "wasm",
    scopeName: "source.wat",
    path: "wasm.tmLanguage.json"
  },
  {
    id: "wenyan",
    scopeName: "source.wenyan",
    path: "wenyan.tmLanguage.json",
    aliases: ["\u6587\u8A00"]
  },
  {
    id: "xml",
    scopeName: "text.xml",
    path: "xml.tmLanguage.json",
    embeddedLangs: ["java"]
  },
  {
    id: "xsl",
    scopeName: "text.xml.xsl",
    path: "xsl.tmLanguage.json",
    embeddedLangs: ["xml"]
  },
  {
    id: "yaml",
    scopeName: "source.yaml",
    path: "yaml.tmLanguage.json"
  },
  {
    id: "zenscript",
    scopeName: "source.zenscript",
    path: "zenscript.tmLanguage.json",
    samplePath: "zenscript.sample"
  }
];
var FontStyle;
(function(FontStyle2) {
  FontStyle2[FontStyle2["NotSet"] = -1] = "NotSet";
  FontStyle2[FontStyle2["None"] = 0] = "None";
  FontStyle2[FontStyle2["Italic"] = 1] = "Italic";
  FontStyle2[FontStyle2["Bold"] = 2] = "Bold";
  FontStyle2[FontStyle2["Underline"] = 4] = "Underline";
})(FontStyle || (FontStyle = {}));
class StackElementMetadata {
  static toBinaryStr(metadata) {
    let r2 = metadata.toString(2);
    while (r2.length < 32) {
      r2 = "0" + r2;
    }
    return r2;
  }
  static printMetadata(metadata) {
    let languageId = StackElementMetadata.getLanguageId(metadata);
    let tokenType2 = StackElementMetadata.getTokenType(metadata);
    let fontStyle = StackElementMetadata.getFontStyle(metadata);
    let foreground = StackElementMetadata.getForeground(metadata);
    let background = StackElementMetadata.getBackground(metadata);
    console.log({
      languageId,
      tokenType: tokenType2,
      fontStyle,
      foreground,
      background
    });
  }
  static getLanguageId(metadata) {
    return (metadata & 255) >>> 0;
  }
  static getTokenType(metadata) {
    return (metadata & 1792) >>> 8;
  }
  static getFontStyle(metadata) {
    return (metadata & 14336) >>> 11;
  }
  static getForeground(metadata) {
    return (metadata & 8372224) >>> 14;
  }
  static getBackground(metadata) {
    return (metadata & 4286578688) >>> 23;
  }
  static set(metadata, languageId, tokenType2, fontStyle, foreground, background) {
    let _languageId = StackElementMetadata.getLanguageId(metadata);
    let _tokenType = StackElementMetadata.getTokenType(metadata);
    let _fontStyle = StackElementMetadata.getFontStyle(metadata);
    let _foreground = StackElementMetadata.getForeground(metadata);
    let _background = StackElementMetadata.getBackground(metadata);
    if (languageId !== 0) {
      _languageId = languageId;
    }
    if (tokenType2 !== 0) {
      _tokenType = tokenType2 === 8 ? 0 : tokenType2;
    }
    if (fontStyle !== FontStyle.NotSet) {
      _fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      _foreground = foreground;
    }
    if (background !== 0) {
      _background = background;
    }
    return (_languageId << 0 | _tokenType << 8 | _fontStyle << 11 | _foreground << 14 | _background << 23) >>> 0;
  }
}
function trimEndSlash(str) {
  if (str.endsWith("/") || str.endsWith("\\"))
    return str.slice(0, -1);
  return str;
}
function trimStartDot(str) {
  if (str.startsWith("./"))
    return str.slice(2);
  return str;
}
function dirname(str) {
  const parts = str.split(/[\/\\]/g);
  return parts[parts.length - 2];
}
function join(...parts) {
  return parts.map(trimEndSlash).map(trimStartDot).join("/");
}
function groupBy(elements, keyGetter) {
  const map2 = /* @__PURE__ */ new Map();
  for (const element of elements) {
    const key = keyGetter(element);
    if (map2.has(key)) {
      const group = map2.get(key);
      group.push(element);
    } else {
      map2.set(key, [element]);
    }
  }
  return map2;
}
function createScanner(text3, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len2 = text3.length;
  var pos = 0, value = "", tokenOffset = 0, token2 = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count2, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count2 || !exact) {
      var ch = text3.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count2) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token2 = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start2 = pos;
    if (text3.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text3.length && isDigit(text3.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text3.length && text3.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text3.length && isDigit(text3.charCodeAt(pos))) {
        pos++;
        while (pos < text3.length && isDigit(text3.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text3.substring(start2, pos);
      }
    }
    var end = pos;
    if (pos < text3.length && (text3.charCodeAt(pos) === 69 || text3.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text3.length && text3.charCodeAt(pos) === 43 || text3.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text3.length && isDigit(text3.charCodeAt(pos))) {
        pos++;
        while (pos < text3.length && isDigit(text3.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text3.substring(start2, end);
  }
  function scanString() {
    var result = "", start2 = pos;
    while (true) {
      if (pos >= len2) {
        result += text3.substring(start2, pos);
        scanError = 2;
        break;
      }
      var ch = text3.charCodeAt(pos);
      if (ch === 34) {
        result += text3.substring(start2, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text3.substring(start2, pos);
        pos++;
        if (pos >= len2) {
          scanError = 2;
          break;
        }
        var ch2 = text3.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start2 = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text3.substring(start2, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len2) {
      tokenOffset = len2;
      return token2 = 17;
    }
    var code3 = text3.charCodeAt(pos);
    if (isWhiteSpace$2(code3)) {
      do {
        pos++;
        value += String.fromCharCode(code3);
        code3 = text3.charCodeAt(pos);
      } while (isWhiteSpace$2(code3));
      return token2 = 15;
    }
    if (isLineBreak(code3)) {
      pos++;
      value += String.fromCharCode(code3);
      if (code3 === 13 && text3.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token2 = 14;
    }
    switch (code3) {
      case 123:
        pos++;
        return token2 = 1;
      case 125:
        pos++;
        return token2 = 2;
      case 91:
        pos++;
        return token2 = 3;
      case 93:
        pos++;
        return token2 = 4;
      case 58:
        pos++;
        return token2 = 6;
      case 44:
        pos++;
        return token2 = 5;
      case 34:
        pos++;
        value = scanString();
        return token2 = 10;
      case 47:
        var start2 = pos - 1;
        if (text3.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len2) {
            if (isLineBreak(text3.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text3.substring(start2, pos);
          return token2 = 12;
        }
        if (text3.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len2 - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text3.charCodeAt(pos);
            if (ch === 42 && text3.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text3.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text3.substring(start2, pos);
          return token2 = 13;
        }
        value += String.fromCharCode(code3);
        pos++;
        return token2 = 16;
      case 45:
        value += String.fromCharCode(code3);
        pos++;
        if (pos === len2 || !isDigit(text3.charCodeAt(pos))) {
          return token2 = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token2 = 11;
      default:
        while (pos < len2 && isUnknownContentCharacter(code3)) {
          pos++;
          code3 = text3.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text3.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token2 = 8;
            case "false":
              return token2 = 9;
            case "null":
              return token2 = 7;
          }
          return token2 = 16;
        }
        value += String.fromCharCode(code3);
        pos++;
        return token2 = 16;
    }
  }
  function isUnknownContentCharacter(code3) {
    if (isWhiteSpace$2(code3) || isLineBreak(code3)) {
      return false;
    }
    switch (code3) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token2;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace$2(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: false
  };
})(ParseOptions || (ParseOptions = {}));
function parse$1$1(text3, errors2, options) {
  if (errors2 === void 0) {
    errors2 = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentProperty = null;
  var currentParent = [];
  var previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  var visitor = {
    onObjectBegin: function() {
      var object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: function(name) {
      currentProperty = name;
    },
    onObjectEnd: function() {
      currentParent = previousParents.pop();
    },
    onArrayBegin: function() {
      var array2 = [];
      onValue(array2);
      previousParents.push(currentParent);
      currentParent = array2;
      currentProperty = null;
    },
    onArrayEnd: function() {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: function(error2, offset2, length) {
      errors2.push({ error: error2, offset: offset2, length });
    }
  };
  visit$2(text3, visitor, options);
  return currentParent[0];
}
function visit$2(text3, visitor, options) {
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text3, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options && options.disallowComments;
  var allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token2 = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError2(14);
          break;
        case 5:
          handleError2(15);
          break;
        case 3:
          handleError2(13);
          break;
        case 1:
          if (!disallowComments) {
            handleError2(11);
          }
          break;
        case 2:
          handleError2(12);
          break;
        case 6:
          handleError2(16);
          break;
      }
      switch (token2) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError2(10);
          } else {
            onComment();
          }
          break;
        case 16:
          handleError2(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return token2;
      }
    }
  }
  function handleError2(error2, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error2);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token2 = _scanner.getToken();
      while (token2 !== 17) {
        if (skipUntilAfter.indexOf(token2) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token2) !== -1) {
          break;
        }
        token2 = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var tokenValue = _scanner.getTokenValue();
        var value = Number(tokenValue);
        if (isNaN(value)) {
          handleError2(2);
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError2(3, [], [2, 5]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError2(4, [], [2, 5]);
      }
    } else {
      handleError2(5, [], [2, 5]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError2(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError2(6, [], []);
      }
      if (!parseProperty()) {
        handleError2(4, [], [2, 5]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError2(7, [2], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError2(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError2(6, [], []);
      }
      if (!parseValue()) {
        handleError2(4, [], [4, 5]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError2(8, [4], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError2(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError2(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError2(9, [], []);
  }
  return true;
}
var parse$4 = parse$1$1;
const isWebWorker = typeof self !== "undefined" && typeof self.WorkerGlobalScope !== "undefined";
const isBrowser = isWebWorker || typeof window !== "undefined" && typeof window.document !== "undefined" && typeof fetch !== "undefined";
let CDN_ROOT = "";
function setCDN(root2) {
  CDN_ROOT = root2;
}
let _onigurumaPromise = null;
async function getOniguruma() {
  if (!_onigurumaPromise) {
    let loader;
    if (isBrowser) {
      {
        loader = main$1.exports.loadWASM({
          data: await fetch(_resolvePath("dist/onig.wasm")).then((r2) => r2.arrayBuffer())
        });
      }
    } else {
      const path2 = require("path");
      const wasmPath = path2.join(require.resolve("vscode-oniguruma"), "../onig.wasm");
      const fs = require("fs");
      const wasmBin = fs.readFileSync(wasmPath).buffer;
      loader = main$1.exports.loadWASM(wasmBin);
    }
    _onigurumaPromise = loader.then(() => {
      return {
        createOnigScanner(patterns) {
          return main$1.exports.createOnigScanner(patterns);
        },
        createOnigString(s2) {
          return main$1.exports.createOnigString(s2);
        }
      };
    });
  }
  return _onigurumaPromise;
}
function _resolvePath(filepath) {
  if (isBrowser) {
    if (!CDN_ROOT) {
      console.warn("[Shiki] no CDN provider found, use `setCDN()` to specify the CDN for loading the resources before calling `getHighlighter()`");
    }
    return `${CDN_ROOT}${filepath}`;
  } else {
    const path2 = require("path");
    if (path2.isAbsolute(filepath)) {
      return filepath;
    } else {
      return path2.resolve(__dirname, "..", filepath);
    }
  }
}
async function _fetchAssets(filepath) {
  const path2 = _resolvePath(filepath);
  if (isBrowser) {
    return await fetch(path2).then((r2) => r2.text());
  } else {
    const fs = require("fs");
    return await fs.promises.readFile(path2, "utf-8");
  }
}
async function _fetchJSONAssets(filepath) {
  const errors2 = [];
  const rawTheme = parse$4(await _fetchAssets(filepath), errors2, {
    allowTrailingComma: true
  });
  if (errors2.length) {
    throw errors2[0];
  }
  return rawTheme;
}
async function fetchTheme(themePath) {
  let theme = await _fetchJSONAssets(themePath);
  const shikiTheme = toShikiTheme(theme);
  if (shikiTheme.include) {
    const includedTheme = await fetchTheme(join(dirname(themePath), shikiTheme.include));
    if (includedTheme.settings) {
      shikiTheme.settings = includedTheme.settings.concat(shikiTheme.settings);
    }
    if (includedTheme.bg && !shikiTheme.bg) {
      shikiTheme.bg = includedTheme.bg;
    }
    if (includedTheme.colors) {
      shikiTheme.colors = Object.assign(Object.assign({}, includedTheme.colors), shikiTheme.colors);
    }
    delete shikiTheme.include;
  }
  return shikiTheme;
}
async function fetchGrammar(filepath) {
  return await _fetchJSONAssets(filepath);
}
function repairTheme(theme) {
  if (!theme.settings)
    theme.settings = [];
  if (theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope) {
    return;
  }
  theme.settings.unshift({
    settings: {
      foreground: theme.fg,
      background: theme.bg
    }
  });
}
function toShikiTheme(rawTheme) {
  const type = rawTheme.type || "dark";
  const shikiTheme = Object.assign(Object.assign({ name: rawTheme.name, type }, rawTheme), getThemeDefaultColors(rawTheme));
  if (rawTheme.include) {
    shikiTheme.include = rawTheme.include;
  }
  if (rawTheme.tokenColors) {
    shikiTheme.settings = rawTheme.tokenColors;
    delete shikiTheme.tokenColors;
  }
  repairTheme(shikiTheme);
  return shikiTheme;
}
const VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
const VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
function getThemeDefaultColors(theme) {
  var _a2, _b, _c, _d, _e, _f2;
  let fg, bg;
  let settings = theme.settings ? theme.settings : theme.tokenColors;
  const globalSetting = settings ? settings.find((s2) => {
    return !s2.name && !s2.scope;
  }) : void 0;
  if ((_a2 = globalSetting === null || globalSetting === void 0 ? void 0 : globalSetting.settings) === null || _a2 === void 0 ? void 0 : _a2.foreground) {
    fg = globalSetting.settings.foreground;
  }
  if ((_b = globalSetting === null || globalSetting === void 0 ? void 0 : globalSetting.settings) === null || _b === void 0 ? void 0 : _b.background) {
    bg = globalSetting.settings.background;
  }
  if (!fg && ((_d = (_c = theme) === null || _c === void 0 ? void 0 : _c.colors) === null || _d === void 0 ? void 0 : _d["editor.foreground"])) {
    fg = theme.colors["editor.foreground"];
  }
  if (!bg && ((_f2 = (_e = theme) === null || _e === void 0 ? void 0 : _e.colors) === null || _f2 === void 0 ? void 0 : _f2["editor.background"])) {
    bg = theme.colors["editor.background"];
  }
  if (!fg) {
    fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
  }
  if (!bg) {
    bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
  }
  return {
    fg,
    bg
  };
}
class Resolver {
  constructor(onigLibPromise, onigLibName) {
    this.languagesPath = "languages/";
    this.languageMap = {};
    this.scopeToLangMap = {};
    this._onigLibPromise = onigLibPromise;
    this._onigLibName = onigLibName;
  }
  get onigLib() {
    return this._onigLibPromise;
  }
  getOnigLibName() {
    return this._onigLibName;
  }
  getLangRegistration(langIdOrAlias) {
    return this.languageMap[langIdOrAlias];
  }
  async loadGrammar(scopeName) {
    const lang2 = this.scopeToLangMap[scopeName];
    if (!lang2) {
      return null;
    }
    if (lang2.grammar) {
      return lang2.grammar;
    }
    const g2 = await fetchGrammar(languages.includes(lang2) ? `${this.languagesPath}${lang2.path}` : lang2.path);
    lang2.grammar = g2;
    return g2;
  }
  addLanguage(l2) {
    this.languageMap[l2.id] = l2;
    if (l2.aliases) {
      l2.aliases.forEach((a2) => {
        this.languageMap[a2] = l2;
      });
    }
    this.scopeToLangMap[l2.scopeName] = l2;
  }
}
function tokenizeWithTheme(theme, colorMap, fileContents, grammar, options) {
  let lines = fileContents.split(/\r\n|\r|\n/);
  let ruleStack = main.exports.INITIAL;
  let actual = [];
  let final = [];
  for (let i2 = 0, len2 = lines.length; i2 < len2; i2++) {
    let line2 = lines[i2];
    if (line2 === "") {
      actual = [];
      final.push([]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line2, ruleStack);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    let result = grammar.tokenizeLine2(line2, ruleStack);
    let tokensLength = result.tokens.length / 2;
    for (let j2 = 0; j2 < tokensLength; j2++) {
      let startIndex = result.tokens[2 * j2];
      let nextStartIndex = j2 + 1 < tokensLength ? result.tokens[2 * j2 + 2] : line2.length;
      if (startIndex === nextStartIndex) {
        continue;
      }
      let metadata = result.tokens[2 * j2 + 1];
      let foreground = StackElementMetadata.getForeground(metadata);
      let foregroundColor = colorMap[foreground];
      let fontStyle = StackElementMetadata.getFontStyle(metadata);
      let explanation = [];
      if (options.includeExplanation) {
        let offset2 = 0;
        while (startIndex + offset2 < nextStartIndex) {
          let tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          let tokenWithScopesText = line2.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);
          offset2 += tokenWithScopesText.length;
          explanation.push({
            content: tokenWithScopesText,
            scopes: explainThemeScopes(theme, tokenWithScopes.scopes)
          });
          tokensWithScopesIndex++;
        }
      }
      actual.push({
        content: line2.substring(startIndex, nextStartIndex),
        color: foregroundColor,
        fontStyle,
        explanation
      });
    }
    final.push(actual);
    actual = [];
    ruleStack = result.ruleStack;
  }
  return final;
}
function explainThemeScopes(theme, scopes) {
  let result = [];
  for (let i2 = 0, len2 = scopes.length; i2 < len2; i2++) {
    let parentScopes = scopes.slice(0, i2);
    let scope = scopes[i2];
    result[i2] = {
      scopeName: scope,
      themeMatches: explainThemeScope(theme, scope, parentScopes)
    };
  }
  return result;
}
function matchesOne(selector2, scope) {
  let selectorPrefix = selector2 + ".";
  if (selector2 === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {
    return true;
  }
  return false;
}
function matches(selector2, selectorParentScopes, scope, parentScopes) {
  if (!matchesOne(selector2, scope)) {
    return false;
  }
  let selectorParentIndex = selectorParentScopes.length - 1;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {
      selectorParentIndex--;
    }
    parentIndex--;
  }
  if (selectorParentIndex === -1) {
    return true;
  }
  return false;
}
function explainThemeScope(theme, scope, parentScopes) {
  let result = [], resultLen = 0;
  for (let i2 = 0, len2 = theme.settings.length; i2 < len2; i2++) {
    let setting = theme.settings[i2];
    let selectors;
    if (typeof setting.scope === "string") {
      selectors = setting.scope.split(/,/).map((scope2) => scope2.trim());
    } else if (Array.isArray(setting.scope)) {
      selectors = setting.scope;
    } else {
      continue;
    }
    for (let j2 = 0, lenJ = selectors.length; j2 < lenJ; j2++) {
      let rawSelector = selectors[j2];
      let rawSelectorPieces = rawSelector.split(/ /);
      let selector2 = rawSelectorPieces[rawSelectorPieces.length - 1];
      let selectorParentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
      if (matches(selector2, selectorParentScopes, scope, parentScopes)) {
        result[resultLen++] = setting;
        j2 = lenJ;
      }
    }
  }
  return result;
}
function renderToHtml(lines, options = {}) {
  var _a2;
  const bg = options.bg || "#fff";
  const optionsByLineNumber = groupBy((_a2 = options.lineOptions) !== null && _a2 !== void 0 ? _a2 : [], (option) => option.line);
  let html = "";
  html += `<pre class="shiki" style="background-color: ${bg}">`;
  if (options.langId) {
    html += `<div class="language-id">${options.langId}</div>`;
  }
  html += `<code>`;
  lines.forEach((l2, lineIndex) => {
    var _a3;
    const lineNumber = lineIndex + 1;
    const lineOptions = (_a3 = optionsByLineNumber.get(lineNumber)) !== null && _a3 !== void 0 ? _a3 : [];
    const lineClasses = getLineClasses(lineOptions).join(" ");
    html += `<span class="${lineClasses}">`;
    l2.forEach((token2) => {
      const cssDeclarations = [`color: ${token2.color || options.fg}`];
      if (token2.fontStyle & FontStyle.Italic) {
        cssDeclarations.push("font-style: italic");
      }
      if (token2.fontStyle & FontStyle.Bold) {
        cssDeclarations.push("font-weight: bold");
      }
      if (token2.fontStyle & FontStyle.Underline) {
        cssDeclarations.push("text-decoration: underline");
      }
      html += `<span style="${cssDeclarations.join("; ")}">${escapeHtml$1(token2.content)}</span>`;
    });
    html += `</span>
`;
  });
  html = html.replace(/\n*$/, "");
  html += `</code></pre>`;
  return html;
}
const htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHtml$1(html) {
  return html.replace(/[&<>"']/g, (chr) => htmlEscapes[chr]);
}
function getLineClasses(lineOptions) {
  var _a2;
  const lineClasses = /* @__PURE__ */ new Set(["line"]);
  for (const lineOption of lineOptions) {
    for (const lineClass of (_a2 = lineOption.classes) !== null && _a2 !== void 0 ? _a2 : []) {
      lineClasses.add(lineClass);
    }
  }
  return Array.from(lineClasses);
}
class Registry extends main.exports.Registry {
  constructor(_resolver) {
    super(_resolver);
    this._resolver = _resolver;
    this.themesPath = "themes/";
    this._resolvedThemes = {};
    this._resolvedGrammars = {};
  }
  getTheme(theme) {
    if (typeof theme === "string") {
      return this._resolvedThemes[theme];
    } else {
      return theme;
    }
  }
  async loadTheme(theme) {
    if (typeof theme === "string") {
      if (!this._resolvedThemes[theme]) {
        this._resolvedThemes[theme] = await fetchTheme(`${this.themesPath}${theme}.json`);
      }
      return this._resolvedThemes[theme];
    } else {
      theme = toShikiTheme(theme);
      if (theme.name) {
        this._resolvedThemes[theme.name] = theme;
      }
      return theme;
    }
  }
  async loadThemes(themes) {
    return await Promise.all(themes.map((theme) => this.loadTheme(theme)));
  }
  getLoadedThemes() {
    return Object.keys(this._resolvedThemes);
  }
  getGrammar(name) {
    return this._resolvedGrammars[name];
  }
  async loadLanguage(lang2) {
    const g2 = await this.loadGrammar(lang2.scopeName);
    this._resolvedGrammars[lang2.id] = g2;
    if (lang2.aliases) {
      lang2.aliases.forEach((la2) => {
        this._resolvedGrammars[la2] = g2;
      });
    }
  }
  async loadLanguages(langs) {
    for (const lang2 of langs) {
      this._resolver.addLanguage(lang2);
    }
    for (const lang2 of langs) {
      await this.loadLanguage(lang2);
    }
  }
  getLoadedLanguages() {
    return Object.keys(this._resolvedGrammars);
  }
}
function resolveLang(lang2) {
  return typeof lang2 === "string" ? languages.find((l2) => {
    var _a2;
    return l2.id === lang2 || ((_a2 = l2.aliases) === null || _a2 === void 0 ? void 0 : _a2.includes(lang2));
  }) : lang2;
}
function resolveOptions(options) {
  var _a2;
  let _languages = languages;
  let _themes = options.themes || [];
  if ((_a2 = options.langs) === null || _a2 === void 0 ? void 0 : _a2.length) {
    _languages = options.langs.map(resolveLang);
  }
  if (options.theme) {
    _themes.unshift(options.theme);
  }
  if (!_themes.length) {
    _themes = ["nord"];
  }
  return { _languages, _themes };
}
async function getHighlighter(options) {
  var _a2, _b;
  const { _languages, _themes } = resolveOptions(options);
  const _resolver = new Resolver(getOniguruma(), "vscode-oniguruma");
  const _registry = new Registry(_resolver);
  if ((_a2 = options.paths) === null || _a2 === void 0 ? void 0 : _a2.themes) {
    _registry.themesPath = options.paths.themes;
  }
  if ((_b = options.paths) === null || _b === void 0 ? void 0 : _b.languages) {
    _resolver.languagesPath = options.paths.languages;
  }
  const themes = await _registry.loadThemes(_themes);
  const _defaultTheme = themes[0];
  let _currentTheme;
  await _registry.loadLanguages(_languages);
  const COLOR_REPLACEMENTS = {
    "#000001": "var(--shiki-color-text)",
    "#000002": "var(--shiki-color-background)",
    "#000004": "var(--shiki-token-constant)",
    "#000005": "var(--shiki-token-string)",
    "#000006": "var(--shiki-token-comment)",
    "#000007": "var(--shiki-token-keyword)",
    "#000008": "var(--shiki-token-parameter)",
    "#000009": "var(--shiki-token-function)",
    "#000010": "var(--shiki-token-string-expression)",
    "#000011": "var(--shiki-token-punctuation)",
    "#000012": "var(--shiki-token-link)"
  };
  function fixCssVariablesTheme(theme, colorMap) {
    theme.bg = COLOR_REPLACEMENTS[theme.bg] || theme.bg;
    theme.fg = COLOR_REPLACEMENTS[theme.fg] || theme.fg;
    colorMap.forEach((val, i2) => {
      colorMap[i2] = COLOR_REPLACEMENTS[val] || val;
    });
  }
  function getTheme(theme) {
    const _theme = theme ? _registry.getTheme(theme) : _defaultTheme;
    if (!_theme) {
      throw Error(`No theme registration for ${theme}`);
    }
    if (!_currentTheme || _currentTheme.name !== _theme.name) {
      _registry.setTheme(_theme);
      _currentTheme = _theme;
    }
    const _colorMap = _registry.getColorMap();
    if (_theme.name === "css-variables") {
      fixCssVariablesTheme(_theme, _colorMap);
    }
    return { _theme, _colorMap };
  }
  function getGrammar(lang2) {
    const _grammar = _registry.getGrammar(lang2);
    if (!_grammar) {
      throw Error(`No language registration for ${lang2}`);
    }
    return { _grammar };
  }
  function codeToThemedTokens(code3, lang2 = "text", theme, options2 = { includeExplanation: true }) {
    if (isPlaintext(lang2)) {
      const lines = code3.split(/\r\n|\r|\n/);
      return [...lines.map((line2) => [{ content: line2 }])];
    }
    const { _grammar } = getGrammar(lang2);
    const { _theme, _colorMap } = getTheme(theme);
    return tokenizeWithTheme(_theme, _colorMap, code3, _grammar, options2);
  }
  function codeToHtml(code3, arg1 = "text", arg2) {
    let options2;
    if (typeof arg1 === "object") {
      options2 = arg1;
    } else {
      options2 = {
        lang: arg1,
        theme: arg2
      };
    }
    const tokens2 = codeToThemedTokens(code3, options2.lang, options2.theme, {
      includeExplanation: false
    });
    const { _theme } = getTheme(options2.theme);
    return renderToHtml(tokens2, {
      fg: _theme.fg,
      bg: _theme.bg,
      lineOptions: options2 === null || options2 === void 0 ? void 0 : options2.lineOptions
    });
  }
  async function loadTheme(theme) {
    await _registry.loadTheme(theme);
  }
  async function loadLanguage(lang2) {
    const _lang = resolveLang(lang2);
    _resolver.addLanguage(_lang);
    await _registry.loadLanguage(_lang);
  }
  function getLoadedThemes() {
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    return _registry.getLoadedLanguages();
  }
  function getBackgroundColor(theme) {
    const { _theme } = getTheme(theme);
    return _theme.bg;
  }
  function getForegroundColor(theme) {
    const { _theme } = getTheme(theme);
    return _theme.fg;
  }
  return {
    codeToThemedTokens,
    codeToHtml,
    getTheme: (theme) => {
      return getTheme(theme)._theme;
    },
    loadTheme,
    loadLanguage,
    getBackgroundColor,
    getForegroundColor,
    getLoadedThemes,
    getLoadedLanguages
  };
}
function isPlaintext(lang2) {
  return !lang2 || ["plaintext", "txt", "text"].includes(lang2);
}
var flexsearch_bundle = { exports: {} };
(function(module) {
  (function _f(self) {
    try {
      if (module)
        self = module;
    } catch (e2) {
    }
    self._factory = _f;
    var t;
    function u(a2) {
      return "undefined" !== typeof a2 ? a2 : true;
    }
    function aa(a2) {
      const b2 = Array(a2);
      for (let c2 = 0; c2 < a2; c2++)
        b2[c2] = v();
      return b2;
    }
    function v() {
      return /* @__PURE__ */ Object.create(null);
    }
    function ba(a2, b2) {
      return b2.length - a2.length;
    }
    function x(a2) {
      return "string" === typeof a2;
    }
    function C(a2) {
      return "object" === typeof a2;
    }
    function D(a2) {
      return "function" === typeof a2;
    }
    function ca(a2, b2) {
      var c2 = da;
      if (a2 && (b2 && (a2 = E(a2, b2)), this.H && (a2 = E(a2, this.H)), this.J && 1 < a2.length && (a2 = E(a2, this.J)), c2 || "" === c2)) {
        a2 = a2.split(c2);
        if (this.filter) {
          b2 = this.filter;
          c2 = a2.length;
          const d2 = [];
          for (let e2 = 0, f2 = 0; e2 < c2; e2++) {
            const g2 = a2[e2];
            g2 && !b2[g2] && (d2[f2++] = g2);
          }
          a2 = d2;
        }
        return a2;
      }
      return a2;
    }
    const da = /[\p{Z}\p{S}\p{P}\p{C}]+/u, ea = /[\u0300-\u036f]/g;
    function fa(a2, b2) {
      const c2 = Object.keys(a2), d2 = c2.length, e2 = [];
      let f2 = "", g2 = 0;
      for (let h2 = 0, k2, m2; h2 < d2; h2++)
        k2 = c2[h2], (m2 = a2[k2]) ? (e2[g2++] = F(b2 ? "(?!\\b)" + k2 + "(\\b|_)" : k2), e2[g2++] = m2) : f2 += (f2 ? "|" : "") + k2;
      f2 && (e2[g2++] = F(b2 ? "(?!\\b)(" + f2 + ")(\\b|_)" : "(" + f2 + ")"), e2[g2] = "");
      return e2;
    }
    function E(a2, b2) {
      for (let c2 = 0, d2 = b2.length; c2 < d2 && (a2 = a2.replace(b2[c2], b2[c2 + 1]), a2); c2 += 2)
        ;
      return a2;
    }
    function F(a2) {
      return new RegExp(a2, "g");
    }
    function ha(a2) {
      let b2 = "", c2 = "";
      for (let d2 = 0, e2 = a2.length, f2; d2 < e2; d2++)
        (f2 = a2[d2]) !== c2 && (b2 += c2 = f2);
      return b2;
    }
    var ja = { encode: ia, F: false, G: "" };
    function ia(a2) {
      return ca.call(this, ("" + a2).toLowerCase(), false);
    }
    const ka = {}, G = {};
    function la(a2) {
      I(a2, "add");
      I(a2, "append");
      I(a2, "search");
      I(a2, "update");
      I(a2, "remove");
    }
    function I(a2, b2) {
      a2[b2 + "Async"] = function() {
        const c2 = this, d2 = arguments;
        var e2 = d2[d2.length - 1];
        let f2;
        D(e2) && (f2 = e2, delete d2[d2.length - 1]);
        e2 = new Promise(function(g2) {
          setTimeout(function() {
            c2.async = true;
            const h2 = c2[b2].apply(c2, d2);
            c2.async = false;
            g2(h2);
          });
        });
        return f2 ? (e2.then(f2), this) : e2;
      };
    }
    function ma(a2, b2, c2, d2) {
      const e2 = a2.length;
      let f2 = [], g2, h2, k2 = 0;
      d2 && (d2 = []);
      for (let m2 = e2 - 1; 0 <= m2; m2--) {
        const n2 = a2[m2], w2 = n2.length, q2 = v();
        let r2 = !g2;
        for (let l2 = 0; l2 < w2; l2++) {
          const p2 = n2[l2], z2 = p2.length;
          if (z2)
            for (let B2 = 0, A2, y2; B2 < z2; B2++)
              if (y2 = p2[B2], g2) {
                if (g2[y2]) {
                  if (!m2) {
                    if (c2)
                      c2--;
                    else if (f2[k2++] = y2, k2 === b2)
                      return f2;
                  }
                  if (m2 || d2)
                    q2[y2] = 1;
                  r2 = true;
                }
                if (d2 && (h2[y2] = (A2 = h2[y2]) ? ++A2 : A2 = 1, A2 < e2)) {
                  const H2 = d2[A2 - 2] || (d2[A2 - 2] = []);
                  H2[H2.length] = y2;
                }
              } else
                q2[y2] = 1;
        }
        if (d2)
          g2 || (h2 = q2);
        else if (!r2)
          return [];
        g2 = q2;
      }
      if (d2)
        for (let m2 = d2.length - 1, n2, w2; 0 <= m2; m2--) {
          n2 = d2[m2];
          w2 = n2.length;
          for (let q2 = 0, r2; q2 < w2; q2++)
            if (r2 = n2[q2], !g2[r2]) {
              if (c2)
                c2--;
              else if (f2[k2++] = r2, k2 === b2)
                return f2;
              g2[r2] = 1;
            }
        }
      return f2;
    }
    function na(a2, b2) {
      const c2 = v(), d2 = v(), e2 = [];
      for (let f2 = 0; f2 < a2.length; f2++)
        c2[a2[f2]] = 1;
      for (let f2 = 0, g2; f2 < b2.length; f2++) {
        g2 = b2[f2];
        for (let h2 = 0, k2; h2 < g2.length; h2++)
          k2 = g2[h2], c2[k2] && !d2[k2] && (d2[k2] = 1, e2[e2.length] = k2);
      }
      return e2;
    }
    function J(a2) {
      this.l = true !== a2 && a2;
      this.cache = v();
      this.h = [];
    }
    function oa(a2, b2, c2) {
      C(a2) && (a2 = a2.query);
      let d2 = this.cache.get(a2);
      d2 || (d2 = this.search(a2, b2, c2), this.cache.set(a2, d2));
      return d2;
    }
    J.prototype.set = function(a2, b2) {
      if (!this.cache[a2]) {
        var c2 = this.h.length;
        c2 === this.l ? delete this.cache[this.h[c2 - 1]] : c2++;
        for (--c2; 0 < c2; c2--)
          this.h[c2] = this.h[c2 - 1];
        this.h[0] = a2;
      }
      this.cache[a2] = b2;
    };
    J.prototype.get = function(a2) {
      const b2 = this.cache[a2];
      if (this.l && b2 && (a2 = this.h.indexOf(a2))) {
        const c2 = this.h[a2 - 1];
        this.h[a2 - 1] = this.h[a2];
        this.h[a2] = c2;
      }
      return b2;
    };
    const qa = { memory: { charset: "latin:extra", D: 3, B: 4, m: false }, performance: { D: 3, B: 3, s: false, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, "default": {} };
    function ra(a2, b2, c2, d2, e2, f2) {
      setTimeout(function() {
        const g2 = a2(c2, JSON.stringify(f2));
        g2 && g2.then ? g2.then(function() {
          b2.export(a2, b2, c2, d2, e2 + 1);
        }) : b2.export(a2, b2, c2, d2, e2 + 1);
      });
    }
    function K(a2, b2) {
      if (!(this instanceof K))
        return new K(a2);
      var c2;
      if (a2) {
        x(a2) ? a2 = qa[a2] : (c2 = a2.preset) && (a2 = Object.assign({}, c2[c2], a2));
        c2 = a2.charset;
        var d2 = a2.lang;
        x(c2) && (-1 === c2.indexOf(":") && (c2 += ":default"), c2 = G[c2]);
        x(d2) && (d2 = ka[d2]);
      } else
        a2 = {};
      let e2, f2, g2 = a2.context || {};
      this.encode = a2.encode || c2 && c2.encode || ia;
      this.register = b2 || v();
      this.D = e2 = a2.resolution || 9;
      this.G = b2 = c2 && c2.G || a2.tokenize || "strict";
      this.depth = "strict" === b2 && g2.depth;
      this.l = u(g2.bidirectional);
      this.s = f2 = u(a2.optimize);
      this.m = u(a2.fastupdate);
      this.B = a2.minlength || 1;
      this.C = a2.boost;
      this.map = f2 ? aa(e2) : v();
      this.A = e2 = g2.resolution || 1;
      this.h = f2 ? aa(e2) : v();
      this.F = c2 && c2.F || a2.rtl;
      this.H = (b2 = a2.matcher || d2 && d2.H) && fa(b2, false);
      this.J = (b2 = a2.stemmer || d2 && d2.J) && fa(b2, true);
      if (c2 = b2 = a2.filter || d2 && d2.filter) {
        c2 = b2;
        d2 = v();
        for (let h2 = 0, k2 = c2.length; h2 < k2; h2++)
          d2[c2[h2]] = 1;
        c2 = d2;
      }
      this.filter = c2;
      this.cache = (b2 = a2.cache) && new J(b2);
    }
    t = K.prototype;
    t.append = function(a2, b2) {
      return this.add(a2, b2, true);
    };
    t.add = function(a2, b2, c2, d2) {
      if (b2 && (a2 || 0 === a2)) {
        if (!d2 && !c2 && this.register[a2])
          return this.update(a2, b2);
        b2 = this.encode(b2);
        if (d2 = b2.length) {
          const m2 = v(), n2 = v(), w2 = this.depth, q2 = this.D;
          for (let r2 = 0; r2 < d2; r2++) {
            let l2 = b2[this.F ? d2 - 1 - r2 : r2];
            var e2 = l2.length;
            if (l2 && e2 >= this.B && (w2 || !n2[l2])) {
              var f2 = L(q2, d2, r2), g2 = "";
              switch (this.G) {
                case "full":
                  if (3 < e2) {
                    for (f2 = 0; f2 < e2; f2++)
                      for (var h2 = e2; h2 > f2; h2--)
                        if (h2 - f2 >= this.B) {
                          var k2 = L(q2, d2, r2, e2, f2);
                          g2 = l2.substring(f2, h2);
                          M(this, n2, g2, k2, a2, c2);
                        }
                    break;
                  }
                case "reverse":
                  if (2 < e2) {
                    for (h2 = e2 - 1; 0 < h2; h2--)
                      g2 = l2[h2] + g2, g2.length >= this.B && M(this, n2, g2, L(q2, d2, r2, e2, h2), a2, c2);
                    g2 = "";
                  }
                case "forward":
                  if (1 < e2) {
                    for (h2 = 0; h2 < e2; h2++)
                      g2 += l2[h2], g2.length >= this.B && M(this, n2, g2, f2, a2, c2);
                    break;
                  }
                default:
                  if (this.C && (f2 = Math.min(f2 / this.C(b2, l2, r2) | 0, q2 - 1)), M(this, n2, l2, f2, a2, c2), w2 && 1 < d2 && r2 < d2 - 1) {
                    for (e2 = v(), g2 = this.A, f2 = l2, h2 = Math.min(w2 + 1, d2 - r2), e2[f2] = 1, k2 = 1; k2 < h2; k2++)
                      if ((l2 = b2[this.F ? d2 - 1 - r2 - k2 : r2 + k2]) && l2.length >= this.B && !e2[l2]) {
                        e2[l2] = 1;
                        const p2 = this.l && l2 > f2;
                        M(this, m2, p2 ? f2 : l2, L(g2 + (d2 / 2 > g2 ? 0 : 1), d2, r2, h2 - 1, k2 - 1), a2, c2, p2 ? l2 : f2);
                      }
                  }
              }
            }
          }
          this.m || (this.register[a2] = 1);
        }
      }
      return this;
    };
    function L(a2, b2, c2, d2, e2) {
      return c2 && 1 < a2 ? b2 + (d2 || 0) <= a2 ? c2 + (e2 || 0) : (a2 - 1) / (b2 + (d2 || 0)) * (c2 + (e2 || 0)) + 1 | 0 : 0;
    }
    function M(a2, b2, c2, d2, e2, f2, g2) {
      let h2 = g2 ? a2.h : a2.map;
      if (!b2[c2] || g2 && !b2[c2][g2])
        a2.s && (h2 = h2[d2]), g2 ? (b2 = b2[c2] || (b2[c2] = v()), b2[g2] = 1, h2 = h2[g2] || (h2[g2] = v())) : b2[c2] = 1, h2 = h2[c2] || (h2[c2] = []), a2.s || (h2 = h2[d2] || (h2[d2] = [])), f2 && -1 !== h2.indexOf(e2) || (h2[h2.length] = e2, a2.m && (a2 = a2.register[e2] || (a2.register[e2] = []), a2[a2.length] = h2));
    }
    t.search = function(a2, b2, c2) {
      c2 || (!b2 && C(a2) ? (c2 = a2, a2 = c2.query) : C(b2) && (c2 = b2));
      let d2 = [], e2;
      let f2, g2 = 0;
      if (c2) {
        b2 = c2.limit;
        g2 = c2.offset || 0;
        var h2 = c2.context;
        f2 = c2.suggest;
      }
      if (a2 && (a2 = this.encode(a2), e2 = a2.length, 1 < e2)) {
        c2 = v();
        var k2 = [];
        for (let n2 = 0, w2 = 0, q2; n2 < e2; n2++)
          if ((q2 = a2[n2]) && q2.length >= this.B && !c2[q2])
            if (this.s || f2 || this.map[q2])
              k2[w2++] = q2, c2[q2] = 1;
            else
              return d2;
        a2 = k2;
        e2 = a2.length;
      }
      if (!e2)
        return d2;
      b2 || (b2 = 100);
      h2 = this.depth && 1 < e2 && false !== h2;
      c2 = 0;
      let m2;
      h2 ? (m2 = a2[0], c2 = 1) : 1 < e2 && a2.sort(ba);
      for (let n2, w2; c2 < e2; c2++) {
        w2 = a2[c2];
        h2 ? (n2 = sa(this, d2, f2, b2, g2, 2 === e2, w2, m2), f2 && false === n2 && d2.length || (m2 = w2)) : n2 = sa(this, d2, f2, b2, g2, 1 === e2, w2);
        if (n2)
          return n2;
        if (f2 && c2 === e2 - 1) {
          k2 = d2.length;
          if (!k2) {
            if (h2) {
              h2 = 0;
              c2 = -1;
              continue;
            }
            return d2;
          }
          if (1 === k2)
            return ta(d2[0], b2, g2);
        }
      }
      return ma(d2, b2, g2, f2);
    };
    function sa(a2, b2, c2, d2, e2, f2, g2, h2) {
      let k2 = [], m2 = h2 ? a2.h : a2.map;
      a2.s || (m2 = ua(m2, g2, h2, a2.l));
      if (m2) {
        let n2 = 0;
        const w2 = Math.min(m2.length, h2 ? a2.A : a2.D);
        for (let q2 = 0, r2 = 0, l2, p2; q2 < w2; q2++)
          if (l2 = m2[q2]) {
            if (a2.s && (l2 = ua(l2, g2, h2, a2.l)), e2 && l2 && f2 && (p2 = l2.length, p2 <= e2 ? (e2 -= p2, l2 = null) : (l2 = l2.slice(e2), e2 = 0)), l2 && (k2[n2++] = l2, f2 && (r2 += l2.length, r2 >= d2)))
              break;
          }
        if (n2) {
          if (f2)
            return ta(k2, d2, 0);
          b2[b2.length] = k2;
          return;
        }
      }
      return !c2 && k2;
    }
    function ta(a2, b2, c2) {
      a2 = 1 === a2.length ? a2[0] : [].concat.apply([], a2);
      return c2 || a2.length > b2 ? a2.slice(c2, c2 + b2) : a2;
    }
    function ua(a2, b2, c2, d2) {
      c2 ? (d2 = d2 && b2 > c2, a2 = (a2 = a2[d2 ? b2 : c2]) && a2[d2 ? c2 : b2]) : a2 = a2[b2];
      return a2;
    }
    t.contain = function(a2) {
      return !!this.register[a2];
    };
    t.update = function(a2, b2) {
      return this.remove(a2).add(a2, b2);
    };
    t.remove = function(a2, b2) {
      const c2 = this.register[a2];
      if (c2) {
        if (this.m)
          for (let d2 = 0, e2; d2 < c2.length; d2++)
            e2 = c2[d2], e2.splice(e2.indexOf(a2), 1);
        else
          N(this.map, a2, this.D, this.s), this.depth && N(this.h, a2, this.A, this.s);
        b2 || delete this.register[a2];
        if (this.cache) {
          b2 = this.cache;
          for (let d2 = 0, e2, f2; d2 < b2.h.length; d2++)
            f2 = b2.h[d2], e2 = b2.cache[f2], -1 !== e2.indexOf(a2) && (b2.h.splice(d2--, 1), delete b2.cache[f2]);
        }
      }
      return this;
    };
    function N(a2, b2, c2, d2, e2) {
      let f2 = 0;
      if (a2.constructor === Array)
        if (e2)
          b2 = a2.indexOf(b2), -1 !== b2 ? 1 < a2.length && (a2.splice(b2, 1), f2++) : f2++;
        else {
          e2 = Math.min(a2.length, c2);
          for (let g2 = 0, h2; g2 < e2; g2++)
            if (h2 = a2[g2])
              f2 = N(h2, b2, c2, d2, e2), d2 || f2 || delete a2[g2];
        }
      else
        for (let g2 in a2)
          (f2 = N(a2[g2], b2, c2, d2, e2)) || delete a2[g2];
      return f2;
    }
    t.searchCache = oa;
    t.export = function(a2, b2, c2, d2, e2) {
      let f2, g2;
      switch (e2 || (e2 = 0)) {
        case 0:
          f2 = "reg";
          if (this.m) {
            g2 = v();
            for (let h2 in this.register)
              g2[h2] = 1;
          } else
            g2 = this.register;
          break;
        case 1:
          f2 = "cfg";
          g2 = { doc: 0, opt: this.s ? 1 : 0 };
          break;
        case 2:
          f2 = "map";
          g2 = this.map;
          break;
        case 3:
          f2 = "ctx";
          g2 = this.h;
          break;
        default:
          return;
      }
      ra(a2, b2 || this, c2 ? c2 + "." + f2 : f2, d2, e2, g2);
      return true;
    };
    t.import = function(a2, b2) {
      if (b2)
        switch (x(b2) && (b2 = JSON.parse(b2)), a2) {
          case "cfg":
            this.s = !!b2.opt;
            break;
          case "reg":
            this.m = false;
            this.register = b2;
            break;
          case "map":
            this.map = b2;
            break;
          case "ctx":
            this.h = b2;
        }
    };
    la(K.prototype);
    function va(a2) {
      a2 = a2.data;
      var b2 = self._index;
      const c2 = a2.args;
      var d2 = a2.task;
      switch (d2) {
        case "init":
          d2 = a2.options || {};
          a2 = a2.factory;
          b2 = d2.encode;
          d2.cache = false;
          b2 && 0 === b2.indexOf("function") && (d2.encode = Function("return " + b2)());
          a2 ? (Function("return " + a2)()(self), self._index = new self.FlexSearch.Index(d2), delete self.FlexSearch) : self._index = new K(d2);
          break;
        default:
          a2 = a2.id, b2 = b2[d2].apply(b2, c2), postMessage("search" === d2 ? { id: a2, msg: b2 } : { id: a2 });
      }
    }
    let wa = 0;
    function O(a2) {
      if (!(this instanceof O))
        return new O(a2);
      var b2;
      a2 ? D(b2 = a2.encode) && (a2.encode = b2.toString()) : a2 = {};
      (b2 = (self || window)._factory) && (b2 = b2.toString());
      const c2 = self.exports, d2 = this;
      this.o = xa(b2, c2, a2.worker);
      this.h = v();
      if (this.o) {
        if (c2)
          this.o.on("message", function(e2) {
            d2.h[e2.id](e2.msg);
            delete d2.h[e2.id];
          });
        else
          this.o.onmessage = function(e2) {
            e2 = e2.data;
            d2.h[e2.id](e2.msg);
            delete d2.h[e2.id];
          };
        this.o.postMessage({ task: "init", factory: b2, options: a2 });
      }
    }
    P("add");
    P("append");
    P("search");
    P("update");
    P("remove");
    function P(a2) {
      O.prototype[a2] = O.prototype[a2 + "Async"] = function() {
        const b2 = this, c2 = [].slice.call(arguments);
        var d2 = c2[c2.length - 1];
        let e2;
        D(d2) && (e2 = d2, c2.splice(c2.length - 1, 1));
        d2 = new Promise(function(f2) {
          setTimeout(function() {
            b2.h[++wa] = f2;
            b2.o.postMessage({ task: a2, id: wa, args: c2 });
          });
        });
        return e2 ? (d2.then(e2), this) : d2;
      };
    }
    function xa(a, b, c) {
      let d;
      try {
        d = b ? eval('new (require("worker_threads")["Worker"])("../dist/node/node.js")') : a ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + va.toString()], { type: "text/javascript" }))) : new Worker(x(c) ? c : "worker/worker.js", { type: "module" });
      } catch (e2) {
      }
      return d;
    }
    function Q(a2) {
      if (!(this instanceof Q))
        return new Q(a2);
      var b2 = a2.document || a2.doc || a2, c2;
      this.K = [];
      this.h = [];
      this.A = [];
      this.register = v();
      this.key = (c2 = b2.key || b2.id) && S(c2, this.A) || "id";
      this.m = u(a2.fastupdate);
      this.C = (c2 = b2.store) && true !== c2 && [];
      this.store = c2 && v();
      this.I = (c2 = b2.tag) && S(c2, this.A);
      this.l = c2 && v();
      this.cache = (c2 = a2.cache) && new J(c2);
      a2.cache = false;
      this.o = a2.worker;
      this.async = false;
      c2 = v();
      let d2 = b2.index || b2.field || b2;
      x(d2) && (d2 = [d2]);
      for (let e2 = 0, f2, g2; e2 < d2.length; e2++)
        f2 = d2[e2], x(f2) || (g2 = f2, f2 = f2.field), g2 = C(g2) ? Object.assign({}, a2, g2) : a2, this.o && (c2[f2] = new O(g2), c2[f2].o || (this.o = false)), this.o || (c2[f2] = new K(g2, this.register)), this.K[e2] = S(f2, this.A), this.h[e2] = f2;
      if (this.C)
        for (a2 = b2.store, x(a2) && (a2 = [a2]), b2 = 0; b2 < a2.length; b2++)
          this.C[b2] = S(a2[b2], this.A);
      this.index = c2;
    }
    function S(a2, b2) {
      const c2 = a2.split(":");
      let d2 = 0;
      for (let e2 = 0; e2 < c2.length; e2++)
        a2 = c2[e2], 0 <= a2.indexOf("[]") && (a2 = a2.substring(0, a2.length - 2)) && (b2[d2] = true), a2 && (c2[d2++] = a2);
      d2 < c2.length && (c2.length = d2);
      return 1 < d2 ? c2 : c2[0];
    }
    function T(a2, b2) {
      if (x(b2))
        a2 = a2[b2];
      else
        for (let c2 = 0; a2 && c2 < b2.length; c2++)
          a2 = a2[b2[c2]];
      return a2;
    }
    function U(a2, b2, c2, d2, e2) {
      a2 = a2[e2];
      if (d2 === c2.length - 1)
        b2[e2] = a2;
      else if (a2)
        if (a2.constructor === Array)
          for (b2 = b2[e2] = Array(a2.length), e2 = 0; e2 < a2.length; e2++)
            U(a2, b2, c2, d2, e2);
        else
          b2 = b2[e2] || (b2[e2] = v()), e2 = c2[++d2], U(a2, b2, c2, d2, e2);
    }
    function V(a2, b2, c2, d2, e2, f2, g2, h2) {
      if (a2 = a2[g2])
        if (d2 === b2.length - 1) {
          if (a2.constructor === Array) {
            if (c2[d2]) {
              for (b2 = 0; b2 < a2.length; b2++)
                e2.add(f2, a2[b2], true, true);
              return;
            }
            a2 = a2.join(" ");
          }
          e2.add(f2, a2, h2, true);
        } else if (a2.constructor === Array)
          for (g2 = 0; g2 < a2.length; g2++)
            V(a2, b2, c2, d2, e2, f2, g2, h2);
        else
          g2 = b2[++d2], V(a2, b2, c2, d2, e2, f2, g2, h2);
    }
    t = Q.prototype;
    t.add = function(a2, b2, c2) {
      C(a2) && (b2 = a2, a2 = T(b2, this.key));
      if (b2 && (a2 || 0 === a2)) {
        if (!c2 && this.register[a2])
          return this.update(a2, b2);
        for (let d2 = 0, e2, f2; d2 < this.h.length; d2++)
          f2 = this.h[d2], e2 = this.K[d2], x(e2) && (e2 = [e2]), V(b2, e2, this.A, 0, this.index[f2], a2, e2[0], c2);
        if (this.I) {
          let d2 = T(b2, this.I), e2 = v();
          x(d2) && (d2 = [d2]);
          for (let f2 = 0, g2, h2; f2 < d2.length; f2++)
            if (g2 = d2[f2], !e2[g2] && (e2[g2] = 1, h2 = this.l[g2] || (this.l[g2] = []), !c2 || -1 === h2.indexOf(a2))) {
              if (h2[h2.length] = a2, this.m) {
                const k2 = this.register[a2] || (this.register[a2] = []);
                k2[k2.length] = h2;
              }
            }
        }
        if (this.store && (!c2 || !this.store[a2])) {
          let d2;
          if (this.C) {
            d2 = v();
            for (let e2 = 0, f2; e2 < this.C.length; e2++)
              f2 = this.C[e2], x(f2) ? d2[f2] = b2[f2] : U(b2, d2, f2, 0, f2[0]);
          }
          this.store[a2] = d2 || b2;
        }
      }
      return this;
    };
    t.append = function(a2, b2) {
      return this.add(a2, b2, true);
    };
    t.update = function(a2, b2) {
      return this.remove(a2).add(a2, b2);
    };
    t.remove = function(a2) {
      C(a2) && (a2 = T(a2, this.key));
      if (this.register[a2]) {
        for (var b2 = 0; b2 < this.h.length && (this.index[this.h[b2]].remove(a2, !this.o), !this.m); b2++)
          ;
        if (this.I && !this.m)
          for (let c2 in this.l) {
            b2 = this.l[c2];
            const d2 = b2.indexOf(a2);
            -1 !== d2 && (1 < b2.length ? b2.splice(d2, 1) : delete this.l[c2]);
          }
        this.store && delete this.store[a2];
        delete this.register[a2];
      }
      return this;
    };
    t.search = function(a2, b2, c2, d2) {
      c2 || (!b2 && C(a2) ? (c2 = a2, a2 = c2.query) : C(b2) && (c2 = b2, b2 = 0));
      let e2 = [], f2 = [], g2, h2, k2, m2, n2, w2, q2 = 0;
      if (c2)
        if (c2.constructor === Array)
          k2 = c2, c2 = null;
        else {
          k2 = (g2 = c2.pluck) || c2.index || c2.field;
          m2 = c2.tag;
          h2 = this.store && c2.enrich;
          n2 = "and" === c2.bool;
          b2 = c2.limit || 100;
          w2 = c2.offset || 0;
          if (m2 && (x(m2) && (m2 = [m2]), !a2)) {
            for (let l2 = 0, p2; l2 < m2.length; l2++)
              if (p2 = ya.call(this, m2[l2], b2, w2, h2))
                e2[e2.length] = p2, q2++;
            return q2 ? e2 : [];
          }
          x(k2) && (k2 = [k2]);
        }
      k2 || (k2 = this.h);
      n2 = n2 && (1 < k2.length || m2 && 1 < m2.length);
      const r2 = !d2 && (this.o || this.async) && [];
      for (let l2 = 0, p2, z2, B2; l2 < k2.length; l2++) {
        let A2;
        z2 = k2[l2];
        x(z2) || (A2 = z2, z2 = z2.field);
        if (r2)
          r2[l2] = this.index[z2].searchAsync(a2, b2, A2 || c2);
        else {
          d2 ? p2 = d2[l2] : p2 = this.index[z2].search(a2, b2, A2 || c2);
          B2 = p2 && p2.length;
          if (m2 && B2) {
            const y2 = [];
            let H2 = 0;
            n2 && (y2[0] = [p2]);
            for (let X2 = 0, pa, R2; X2 < m2.length; X2++)
              if (pa = m2[X2], B2 = (R2 = this.l[pa]) && R2.length)
                H2++, y2[y2.length] = n2 ? [R2] : R2;
            H2 && (p2 = n2 ? ma(y2, b2 || 100, w2 || 0) : na(p2, y2), B2 = p2.length);
          }
          if (B2)
            f2[q2] = z2, e2[q2++] = p2;
          else if (n2)
            return [];
        }
      }
      if (r2) {
        const l2 = this;
        return new Promise(function(p2) {
          Promise.all(r2).then(function(z2) {
            p2(l2.search(a2, b2, c2, z2));
          });
        });
      }
      if (!q2)
        return [];
      if (g2 && (!h2 || !this.store))
        return e2[0];
      for (let l2 = 0, p2; l2 < f2.length; l2++) {
        p2 = e2[l2];
        p2.length && h2 && (p2 = za.call(this, p2));
        if (g2)
          return p2;
        e2[l2] = { field: f2[l2], result: p2 };
      }
      return e2;
    };
    function ya(a2, b2, c2, d2) {
      let e2 = this.l[a2], f2 = e2 && e2.length - c2;
      if (f2 && 0 < f2) {
        if (f2 > b2 || c2)
          e2 = e2.slice(c2, c2 + b2);
        d2 && (e2 = za.call(this, e2));
        return { tag: a2, result: e2 };
      }
    }
    function za(a2) {
      const b2 = Array(a2.length);
      for (let c2 = 0, d2; c2 < a2.length; c2++)
        d2 = a2[c2], b2[c2] = { id: d2, doc: this.store[d2] };
      return b2;
    }
    t.contain = function(a2) {
      return !!this.register[a2];
    };
    t.get = function(a2) {
      return this.store[a2];
    };
    t.set = function(a2, b2) {
      this.store[a2] = b2;
      return this;
    };
    t.searchCache = oa;
    t.export = function(a2, b2, c2, d2, e2) {
      e2 || (e2 = 0);
      d2 || (d2 = 0);
      if (d2 < this.h.length) {
        const f2 = this.h[d2], g2 = this.index[f2];
        b2 = this;
        setTimeout(function() {
          g2.export(a2, b2, e2 ? f2.replace(":", "-") : "", d2, e2++) || (d2++, e2 = 1, b2.export(a2, b2, f2, d2, e2));
        });
      } else {
        let f2;
        switch (e2) {
          case 1:
            c2 = "tag";
            f2 = this.l;
            break;
          case 2:
            c2 = "store";
            f2 = this.store;
            break;
          default:
            return;
        }
        ra(a2, this, c2, d2, e2, f2);
      }
    };
    t.import = function(a2, b2) {
      if (b2)
        switch (x(b2) && (b2 = JSON.parse(b2)), a2) {
          case "tag":
            this.l = b2;
            break;
          case "reg":
            this.m = false;
            this.register = b2;
            for (let d2 = 0, e2; d2 < this.h.length; d2++)
              e2 = this.index[this.h[d2]], e2.register = b2, e2.m = false;
            break;
          case "store":
            this.store = b2;
            break;
          default:
            a2 = a2.split(".");
            const c2 = a2[0];
            a2 = a2[1];
            c2 && a2 && this.index[c2].import(a2, b2);
        }
    };
    la(Q.prototype);
    var Ba = { encode: Aa, F: false, G: "" };
    const Ca = [F("[\xE0\xE1\xE2\xE3\xE4\xE5]"), "a", F("[\xE8\xE9\xEA\xEB]"), "e", F("[\xEC\xED\xEE\xEF]"), "i", F("[\xF2\xF3\xF4\xF5\xF6\u0151]"), "o", F("[\xF9\xFA\xFB\xFC\u0171]"), "u", F("[\xFD\u0177\xFF]"), "y", F("\xF1"), "n", F("[\xE7c]"), "k", F("\xDF"), "s", F(" & "), " and "];
    function Aa(a2) {
      var b2 = a2;
      b2.normalize && (b2 = b2.normalize("NFD").replace(ea, ""));
      return ca.call(this, b2.toLowerCase(), !a2.normalize && Ca);
    }
    var Ea = { encode: Da, F: false, G: "strict" };
    const Fa = /[^a-z0-9]+/, Ga = { b: "p", v: "f", w: "f", z: "s", x: "s", "\xDF": "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" };
    function Da(a2) {
      a2 = Aa.call(this, a2).join(" ");
      const b2 = [];
      if (a2) {
        const c2 = a2.split(Fa), d2 = c2.length;
        for (let e2 = 0, f2, g2 = 0; e2 < d2; e2++)
          if ((a2 = c2[e2]) && (!this.filter || !this.filter[a2])) {
            f2 = a2[0];
            let h2 = Ga[f2] || f2, k2 = h2;
            for (let m2 = 1; m2 < a2.length; m2++) {
              f2 = a2[m2];
              const n2 = Ga[f2] || f2;
              n2 && n2 !== k2 && (h2 += n2, k2 = n2);
            }
            b2[g2++] = h2;
          }
      }
      return b2;
    }
    var Ia = { encode: Ha, F: false, G: "" };
    const Ja = [F("ae"), "a", F("oe"), "o", F("sh"), "s", F("th"), "t", F("ph"), "f", F("pf"), "f", F("(?![aeo])h(?![aeo])"), "", F("(?!^[aeo])h(?!^[aeo])"), ""];
    function Ha(a2, b2) {
      a2 && (a2 = Da.call(this, a2).join(" "), 2 < a2.length && (a2 = E(a2, Ja)), b2 || (1 < a2.length && (a2 = ha(a2)), a2 && (a2 = a2.split(" "))));
      return a2;
    }
    var La = { encode: Ka, F: false, G: "" };
    const Ma = F("(?!\\b)[aeo]");
    function Ka(a2) {
      a2 && (a2 = Ha.call(this, a2, true), 1 < a2.length && (a2 = a2.replace(Ma, "")), 1 < a2.length && (a2 = ha(a2)), a2 && (a2 = a2.split(" ")));
      return a2;
    }
    G["latin:default"] = ja;
    G["latin:simple"] = Ba;
    G["latin:balance"] = Ea;
    G["latin:advanced"] = Ia;
    G["latin:extra"] = La;
    const W = self;
    let Y;
    const Z = { Index: K, Document: Q, Worker: O, registerCharset: function(a2, b2) {
      G[a2] = b2;
    }, registerLanguage: function(a2, b2) {
      ka[a2] = b2;
    } };
    (Y = W.define) && Y.amd ? Y([], function() {
      return Z;
    }) : W.exports ? W.exports = Z : W.FlexSearch = Z;
  })(commonjsGlobal);
})(flexsearch_bundle);
var flexsearch = flexsearch_bundle.exports;
var colorHash = {};
(function(exports2) {
  var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    return function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
  };
  var _block, _blocks, _bytes, _finalized, _first, _h0, _h1, _h2, _h3, _h4, _h5, _h6, _h7, _hashed, _hBytes, _is224, _lastByteIndex, _start, _inner, _is224_1, _oKeyPad, _sharedMemory;
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var BKDRHash = function(str) {
    var seed = 131;
    var seed2 = 137;
    var hash2 = 0;
    str += "x";
    var MAX_SAFE_INTEGER = Math.floor(9007199254740991 / seed2);
    for (var i2 = 0; i2 < str.length; i2++) {
      if (hash2 > MAX_SAFE_INTEGER) {
        hash2 = Math.floor(hash2 / seed2);
      }
      hash2 = hash2 * seed + str.charCodeAt(i2);
    }
    return hash2;
  };
  var HEX_CHARS = "0123456789abcdef".split("");
  var EXTRA = [
    -2147483648,
    8388608,
    32768,
    128
  ];
  var SHIFT = [
    24,
    16,
    8,
    0
  ];
  var K2 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  var blocks = [];
  var Sha256 = function() {
    function Sha2562(is2241, sharedMemory1) {
      if (is2241 === void 0) {
        is2241 = false;
      }
      if (sharedMemory1 === void 0) {
        sharedMemory1 = false;
      }
      _block.set(this, void 0);
      _blocks.set(this, void 0);
      _bytes.set(this, void 0);
      _finalized.set(this, void 0);
      _first.set(this, void 0);
      _h0.set(this, void 0);
      _h1.set(this, void 0);
      _h2.set(this, void 0);
      _h3.set(this, void 0);
      _h4.set(this, void 0);
      _h5.set(this, void 0);
      _h6.set(this, void 0);
      _h7.set(this, void 0);
      _hashed.set(this, void 0);
      _hBytes.set(this, void 0);
      _is224.set(this, void 0);
      _lastByteIndex.set(this, 0);
      _start.set(this, void 0);
      this.init(is2241, sharedMemory1);
    }
    Sha2562.prototype.init = function(is224, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        __classPrivateFieldSet(this, _blocks, blocks);
      } else {
        __classPrivateFieldSet(this, _blocks, [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]);
      }
      if (is224) {
        __classPrivateFieldSet(this, _h0, 3238371032);
        __classPrivateFieldSet(this, _h1, 914150663);
        __classPrivateFieldSet(this, _h2, 812702999);
        __classPrivateFieldSet(this, _h3, 4144912697);
        __classPrivateFieldSet(this, _h4, 4290775857);
        __classPrivateFieldSet(this, _h5, 1750603025);
        __classPrivateFieldSet(this, _h6, 1694076839);
        __classPrivateFieldSet(this, _h7, 3204075428);
      } else {
        __classPrivateFieldSet(this, _h0, 1779033703);
        __classPrivateFieldSet(this, _h1, 3144134277);
        __classPrivateFieldSet(this, _h2, 1013904242);
        __classPrivateFieldSet(this, _h3, 2773480762);
        __classPrivateFieldSet(this, _h4, 1359893119);
        __classPrivateFieldSet(this, _h5, 2600822924);
        __classPrivateFieldSet(this, _h6, 528734635);
        __classPrivateFieldSet(this, _h7, 1541459225);
      }
      __classPrivateFieldSet(this, _block, __classPrivateFieldSet(this, _start, __classPrivateFieldSet(this, _bytes, __classPrivateFieldSet(this, _hBytes, 0))));
      __classPrivateFieldSet(this, _finalized, __classPrivateFieldSet(this, _hashed, false));
      __classPrivateFieldSet(this, _first, true);
      __classPrivateFieldSet(this, _is224, is224);
    };
    Sha2562.prototype.update = function(message) {
      if (__classPrivateFieldGet(this, _finalized)) {
        return this;
      }
      var msg;
      if (message instanceof ArrayBuffer) {
        msg = new Uint8Array(message);
      } else {
        msg = message;
      }
      var index2 = 0;
      var length = msg.length;
      var blocks1 = __classPrivateFieldGet(this, _blocks);
      while (index2 < length) {
        var i2 = void 0;
        if (__classPrivateFieldGet(this, _hashed)) {
          __classPrivateFieldSet(this, _hashed, false);
          blocks1[0] = __classPrivateFieldGet(this, _block);
          blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0;
        }
        if (typeof msg !== "string") {
          for (i2 = __classPrivateFieldGet(this, _start); index2 < length && i2 < 64; ++index2) {
            blocks1[i2 >> 2] |= msg[index2] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = __classPrivateFieldGet(this, _start); index2 < length && i2 < 64; ++index2) {
            var code3 = msg.charCodeAt(index2);
            if (code3 < 128) {
              blocks1[i2 >> 2] |= code3 << SHIFT[i2++ & 3];
            } else if (code3 < 2048) {
              blocks1[i2 >> 2] |= (192 | code3 >> 6) << SHIFT[i2++ & 3];
              blocks1[i2 >> 2] |= (128 | code3 & 63) << SHIFT[i2++ & 3];
            } else if (code3 < 55296 || code3 >= 57344) {
              blocks1[i2 >> 2] |= (224 | code3 >> 12) << SHIFT[i2++ & 3];
              blocks1[i2 >> 2] |= (128 | code3 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks1[i2 >> 2] |= (128 | code3 & 63) << SHIFT[i2++ & 3];
            } else {
              code3 = 65536 + ((code3 & 1023) << 10 | msg.charCodeAt(++index2) & 1023);
              blocks1[i2 >> 2] |= (240 | code3 >> 18) << SHIFT[i2++ & 3];
              blocks1[i2 >> 2] |= (128 | code3 >> 12 & 63) << SHIFT[i2++ & 3];
              blocks1[i2 >> 2] |= (128 | code3 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks1[i2 >> 2] |= (128 | code3 & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        __classPrivateFieldSet(this, _lastByteIndex, i2);
        __classPrivateFieldSet(this, _bytes, __classPrivateFieldGet(this, _bytes) + (i2 - __classPrivateFieldGet(this, _start)));
        if (i2 >= 64) {
          __classPrivateFieldSet(this, _block, blocks1[16]);
          __classPrivateFieldSet(this, _start, i2 - 64);
          this.hash();
          __classPrivateFieldSet(this, _hashed, true);
        } else {
          __classPrivateFieldSet(this, _start, i2);
        }
      }
      if (__classPrivateFieldGet(this, _bytes) > 4294967295) {
        __classPrivateFieldSet(this, _hBytes, __classPrivateFieldGet(this, _hBytes) + (__classPrivateFieldGet(this, _bytes) / 4294967296 << 0));
        __classPrivateFieldSet(this, _bytes, __classPrivateFieldGet(this, _bytes) % 4294967296);
      }
      return this;
    };
    Sha2562.prototype.finalize = function() {
      if (__classPrivateFieldGet(this, _finalized)) {
        return;
      }
      __classPrivateFieldSet(this, _finalized, true);
      var blocks1 = __classPrivateFieldGet(this, _blocks);
      var i2 = __classPrivateFieldGet(this, _lastByteIndex);
      blocks1[16] = __classPrivateFieldGet(this, _block);
      blocks1[i2 >> 2] |= EXTRA[i2 & 3];
      __classPrivateFieldSet(this, _block, blocks1[16]);
      if (i2 >= 56) {
        if (!__classPrivateFieldGet(this, _hashed)) {
          this.hash();
        }
        blocks1[0] = __classPrivateFieldGet(this, _block);
        blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0;
      }
      blocks1[14] = __classPrivateFieldGet(this, _hBytes) << 3 | __classPrivateFieldGet(this, _bytes) >>> 29;
      blocks1[15] = __classPrivateFieldGet(this, _bytes) << 3;
      this.hash();
    };
    Sha2562.prototype.hash = function() {
      var a2 = __classPrivateFieldGet(this, _h0);
      var b2 = __classPrivateFieldGet(this, _h1);
      var c2 = __classPrivateFieldGet(this, _h2);
      var d2 = __classPrivateFieldGet(this, _h3);
      var e2 = __classPrivateFieldGet(this, _h4);
      var f2 = __classPrivateFieldGet(this, _h5);
      var g2 = __classPrivateFieldGet(this, _h6);
      var h2 = __classPrivateFieldGet(this, _h7);
      var blocks1 = __classPrivateFieldGet(this, _blocks);
      var s0;
      var s1;
      var maj;
      var t1;
      var t2;
      var ch;
      var ab;
      var da2;
      var cd;
      var bc;
      for (var j2 = 16; j2 < 64; ++j2) {
        t1 = blocks1[j2 - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks1[j2 - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks1[j2] = blocks1[j2 - 16] + s0 + blocks1[j2 - 7] + s1 << 0;
      }
      bc = b2 & c2;
      for (var j1 = 0; j1 < 64; j1 += 4) {
        if (__classPrivateFieldGet(this, _first)) {
          if (__classPrivateFieldGet(this, _is224)) {
            ab = 300032;
            t1 = blocks1[0] - 1413257819;
            h2 = t1 - 150054599 << 0;
            d2 = t1 + 24177077 << 0;
          } else {
            ab = 704751109;
            t1 = blocks1[0] - 210244248;
            h2 = t1 - 1521486534 << 0;
            d2 = t1 + 143694565 << 0;
          }
          __classPrivateFieldSet(this, _first, false);
        } else {
          s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ab = a2 & b2;
          maj = ab ^ a2 & c2 ^ bc;
          ch = e2 & f2 ^ ~e2 & g2;
          t1 = h2 + s1 + ch + K2[j1] + blocks1[j1];
          t2 = s0 + maj;
          h2 = d2 + t1 << 0;
          d2 = t1 + t2 << 0;
        }
        s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
        s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
        da2 = d2 & a2;
        maj = da2 ^ d2 & b2 ^ ab;
        ch = h2 & e2 ^ ~h2 & f2;
        t1 = g2 + s1 + ch + K2[j1 + 1] + blocks1[j1 + 1];
        t2 = s0 + maj;
        g2 = c2 + t1 << 0;
        c2 = t1 + t2 << 0;
        s0 = (c2 >>> 2 | c2 << 30) ^ (c2 >>> 13 | c2 << 19) ^ (c2 >>> 22 | c2 << 10);
        s1 = (g2 >>> 6 | g2 << 26) ^ (g2 >>> 11 | g2 << 21) ^ (g2 >>> 25 | g2 << 7);
        cd = c2 & d2;
        maj = cd ^ c2 & a2 ^ da2;
        ch = g2 & h2 ^ ~g2 & e2;
        t1 = f2 + s1 + ch + K2[j1 + 2] + blocks1[j1 + 2];
        t2 = s0 + maj;
        f2 = b2 + t1 << 0;
        b2 = t1 + t2 << 0;
        s0 = (b2 >>> 2 | b2 << 30) ^ (b2 >>> 13 | b2 << 19) ^ (b2 >>> 22 | b2 << 10);
        s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
        bc = b2 & c2;
        maj = bc ^ b2 & d2 ^ cd;
        ch = f2 & g2 ^ ~f2 & h2;
        t1 = e2 + s1 + ch + K2[j1 + 3] + blocks1[j1 + 3];
        t2 = s0 + maj;
        e2 = a2 + t1 << 0;
        a2 = t1 + t2 << 0;
      }
      __classPrivateFieldSet(this, _h0, __classPrivateFieldGet(this, _h0) + a2 << 0);
      __classPrivateFieldSet(this, _h1, __classPrivateFieldGet(this, _h1) + b2 << 0);
      __classPrivateFieldSet(this, _h2, __classPrivateFieldGet(this, _h2) + c2 << 0);
      __classPrivateFieldSet(this, _h3, __classPrivateFieldGet(this, _h3) + d2 << 0);
      __classPrivateFieldSet(this, _h4, __classPrivateFieldGet(this, _h4) + e2 << 0);
      __classPrivateFieldSet(this, _h5, __classPrivateFieldGet(this, _h5) + f2 << 0);
      __classPrivateFieldSet(this, _h6, __classPrivateFieldGet(this, _h6) + g2 << 0);
      __classPrivateFieldSet(this, _h7, __classPrivateFieldGet(this, _h7) + h2 << 0);
    };
    Sha2562.prototype.hex = function() {
      this.finalize();
      var h0 = __classPrivateFieldGet(this, _h0);
      var h1 = __classPrivateFieldGet(this, _h1);
      var h2 = __classPrivateFieldGet(this, _h2);
      var h3 = __classPrivateFieldGet(this, _h3);
      var h4 = __classPrivateFieldGet(this, _h4);
      var h5 = __classPrivateFieldGet(this, _h5);
      var h6 = __classPrivateFieldGet(this, _h6);
      var h7 = __classPrivateFieldGet(this, _h7);
      var hex2 = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!__classPrivateFieldGet(this, _is224)) {
        hex2 += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
      }
      return hex2;
    };
    Sha2562.prototype.toString = function() {
      return this.hex();
    };
    Sha2562.prototype.digest = function() {
      this.finalize();
      var h0 = __classPrivateFieldGet(this, _h0);
      var h1 = __classPrivateFieldGet(this, _h1);
      var h2 = __classPrivateFieldGet(this, _h2);
      var h3 = __classPrivateFieldGet(this, _h3);
      var h4 = __classPrivateFieldGet(this, _h4);
      var h5 = __classPrivateFieldGet(this, _h5);
      var h6 = __classPrivateFieldGet(this, _h6);
      var h7 = __classPrivateFieldGet(this, _h7);
      var arr = [
        h0 >> 24 & 255,
        h0 >> 16 & 255,
        h0 >> 8 & 255,
        h0 & 255,
        h1 >> 24 & 255,
        h1 >> 16 & 255,
        h1 >> 8 & 255,
        h1 & 255,
        h2 >> 24 & 255,
        h2 >> 16 & 255,
        h2 >> 8 & 255,
        h2 & 255,
        h3 >> 24 & 255,
        h3 >> 16 & 255,
        h3 >> 8 & 255,
        h3 & 255,
        h4 >> 24 & 255,
        h4 >> 16 & 255,
        h4 >> 8 & 255,
        h4 & 255,
        h5 >> 24 & 255,
        h5 >> 16 & 255,
        h5 >> 8 & 255,
        h5 & 255,
        h6 >> 24 & 255,
        h6 >> 16 & 255,
        h6 >> 8 & 255,
        h6 & 255
      ];
      if (!__classPrivateFieldGet(this, _is224)) {
        arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
      }
      return arr;
    };
    Sha2562.prototype.array = function() {
      return this.digest();
    };
    Sha2562.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer2 = new ArrayBuffer(__classPrivateFieldGet(this, _is224) ? 28 : 32);
      var dataView = new DataView(buffer2);
      dataView.setUint32(0, __classPrivateFieldGet(this, _h0));
      dataView.setUint32(4, __classPrivateFieldGet(this, _h1));
      dataView.setUint32(8, __classPrivateFieldGet(this, _h2));
      dataView.setUint32(12, __classPrivateFieldGet(this, _h3));
      dataView.setUint32(16, __classPrivateFieldGet(this, _h4));
      dataView.setUint32(20, __classPrivateFieldGet(this, _h5));
      dataView.setUint32(24, __classPrivateFieldGet(this, _h6));
      if (!__classPrivateFieldGet(this, _is224)) {
        dataView.setUint32(28, __classPrivateFieldGet(this, _h7));
      }
      return buffer2;
    };
    return Sha2562;
  }();
  _block = /* @__PURE__ */ new WeakMap(), _blocks = /* @__PURE__ */ new WeakMap(), _bytes = /* @__PURE__ */ new WeakMap(), _finalized = /* @__PURE__ */ new WeakMap(), _first = /* @__PURE__ */ new WeakMap(), _h0 = /* @__PURE__ */ new WeakMap(), _h1 = /* @__PURE__ */ new WeakMap(), _h2 = /* @__PURE__ */ new WeakMap(), _h3 = /* @__PURE__ */ new WeakMap(), _h4 = /* @__PURE__ */ new WeakMap(), _h5 = /* @__PURE__ */ new WeakMap(), _h6 = /* @__PURE__ */ new WeakMap(), _h7 = /* @__PURE__ */ new WeakMap(), _hashed = /* @__PURE__ */ new WeakMap(), _hBytes = /* @__PURE__ */ new WeakMap(), _is224 = /* @__PURE__ */ new WeakMap(), _lastByteIndex = /* @__PURE__ */ new WeakMap(), _start = /* @__PURE__ */ new WeakMap();
  (function(_super) {
    __extends(HmacSha256, _super);
    function HmacSha256(secretKey, is2242, sharedMemory2) {
      if (is2242 === void 0) {
        is2242 = false;
      }
      if (sharedMemory2 === void 0) {
        sharedMemory2 = false;
      }
      var _this = _super.call(this, is2242, sharedMemory2) || this;
      _inner.set(_this, void 0);
      _is224_1.set(_this, void 0);
      _oKeyPad.set(_this, void 0);
      _sharedMemory.set(_this, void 0);
      var key;
      if (typeof secretKey === "string") {
        var bytes = [];
        var length_1 = secretKey.length;
        var index2 = 0;
        for (var i2 = 0; i2 < length_1; ++i2) {
          var code3 = secretKey.charCodeAt(i2);
          if (code3 < 128) {
            bytes[index2++] = code3;
          } else if (code3 < 2048) {
            bytes[index2++] = 192 | code3 >> 6;
            bytes[index2++] = 128 | code3 & 63;
          } else if (code3 < 55296 || code3 >= 57344) {
            bytes[index2++] = 224 | code3 >> 12;
            bytes[index2++] = 128 | code3 >> 6 & 63;
            bytes[index2++] = 128 | code3 & 63;
          } else {
            code3 = 65536 + ((code3 & 1023) << 10 | secretKey.charCodeAt(++i2) & 1023);
            bytes[index2++] = 240 | code3 >> 18;
            bytes[index2++] = 128 | code3 >> 12 & 63;
            bytes[index2++] = 128 | code3 >> 6 & 63;
            bytes[index2++] = 128 | code3 & 63;
          }
        }
        key = bytes;
      } else {
        if (secretKey instanceof ArrayBuffer) {
          key = new Uint8Array(secretKey);
        } else {
          key = secretKey;
        }
      }
      if (key.length > 64) {
        key = new Sha256(is2242, true).update(key).array();
      }
      var oKeyPad = [];
      var iKeyPad = [];
      for (var i2 = 0; i2 < 64; ++i2) {
        var b2 = key[i2] || 0;
        oKeyPad[i2] = 92 ^ b2;
        iKeyPad[i2] = 54 ^ b2;
      }
      _this.update(iKeyPad);
      __classPrivateFieldSet(_this, _oKeyPad, oKeyPad);
      __classPrivateFieldSet(_this, _inner, true);
      __classPrivateFieldSet(_this, _is224_1, is2242);
      __classPrivateFieldSet(_this, _sharedMemory, sharedMemory2);
      return _this;
    }
    HmacSha256.prototype.finalize = function() {
      _super.prototype.finalize.call(this);
      if (__classPrivateFieldGet(this, _inner)) {
        __classPrivateFieldSet(this, _inner, false);
        var innerHash = this.array();
        _super.prototype.init.call(this, __classPrivateFieldGet(this, _is224_1), __classPrivateFieldGet(this, _sharedMemory));
        this.update(__classPrivateFieldGet(this, _oKeyPad));
        this.update(innerHash);
        _super.prototype.finalize.call(this);
      }
    };
    return HmacSha256;
  })(Sha256);
  _inner = /* @__PURE__ */ new WeakMap(), _is224_1 = /* @__PURE__ */ new WeakMap(), _oKeyPad = /* @__PURE__ */ new WeakMap(), _sharedMemory = /* @__PURE__ */ new WeakMap();
  function Sha256ToInt(s2) {
    var sha256 = new Sha256();
    sha256.update(s2);
    return parseInt(sha256.hex().substring(0, 8), 16);
  }
  var RGB2HEX = function(RGBArray) {
    var hex2 = "#";
    RGBArray.forEach(function(value) {
      if (value < 16) {
        hex2 += 0;
      }
      hex2 += value.toString(16);
    });
    return hex2;
  };
  var HSL2RGB = function(H2, S2, L2) {
    H2 /= 360;
    var q2 = L2 < 0.5 ? L2 * (1 + S2) : L2 + S2 - L2 * S2;
    var p2 = 2 * L2 - q2;
    return [
      H2 + 1 / 3,
      H2,
      H2 - 1 / 3
    ].map(function(color2) {
      if (color2 < 0) {
        color2++;
      }
      if (color2 > 1) {
        color2--;
      }
      if (color2 < 1 / 6) {
        color2 = p2 + (q2 - p2) * 6 * color2;
      } else if (color2 < 0.5) {
        color2 = q2;
      } else if (color2 < 2 / 3) {
        color2 = p2 + (q2 - p2) * 6 * (2 / 3 - color2);
      } else {
        color2 = p2;
      }
      return Math.round(color2 * 255);
    });
  };
  var ColorHash2 = function() {
    function ColorHash3(options) {
      if (options === void 0) {
        options = {};
      }
      var _a2 = [
        options.lightness,
        options.saturation
      ].map(function(param) {
        param = param !== void 0 ? param : [
          0.35,
          0.5,
          0.65
        ];
        return Array.isArray(param) ? param.concat() : [
          param
        ];
      }), L2 = _a2[0], S2 = _a2[1];
      this.L = L2;
      this.S = S2;
      if (typeof options.hue === "number") {
        options.hue = {
          min: options.hue,
          max: options.hue
        };
      }
      if (typeof options.hue === "object" && !Array.isArray(options.hue)) {
        options.hue = [
          options.hue
        ];
      }
      if (typeof options.hue === "undefined") {
        options.hue = [];
      }
      this.hueRanges = options.hue.map(function(range2) {
        return {
          min: typeof range2.min === "undefined" ? 0 : range2.min,
          max: typeof range2.max === "undefined" ? 360 : range2.max
        };
      });
      this.hash = Sha256ToInt;
      if (typeof options.hash === "function") {
        this.hash = options.hash;
      }
      if (options.hash === "bkdr") {
        this.hash = BKDRHash;
      }
    }
    ColorHash3.prototype.hsl = function(str) {
      var H2, S1, L1;
      var hash2 = this.hash(str);
      var hueResolution = 727;
      if (this.hueRanges.length) {
        var range2 = this.hueRanges[hash2 % this.hueRanges.length];
        H2 = hash2 / this.hueRanges.length % hueResolution * (range2.max - range2.min) / hueResolution + range2.min;
      } else {
        H2 = hash2 % 359;
      }
      hash2 = Math.ceil(hash2 / 360);
      S1 = this.S[hash2 % this.S.length];
      hash2 = Math.ceil(hash2 / this.S.length);
      L1 = this.L[hash2 % this.L.length];
      return [
        H2,
        S1,
        L1
      ];
    };
    ColorHash3.prototype.rgb = function(str) {
      var hsl2 = this.hsl(str);
      return HSL2RGB.apply(this, hsl2);
    };
    ColorHash3.prototype.hex = function(str) {
      var rgb2 = this.rgb(str);
      return RGB2HEX(rgb2);
    };
    return ColorHash3;
  }();
  exports2["default"] = ColorHash2;
})(colorHash);
var ColorHash = /* @__PURE__ */ getDefaultExportFromCjs(colorHash);
var s$1 = 1e3;
var m$2 = s$1 * 60;
var h$1 = m$2 * 60;
var d$1 = h$1 * 24;
var w$1 = d$1 * 7;
var y$2 = d$1 * 365.25;
var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse$3(val);
  } else if (type === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
function parse$3(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match5 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match5) {
    return;
  }
  var n2 = parseFloat(match5[1]);
  var type = (match5[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n2 * y$2;
    case "weeks":
    case "week":
    case "w":
      return n2 * w$1;
    case "days":
    case "day":
    case "d":
      return n2 * d$1;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n2 * h$1;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n2 * m$2;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n2 * s$1;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n2;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d$1) {
    return Math.round(ms2 / d$1) + "d";
  }
  if (msAbs >= h$1) {
    return Math.round(ms2 / h$1) + "h";
  }
  if (msAbs >= m$2) {
    return Math.round(ms2 / m$2) + "m";
  }
  if (msAbs >= s$1) {
    return Math.round(ms2 / s$1) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d$1) {
    return plural(ms2, msAbs, d$1, "day");
  }
  if (msAbs >= h$1) {
    return plural(ms2, msAbs, h$1, "hour");
  }
  if (msAbs >= m$2) {
    return plural(ms2, msAbs, m$2, "minute");
  }
  if (msAbs >= s$1) {
    return plural(ms2, msAbs, s$1, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n2, name) {
  var isPlural = msAbs >= n2 * 1.5;
  return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
}
var ms$1 = ms;
var slugify$1 = { exports: {} };
(function(module2, exports2) {
  (function(name, root2, factory) {
    {
      module2.exports = factory();
      module2.exports["default"] = factory();
    }
  })("slugify", commonjsGlobal, function() {
    var charMap = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","\xA2":"cent","\xA3":"pound","\xA4":"currency","\xA5":"yen","\xA9":"(c)","\xAA":"a","\xAE":"(r)","\xBA":"o","\xC0":"A","\xC1":"A","\xC2":"A","\xC3":"A","\xC4":"A","\xC5":"A","\xC6":"AE","\xC7":"C","\xC8":"E","\xC9":"E","\xCA":"E","\xCB":"E","\xCC":"I","\xCD":"I","\xCE":"I","\xCF":"I","\xD0":"D","\xD1":"N","\xD2":"O","\xD3":"O","\xD4":"O","\xD5":"O","\xD6":"O","\xD8":"O","\xD9":"U","\xDA":"U","\xDB":"U","\xDC":"U","\xDD":"Y","\xDE":"TH","\xDF":"ss","\xE0":"a","\xE1":"a","\xE2":"a","\xE3":"a","\xE4":"a","\xE5":"a","\xE6":"ae","\xE7":"c","\xE8":"e","\xE9":"e","\xEA":"e","\xEB":"e","\xEC":"i","\xED":"i","\xEE":"i","\xEF":"i","\xF0":"d","\xF1":"n","\xF2":"o","\xF3":"o","\xF4":"o","\xF5":"o","\xF6":"o","\xF8":"o","\xF9":"u","\xFA":"u","\xFB":"u","\xFC":"u","\xFD":"y","\xFE":"th","\xFF":"y","\u0100":"A","\u0101":"a","\u0102":"A","\u0103":"a","\u0104":"A","\u0105":"a","\u0106":"C","\u0107":"c","\u010C":"C","\u010D":"c","\u010E":"D","\u010F":"d","\u0110":"DJ","\u0111":"dj","\u0112":"E","\u0113":"e","\u0116":"E","\u0117":"e","\u0118":"e","\u0119":"e","\u011A":"E","\u011B":"e","\u011E":"G","\u011F":"g","\u0122":"G","\u0123":"g","\u0128":"I","\u0129":"i","\u012A":"i","\u012B":"i","\u012E":"I","\u012F":"i","\u0130":"I","\u0131":"i","\u0136":"k","\u0137":"k","\u013B":"L","\u013C":"l","\u013D":"L","\u013E":"l","\u0141":"L","\u0142":"l","\u0143":"N","\u0144":"n","\u0145":"N","\u0146":"n","\u0147":"N","\u0148":"n","\u014C":"O","\u014D":"o","\u0150":"O","\u0151":"o","\u0152":"OE","\u0153":"oe","\u0154":"R","\u0155":"r","\u0158":"R","\u0159":"r","\u015A":"S","\u015B":"s","\u015E":"S","\u015F":"s","\u0160":"S","\u0161":"s","\u0162":"T","\u0163":"t","\u0164":"T","\u0165":"t","\u0168":"U","\u0169":"u","\u016A":"u","\u016B":"u","\u016E":"U","\u016F":"u","\u0170":"U","\u0171":"u","\u0172":"U","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017A":"z","\u017B":"Z","\u017C":"z","\u017D":"Z","\u017E":"z","\u018F":"E","\u0192":"f","\u01A0":"O","\u01A1":"o","\u01AF":"U","\u01B0":"u","\u01C8":"LJ","\u01C9":"lj","\u01CB":"NJ","\u01CC":"nj","\u0218":"S","\u0219":"s","\u021A":"T","\u021B":"t","\u0259":"e","\u02DA":"o","\u0386":"A","\u0388":"E","\u0389":"H","\u038A":"I","\u038C":"O","\u038E":"Y","\u038F":"W","\u0390":"i","\u0391":"A","\u0392":"B","\u0393":"G","\u0394":"D","\u0395":"E","\u0396":"Z","\u0397":"H","\u0398":"8","\u0399":"I","\u039A":"K","\u039B":"L","\u039C":"M","\u039D":"N","\u039E":"3","\u039F":"O","\u03A0":"P","\u03A1":"R","\u03A3":"S","\u03A4":"T","\u03A5":"Y","\u03A6":"F","\u03A7":"X","\u03A8":"PS","\u03A9":"W","\u03AA":"I","\u03AB":"Y","\u03AC":"a","\u03AD":"e","\u03AE":"h","\u03AF":"i","\u03B0":"y","\u03B1":"a","\u03B2":"b","\u03B3":"g","\u03B4":"d","\u03B5":"e","\u03B6":"z","\u03B7":"h","\u03B8":"8","\u03B9":"i","\u03BA":"k","\u03BB":"l","\u03BC":"m","\u03BD":"n","\u03BE":"3","\u03BF":"o","\u03C0":"p","\u03C1":"r","\u03C2":"s","\u03C3":"s","\u03C4":"t","\u03C5":"y","\u03C6":"f","\u03C7":"x","\u03C8":"ps","\u03C9":"w","\u03CA":"i","\u03CB":"y","\u03CC":"o","\u03CD":"y","\u03CE":"w","\u0401":"Yo","\u0402":"DJ","\u0404":"Ye","\u0406":"I","\u0407":"Yi","\u0408":"J","\u0409":"LJ","\u040A":"NJ","\u040B":"C","\u040F":"DZ","\u0410":"A","\u0411":"B","\u0412":"V","\u0413":"G","\u0414":"D","\u0415":"E","\u0416":"Zh","\u0417":"Z","\u0418":"I","\u0419":"J","\u041A":"K","\u041B":"L","\u041C":"M","\u041D":"N","\u041E":"O","\u041F":"P","\u0420":"R","\u0421":"S","\u0422":"T","\u0423":"U","\u0424":"F","\u0425":"H","\u0426":"C","\u0427":"Ch","\u0428":"Sh","\u0429":"Sh","\u042A":"U","\u042B":"Y","\u042C":"","\u042D":"E","\u042E":"Yu","\u042F":"Ya","\u0430":"a","\u0431":"b","\u0432":"v","\u0433":"g","\u0434":"d","\u0435":"e","\u0436":"zh","\u0437":"z","\u0438":"i","\u0439":"j","\u043A":"k","\u043B":"l","\u043C":"m","\u043D":"n","\u043E":"o","\u043F":"p","\u0440":"r","\u0441":"s","\u0442":"t","\u0443":"u","\u0444":"f","\u0445":"h","\u0446":"c","\u0447":"ch","\u0448":"sh","\u0449":"sh","\u044A":"u","\u044B":"y","\u044C":"","\u044D":"e","\u044E":"yu","\u044F":"ya","\u0451":"yo","\u0452":"dj","\u0454":"ye","\u0456":"i","\u0457":"yi","\u0458":"j","\u0459":"lj","\u045A":"nj","\u045B":"c","\u045D":"u","\u045F":"dz","\u0490":"G","\u0491":"g","\u0492":"GH","\u0493":"gh","\u049A":"KH","\u049B":"kh","\u04A2":"NG","\u04A3":"ng","\u04AE":"UE","\u04AF":"ue","\u04B0":"U","\u04B1":"u","\u04BA":"H","\u04BB":"h","\u04D8":"AE","\u04D9":"ae","\u04E8":"OE","\u04E9":"oe","\u0531":"A","\u0532":"B","\u0533":"G","\u0534":"D","\u0535":"E","\u0536":"Z","\u0537":"E'","\u0538":"Y'","\u0539":"T'","\u053A":"JH","\u053B":"I","\u053C":"L","\u053D":"X","\u053E":"C'","\u053F":"K","\u0540":"H","\u0541":"D'","\u0542":"GH","\u0543":"TW","\u0544":"M","\u0545":"Y","\u0546":"N","\u0547":"SH","\u0549":"CH","\u054A":"P","\u054B":"J","\u054C":"R'","\u054D":"S","\u054E":"V","\u054F":"T","\u0550":"R","\u0551":"C","\u0553":"P'","\u0554":"Q'","\u0555":"O''","\u0556":"F","\u0587":"EV","\u0621":"a","\u0622":"aa","\u0623":"a","\u0624":"u","\u0625":"i","\u0626":"e","\u0627":"a","\u0628":"b","\u0629":"h","\u062A":"t","\u062B":"th","\u062C":"j","\u062D":"h","\u062E":"kh","\u062F":"d","\u0630":"th","\u0631":"r","\u0632":"z","\u0633":"s","\u0634":"sh","\u0635":"s","\u0636":"dh","\u0637":"t","\u0638":"z","\u0639":"a","\u063A":"gh","\u0641":"f","\u0642":"q","\u0643":"k","\u0644":"l","\u0645":"m","\u0646":"n","\u0647":"h","\u0648":"w","\u0649":"a","\u064A":"y","\u064B":"an","\u064C":"on","\u064D":"en","\u064E":"a","\u064F":"u","\u0650":"e","\u0652":"","\u0660":"0","\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u067E":"p","\u0686":"ch","\u0698":"zh","\u06A9":"k","\u06AF":"g","\u06CC":"y","\u06F0":"0","\u06F1":"1","\u06F2":"2","\u06F3":"3","\u06F4":"4","\u06F5":"5","\u06F6":"6","\u06F7":"7","\u06F8":"8","\u06F9":"9","\u0E3F":"baht","\u10D0":"a","\u10D1":"b","\u10D2":"g","\u10D3":"d","\u10D4":"e","\u10D5":"v","\u10D6":"z","\u10D7":"t","\u10D8":"i","\u10D9":"k","\u10DA":"l","\u10DB":"m","\u10DC":"n","\u10DD":"o","\u10DE":"p","\u10DF":"zh","\u10E0":"r","\u10E1":"s","\u10E2":"t","\u10E3":"u","\u10E4":"f","\u10E5":"k","\u10E6":"gh","\u10E7":"q","\u10E8":"sh","\u10E9":"ch","\u10EA":"ts","\u10EB":"dz","\u10EC":"ts","\u10ED":"ch","\u10EE":"kh","\u10EF":"j","\u10F0":"h","\u1E62":"S","\u1E63":"s","\u1E80":"W","\u1E81":"w","\u1E82":"W","\u1E83":"w","\u1E84":"W","\u1E85":"w","\u1E9E":"SS","\u1EA0":"A","\u1EA1":"a","\u1EA2":"A","\u1EA3":"a","\u1EA4":"A","\u1EA5":"a","\u1EA6":"A","\u1EA7":"a","\u1EA8":"A","\u1EA9":"a","\u1EAA":"A","\u1EAB":"a","\u1EAC":"A","\u1EAD":"a","\u1EAE":"A","\u1EAF":"a","\u1EB0":"A","\u1EB1":"a","\u1EB2":"A","\u1EB3":"a","\u1EB4":"A","\u1EB5":"a","\u1EB6":"A","\u1EB7":"a","\u1EB8":"E","\u1EB9":"e","\u1EBA":"E","\u1EBB":"e","\u1EBC":"E","\u1EBD":"e","\u1EBE":"E","\u1EBF":"e","\u1EC0":"E","\u1EC1":"e","\u1EC2":"E","\u1EC3":"e","\u1EC4":"E","\u1EC5":"e","\u1EC6":"E","\u1EC7":"e","\u1EC8":"I","\u1EC9":"i","\u1ECA":"I","\u1ECB":"i","\u1ECC":"O","\u1ECD":"o","\u1ECE":"O","\u1ECF":"o","\u1ED0":"O","\u1ED1":"o","\u1ED2":"O","\u1ED3":"o","\u1ED4":"O","\u1ED5":"o","\u1ED6":"O","\u1ED7":"o","\u1ED8":"O","\u1ED9":"o","\u1EDA":"O","\u1EDB":"o","\u1EDC":"O","\u1EDD":"o","\u1EDE":"O","\u1EDF":"o","\u1EE0":"O","\u1EE1":"o","\u1EE2":"O","\u1EE3":"o","\u1EE4":"U","\u1EE5":"u","\u1EE6":"U","\u1EE7":"u","\u1EE8":"U","\u1EE9":"u","\u1EEA":"U","\u1EEB":"u","\u1EEC":"U","\u1EED":"u","\u1EEE":"U","\u1EEF":"u","\u1EF0":"U","\u1EF1":"u","\u1EF2":"Y","\u1EF3":"y","\u1EF4":"Y","\u1EF5":"y","\u1EF6":"Y","\u1EF7":"y","\u1EF8":"Y","\u1EF9":"y","\u2013":"-","\u2018":"'","\u2019":"'","\u201C":"\\"","\u201D":"\\"","\u201E":"\\"","\u2020":"+","\u2022":"*","\u2026":"...","\u20A0":"ecu","\u20A2":"cruzeiro","\u20A3":"french franc","\u20A4":"lira","\u20A5":"mill","\u20A6":"naira","\u20A7":"peseta","\u20A8":"rupee","\u20A9":"won","\u20AA":"new shequel","\u20AB":"dong","\u20AC":"euro","\u20AD":"kip","\u20AE":"tugrik","\u20AF":"drachma","\u20B0":"penny","\u20B1":"peso","\u20B2":"guarani","\u20B3":"austral","\u20B4":"hryvnia","\u20B5":"cedi","\u20B8":"kazakhstani tenge","\u20B9":"indian rupee","\u20BA":"turkish lira","\u20BD":"russian ruble","\u20BF":"bitcoin","\u2120":"sm","\u2122":"tm","\u2202":"d","\u2206":"delta","\u2211":"sum","\u221E":"infinity","\u2665":"love","\u5143":"yuan","\u5186":"yen","\uFDFC":"rial","\uFEF5":"laa","\uFEF7":"laa","\uFEF9":"lai","\uFEFB":"la"}`);
    var locales2 = JSON.parse('{"bg":{"\u0419":"Y","\u0426":"Ts","\u0429":"Sht","\u042A":"A","\u042C":"Y","\u0439":"y","\u0446":"ts","\u0449":"sht","\u044A":"a","\u044C":"y"},"de":{"\xC4":"AE","\xE4":"ae","\xD6":"OE","\xF6":"oe","\xDC":"UE","\xFC":"ue","\xDF":"ss","%":"prozent","&":"und","|":"oder","\u2211":"summe","\u221E":"unendlich","\u2665":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","\xA2":"centavos","\xA3":"libras","\xA4":"moneda","\u20A3":"francos","\u2211":"suma","\u221E":"infinito","\u2665":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","\xA2":"centime","\xA3":"livre","\xA4":"devise","\u20A3":"franc","\u2211":"somme","\u221E":"infini","\u2665":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","\xA2":"centavo","\u2211":"soma","\xA3":"libra","\u221E":"infinito","\u2665":"amor"},"uk":{"\u0418":"Y","\u0438":"y","\u0419":"Y","\u0439":"y","\u0426":"Ts","\u0446":"ts","\u0425":"Kh","\u0445":"kh","\u0429":"Shch","\u0449":"shch","\u0413":"H","\u0433":"h"},"vi":{"\u0110":"D","\u0111":"d"},"da":{"\xD8":"OE","\xF8":"oe","\xC5":"AA","\xE5":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"st\xF8rre end"},"nb":{"&":"og","\xC5":"AA","\xC6":"AE","\xD8":"OE","\xE5":"aa","\xE6":"ae","\xF8":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","\xC5":"AA","\xC4":"AE","\xD6":"OE","\xE5":"aa","\xE4":"ae","\xF6":"oe"}}');
    function replace2(string2, options) {
      if (typeof string2 !== "string") {
        throw new Error("slugify: string argument expected");
      }
      options = typeof options === "string" ? { replacement: options } : options || {};
      var locale2 = locales2[options.locale] || {};
      var replacement = options.replacement === void 0 ? "-" : options.replacement;
      var trim = options.trim === void 0 ? true : options.trim;
      var slug = string2.normalize().split("").reduce(function(result, ch) {
        var appendChar = locale2[ch] || charMap[ch] || ch;
        if (appendChar === replacement) {
          appendChar = " ";
        }
        return result + appendChar.replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
      }, "");
      if (options.strict) {
        slug = slug.replace(/[^A-Za-z0-9\s]/g, "");
      }
      if (trim) {
        slug = slug.trim();
      }
      slug = slug.replace(/\s+/g, replacement);
      if (options.lower) {
        slug = slug.toLowerCase();
      }
      return slug;
    }
    replace2.extend = function(customMap) {
      Object.assign(charMap, customMap);
    };
    return replace2;
  });
})(slugify$1);
var slugify = slugify$1.exports;
var gun = { exports: {} };
(function(module2) {
  (function() {
    function USE(arg, req) {
      return req ? commonjsRequire(arg) : arg.slice ? USE[R2(arg)] : function(mod2, path2) {
        arg(mod2 = { exports: {} });
        USE[R2(path2)] = mod2.exports;
      };
      function R2(p2) {
        return p2.split("/").slice(-1).toString().replace(".js", "");
      }
    }
    {
      var MODULE = module2;
    }
    USE(function(module3) {
      String.random = function(l2, c2) {
        var s2 = "";
        l2 = l2 || 24;
        c2 = c2 || "0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz";
        while (l2-- > 0) {
          s2 += c2.charAt(Math.floor(Math.random() * c2.length));
        }
        return s2;
      };
      String.match = function(t2, o2) {
        var tmp, u2;
        if ("string" !== typeof t2) {
          return false;
        }
        if ("string" == typeof o2) {
          o2 = { "=": o2 };
        }
        o2 = o2 || {};
        tmp = o2["="] || o2["*"] || o2[">"] || o2["<"];
        if (t2 === tmp) {
          return true;
        }
        if (u2 !== o2["="]) {
          return false;
        }
        tmp = o2["*"] || o2[">"];
        if (t2.slice(0, (tmp || "").length) === tmp) {
          return true;
        }
        if (u2 !== o2["*"]) {
          return false;
        }
        if (u2 !== o2[">"] && u2 !== o2["<"]) {
          return t2 >= o2[">"] && t2 <= o2["<"] ? true : false;
        }
        if (u2 !== o2[">"] && t2 >= o2[">"]) {
          return true;
        }
        if (u2 !== o2["<"] && t2 <= o2["<"]) {
          return true;
        }
        return false;
      };
      String.hash = function(s2, c2) {
        if (typeof s2 !== "string") {
          return;
        }
        c2 = c2 || 0;
        if (!s2.length) {
          return c2;
        }
        for (var i2 = 0, l2 = s2.length, n2; i2 < l2; ++i2) {
          n2 = s2.charCodeAt(i2);
          c2 = (c2 << 5) - c2 + n2;
          c2 |= 0;
        }
        return c2;
      };
      var has2 = Object.prototype.hasOwnProperty;
      Object.plain = function(o2) {
        return o2 ? o2 instanceof Object && o2.constructor === Object || Object.prototype.toString.call(o2).match(/^\[object (\w+)\]$/)[1] === "Object" : false;
      };
      Object.empty = function(o2, n2) {
        for (var k2 in o2) {
          if (has2.call(o2, k2) && (!n2 || -1 == n2.indexOf(k2))) {
            return false;
          }
        }
        return true;
      };
      Object.keys = Object.keys || function(o2) {
        var l2 = [];
        for (var k2 in o2) {
          if (has2.call(o2, k2)) {
            l2.push(k2);
          }
        }
        return l2;
      };
      (function() {
        var u2, sT = setTimeout, l2 = 0, c2 = 0, sI = typeof setImmediate !== "" + u2 && setImmediate || sT;
        sT.hold = sT.hold || 9;
        sT.poll = sT.poll || function(f2) {
          if (sT.hold >= +new Date() - l2 && c2++ < 3333) {
            f2();
            return;
          }
          sI(function() {
            l2 = +new Date();
            f2();
          }, c2 = 0);
        };
      })();
      (function() {
        var sT = setTimeout, t2 = sT.turn = sT.turn || function(f3) {
          1 == s2.push(f3) && p2(T2);
        }, s2 = t2.s = [], p2 = sT.poll, i2 = 0, f2, T2 = function() {
          if (f2 = s2[i2++]) {
            f2();
          }
          if (i2 == s2.length || 99 == i2) {
            s2 = t2.s = s2.slice(i2);
            i2 = 0;
          }
          if (s2.length) {
            p2(T2);
          }
        };
      })();
      (function() {
        var u2, sT = setTimeout, T2 = sT.turn;
        (sT.each = sT.each || function(l2, f2, e2, S2) {
          S2 = S2 || 9;
          (function t2(s2, L2, r2) {
            if (L2 = (s2 = (l2 || []).splice(0, S2)).length) {
              for (var i2 = 0; i2 < L2; i2++) {
                if (u2 !== (r2 = f2(s2[i2]))) {
                  break;
                }
              }
              if (u2 === r2) {
                T2(t2);
                return;
              }
            }
            e2 && e2(r2);
          })();
        })();
      })();
    })(USE, "./shim");
    USE(function(module3) {
      module3.exports = function onto(tag, arg, as2) {
        if (!tag) {
          return { to: onto };
        }
        var u2, f2 = "function" == typeof arg, tag = (this.tag || (this.tag = {}))[tag] || f2 && (this.tag[tag] = { tag, to: onto._ = { next: function(arg2) {
          var tmp;
          if (tmp = this.to) {
            tmp.next(arg2);
          }
        } } });
        if (f2) {
          var be2 = {
            off: onto.off || (onto.off = function() {
              if (this.next === onto._.next) {
                return true;
              }
              if (this === this.the.last) {
                this.the.last = this.back;
              }
              this.to.back = this.back;
              this.next = onto._.next;
              this.back.to = this.to;
              if (this.the.last === this.the) {
                delete this.on.tag[this.the.tag];
              }
            }),
            to: onto._,
            next: arg,
            the: tag,
            on: this,
            as: as2
          };
          (be2.back = tag.last || tag).to = be2;
          return tag.last = be2;
        }
        if ((tag = tag.to) && u2 !== arg) {
          tag.next(arg);
        }
        return tag;
      };
    })(USE, "./onto");
    USE(function(module3) {
      module3.exports = function(v2) {
        return v2 === null || "string" === typeof v2 || "boolean" === typeof v2 || "number" === typeof v2 && v2 != Infinity && v2 != -Infinity && v2 === v2 || !!v2 && "string" == typeof v2["#"] && Object.keys(v2).length === 1 && v2["#"];
      };
    })(USE, "./valid");
    USE(function(module3) {
      USE("./shim");
      function State() {
        var t2 = +new Date();
        if (last < t2) {
          return N2 = 0, last = t2 + State.drift;
        }
        return last = t2 + (N2 += 1) / D2 + State.drift;
      }
      State.drift = 0;
      var NI = -Infinity, N2 = 0, D2 = 999, last = NI, u2;
      State.is = function(n2, k2, o2) {
        var tmp = k2 && n2 && n2._ && n2._[">"] || o2;
        if (!tmp) {
          return;
        }
        return "number" == typeof (tmp = tmp[k2]) ? tmp : NI;
      };
      State.ify = function(n2, k2, s2, v2, soul) {
        (n2 = n2 || {})._ = n2._ || {};
        if (soul) {
          n2._["#"] = soul;
        }
        var tmp = n2._[">"] || (n2._[">"] = {});
        if (u2 !== k2 && k2 !== "_") {
          if ("number" == typeof s2) {
            tmp[k2] = s2;
          }
          if (u2 !== v2) {
            n2[k2] = v2;
          }
        }
        return n2;
      };
      module3.exports = State;
    })(USE, "./state");
    USE(function(module3) {
      USE("./shim");
      function Dup(opt) {
        var dup = { s: {} }, s2 = dup.s;
        opt = opt || { max: 999, age: 1e3 * 9 };
        dup.check = function(id2) {
          if (!s2[id2]) {
            return false;
          }
          return dt(id2);
        };
        var dt = dup.track = function(id2) {
          var it2 = s2[id2] || (s2[id2] = {});
          it2.was = dup.now = +new Date();
          if (!dup.to) {
            dup.to = setTimeout(dup.drop, opt.age + 9);
          }
          return it2;
        };
        dup.drop = function(age) {
          dup.to = null;
          dup.now = +new Date();
          var l2 = Object.keys(s2);
          console.STAT && console.STAT(dup.now, +new Date() - dup.now, "dup drop keys");
          setTimeout.each(l2, function(id2) {
            var it2 = s2[id2];
            if (it2 && (age || opt.age) > dup.now - it2.was) {
              return;
            }
            delete s2[id2];
          }, 0, 99);
        };
        return dup;
      }
      module3.exports = Dup;
    })(USE, "./dup");
    USE(function(module3) {
      USE("./onto");
      module3.exports = function ask(cb, as2) {
        if (!this.on) {
          return;
        }
        var lack = (this.opt || {}).lack || 9e3;
        if (!("function" == typeof cb)) {
          if (!cb) {
            return;
          }
          var id2 = cb["#"] || cb, tmp = (this.tag || "")[id2];
          if (!tmp) {
            return;
          }
          if (as2) {
            tmp = this.on(id2, as2);
            clearTimeout(tmp.err);
            tmp.err = setTimeout(function() {
              tmp.off();
            }, lack);
          }
          return true;
        }
        var id2 = as2 && as2["#"] || random(9);
        if (!cb) {
          return id2;
        }
        var to2 = this.on(id2, cb, as2);
        to2.err = to2.err || setTimeout(function() {
          to2.off();
          to2.next({ err: "Error: No ACK yet.", lack: true });
        }, lack);
        return id2;
      };
      var random = String.random || function() {
        return Math.random().toString(36).slice(2);
      };
    })(USE, "./ask");
    USE(function(module3) {
      function Gun2(o2) {
        if (o2 instanceof Gun2) {
          return (this._ = { $: this }).$;
        }
        if (!(this instanceof Gun2)) {
          return new Gun2(o2);
        }
        return Gun2.create(this._ = { $: this, opt: o2 });
      }
      Gun2.is = function($2) {
        return $2 instanceof Gun2 || $2 && $2._ && $2 === $2._.$ || false;
      };
      Gun2.version = 0.202;
      Gun2.chain = Gun2.prototype;
      Gun2.chain.toJSON = function() {
      };
      USE("./shim");
      Gun2.valid = USE("./valid");
      Gun2.state = USE("./state");
      Gun2.on = USE("./onto");
      Gun2.dup = USE("./dup");
      Gun2.ask = USE("./ask");
      (function() {
        Gun2.create = function(at2) {
          at2.root = at2.root || at2;
          at2.graph = at2.graph || {};
          at2.on = at2.on || Gun2.on;
          at2.ask = at2.ask || Gun2.ask;
          at2.dup = at2.dup || Gun2.dup();
          var gun2 = at2.$.opt(at2.opt);
          if (!at2.once) {
            at2.on("in", universe, at2);
            at2.on("out", universe, at2);
            at2.on("put", map2, at2);
            Gun2.on("create", at2);
            at2.on("create", at2);
          }
          at2.once = 1;
          return gun2;
        };
        function universe(msg) {
          if (!msg) {
            return;
          }
          if (msg.out === universe) {
            this.to.next(msg);
            return;
          }
          var eve = this, as2 = eve.as, at2 = as2.at || as2, gun2 = at2.$, dup = at2.dup, tmp, DBG = msg.DBG;
          (tmp = msg["#"]) || (tmp = msg["#"] = text_rand(9));
          if (dup.check(tmp)) {
            return;
          }
          dup.track(tmp);
          tmp = msg._;
          msg._ = "function" == typeof tmp ? tmp : function() {
          };
          msg.$ && msg.$ === (msg.$._ || "").$ || (msg.$ = gun2);
          if (msg["@"] && !msg.put) {
            ack(msg);
          }
          if (!at2.ask(msg["@"], msg)) {
            DBG && (DBG.u = +new Date());
            if (msg.put) {
              put(msg);
              return;
            } else if (msg.get) {
              Gun2.on.get(msg, gun2);
            }
          }
          DBG && (DBG.uc = +new Date());
          eve.to.next(msg);
          DBG && (DBG.ua = +new Date());
          if (msg.nts || msg.NTS) {
            return;
          }
          msg.out = universe;
          at2.on("out", msg);
          DBG && (DBG.ue = +new Date());
        }
        function put(msg) {
          if (!msg) {
            return;
          }
          var ctx = msg._ || "", root2 = ctx.root = ((ctx.$ = msg.$ || "")._ || "").root;
          if (msg["@"] && ctx.faith && !ctx.miss) {
            msg.out = universe;
            root2.on("out", msg);
            return;
          }
          ctx.latch = root2.hatch;
          ctx.match = root2.hatch = [];
          var put2 = msg.put;
          var DBG = ctx.DBG = msg.DBG, S2 = +new Date();
          CT = CT || S2;
          if (put2["#"] && put2["."]) {
            return;
          }
          DBG && (DBG.p = S2);
          ctx["#"] = msg["#"];
          ctx.msg = msg;
          ctx.all = 0;
          ctx.stun = 1;
          var nl = Object.keys(put2);
          console.STAT && console.STAT(S2, ((DBG || ctx).pk = +new Date()) - S2, "put sort");
          var ni2 = 0, nj, kl, soul, node, states, err, tmp;
          (function pop(o2) {
            if (nj != ni2) {
              nj = ni2;
              if (!(soul = nl[ni2])) {
                console.STAT && console.STAT(S2, ((DBG || ctx).pd = +new Date()) - S2, "put");
                fire(ctx);
                return;
              }
              if (!(node = put2[soul])) {
                err = ERR + cut(soul) + "no node.";
              } else if (!(tmp = node._)) {
                err = ERR + cut(soul) + "no meta.";
              } else if (soul !== tmp["#"]) {
                err = ERR + cut(soul) + "soul not same.";
              } else if (!(states = tmp[">"])) {
                err = ERR + cut(soul) + "no state.";
              }
              kl = Object.keys(node || {});
            }
            if (err) {
              msg.err = ctx.err = err;
              fire(ctx);
              return;
            }
            var i2 = 0, key;
            o2 = o2 || 0;
            while (o2++ < 9 && (key = kl[i2++])) {
              if ("_" === key) {
                continue;
              }
              var val = node[key], state = states[key];
              if (u2 === state) {
                err = ERR + cut(key) + "on" + cut(soul) + "no state.";
                break;
              }
              if (!valid(val)) {
                err = ERR + cut(key) + "on" + cut(soul) + "bad " + typeof val + cut(val);
                break;
              }
              ham(val, key, soul, state, msg);
              ++C3;
            }
            if ((kl = kl.slice(i2)).length) {
              turn(pop);
              return;
            }
            ++ni2;
            kl = null;
            pop(o2);
          })();
        }
        Gun2.on.put = put;
        function ham(val, key, soul, state, msg) {
          var ctx = msg._ || "", root2 = ctx.root, graph = root2.graph, tmp;
          var vertex = graph[soul] || empty2, was = state_is(vertex, key, 1), known = vertex[key];
          var DBG = ctx.DBG;
          if (tmp = console.STAT) {
            if (!graph[soul] || !known) {
              tmp.has = (tmp.has || 0) + 1;
            }
          }
          var now2 = State();
          if (state > now2) {
            setTimeout(function() {
              ham(val, key, soul, state, msg);
            }, (tmp = state - now2) > MD ? MD : tmp);
            console.STAT && console.STAT((DBG || ctx).Hf = +new Date(), tmp, "future");
            return;
          }
          if (state < was) {
            if (!ctx.miss) {
              return;
            }
          }
          if (!ctx.faith) {
            if (state === was && (val === known || L2(val) <= L2(known))) {
              if (!ctx.miss) {
                return;
              }
            }
          }
          ctx.stun++;
          var aid = msg["#"] + ctx.all++, id2 = { toString: function() {
            return aid;
          }, _: ctx };
          id2.toJSON = id2.toString;
          DBG && (DBG.ph = DBG.ph || +new Date());
          root2.on("put", { "#": id2, "@": msg["@"], put: { "#": soul, ".": key, ":": val, ">": state }, _: ctx });
        }
        function map2(msg) {
          var DBG;
          if (DBG = (msg._ || "").DBG) {
            DBG.pa = +new Date();
            DBG.pm = DBG.pm || +new Date();
          }
          var eve = this, root2 = eve.as, graph = root2.graph, ctx = msg._, put2 = msg.put, soul = put2["#"], key = put2["."], val = put2[":"], state = put2[">"];
          msg["#"];
          var tmp;
          if ((tmp = ctx.msg) && (tmp = tmp.put) && (tmp = tmp[soul])) {
            state_ify(tmp, key, state, val, soul);
          }
          graph[soul] = state_ify(graph[soul], key, state, val, soul);
          if (tmp = (root2.next || "")[soul]) {
            tmp.on("in", msg);
          }
          fire(ctx);
          eve.to.next(msg);
        }
        function fire(ctx, msg) {
          var root2;
          if (ctx.stop) {
            return;
          }
          if (!ctx.err && 0 < --ctx.stun) {
            return;
          }
          ctx.stop = 1;
          if (!(root2 = ctx.root)) {
            return;
          }
          var tmp = ctx.match;
          tmp.end = 1;
          if (tmp === root2.hatch) {
            if (!(tmp = ctx.latch) || tmp.end) {
              delete root2.hatch;
            } else {
              root2.hatch = tmp;
            }
          }
          ctx.hatch && ctx.hatch();
          setTimeout.each(ctx.match, function(cb) {
            cb && cb();
          });
          if (!(msg = ctx.msg) || ctx.err || msg.err) {
            return;
          }
          msg.out = universe;
          ctx.root.on("out", msg);
          CF();
        }
        function ack(msg) {
          var id2 = msg["@"] || "", ctx;
          if (!(ctx = id2._)) {
            return;
          }
          ctx.acks = (ctx.acks || 0) + 1;
          if (ctx.err = msg.err) {
            msg["@"] = ctx["#"];
            fire(ctx);
          }
          if (!ctx.stop && !ctx.crack) {
            ctx.crack = ctx.match && ctx.match.push(function() {
              back(ctx);
            });
          }
          back(ctx);
        }
        function back(ctx) {
          if (!ctx || !ctx.root) {
            return;
          }
          if (ctx.stun || ctx.acks !== ctx.all) {
            return;
          }
          ctx.root.on("in", { "@": ctx["#"], err: ctx.err, ok: ctx.err ? u2 : { "": 1 } });
        }
        var ERR = "Error: Invalid graph!";
        var cut = function(s2) {
          return " '" + ("" + s2).slice(0, 9) + "...' ";
        };
        var L2 = JSON.stringify, MD = 2147483647, State = Gun2.state;
        var C3 = 0, CT, CF = function() {
          if (C3 > 999 && C3 / -(CT - (CT = +new Date())) > 1) {
            Gun2.window && console.log("Warning: You're syncing 1K+ records a second, faster than DOM can update - consider limiting query.");
            CF = function() {
              C3 = 0;
            };
          }
        };
      })();
      (function() {
        Gun2.on.get = function(msg, gun2) {
          var root2 = gun2._, get2 = msg.get, soul = get2["#"], node = root2.graph[soul], has2 = get2["."];
          var next = root2.next || (root2.next = {});
          next[soul];
          var ctx = msg._ || {}, DBG = ctx.DBG = msg.DBG;
          DBG && (DBG.g = +new Date());
          if (!node) {
            return root2.on("get", msg);
          }
          if (has2) {
            if ("string" != typeof has2 || u2 === node[has2]) {
              return root2.on("get", msg);
            }
            node = state_ify({}, has2, state_is(node, has2), node[has2], soul);
          }
          node && ack(msg, node);
          root2.on("get", msg);
        };
        function ack(msg, node) {
          var S2 = +new Date(), ctx = msg._ || {}, DBG = ctx.DBG = msg.DBG;
          var to2 = msg["#"], id2 = text_rand(9), keys2 = Object.keys(node || "").sort(), soul = ((node || "")._ || "")["#"];
          keys2.length;
          var root2 = msg.$._.root, F2 = node === root2.graph[soul];
          console.STAT && console.STAT(S2, ((DBG || ctx).gk = +new Date()) - S2, "got keys");
          node && function go() {
            S2 = +new Date();
            var i2 = 0, k2, put = {}, tmp;
            while (i2 < 9 && (k2 = keys2[i2++])) {
              state_ify(put, k2, state_is(node, k2), node[k2], soul);
            }
            keys2 = keys2.slice(i2);
            (tmp = {})[soul] = put;
            put = tmp;
            var faith;
            if (F2) {
              faith = function() {
              };
              faith.ram = faith.faith = true;
            }
            tmp = keys2.length;
            console.STAT && console.STAT(S2, -(S2 - (S2 = +new Date())), "got copied some");
            DBG && (DBG.ga = +new Date());
            root2.on("in", { "@": to2, "#": id2, put, "%": tmp ? id2 = text_rand(9) : u2, $: root2.$, _: faith, DBG });
            console.STAT && console.STAT(S2, +new Date() - S2, "got in");
            if (!tmp) {
              return;
            }
            setTimeout.turn(go);
          }();
          if (!node) {
            root2.on("in", { "@": msg["#"] });
          }
        }
        Gun2.on.get.ack = ack;
      })();
      (function() {
        Gun2.chain.opt = function(opt) {
          opt = opt || {};
          var gun2 = this, at2 = gun2._, tmp = opt.peers || opt;
          if (!Object.plain(opt)) {
            opt = {};
          }
          if (!Object.plain(at2.opt)) {
            at2.opt = opt;
          }
          if ("string" == typeof tmp) {
            tmp = [tmp];
          }
          if (!Object.plain(at2.opt.peers)) {
            at2.opt.peers = {};
          }
          if (tmp instanceof Array) {
            opt.peers = {};
            tmp.forEach(function(url) {
              var p2 = {};
              p2.id = p2.url = url;
              opt.peers[url] = at2.opt.peers[url] = at2.opt.peers[url] || p2;
            });
          }
          obj_each(opt, function each(k2) {
            var v2 = this[k2];
            if (this && this.hasOwnProperty(k2) || "string" == typeof v2 || Object.empty(v2)) {
              this[k2] = v2;
              return;
            }
            if (v2 && v2.constructor !== Object && !(v2 instanceof Array)) {
              return;
            }
            obj_each(v2, each);
          });
          at2.opt.from = opt;
          Gun2.on("opt", at2);
          at2.opt.uuid = at2.opt.uuid || function uuid(l2) {
            return Gun2.state().toString(36).replace(".", "") + String.random(l2 || 12);
          };
          return gun2;
        };
      })();
      var obj_each = function(o2, f2) {
        Object.keys(o2).forEach(f2, o2);
      }, text_rand = String.random, turn = setTimeout.turn, valid = Gun2.valid, state_is = Gun2.state.is, state_ify = Gun2.state.ify, u2, empty2 = {}, C2;
      Gun2.log = function() {
        return !Gun2.log.off && C2.log.apply(C2, arguments), [].slice.call(arguments).join(" ");
      };
      Gun2.log.once = function(w2, s2, o2) {
        return (o2 = Gun2.log.once)[w2] = o2[w2] || 0, o2[w2]++ || Gun2.log(s2);
      };
      if (typeof window !== "undefined") {
        (window.GUN = window.Gun = Gun2).window = window;
      }
      try {
        if (typeof MODULE !== "undefined") {
          MODULE.exports = Gun2;
        }
      } catch (e2) {
      }
      module3.exports = Gun2;
      (Gun2.window || {}).console = (Gun2.window || {}).console || { log: function() {
      } };
      (C2 = console).only = function(i2, s2) {
        return C2.only.i && i2 === C2.only.i && C2.only.i++ && (C2.log.apply(C2, arguments) || s2);
      };
      Gun2.log.once("welcome", "Hello wonderful person! :) Thanks for using GUN, please ask for help on http://chat.gun.eco if anything takes you longer than 5min to figure out!");
    })(USE, "./root");
    USE(function(module3) {
      var Gun2 = USE("./root");
      Gun2.chain.back = function(n2, opt) {
        var tmp;
        n2 = n2 || 1;
        if (-1 === n2 || Infinity === n2) {
          return this._.root.$;
        } else if (1 === n2) {
          return (this._.back || this._).$;
        }
        var gun2 = this, at2 = gun2._;
        if (typeof n2 === "string") {
          n2 = n2.split(".");
        }
        if (n2 instanceof Array) {
          var i2 = 0, l2 = n2.length, tmp = at2;
          for (i2; i2 < l2; i2++) {
            tmp = (tmp || empty2)[n2[i2]];
          }
          if (u2 !== tmp) {
            return opt ? gun2 : tmp;
          } else if (tmp = at2.back) {
            return tmp.$.back(n2, opt);
          }
          return;
        }
        if ("function" == typeof n2) {
          var yes, tmp = { back: at2 };
          while ((tmp = tmp.back) && u2 === (yes = n2(tmp, opt))) {
          }
          return yes;
        }
        if ("number" == typeof n2) {
          return (at2.back || at2).$.back(n2 - 1);
        }
        return this;
      };
      var empty2 = {}, u2;
    })(USE, "./back");
    USE(function(module3) {
      var Gun2 = USE("./root");
      Gun2.chain.chain = function(sub2) {
        var gun2 = this, at2 = gun2._, chain = new (sub2 || gun2).constructor(gun2), cat = chain._, root2;
        cat.root = root2 = at2.root;
        cat.id = ++root2.once;
        cat.back = gun2._;
        cat.on = Gun2.on;
        cat.on("in", Gun2.on.in, cat);
        cat.on("out", Gun2.on.out, cat);
        return chain;
      };
      function output(msg) {
        var get2, at2 = this.as, back = at2.back, root2 = at2.root, tmp;
        if (!msg.$) {
          msg.$ = at2.$;
        }
        this.to.next(msg);
        if (at2.err) {
          at2.on("in", { put: at2.put = u2, $: at2.$ });
          return;
        }
        if (get2 = msg.get) {
          if (root2.pass) {
            root2.pass[at2.id] = at2;
          }
          if (at2.lex) {
            Object.keys(at2.lex).forEach(function(k2) {
              tmp[k2] = at2.lex[k2];
            }, tmp = msg.get = msg.get || {});
          }
          if (get2["#"] || at2.soul) {
            get2["#"] = get2["#"] || at2.soul;
            msg["#"] || (msg["#"] = text_rand(9));
            back = root2.$.get(get2["#"])._;
            if (!(get2 = get2["."])) {
              tmp = back.ask && back.ask[""];
              (back.ask || (back.ask = {}))[""] = back;
              if (u2 !== back.put) {
                back.on("in", back);
                if (tmp) {
                  return;
                }
              }
              msg.$ = back.$;
            } else if (obj_has(back.put, get2)) {
              tmp = back.ask && back.ask[get2];
              (back.ask || (back.ask = {}))[get2] = back.$.get(get2)._;
              back.on("in", { get: get2, put: { "#": back.soul, ".": get2, ":": back.put[get2], ">": state_is(root2.graph[back.soul], get2) } });
              if (tmp) {
                return;
              }
            }
            root2.ask(ack, msg);
            return root2.on("in", msg);
          }
          if (get2["."]) {
            if (at2.get) {
              msg = { get: { ".": at2.get }, $: at2.$ };
              (back.ask || (back.ask = {}))[at2.get] = msg.$._;
              return back.on("out", msg);
            }
            msg = { get: at2.lex ? msg.get : {}, $: at2.$ };
            return back.on("out", msg);
          }
          (at2.ask || (at2.ask = {}))[""] = at2;
          if (at2.get) {
            get2["."] = at2.get;
            (back.ask || (back.ask = {}))[at2.get] = msg.$._;
            return back.on("out", msg);
          }
        }
        return back.on("out", msg);
      }
      Gun2.on.out = output;
      function input(msg, cat) {
        cat = cat || this.as;
        var root2 = cat.root, gun2 = msg.$ || (msg.$ = cat.$), at2 = (gun2 || "")._ || empty2, tmp = msg.put || "", soul = tmp["#"], key = tmp["."], change = u2 !== tmp["="] ? tmp["="] : tmp[":"], state2 = tmp[">"] || -Infinity, sat;
        if (u2 !== msg.put && (u2 === tmp["#"] || u2 === tmp["."] || u2 === tmp[":"] && u2 === tmp["="] || u2 === tmp[">"])) {
          if (!valid(tmp)) {
            if (!(soul = ((tmp || "")._ || "")["#"])) {
              console.log("chain not yet supported for", tmp, "...", msg, cat);
              return;
            }
            gun2 = cat.root.$.get(soul);
            return setTimeout.each(Object.keys(tmp).sort(), function(k2) {
              if ("_" == k2 || u2 === (state2 = state_is(tmp, k2))) {
                return;
              }
              cat.on("in", { $: gun2, put: { "#": soul, ".": k2, "=": tmp[k2], ">": state2 }, VIA: msg });
            });
          }
          cat.on("in", { $: at2.back.$, put: { "#": soul = at2.back.soul, ".": key = at2.has || at2.get, "=": tmp, ">": state_is(at2.back.put, key) }, via: msg });
          return;
        }
        if ((msg.seen || "")[cat.id]) {
          return;
        }
        (msg.seen || (msg.seen = function() {
        }))[cat.id] = cat;
        if (cat !== at2) {
          Object.keys(msg).forEach(function(k2) {
            tmp[k2] = msg[k2];
          }, tmp = {});
          tmp.get = cat.get || tmp.get;
          if (!cat.soul && !cat.has) {
            tmp.$$$ = tmp.$$$ || cat.$;
          } else if (at2.soul) {
            tmp.$ = cat.$;
            tmp.$$ = tmp.$$ || at2.$;
          }
          msg = tmp;
        }
        unlink(msg, cat);
        if ((cat.soul || msg.$$) && state2 >= state_is(root2.graph[soul], key)) {
          (tmp = root2.$.get(soul)._).put = state_ify(tmp.put, key, state2, change, soul);
        }
        if (!at2.soul && state2 >= state_is(root2.graph[soul], key) && (sat = (root2.$.get(soul)._.next || "")[key])) {
          sat.put = change;
          if ("string" == typeof (tmp = valid(change))) {
            sat.put = root2.$.get(tmp)._.put || change;
          }
        }
        this.to && this.to.next(msg);
        cat.any && setTimeout.each(Object.keys(cat.any), function(any) {
          (any = cat.any[any]) && any(msg);
        }, 0, 99);
        cat.echo && setTimeout.each(Object.keys(cat.echo), function(lat2) {
          (lat2 = cat.echo[lat2]) && lat2.on("in", msg);
        }, 0, 99);
        if (((msg.$$ || "")._ || at2).soul) {
          if ((sat = cat.next) && (sat = sat[key])) {
            tmp = {};
            Object.keys(msg).forEach(function(k2) {
              tmp[k2] = msg[k2];
            });
            tmp.$ = (msg.$$ || msg.$).get(tmp.get = key);
            delete tmp.$$;
            delete tmp.$$$;
            sat.on("in", tmp);
          }
        }
        link3(msg, cat);
      }
      Gun2.on.in = input;
      function link3(msg, cat) {
        cat = cat || this.as || msg.$._;
        if (msg.$$ && this !== Gun2.on) {
          return;
        }
        if (!msg.put || cat.soul) {
          return;
        }
        var put = msg.put || "", link4 = put["="] || put[":"], tmp;
        var root2 = cat.root, tat = root2.$.get(put["#"]).get(put["."])._;
        if ("string" != typeof (link4 = valid(link4))) {
          if (this === Gun2.on) {
            (tat.echo || (tat.echo = {}))[cat.id] = cat;
          }
          return;
        }
        if ((tat.echo || (tat.echo = {}))[cat.id] && !(root2.pass || "")[cat.id]) {
          return;
        }
        if (tmp = root2.pass) {
          if (tmp[link4 + cat.id]) {
            return;
          }
          tmp[link4 + cat.id] = 1;
        }
        (tat.echo || (tat.echo = {}))[cat.id] = cat;
        if (cat.has) {
          cat.link = link4;
        }
        var sat = root2.$.get(tat.link = link4)._;
        (sat.echo || (sat.echo = {}))[tat.id] = tat;
        var tmp = cat.ask || "";
        if (tmp[""] || cat.lex) {
          sat.on("out", { get: { "#": link4 } });
        }
        setTimeout.each(Object.keys(tmp), function(get2, sat2) {
          if (!get2 || !(sat2 = tmp[get2])) {
            return;
          }
          sat2.on("out", { get: { "#": link4, ".": get2 } });
        }, 0, 99);
      }
      Gun2.on.link = link3;
      function unlink(msg, cat) {
        var put = msg.put || "", change = u2 !== put["="] ? put["="] : put[":"], root2 = cat.root, link4, tmp;
        if (u2 === change) {
          if (cat.soul && u2 !== cat.put) {
            return;
          }
          tmp = (msg.$$ || msg.$ || "")._ || "";
          if (msg["@"] && (u2 !== tmp.put || u2 !== cat.put)) {
            return;
          }
          if (link4 = cat.link || msg.linked) {
            delete (root2.$.get(link4)._.echo || "")[cat.id];
          }
          if (cat.has) {
            cat.link = null;
          }
          cat.put = u2;
          setTimeout.each(Object.keys(cat.next || ""), function(get2, sat) {
            if (!(sat = cat.next[get2])) {
              return;
            }
            if (link4) {
              delete (root2.$.get(link4).get(get2)._.echo || "")[sat.id];
            }
            sat.on("in", { get: get2, put: u2, $: sat.$ });
          }, 0, 99);
          return;
        }
        if (cat.soul) {
          return;
        }
        if (msg.$$) {
          return;
        }
        link4 = valid(change);
        tmp = msg.$._ || "";
        if (link4 === tmp.link || cat.has && !tmp.link) {
          if ((root2.pass || "")[cat.id] && "string" !== typeof link4)
            ;
          else {
            return;
          }
        }
        delete (tmp.echo || "")[cat.id];
        unlink({ get: cat.get, put: u2, $: msg.$, linked: msg.linked = msg.linked || tmp.link }, cat);
      }
      Gun2.on.unlink = unlink;
      function ack(msg, ev) {
        var as2 = this.as, at2 = as2.$._;
        at2.root;
        var get2 = as2.get || "", tmp = (msg.put || "")[get2["#"]] || "";
        if (!msg.put || "string" == typeof get2["."] && u2 === tmp[get2["."]]) {
          if (u2 !== at2.put) {
            return;
          }
          if (!at2.soul && !at2.has) {
            return;
          }
          at2.ack = (at2.ack || 0) + 1;
          at2.on("in", {
            get: at2.get,
            put: at2.put = u2,
            $: at2.$,
            "@": msg["@"]
          });
          return;
        }
        (msg._ || {}).miss = 1;
        Gun2.on.put(msg);
        return;
      }
      var empty2 = {}, u2, text_rand = String.random, valid = Gun2.valid, obj_has = function(o2, k2) {
        return o2 && Object.prototype.hasOwnProperty.call(o2, k2);
      }, state = Gun2.state, state_is = state.is, state_ify = state.ify;
    })(USE, "./chain");
    USE(function(module3) {
      var Gun2 = USE("./root");
      Gun2.chain.get = function(key, cb, as2) {
        var gun2, tmp;
        if (typeof key === "string") {
          if (key.length == 0) {
            (gun2 = this.chain())._.err = { err: Gun2.log("0 length key!", key) };
            if (cb) {
              cb.call(gun2, gun2._.err);
            }
            return gun2;
          }
          var back = this, cat = back._;
          var next = cat.next || empty2;
          if (!(gun2 = next[key])) {
            gun2 = key && cache2(key, back);
          }
          gun2 = gun2 && gun2.$;
        } else if ("function" == typeof key) {
          let any = function(msg, eve, f2) {
            if (any.stun) {
              return;
            }
            if ((tmp2 = root2.pass) && !tmp2[id2]) {
              return;
            }
            var at2 = msg.$._, sat = (msg.$$ || "")._, data2 = (sat || at2).put, odd = !at2.has && !at2.soul, test2 = {}, tmp2;
            if (odd || u2 === data2) {
              data2 = u2 === ((tmp2 = msg.put) || "")["="] ? u2 === (tmp2 || "")[":"] ? tmp2 : tmp2[":"] : tmp2["="];
            }
            if ("string" == typeof (tmp2 = Gun2.valid(data2))) {
              data2 = u2 === (tmp2 = root2.$.get(tmp2)._.put) ? opt.not ? u2 : data2 : tmp2;
            }
            if (opt.not && u2 === data2) {
              return;
            }
            if (u2 === opt.stun) {
              if ((tmp2 = root2.stun) && tmp2.on) {
                cat.$.back(function(a2) {
                  tmp2.on("" + a2.id, test2 = {});
                  if ((test2.run || 0) < any.id) {
                    return test2;
                  }
                });
                !test2.run && tmp2.on("" + at2.id, test2 = {});
                !test2.run && sat && tmp2.on("" + sat.id, test2 = {});
                if (any.id > test2.run) {
                  if (!test2.stun || test2.stun.end) {
                    test2.stun = tmp2.on("stun");
                    test2.stun = test2.stun && test2.stun.last;
                  }
                  if (test2.stun && !test2.stun.end) {
                    (test2.stun.add || (test2.stun.add = {}))[id2] = function() {
                      any(msg, eve, 1);
                    };
                    return;
                  }
                }
              }
              if (u2 === data2) {
                f2 = 0;
              }
              if ((tmp2 = root2.hatch) && !tmp2.end && u2 === opt.hatch && !f2) {
                if (wait[at2.$._.id]) {
                  return;
                }
                wait[at2.$._.id] = 1;
                tmp2.push(function() {
                  any(msg, eve, 1);
                });
                return;
              }
              wait = {};
            }
            if (root2.pass) {
              if (root2.pass[id2 + at2.id]) {
                return;
              }
              root2.pass[id2 + at2.id] = 1;
            }
            if (opt.on) {
              opt.ok.call(at2.$, data2, at2.get, msg, eve || any);
              return;
            }
            if (opt.v2020) {
              opt.ok(msg, eve || any);
              return;
            }
            Object.keys(msg).forEach(function(k2) {
              tmp2[k2] = msg[k2];
            }, tmp2 = {});
            msg = tmp2;
            msg.put = data2;
            opt.ok.call(opt.as, msg, eve || any);
          };
          if (true === cb) {
            return soul(this, key, cb, as2), this;
          }
          gun2 = this;
          var cat = gun2._, opt = cb || {}, root2 = cat.root, id2;
          opt.at = cat;
          opt.ok = key;
          var wait = {};
          any.at = cat;
          (cat.any || (cat.any = {}))[id2 = String.random(7)] = any;
          any.off = function() {
            any.stun = 1;
            if (!cat.any) {
              return;
            }
            delete cat.any[id2];
          };
          any.rid = rid;
          any.id = opt.run || ++root2.once;
          tmp = root2.pass;
          (root2.pass = {})[id2] = 1;
          opt.out = opt.out || { get: {} };
          cat.on("out", opt.out);
          root2.pass = tmp;
          return gun2;
        } else if ("number" == typeof key) {
          return this.get("" + key, cb, as2);
        } else if ("string" == typeof (tmp = valid(key))) {
          return this.get(tmp, cb, as2);
        } else if (tmp = this.get.next) {
          gun2 = tmp(this, key);
        }
        if (!gun2) {
          (gun2 = this.chain())._.err = { err: Gun2.log("Invalid get request!", key) };
          if (cb) {
            cb.call(gun2, gun2._.err);
          }
          return gun2;
        }
        if (cb && "function" == typeof cb) {
          gun2.get(cb, as2);
        }
        return gun2;
      };
      function cache2(key, back) {
        var cat = back._, next = cat.next, gun2 = back.chain(), at2 = gun2._;
        if (!next) {
          next = cat.next = {};
        }
        next[at2.get = key] = at2;
        if (back === cat.root.$) {
          at2.soul = key;
        } else if (cat.soul || cat.has) {
          at2.has = key;
        }
        return at2;
      }
      function soul(gun2, cb, opt, as2) {
        var cat = gun2._, acks = 0, tmp;
        if (tmp = cat.soul || cat.link) {
          return cb(tmp, as2, cat);
        }
        if (cat.jam) {
          return cat.jam.push([cb, as2]);
        }
        cat.jam = [[cb, as2]];
        gun2.get(function go(msg, eve) {
          if (u2 === msg.put && !cat.root.opt.super && (tmp = Object.keys(cat.root.opt.peers).length) && ++acks <= tmp) {
            return;
          }
          eve.rid(msg);
          var at2 = (at2 = msg.$) && at2._ || {}, i2 = 0, as3;
          tmp = cat.jam;
          delete cat.jam;
          while (as3 = tmp[i2++]) {
            var cb2 = as3[0];
            as3 = as3[1];
            cb2 && cb2(at2.link || at2.soul || Gun2.valid(msg.put) || ((msg.put || {})._ || {})["#"], as3, msg, eve);
          }
        }, { out: { get: { ".": true } } });
        return gun2;
      }
      function rid(at2) {
        var cat = this.at || this.on;
        if (!at2 || cat.soul || cat.has) {
          return this.off();
        }
        if (!(at2 = (at2 = (at2 = at2.$ || at2)._ || at2).id)) {
          return;
        }
        cat.map;
        var seen;
        if ((seen = this.seen || (this.seen = {}))[at2]) {
          return true;
        }
        seen[at2] = true;
        return;
      }
      var empty2 = {}, valid = Gun2.valid, u2;
    })(USE, "./get");
    USE(function(module3) {
      var Gun2 = USE("./root");
      Gun2.chain.put = function(data2, cb, as2) {
        var gun2 = this, at2 = gun2._, root2 = at2.root;
        as2 = as2 || {};
        as2.root = at2.root;
        as2.run || (as2.run = root2.once);
        stun(as2, at2.id);
        as2.ack = as2.ack || cb;
        as2.via = as2.via || gun2;
        as2.data = as2.data || data2;
        as2.soul || (as2.soul = at2.soul || "string" == typeof cb && cb);
        var s2 = as2.state = as2.state || Gun2.state();
        if ("function" == typeof data2) {
          data2(function(d2) {
            as2.data = d2;
            gun2.put(u2, u2, as2);
          });
          return gun2;
        }
        if (!as2.soul) {
          return get2(as2), gun2;
        }
        as2.$ = root2.$.get(as2.soul);
        as2.todo = [{ it: as2.data, ref: as2.$ }];
        as2.turn = as2.turn || turn;
        as2.ran = as2.ran || ran;
        (function walk() {
          var to2 = as2.todo, at3 = to2.pop(), d2 = at3.it;
          at3.ref && at3.ref._.id;
          var v2, k2, cat, tmp, g2;
          stun(as2, at3.ref);
          if (tmp = at3.todo) {
            k2 = tmp.pop();
            d2 = d2[k2];
            if (tmp.length) {
              to2.push(at3);
            }
          }
          k2 && (to2.path || (to2.path = [])).push(k2);
          if (!(v2 = valid(d2)) && !(g2 = Gun2.is(d2))) {
            if (!Object.plain(d2)) {
              ran.err(as2, "Invalid data: " + check2(d2) + " at " + (as2.via.back(function(at4) {
                at4.get && tmp.push(at4.get);
              }, tmp = []) || tmp.join(".")) + "." + (to2.path || []).join("."));
              return;
            }
            var seen = as2.seen || (as2.seen = []), i2 = seen.length;
            while (i2--) {
              if (d2 === (tmp = seen[i2]).it) {
                v2 = d2 = tmp.link;
                break;
              }
            }
          }
          if (k2 && v2) {
            at3.node = state_ify(at3.node, k2, s2, d2);
          } else {
            let resolve2 = function(msg, eve) {
              var end = cat.link["#"];
              if (eve) {
                eve.off();
                eve.rid(msg);
              }
              var soul = end || msg.soul || (tmp = (msg.$$ || msg.$)._ || "").soul || tmp.link || ((tmp = tmp.put || "")._ || "")["#"] || tmp["#"] || ((tmp = msg.put || "") && msg.$$ ? tmp["#"] : (tmp["="] || tmp[":"] || "")["#"]);
              !end && stun(as2, msg.$);
              if (!soul && !at3.link["#"]) {
                (at3.wait || (at3.wait = [])).push(function() {
                  resolve2(msg, eve);
                });
                return;
              }
              if (!soul) {
                soul = [];
                (msg.$$ || msg.$).back(function(at4) {
                  if (tmp = at4.soul || at4.link) {
                    return soul.push(tmp);
                  }
                  soul.push(at4.get);
                });
                soul = soul.reverse().join("/");
              }
              cat.link["#"] = soul;
              !g2 && (((as2.graph || (as2.graph = {}))[soul] = cat.node || (cat.node = { _: {} }))._["#"] = soul);
              delete as2.wait[id2];
              cat.wait && setTimeout.each(cat.wait, function(cb2) {
                cb2 && cb2();
              });
              as2.ran(as2);
            };
            if (!as2.seen) {
              ran.err(as2, "Data at root of graph must be a node (an object).");
              return;
            }
            as2.seen.push(cat = { it: d2, link: {}, todo: g2 ? [] : Object.keys(d2).sort().reverse(), path: (to2.path || []).slice(), up: at3 });
            at3.node = state_ify(at3.node, k2, s2, cat.link);
            !g2 && cat.todo.length && to2.push(cat);
            var id2 = as2.seen.length;
            (as2.wait || (as2.wait = {}))[id2] = "";
            tmp = (cat.ref = g2 ? d2 : k2 ? at3.ref.get(k2) : at3.ref)._;
            (tmp = d2 && (d2._ || "")["#"] || tmp.soul || tmp.link) ? resolve2({ soul: tmp }) : cat.ref.get(resolve2, { run: as2.run, v2020: 1, out: { get: { ".": " " } } });
          }
          if (!to2.length) {
            return as2.ran(as2);
          }
          as2.turn(walk);
        })();
        return gun2;
      };
      function stun(as2, id2) {
        if (!id2) {
          return;
        }
        id2 = (id2._ || "").id || id2;
        var run = as2.root.stun || (as2.root.stun = { on: Gun2.on }), test2 = {}, tmp;
        as2.stun || (as2.stun = run.on("stun", function() {
        }));
        if (tmp = run.on("" + id2)) {
          tmp.the.last.next(test2);
        }
        if (test2.run >= as2.run) {
          return;
        }
        run.on("" + id2, function(test3) {
          if (as2.stun.end) {
            this.off();
            this.to.next(test3);
            return;
          }
          test3.run = test3.run || as2.run;
          test3.stun = test3.stun || as2.stun;
          return;
        });
      }
      function ran(as2) {
        if (as2.err) {
          ran.end(as2.stun, as2.root);
          return;
        }
        if (as2.todo.length || as2.end || !Object.empty(as2.wait)) {
          return;
        }
        as2.end = 1;
        var cat = as2.$.back(-1)._, root2 = cat.root, ask = cat.ask(function(ack) {
          root2.on("ack", ack);
          if (ack.err) {
            Gun2.log(ack);
          }
          if (++acks > (as2.acks || 0)) {
            this.off();
          }
          if (!as2.ack) {
            return;
          }
          as2.ack(ack, this);
        }, as2.opt), acks = 0, stun2 = as2.stun, tmp;
        (tmp = function() {
          if (!stun2) {
            return;
          }
          ran.end(stun2, root2);
          setTimeout.each(Object.keys(stun2 = stun2.add || ""), function(cb) {
            if (cb = stun2[cb]) {
              cb();
            }
          });
        }).hatch = tmp;
        as2.via._.on("out", { put: as2.out = as2.graph, opt: as2.opt, "#": ask, _: tmp });
      }
      ran.end = function(stun2, root2) {
        stun2.end = noop2;
        if (stun2.the.to === stun2 && stun2 === stun2.the.last) {
          delete root2.stun;
        }
        stun2.off();
      };
      ran.err = function(as2, err) {
        (as2.ack || noop2).call(as2, as2.out = { err: as2.err = Gun2.log(err) });
        as2.ran(as2);
      };
      function get2(as2) {
        var at2 = as2.via._, tmp;
        as2.via = as2.via.back(function(at3) {
          if (at3.soul || !at3.get) {
            return at3.$;
          }
          tmp = as2.data;
          (as2.data = {})[at3.get] = tmp;
        });
        if (!as2.via || !as2.via._.soul) {
          as2.via = at2.root.$.get(((as2.data || "")._ || "")["#"] || at2.$.back("opt.uuid")());
        }
        as2.via.put(as2.data, as2.ack, as2);
        return;
      }
      function check2(d2, tmp) {
        return d2 && (tmp = d2.constructor) && tmp.name || typeof d2;
      }
      var u2, noop2 = function() {
      }, turn = setTimeout.turn, valid = Gun2.valid, state_ify = Gun2.state.ify;
    })(USE, "./put");
    USE(function(module3) {
      var Gun2 = USE("./root");
      USE("./chain");
      USE("./back");
      USE("./put");
      USE("./get");
      module3.exports = Gun2;
    })(USE, "./index");
    USE(function(module3) {
      var Gun2 = USE("./index");
      Gun2.chain.on = function(tag, arg, eas, as2) {
        var gun2 = this, cat = gun2._;
        cat.root;
        var act;
        if (typeof tag === "string") {
          if (!arg) {
            return cat.on(tag);
          }
          act = cat.on(tag, arg, eas || cat, as2);
          if (eas && eas.$) {
            (eas.subs || (eas.subs = [])).push(act);
          }
          return gun2;
        }
        var opt = arg;
        (opt = true === opt ? { change: true } : opt || {}).not = 1;
        opt.on = 1;
        gun2.get(tag, opt);
        return gun2;
      };
      Gun2.chain.once = function(cb, opt) {
        opt = opt || {};
        if (!cb) {
          return none2(this);
        }
        var gun2 = this, cat = gun2._, root2 = cat.root;
        cat.put;
        var id2 = String.random(7), tmp;
        gun2.get(function(data2, key, msg, eve) {
          var $2 = this, at2 = $2._, one2 = at2.one || (at2.one = {});
          if (eve.stun) {
            return;
          }
          if ("" === one2[id2]) {
            return;
          }
          if (true === (tmp = Gun2.valid(data2))) {
            once();
            return;
          }
          if ("string" == typeof tmp) {
            return;
          }
          clearTimeout((cat.one || "")[id2]);
          clearTimeout(one2[id2]);
          one2[id2] = setTimeout(once, opt.wait || 99);
          function once(f2) {
            if (!at2.has && !at2.soul) {
              at2 = { put: data2, get: key };
            }
            if (u2 === (tmp = at2.put)) {
              tmp = ((msg.$$ || "")._ || "").put;
            }
            if ("string" == typeof Gun2.valid(tmp)) {
              tmp = root2.$.get(tmp)._.put;
              if (tmp === u2 && !f2) {
                one2[id2] = setTimeout(function() {
                  once(1);
                }, opt.wait || 99);
                return;
              }
            }
            if (eve.stun) {
              return;
            }
            if ("" === one2[id2]) {
              return;
            }
            one2[id2] = "";
            if (cat.soul || cat.has) {
              eve.off();
            }
            cb.call($2, tmp, at2.get);
            clearTimeout(one2[id2]);
          }
        }, { on: 1 });
        return gun2;
      };
      function none2(gun2, opt, chain) {
        Gun2.log.once("valonce", "Chainable val is experimental, its behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.");
        (chain = gun2.chain())._.nix = gun2.once(function(data2, key) {
          chain._.on("in", this._);
        });
        chain._.lex = gun2._.lex;
        return chain;
      }
      Gun2.chain.off = function() {
        var gun2 = this, at2 = gun2._, tmp;
        var cat = at2.back;
        if (!cat) {
          return;
        }
        at2.ack = 0;
        if (tmp = cat.next) {
          if (tmp[at2.get]) {
            delete tmp[at2.get];
          }
        }
        if (tmp = cat.ask) {
          delete tmp[at2.get];
        }
        if (tmp = cat.put) {
          delete tmp[at2.get];
        }
        if (tmp = at2.soul) {
          delete cat.root.graph[tmp];
        }
        if (tmp = at2.map) {
          Object.keys(tmp).forEach(function(i2, at3) {
            at3 = tmp[i2];
            if (at3.link) {
              cat.root.$.get(at3.link).off();
            }
          });
        }
        if (tmp = at2.next) {
          Object.keys(tmp).forEach(function(i2, neat) {
            neat = tmp[i2];
            neat.$.off();
          });
        }
        at2.on("off", {});
        return gun2;
      };
      var u2;
    })(USE, "./on");
    USE(function(module3) {
      var Gun2 = USE("./index"), next = Gun2.chain.get.next;
      Gun2.chain.get.next = function(gun2, lex) {
        var tmp;
        if (!Object.plain(lex)) {
          return (next || noop2)(gun2, lex);
        }
        if (tmp = ((tmp = lex["#"]) || "")["="] || tmp) {
          return gun2.get(tmp);
        }
        (tmp = gun2.chain()._).lex = lex;
        gun2.on("in", function(eve) {
          if (String.match(eve.get || (eve.put || "")["."], lex["."] || lex["#"] || lex)) {
            tmp.on("in", eve);
          }
          this.to.next(eve);
        });
        return tmp.$;
      };
      Gun2.chain.map = function(cb, opt, t2) {
        var gun2 = this, cat = gun2._, lex, chain;
        if (Object.plain(cb)) {
          lex = cb["."] ? cb : { ".": cb };
          cb = u2;
        }
        if (!cb) {
          if (chain = cat.each) {
            return chain;
          }
          (cat.each = chain = gun2.chain())._.lex = lex || chain._.lex || cat.lex;
          chain._.nix = gun2.back("nix");
          gun2.on("in", map2, chain._);
          return chain;
        }
        Gun2.log.once("mapfn", "Map functions are experimental, their behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.");
        chain = gun2.chain();
        gun2.map().on(function(data2, key, msg, eve) {
          var next2 = (cb || noop2).call(this, data2, key, msg, eve);
          if (u2 === next2) {
            return;
          }
          if (data2 === next2) {
            return chain._.on("in", msg);
          }
          if (Gun2.is(next2)) {
            return chain._.on("in", next2._);
          }
          var tmp = {};
          Object.keys(msg.put).forEach(function(k2) {
            tmp[k2] = msg.put[k2];
          }, tmp);
          tmp["="] = next2;
          chain._.on("in", { get: key, put: tmp });
        });
        return chain;
      };
      function map2(msg) {
        this.to.next(msg);
        var cat = this.as, gun2 = msg.$, at2 = gun2._, put = msg.put, tmp;
        if (!at2.soul && !msg.$$) {
          return;
        }
        if ((tmp = cat.lex) && !String.match(msg.get || (put || "")["."], tmp["."] || tmp["#"] || tmp)) {
          return;
        }
        Gun2.on.link(msg, cat);
      }
      var noop2 = function() {
      }, u2;
    })(USE, "./map");
    USE(function(module3) {
      var Gun2 = USE("./index");
      Gun2.chain.set = function(item, cb, opt) {
        var gun2 = this, root2 = gun2.back(-1), soul, tmp;
        cb = cb || function() {
        };
        opt = opt || {};
        opt.item = opt.item || item;
        if (soul = ((item || "")._ || "")["#"]) {
          (item = {})["#"] = soul;
        }
        if ("string" == typeof (tmp = Gun2.valid(item))) {
          return gun2.get(soul = tmp).put(item, cb, opt);
        }
        if (!Gun2.is(item)) {
          if (Object.plain(item)) {
            item = root2.get(soul = gun2.back("opt.uuid")()).put(item);
          }
          return gun2.get(soul || root2.back("opt.uuid")(7)).put(item, cb, opt);
        }
        gun2.put(function(go) {
          item.get(function(soul2, o2, msg) {
            if (!soul2) {
              return cb.call(gun2, { err: Gun2.log('Only a node can be linked! Not "' + msg.put + '"!') });
            }
            (tmp = {})[soul2] = { "#": soul2 };
            go(tmp);
          }, true);
        });
        return item;
      };
    })(USE, "./set");
    USE(function(module3) {
      USE("./shim");
      var noop2 = function() {
      };
      var parse2 = JSON.parseAsync || function(t2, cb, r2) {
        var u3, d2 = +new Date();
        try {
          cb(u3, JSON.parse(t2, r2), json.sucks(+new Date() - d2));
        } catch (e2) {
          cb(e2);
        }
      };
      var json = JSON.stringifyAsync || function(v2, cb, r2, s2) {
        var u3, d2 = +new Date();
        try {
          cb(u3, JSON.stringify(v2, r2, s2), json.sucks(+new Date() - d2));
        } catch (e2) {
          cb(e2);
        }
      };
      json.sucks = function(d2) {
        if (d2 > 99) {
          console.log("Warning: JSON blocking CPU detected. Add `gun/lib/yson.js` to fix.");
          json.sucks = noop2;
        }
      };
      function Mesh(root2) {
        var mesh = function() {
        };
        var opt = root2.opt || {};
        opt.log = opt.log || console.log;
        opt.gap = opt.gap || opt.wait || 0;
        opt.max = opt.max || (opt.memory ? opt.memory * 999 * 999 : 3e8) * 0.3;
        opt.pack = opt.pack || opt.max * 0.01 * 0.01;
        opt.puff = opt.puff || 9;
        var puff = setTimeout.turn || setTimeout;
        var dup = root2.dup, dup_check = dup.check, dup_track = dup.track;
        var hear = mesh.hear = function(raw, peer) {
          if (!raw) {
            return;
          }
          if (opt.max <= raw.length) {
            return mesh.say({ dam: "!", err: "Message too big!" }, peer);
          }
          if (mesh === this) {
            hear.d += raw.length || 0;
            ++hear.c;
          }
          var S2 = peer.SH = +new Date();
          var tmp = raw[0], msg;
          if ("[" === tmp) {
            parse2(raw, function(err, msg2) {
              if (err || !msg2) {
                return mesh.say({ dam: "!", err: "DAM JSON parse error." }, peer);
              }
              console.STAT && console.STAT(+new Date(), msg2.length, "# on hear batch");
              var P2 = opt.puff;
              (function go() {
                var S3 = +new Date();
                var i2 = 0, m2;
                while (i2 < P2 && (m2 = msg2[i2++])) {
                  mesh.hear(m2, peer);
                }
                msg2 = msg2.slice(i2);
                console.STAT && console.STAT(S3, +new Date() - S3, "hear loop");
                flush(peer);
                if (!msg2.length) {
                  return;
                }
                puff(go, 0);
              })();
            });
            raw = "";
            return;
          }
          if ("{" === tmp || (raw["#"] || Object.plain(raw)) && (msg = raw)) {
            if (msg) {
              return hear.one(msg, peer, S2);
            }
            parse2(raw, function(err, msg2) {
              if (err || !msg2) {
                return mesh.say({ dam: "!", err: "DAM JSON parse error." }, peer);
              }
              hear.one(msg2, peer, S2);
            });
            return;
          }
        };
        hear.one = function(msg, peer, S2) {
          var id2, hash2, tmp, ash, DBG;
          if (msg.DBG) {
            msg.DBG = DBG = { DBG: msg.DBG };
          }
          DBG && (DBG.h = S2);
          DBG && (DBG.hp = +new Date());
          if (!(id2 = msg["#"])) {
            id2 = msg["#"] = String.random(9);
          }
          if (tmp = dup_check(id2)) {
            return;
          }
          if (!(hash2 = msg["##"]) && false)
            ;
          if (hash2 && (tmp = msg["@"] || msg.get && id2) && dup.check(ash = tmp + hash2)) {
            return;
          }
          (msg._ = function() {
          }).via = mesh.leap = peer;
          if ((tmp = msg["><"]) && "string" == typeof tmp) {
            tmp.slice(0, 99).split(",").forEach(function(k2) {
              this[k2] = 1;
            }, msg._.yo = {});
          }
          if (tmp = msg.dam) {
            if (tmp = mesh.hear[tmp]) {
              tmp(msg, peer, root2);
            }
            dup_track(id2);
            return;
          }
          var S2 = +new Date();
          DBG && (DBG.is = S2);
          peer.SI = id2;
          root2.on("in", mesh.last = msg);
          DBG && (DBG.hd = +new Date());
          console.STAT && console.STAT(S2, +new Date() - S2, msg.get ? "msg get" : msg.put ? "msg put" : "msg");
          (tmp = dup_track(id2)).via = peer;
          if (msg.get) {
            tmp.it = msg;
          }
          if (ash) {
            dup_track(ash);
          }
          mesh.leap = mesh.last = null;
        };
        hear.c = hear.d = 0;
        (function() {
          var SMIA = 0;
          var loop;
          mesh.hash = function(msg, peer) {
            var h2, s2, t2;
            var S2 = +new Date();
            json(msg.put, function hash2(err, text3) {
              var ss = (s2 || (s2 = t2 = text3 || "")).slice(0, 32768);
              h2 = String.hash(ss, h2);
              s2 = s2.slice(32768);
              if (s2) {
                puff(hash2, 0);
                return;
              }
              console.STAT && console.STAT(S2, +new Date() - S2, "say json+hash");
              msg._.$put = t2;
              msg["##"] = h2;
              mesh.say(msg, peer);
              delete msg._.$put;
            }, sort);
          };
          function sort(k2, v2) {
            var tmp;
            if (!(v2 instanceof Object)) {
              return v2;
            }
            Object.keys(v2).sort().forEach(sorta, { to: tmp = {}, on: v2 });
            return tmp;
          }
          function sorta(k2) {
            this.to[k2] = this.on[k2];
          }
          mesh.say = function(msg, peer) {
            var tmp;
            if ((tmp = this) && (tmp = tmp.to) && tmp.next) {
              tmp.next(msg);
            }
            if (!msg) {
              return false;
            }
            var id2, raw, ack = msg["@"];
            var meta2 = msg._ || (msg._ = function() {
            });
            var DBG = msg.DBG, S2 = +new Date();
            meta2.y = meta2.y || S2;
            if (!peer) {
              DBG && (DBG.y = S2);
            }
            if (!(id2 = msg["#"])) {
              id2 = msg["#"] = String.random(9);
            }
            !loop && dup_track(id2);
            if (msg.put && (msg.err || (dup.s[id2] || "").err)) {
              return false;
            }
            if (!msg["##"] && u2 !== msg.put && !meta2.via && ack) {
              mesh.hash(msg, peer);
              return;
            }
            if (!peer && ack) {
              peer = (tmp = dup.s[ack]) && (tmp.via || (tmp = tmp.it) && (tmp = tmp._) && tmp.via) || (tmp = mesh.last) && ack === tmp["#"] && mesh.leap;
            }
            if (!peer && ack) {
              if (dup.s[ack]) {
                return;
              }
              console.STAT && console.STAT(+new Date(), ++SMIA, "total no peer to ack to");
              return false;
            }
            if (!peer && mesh.way) {
              return mesh.way(msg);
            }
            DBG && (DBG.yh = +new Date());
            if (!(raw = meta2.raw)) {
              mesh.raw(msg, peer);
              return;
            }
            DBG && (DBG.yr = +new Date());
            if (!peer || !peer.id) {
              if (!Object.plain(peer || opt.peers)) {
                return false;
              }
              var S2 = +new Date();
              opt.puff;
              var ps = opt.peers, pl = Object.keys(peer || opt.peers || {});
              console.STAT && console.STAT(S2, +new Date() - S2, "peer keys");
              (function go() {
                var S3 = +new Date();
                loop = 1;
                var wr2 = meta2.raw;
                meta2.raw = raw;
                var i2 = 0, p2;
                while (i2 < 9 && (p2 = (pl || "")[i2++])) {
                  if (!(p2 = ps[p2])) {
                    continue;
                  }
                  mesh.say(msg, p2);
                }
                meta2.raw = wr2;
                loop = 0;
                pl = pl.slice(i2);
                console.STAT && console.STAT(S3, +new Date() - S3, "say loop");
                if (!pl.length) {
                  return;
                }
                puff(go, 0);
                ack && dup_track(ack);
              })();
              return;
            }
            if (!peer.wire && mesh.wire) {
              mesh.wire(peer);
            }
            if (id2 === peer.last) {
              return;
            }
            peer.last = id2;
            if (peer === meta2.via) {
              return false;
            }
            if ((tmp = meta2.yo) && (tmp[peer.url] || tmp[peer.pid] || tmp[peer.id])) {
              return false;
            }
            console.STAT && console.STAT(S2, ((DBG || meta2).yp = +new Date()) - (meta2.y || S2), "say prep");
            !loop && ack && dup_track(ack);
            if (peer.batch) {
              peer.tail = (tmp = peer.tail || 0) + raw.length;
              if (peer.tail <= opt.pack) {
                peer.batch += (tmp ? "," : "") + raw;
                return;
              }
              flush(peer);
            }
            peer.batch = "[";
            var ST = +new Date();
            setTimeout(function() {
              console.STAT && console.STAT(ST, +new Date() - ST, "0ms TO");
              flush(peer);
            }, opt.gap);
            send2(raw, peer);
            console.STAT && ack === peer.SI && console.STAT(S2, +new Date() - peer.SH, "say ack");
          };
          mesh.say.c = mesh.say.d = 0;
          mesh.raw = function(msg, peer) {
            if (!msg) {
              return "";
            }
            var meta2 = msg._ || {}, put, tmp;
            if (tmp = meta2.raw) {
              return tmp;
            }
            if ("string" == typeof msg) {
              return msg;
            }
            var hash2 = msg["##"], ack = msg["@"];
            if (hash2 && ack) {
              if (!meta2.via && dup_check(ack + hash2)) {
                return false;
              }
              if ((tmp = (dup.s[ack] || "").it) || (tmp = mesh.last) && ack === tmp["#"]) {
                if (hash2 === tmp["##"]) {
                  return false;
                }
                if (!tmp["##"]) {
                  tmp["##"] = hash2;
                }
              }
            }
            if (!msg.dam) {
              var i2 = 0, to2 = [];
              tmp = opt.peers;
              for (var k2 in tmp) {
                var p2 = tmp[k2];
                to2.push(p2.url || p2.pid || p2.id);
                if (++i2 > 6) {
                  break;
                }
              }
              if (i2 > 1) {
                msg["><"] = to2.join();
              }
            }
            if (put = meta2.$put) {
              tmp = {};
              Object.keys(msg).forEach(function(k3) {
                tmp[k3] = msg[k3];
              });
              tmp.put = ":])([:";
              json(tmp, function(err, raw) {
                if (err) {
                  return;
                }
                var S2 = +new Date();
                tmp = raw.indexOf('"put":":])([:"');
                res(u2, raw = raw.slice(0, tmp + 6) + put + raw.slice(tmp + 14));
                console.STAT && console.STAT(S2, +new Date() - S2, "say slice");
              });
              return;
            }
            json(msg, res);
            function res(err, raw) {
              if (err) {
                return;
              }
              meta2.raw = raw;
              mesh.say(msg, peer);
            }
          };
        })();
        function flush(peer) {
          var tmp = peer.batch, t2 = "string" == typeof tmp;
          if (t2) {
            tmp += "]";
          }
          peer.batch = peer.tail = null;
          if (!tmp) {
            return;
          }
          if (t2 ? 3 > tmp.length : !tmp.length) {
            return;
          }
          if (!t2) {
            try {
              tmp = 1 === tmp.length ? tmp[0] : JSON.stringify(tmp);
            } catch (e2) {
              return opt.log("DAM JSON stringify error", e2);
            }
          }
          if (!tmp) {
            return;
          }
          send2(tmp, peer);
        }
        function send2(raw, peer) {
          try {
            var wire = peer.wire;
            if (peer.say) {
              peer.say(raw);
            } else if (wire.send) {
              wire.send(raw);
            }
            mesh.say.d += raw.length || 0;
            ++mesh.say.c;
          } catch (e2) {
            (peer.queue = peer.queue || []).push(raw);
          }
        }
        mesh.hi = function(peer) {
          var wire = peer.wire, tmp;
          if (!wire) {
            mesh.wire(peer.length && { url: peer } || peer);
            return;
          }
          if (peer.id) {
            opt.peers[peer.url || peer.id] = peer;
          } else {
            tmp = peer.id = peer.id || String.random(9);
            mesh.say({ dam: "?", pid: root2.opt.pid }, opt.peers[tmp] = peer);
            delete dup.s[peer.last];
          }
          peer.met = peer.met || +new Date();
          if (!wire.hied) {
            root2.on(wire.hied = "hi", peer);
          }
          tmp = peer.queue;
          peer.queue = [];
          setTimeout.each(tmp || [], function(msg) {
            send2(msg, peer);
          }, 0, 9);
        };
        mesh.bye = function(peer) {
          root2.on("bye", peer);
          var tmp = +new Date();
          tmp = tmp - (peer.met || tmp);
          mesh.bye.time = ((mesh.bye.time || tmp) + tmp) / 2;
        };
        mesh.hear["!"] = function(msg, peer) {
          opt.log("Error:", msg.err);
        };
        mesh.hear["?"] = function(msg, peer) {
          if (msg.pid) {
            if (!peer.pid) {
              peer.pid = msg.pid;
            }
            if (msg["@"]) {
              return;
            }
          }
          mesh.say({ dam: "?", pid: opt.pid, "@": msg["#"] }, peer);
          delete dup.s[peer.last];
        };
        root2.on("create", function(root3) {
          root3.opt.pid = root3.opt.pid || String.random(9);
          this.to.next(root3);
          root3.on("out", mesh.say);
        });
        root2.on("bye", function(peer, tmp) {
          peer = opt.peers[peer.id || peer] || peer;
          this.to.next(peer);
          peer.bye ? peer.bye() : (tmp = peer.wire) && tmp.close && tmp.close();
          delete opt.peers[peer.id];
          peer.wire = null;
        });
        var gets = {};
        root2.on("bye", function(peer, tmp) {
          this.to.next(peer);
          if (tmp = console.STAT) {
            tmp.peers = (tmp.peers || 0) - 1;
          }
          if (!(tmp = peer.url)) {
            return;
          }
          gets[tmp] = true;
          setTimeout(function() {
            delete gets[tmp];
          }, opt.lack || 9e3);
        });
        root2.on("hi", function(peer, tmp) {
          this.to.next(peer);
          if (tmp = console.STAT) {
            tmp.peers = (tmp.peers || 0) + 1;
          }
          if (!(tmp = peer.url) || !gets[tmp]) {
            return;
          }
          delete gets[tmp];
          if (opt.super) {
            return;
          }
          setTimeout.each(Object.keys(root2.next), function(soul) {
            root2.next[soul];
            tmp = {};
            tmp[soul] = root2.graph[soul];
            tmp = String.hash(tmp);
            mesh.say({ "##": tmp, get: { "#": soul } }, peer);
          });
        });
        return mesh;
      }
      var u2;
      try {
        module3.exports = Mesh;
      } catch (e2) {
      }
    })(USE, "./mesh");
    USE(function(module3) {
      var Gun2 = USE("../index");
      Gun2.Mesh = USE("./mesh");
      Gun2.on("opt", function(root2) {
        this.to.next(root2);
        if (root2.once) {
          return;
        }
        var opt = root2.opt;
        if (false === opt.WebSocket) {
          return;
        }
        var env = Gun2.window || {};
        var websocket = opt.WebSocket || env.WebSocket || env.webkitWebSocket || env.mozWebSocket;
        if (!websocket) {
          return;
        }
        opt.WebSocket = websocket;
        var mesh = opt.mesh = opt.mesh || Gun2.Mesh(root2);
        mesh.wire || opt.wire;
        mesh.wire = opt.wire = open2;
        function open2(peer) {
          try {
            if (!peer || !peer.url) {
              return wire && wire(peer);
            }
            var url = peer.url.replace(/^http/, "ws");
            var wire = peer.wire = new opt.WebSocket(url);
            wire.onclose = function() {
              opt.mesh.bye(peer);
              reconnect(peer);
            };
            wire.onerror = function(error2) {
              reconnect(peer);
            };
            wire.onopen = function() {
              opt.mesh.hi(peer);
            };
            wire.onmessage = function(msg) {
              if (!msg) {
                return;
              }
              opt.mesh.hear(msg.data || msg, peer);
            };
            return wire;
          } catch (e2) {
          }
        }
        setTimeout(function() {
          !opt.super && root2.on("out", { dam: "hi" });
        }, 1);
        var wait = 2 * 999;
        function reconnect(peer) {
          clearTimeout(peer.defer);
          if (!opt.peers[peer.url]) {
            return;
          }
          if (doc2 && peer.retry <= 0) {
            return;
          }
          peer.retry = (peer.retry || opt.retry + 1 || 60) - (-peer.tried + (peer.tried = +new Date()) < wait * 4 ? 1 : 0);
          peer.defer = setTimeout(function to2() {
            if (doc2 && doc2.hidden) {
              return setTimeout(to2, wait);
            }
            open2(peer);
          }, wait);
        }
        var doc2 = "" + u2 !== typeof document && document;
      });
      var u2;
    })(USE, "./websocket");
    USE(function(module3) {
      if (typeof Gun === "undefined") {
        return;
      }
      var noop2 = function() {
      }, store;
      try {
        store = (Gun.window || noop2).localStorage;
      } catch (e2) {
      }
      if (!store) {
        Gun.log("Warning: No localStorage exists to persist data to!");
        store = { setItem: function(k2, v2) {
          this[k2] = v2;
        }, removeItem: function(k2) {
          delete this[k2];
        }, getItem: function(k2) {
          return this[k2];
        } };
      }
      var json = JSON.stringifyAsync || function(v2, cb, r2, s2) {
        var u2;
        try {
          cb(u2, JSON.stringify(v2, r2, s2));
        } catch (e2) {
          cb(e2);
        }
      };
      Gun.on("create", function lg2(root2) {
        this.to.next(root2);
        var opt = root2.opt;
        root2.graph;
        var acks = [], disk, to2, size2, stop;
        if (false === opt.localStorage) {
          return;
        }
        opt.prefix = opt.file || "gun/";
        try {
          disk = lg2[opt.prefix] = lg2[opt.prefix] || JSON.parse(size2 = store.getItem(opt.prefix)) || {};
        } catch (e2) {
          disk = lg2[opt.prefix] = {};
        }
        size2 = (size2 || "").length;
        root2.on("get", function(msg) {
          this.to.next(msg);
          var lex = msg.get, soul, data2, tmp, u2;
          if (!lex || !(soul = lex["#"])) {
            return;
          }
          data2 = disk[soul] || u2;
          if (data2 && (tmp = lex["."]) && !Object.plain(tmp)) {
            data2 = Gun.state.ify({}, tmp, Gun.state.is(data2, tmp), data2[tmp], soul);
          }
          Gun.on.get.ack(msg, data2);
        });
        root2.on("put", function(msg) {
          this.to.next(msg);
          var put = msg.put, soul = put["#"], key = put["."], id2 = msg["#"];
          disk[soul] = Gun.state.ify(disk[soul], key, put[">"], put[":"], soul);
          if (stop && size2 > 4999880) {
            root2.on("in", { "@": id2, err: "localStorage max!" });
            return;
          }
          if (!msg["@"]) {
            acks.push(id2);
          }
          if (to2) {
            return;
          }
          to2 = setTimeout(flush, 9 + size2 / 333);
        });
        function flush() {
          if (!acks.length && ((setTimeout.turn || "").s || "").length) {
            setTimeout(flush, 99);
            return;
          }
          var ack = acks;
          clearTimeout(to2);
          to2 = false;
          acks = [];
          json(disk, function(err, tmp) {
            try {
              !err && store.setItem(opt.prefix, tmp);
            } catch (e2) {
              err = stop = e2 || "localStorage failure";
            }
            if (err) {
              Gun.log(err + " Consider using GUN's IndexedDB plugin for RAD for more storage space, https://gun.eco/docs/RAD#install");
              root2.on("localStorage:error", { err, get: opt.prefix, put: disk });
            }
            size2 = tmp.length;
            if (!err && !Object.empty(opt.peers)) {
              return;
            }
            setTimeout.each(ack, function(id2) {
              root2.on("in", { "@": id2, err, ok: 0 });
            }, 0, 99);
          });
        }
      });
    })(USE, "./localStorage");
  })();
  (function() {
    var u2;
    if ("" + u2 == typeof Gun) {
      return;
    }
    var DEP = function(n2) {
      console.warn("Warning! Deprecated internal utility will break in next version:", n2);
    };
    var Type = Gun;
    Type.fn = Type.fn || { is: function(fn2) {
      DEP("fn");
      return !!fn2 && "function" == typeof fn2;
    } };
    Type.bi = Type.bi || { is: function(b2) {
      DEP("bi");
      return b2 instanceof Boolean || typeof b2 == "boolean";
    } };
    Type.num = Type.num || { is: function(n2) {
      DEP("num");
      return !list_is(n2) && (n2 - parseFloat(n2) + 1 >= 0 || Infinity === n2 || -Infinity === n2);
    } };
    Type.text = Type.text || { is: function(t2) {
      DEP("text");
      return typeof t2 == "string";
    } };
    Type.text.ify = Type.text.ify || function(t2) {
      DEP("text.ify");
      if (Type.text.is(t2)) {
        return t2;
      }
      if (typeof JSON !== "undefined") {
        return JSON.stringify(t2);
      }
      return t2 && t2.toString ? t2.toString() : t2;
    };
    Type.text.random = Type.text.random || function(l2, c2) {
      DEP("text.random");
      var s2 = "";
      l2 = l2 || 24;
      c2 = c2 || "0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz";
      while (l2 > 0) {
        s2 += c2.charAt(Math.floor(Math.random() * c2.length));
        l2--;
      }
      return s2;
    };
    Type.text.match = Type.text.match || function(t2, o2) {
      var tmp, u3;
      DEP("text.match");
      if ("string" !== typeof t2) {
        return false;
      }
      if ("string" == typeof o2) {
        o2 = { "=": o2 };
      }
      o2 = o2 || {};
      tmp = o2["="] || o2["*"] || o2[">"] || o2["<"];
      if (t2 === tmp) {
        return true;
      }
      if (u3 !== o2["="]) {
        return false;
      }
      tmp = o2["*"] || o2[">"] || o2["<"];
      if (t2.slice(0, (tmp || "").length) === tmp) {
        return true;
      }
      if (u3 !== o2["*"]) {
        return false;
      }
      if (u3 !== o2[">"] && u3 !== o2["<"]) {
        return t2 >= o2[">"] && t2 <= o2["<"] ? true : false;
      }
      if (u3 !== o2[">"] && t2 >= o2[">"]) {
        return true;
      }
      if (u3 !== o2["<"] && t2 <= o2["<"]) {
        return true;
      }
      return false;
    };
    Type.text.hash = Type.text.hash || function(s2, c2) {
      DEP("text.hash");
      if (typeof s2 !== "string") {
        return;
      }
      c2 = c2 || 0;
      if (!s2.length) {
        return c2;
      }
      for (var i2 = 0, l2 = s2.length, n2; i2 < l2; ++i2) {
        n2 = s2.charCodeAt(i2);
        c2 = (c2 << 5) - c2 + n2;
        c2 |= 0;
      }
      return c2;
    };
    Type.list = Type.list || { is: function(l2) {
      DEP("list");
      return l2 instanceof Array;
    } };
    Type.list.slit = Type.list.slit || Array.prototype.slice;
    Type.list.sort = Type.list.sort || function(k2) {
      DEP("list.sort");
      return function(A2, B2) {
        if (!A2 || !B2) {
          return 0;
        }
        A2 = A2[k2];
        B2 = B2[k2];
        if (A2 < B2) {
          return -1;
        } else if (A2 > B2) {
          return 1;
        } else {
          return 0;
        }
      };
    };
    Type.list.map = Type.list.map || function(l2, c2, _2) {
      DEP("list.map");
      return obj_map(l2, c2, _2);
    };
    Type.list.index = 1;
    Type.obj = Type.boj || { is: function(o2) {
      DEP("obj");
      return o2 ? o2 instanceof Object && o2.constructor === Object || Object.prototype.toString.call(o2).match(/^\[object (\w+)\]$/)[1] === "Object" : false;
    } };
    Type.obj.put = Type.obj.put || function(o2, k2, v2) {
      DEP("obj.put");
      return (o2 || {})[k2] = v2, o2;
    };
    Type.obj.has = Type.obj.has || function(o2, k2) {
      DEP("obj.has");
      return o2 && Object.prototype.hasOwnProperty.call(o2, k2);
    };
    Type.obj.del = Type.obj.del || function(o2, k2) {
      DEP("obj.del");
      if (!o2) {
        return;
      }
      o2[k2] = null;
      delete o2[k2];
      return o2;
    };
    Type.obj.as = Type.obj.as || function(o2, k2, v2, u3) {
      DEP("obj.as");
      return o2[k2] = o2[k2] || (u3 === v2 ? {} : v2);
    };
    Type.obj.ify = Type.obj.ify || function(o2) {
      DEP("obj.ify");
      if (obj_is(o2)) {
        return o2;
      }
      try {
        o2 = JSON.parse(o2);
      } catch (e2) {
        o2 = {};
      }
      return o2;
    };
    (function() {
      var u3;
      function map2(v2, k2) {
        if (obj_has(this, k2) && u3 !== this[k2]) {
          return;
        }
        this[k2] = v2;
      }
      Type.obj.to = Type.obj.to || function(from2, to2) {
        DEP("obj.to");
        to2 = to2 || {};
        obj_map(from2, map2, to2);
        return to2;
      };
    })();
    Type.obj.copy = Type.obj.copy || function(o2) {
      DEP("obj.copy");
      return !o2 ? o2 : JSON.parse(JSON.stringify(o2));
    };
    (function() {
      function empty2(v2, i2) {
        var n2 = this.n, u3;
        if (n2 && (i2 === n2 || obj_is(n2) && obj_has(n2, i2))) {
          return;
        }
        if (u3 !== i2) {
          return true;
        }
      }
      Type.obj.empty = Type.obj.empty || function(o2, n2) {
        DEP("obj.empty");
        if (!o2) {
          return true;
        }
        return obj_map(o2, empty2, { n: n2 }) ? false : true;
      };
    })();
    (function() {
      function t2(k2, v2) {
        if (2 === arguments.length) {
          t2.r = t2.r || {};
          t2.r[k2] = v2;
          return;
        }
        t2.r = t2.r || [];
        t2.r.push(k2);
      }
      var keys2 = Object.keys, map2;
      Object.keys = Object.keys || function(o2) {
        return map2(o2, function(v2, k2, t3) {
          t3(k2);
        });
      };
      Type.obj.map = map2 = Type.obj.map || function(l2, c2, _2) {
        DEP("obj.map");
        var u3, i2 = 0, x2, r2, ll2, lle, f2 = "function" == typeof c2;
        t2.r = u3;
        if (keys2 && obj_is(l2)) {
          ll2 = keys2(l2);
          lle = true;
        }
        _2 = _2 || {};
        if (list_is(l2) || ll2) {
          x2 = (ll2 || l2).length;
          for (; i2 < x2; i2++) {
            var ii2 = i2 + Type.list.index;
            if (f2) {
              r2 = lle ? c2.call(_2, l2[ll2[i2]], ll2[i2], t2) : c2.call(_2, l2[i2], ii2, t2);
              if (r2 !== u3) {
                return r2;
              }
            } else {
              if (c2 === l2[lle ? ll2[i2] : i2]) {
                return ll2 ? ll2[i2] : ii2;
              }
            }
          }
        } else {
          for (i2 in l2) {
            if (f2) {
              if (obj_has(l2, i2)) {
                r2 = _2 ? c2.call(_2, l2[i2], i2, t2) : c2(l2[i2], i2, t2);
                if (r2 !== u3) {
                  return r2;
                }
              }
            } else {
              if (c2 === l2[i2]) {
                return i2;
              }
            }
          }
        }
        return f2 ? t2.r : Type.list.index ? 0 : -1;
      };
    })();
    Type.time = Type.time || {};
    Type.time.is = Type.time.is || function(t2) {
      DEP("time");
      return t2 ? t2 instanceof Date : +new Date().getTime();
    };
    var fn_is = Type.fn.is;
    var list_is = Type.list.is;
    var obj = Type.obj, obj_is = obj.is, obj_has = obj.has, obj_map = obj.map;
    var Val = {};
    Val.is = function(v2) {
      DEP("val.is");
      if (v2 === u2) {
        return false;
      }
      if (v2 === null) {
        return true;
      }
      if (v2 === Infinity) {
        return false;
      }
      if (text_is(v2) || bi_is(v2) || num_is(v2)) {
        return true;
      }
      return Val.link.is(v2) || false;
    };
    Val.link = Val.rel = { _: "#" };
    (function() {
      Val.link.is = function(v2) {
        DEP("val.link.is");
        if (v2 && v2[rel_] && !v2._ && obj_is(v2)) {
          var o2 = {};
          obj_map(v2, map2, o2);
          if (o2.id) {
            return o2.id;
          }
        }
        return false;
      };
      function map2(s2, k2) {
        var o2 = this;
        if (o2.id) {
          return o2.id = false;
        }
        if (k2 == rel_ && text_is(s2)) {
          o2.id = s2;
        } else {
          return o2.id = false;
        }
      }
    })();
    Val.link.ify = function(t2) {
      DEP("val.link.ify");
      return obj_put({}, rel_, t2);
    };
    Type.obj.has._ = ".";
    var rel_ = Val.link._, u2;
    var bi_is = Type.bi.is;
    var num_is = Type.num.is;
    var text_is = Type.text.is;
    var obj = Type.obj, obj_is = obj.is, obj_put = obj.put, obj_map = obj.map;
    Type.val = Type.val || Val;
    var Node = { _: "_" };
    Node.soul = function(n2, o2) {
      DEP("node.soul");
      return n2 && n2._ && n2._[o2 || soul_];
    };
    Node.soul.ify = function(n2, o2) {
      DEP("node.soul.ify");
      o2 = typeof o2 === "string" ? { soul: o2 } : o2 || {};
      n2 = n2 || {};
      n2._ = n2._ || {};
      n2._[soul_] = o2.soul || n2._[soul_] || text_random();
      return n2;
    };
    Node.soul._ = Val.link._;
    (function() {
      Node.is = function(n2, cb, as2) {
        DEP("node.is");
        var s2;
        if (!obj_is(n2)) {
          return false;
        }
        if (s2 = Node.soul(n2)) {
          return !obj_map(n2, map2, { as: as2, cb, s: s2, n: n2 });
        }
        return false;
      };
      function map2(v2, k2) {
        if (k2 === Node._) {
          return;
        }
        if (!Val.is(v2)) {
          return true;
        }
        if (this.cb) {
          this.cb.call(this.as, v2, k2, this.n, this.s);
        }
      }
    })();
    (function() {
      Node.ify = function(obj2, o2, as2) {
        DEP("node.ify");
        if (!o2) {
          o2 = {};
        } else if (typeof o2 === "string") {
          o2 = { soul: o2 };
        } else if ("function" == typeof o2) {
          o2 = { map: o2 };
        }
        if (o2.map) {
          o2.node = o2.map.call(as2, obj2, u2, o2.node || {});
        }
        if (o2.node = Node.soul.ify(o2.node || {}, o2)) {
          obj_map(obj2, map2, { o: o2, as: as2 });
        }
        return o2.node;
      };
      function map2(v2, k2) {
        var o2 = this.o, tmp, u3;
        if (o2.map) {
          tmp = o2.map.call(this.as, v2, "" + k2, o2.node);
          if (u3 === tmp) {
            obj_del(o2.node, k2);
          } else if (o2.node) {
            o2.node[k2] = tmp;
          }
          return;
        }
        if (Val.is(v2)) {
          o2.node[k2] = v2;
        }
      }
    })();
    var obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_map = obj.map;
    var text3 = Type.text, text_random = text3.random;
    var soul_ = Node.soul._;
    var u2;
    Type.node = Type.node || Node;
    var State = Type.state;
    State.lex = function() {
      DEP("state.lex");
      return State().toString(36).replace(".", "");
    };
    State.to = function(from2, k2, to2) {
      DEP("state.to");
      var val = (from2 || {})[k2];
      if (obj_is(val)) {
        val = obj_copy(val);
      }
      return State.ify(to2, k2, State.is(from2, k2), val, Node.soul(from2));
    };
    (function() {
      State.map = function(cb, s2, as2) {
        DEP("state.map");
        var u3;
        var o2 = obj_is(o2 = cb || s2) ? o2 : null;
        cb = fn_is(cb = cb || s2) ? cb : null;
        if (o2 && !cb) {
          s2 = num_is(s2) ? s2 : State();
          o2[N_] = o2[N_] || {};
          obj_map(o2, map2, { o: o2, s: s2 });
          return o2;
        }
        as2 = as2 || obj_is(s2) ? s2 : u3;
        s2 = num_is(s2) ? s2 : State();
        return function(v2, k2, o3, opt) {
          if (!cb) {
            map2.call({ o: o3, s: s2 }, v2, k2);
            return v2;
          }
          cb.call(as2 || this || {}, v2, k2, o3, opt);
          if (obj_has(o3, k2) && u3 === o3[k2]) {
            return;
          }
          map2.call({ o: o3, s: s2 }, v2, k2);
        };
      };
      function map2(v2, k2) {
        if (N_ === k2) {
          return;
        }
        State.ify(this.o, k2, this.s);
      }
    })();
    var obj = Type.obj;
    obj.as;
    var obj_has = obj.has, obj_is = obj.is, obj_map = obj.map, obj_copy = obj.copy;
    var num2 = Type.num, num_is = num2.is;
    var fn = Type.fn, fn_is = fn.is;
    var N_ = Node._, u2;
    var Graph = {};
    (function() {
      Graph.is = function(g2, cb, fn2, as2) {
        DEP("graph.is");
        if (!g2 || !obj_is(g2) || obj_empty(g2)) {
          return false;
        }
        return !obj_map(g2, map2, { cb, fn: fn2, as: as2 });
      };
      function map2(n2, s2) {
        if (!n2 || s2 !== Node.soul(n2) || !Node.is(n2, this.fn, this.as)) {
          return true;
        }
        if (!this.cb) {
          return;
        }
        nf.n = n2;
        nf.as = this.as;
        this.cb.call(nf.as, n2, s2, nf);
      }
      function nf(fn2) {
        if (fn2) {
          Node.is(nf.n, fn2, nf.as);
        }
      }
    })();
    (function() {
      Graph.ify = function(obj2, env, as2) {
        DEP("graph.ify");
        var at2 = { path: [], obj: obj2 };
        if (!env) {
          env = {};
        } else if (typeof env === "string") {
          env = { soul: env };
        } else if ("function" == typeof env) {
          env.map = env;
        }
        if (typeof as2 === "string") {
          env.soul = env.soul || as2;
          as2 = u2;
        }
        if (env.soul) {
          at2.link = Val.link.ify(env.soul);
        }
        env.shell = (as2 || {}).shell;
        env.graph = env.graph || {};
        env.seen = env.seen || [];
        env.as = env.as || as2;
        node(env, at2);
        env.root = at2.node;
        return env.graph;
      };
      function node(env, at2) {
        var tmp;
        if (tmp = seen(env, at2)) {
          return tmp;
        }
        at2.env = env;
        at2.soul = soul;
        if (Node.ify(at2.obj, map2, at2)) {
          at2.link = at2.link || Val.link.ify(Node.soul(at2.node));
          if (at2.obj !== env.shell) {
            env.graph[Val.link.is(at2.link)] = at2.node;
          }
        }
        return at2;
      }
      function map2(v2, k2, n2) {
        var at2 = this, env = at2.env, is, tmp;
        if (Node._ === k2 && obj_has(v2, Val.link._)) {
          return n2._;
        }
        if (!(is = valid(v2, k2, n2, at2, env))) {
          return;
        }
        if (!k2) {
          at2.node = at2.node || n2 || {};
          if (obj_has(v2, Node._) && Node.soul(v2)) {
            at2.node._ = obj_copy(v2._);
          }
          at2.node = Node.soul.ify(at2.node, Val.link.is(at2.link));
          at2.link = at2.link || Val.link.ify(Node.soul(at2.node));
        }
        if (tmp = env.map) {
          tmp.call(env.as || {}, v2, k2, n2, at2);
          if (obj_has(n2, k2)) {
            v2 = n2[k2];
            if (u2 === v2) {
              obj_del(n2, k2);
              return;
            }
            if (!(is = valid(v2, k2, n2, at2, env))) {
              return;
            }
          }
        }
        if (!k2) {
          return at2.node;
        }
        if (true === is) {
          return v2;
        }
        tmp = node(env, { obj: v2, path: at2.path.concat(k2) });
        if (!tmp.node) {
          return;
        }
        return tmp.link;
      }
      function soul(id2) {
        var at2 = this;
        var prev = Val.link.is(at2.link), graph = at2.env.graph;
        at2.link = at2.link || Val.link.ify(id2);
        at2.link[Val.link._] = id2;
        if (at2.node && at2.node[Node._]) {
          at2.node[Node._][Val.link._] = id2;
        }
        if (obj_has(graph, prev)) {
          graph[id2] = graph[prev];
          obj_del(graph, prev);
        }
      }
      function valid(v2, k2, n2, at2, env) {
        var tmp;
        if (Val.is(v2)) {
          return true;
        }
        if (obj_is(v2)) {
          return 1;
        }
        if (tmp = env.invalid) {
          v2 = tmp.call(env.as || {}, v2, k2, n2);
          return valid(v2, k2, n2, at2, env);
        }
        env.err = "Invalid value at '" + at2.path.concat(k2).join(".") + "'!";
        if (Type.list.is(v2)) {
          env.err += " Use `.set(item)` instead of an Array.";
        }
      }
      function seen(env, at2) {
        var arr = env.seen, i2 = arr.length, has2;
        while (i2--) {
          has2 = arr[i2];
          if (at2.obj === has2.obj) {
            return has2;
          }
        }
        arr.push(at2);
      }
    })();
    Graph.node = function(node) {
      DEP("graph.node");
      var soul = Node.soul(node);
      if (!soul) {
        return;
      }
      return obj_put({}, soul, node);
    };
    (function() {
      Graph.to = function(graph, root2, opt) {
        DEP("graph.to");
        if (!graph) {
          return;
        }
        var obj2 = {};
        opt = opt || { seen: {} };
        obj_map(graph[root2], map2, { obj: obj2, graph, opt });
        return obj2;
      };
      function map2(v2, k2) {
        var tmp, obj2;
        if (Node._ === k2) {
          if (obj_empty(v2, Val.link._)) {
            return;
          }
          this.obj[k2] = obj_copy(v2);
          return;
        }
        if (!(tmp = Val.link.is(v2))) {
          this.obj[k2] = v2;
          return;
        }
        if (obj2 = this.opt.seen[tmp]) {
          this.obj[k2] = obj2;
          return;
        }
        this.obj[k2] = this.opt.seen[tmp] = Graph.to(this.graph, tmp, this.opt);
      }
    })();
    var fn_is = Type.fn.is;
    var obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_has = obj.has, obj_empty = obj.empty, obj_put = obj.put, obj_map = obj.map, obj_copy = obj.copy;
    var u2;
    Type.graph = Type.graph || Graph;
  })();
})(gun);
var Gun$3 = gun.exports;
var Gun$2 = typeof window !== "undefined" ? window.Gun : gun.exports;
Gun$2.chain.promise = function(cb) {
  var gun2 = this, cb = cb || function(ctx) {
    return ctx;
  };
  return new Promise(function(res, rej) {
    gun2.once(function(data2, key) {
      res({ put: data2, get: key, gun: this });
    });
  }).then(cb);
};
Gun$2.chain.then = function(cb) {
  var gun2 = this;
  var p2 = new Promise((res, rej) => {
    gun2.once(function(data2, key) {
      res(data2, key);
    });
  });
  return cb ? p2.then(cb) : p2;
};
var radix = { exports: {} };
(function() {
  function Radix() {
    var radix2 = function(key, val, t2) {
      radix2.unit = 0;
      if (!t2 && u2 !== val) {
        radix2.last = "" + key < radix2.last ? radix2.last : "" + key;
        delete (radix2.$ || {})[_2];
      }
      t2 = t2 || radix2.$ || (radix2.$ = {});
      if (!key && Object.keys(t2).length) {
        return t2;
      }
      key = "" + key;
      var i2 = 0, l2 = key.length - 1, k2 = key[i2], at2, tmp;
      while (!(at2 = t2[k2]) && i2 < l2) {
        k2 += key[++i2];
      }
      if (!at2) {
        if (!each(t2, function(r2, s2) {
          var ii2 = 0, kk = "";
          if ((s2 || "").length) {
            while (s2[ii2] == key[ii2]) {
              kk += s2[ii2++];
            }
          }
          if (kk) {
            if (u2 === val) {
              if (ii2 <= l2) {
                return;
              }
              (tmp || (tmp = {}))[s2.slice(ii2)] = r2;
              return r2;
            }
            var __ = {};
            __[s2.slice(ii2)] = r2;
            ii2 = key.slice(ii2);
            "" === ii2 ? __[""] = val : (__[ii2] = {})[""] = val;
            t2[kk] = __;
            if (Radix.debug && "undefined" === "" + kk) {
              console.log(0, kk);
              debugger;
            }
            delete t2[s2];
            return true;
          }
        })) {
          if (u2 === val) {
            return;
          }
          (t2[k2] || (t2[k2] = {}))[""] = val;
          if (Radix.debug && "undefined" === "" + k2) {
            console.log(1, k2);
            debugger;
          }
        }
        if (u2 === val) {
          return tmp;
        }
      } else if (i2 == l2) {
        if (u2 === val) {
          return u2 === (tmp = at2[""]) ? at2 : (radix2.unit = 1) && tmp;
        }
        at2[""] = val;
      } else {
        if (u2 !== val) {
          delete at2[_2];
        }
        return radix2(key.slice(++i2), val, at2 || (at2 = {}));
      }
    };
    return radix2;
  }
  Radix.map = function rap(radix2, cb, opt, pre2) {
    pre2 = pre2 || [];
    var t2 = "function" == typeof radix2 ? radix2.$ || {} : radix2;
    //!opt && console.log("WHAT IS T?", JSON.stringify(t).length);
    if (!t2) {
      return;
    }
    if ("string" == typeof t2) {
      if (Radix.debug) {
        throw ["BUG:", radix2, cb, opt, pre2];
      }
      return;
    }
    var keys2 = (t2[_2] || no).sort || (t2[_2] = function $2() {
      $2.sort = Object.keys(t2).sort();
      return $2;
    }()).sort, rev;
    opt = true === opt ? { branch: true } : opt || {};
    if (rev = opt.reverse) {
      keys2 = keys2.slice(0).reverse();
    }
    var start2 = opt.start, end = opt.end, END = "\uFFFF";
    var i2 = 0, l2 = keys2.length;
    for (; i2 < l2; i2++) {
      var key = keys2[i2], tree = t2[key], tmp, p2, pt;
      if (!tree || "" === key || _2 === key || "undefined" === key) {
        continue;
      }
      p2 = pre2.slice(0);
      p2.push(key);
      pt = p2.join("");
      if (u2 !== start2 && pt < (start2 || "").slice(0, pt.length)) {
        continue;
      }
      if (u2 !== end && (end || END) < pt) {
        continue;
      }
      if (rev) {
        tmp = rap(tree, cb, opt, p2);
        if (u2 !== tmp) {
          return tmp;
        }
      }
      if (u2 !== (tmp = tree[""])) {
        var yes = 1;
        if (u2 !== start2 && pt < (start2 || "")) {
          yes = 0;
        }
        if (u2 !== end && pt > (end || END)) {
          yes = 0;
        }
        if (yes) {
          tmp = cb(tmp, pt, key, pre2);
          if (u2 !== tmp) {
            return tmp;
          }
        }
      } else if (opt.branch) {
        tmp = cb(u2, pt, key, pre2);
        if (u2 !== tmp) {
          return tmp;
        }
      }
      pre2 = p2;
      if (!rev) {
        tmp = rap(tree, cb, opt, pre2);
        if (u2 !== tmp) {
          return tmp;
        }
      }
      pre2.pop();
    }
  };
  if (typeof window !== "undefined") {
    window.Radix = Radix;
  } else {
    try {
      radix.exports = Radix;
    } catch (e2) {
    }
  }
  var each = Radix.object = function(o2, f2, r2) {
    for (var k2 in o2) {
      if (!o2.hasOwnProperty(k2)) {
        continue;
      }
      if ((r2 = f2(o2[k2], k2)) !== u2) {
        return r2;
      }
    }
  }, no = {}, u2;
  var _2 = String.fromCharCode(24);
})();
var radisk = { exports: {} };
var yson = { exports: {} };
(function(module2) {
  (function() {
    var yson2 = {}, u2, sI = setTimeout.turn || typeof setImmediate != "" + u2 && setImmediate || setTimeout;
    yson2.parseAsync = function(text3, done, revive, M2) {
      if ("string" != typeof text3) {
        try {
          done(u2, JSON.parse(text3));
        } catch (e2) {
          done(e2);
        }
        return;
      }
      var ctx = { i: 0, text: text3, done, l: text3.length, up: [] };
      M2 = M2 || 1024 * 32;
      parse2();
      function parse2() {
        var s2 = ctx.text;
        var i2 = ctx.i, l2 = ctx.l, j2 = 0;
        var w2 = ctx.w, b2, tmp;
        while (j2++ < M2) {
          var c2 = s2[i2++];
          if (i2 > l2) {
            ctx.end = true;
            break;
          }
          if (w2) {
            i2 = s2.indexOf('"', i2 - 1);
            c2 = s2[i2];
            tmp = 0;
            while ("\\" == s2[i2 - ++tmp]) {
            }
            tmp = !(tmp % 2);
            b2 = b2 || tmp;
            if ('"' == c2 && !tmp) {
              w2 = u2;
              tmp = ctx.s;
              if (ctx.a) {
                tmp = s2.slice(ctx.sl, i2);
                if (b2 || 1 + tmp.indexOf("\\")) {
                  tmp = JSON.parse('"' + tmp + '"');
                }
                if (ctx.at instanceof Array) {
                  ctx.at.push(ctx.s = tmp);
                } else {
                  if (!ctx.at) {
                    ctx.end = j2 = M2;
                    tmp = u2;
                  }
                  (ctx.at || {})[ctx.s] = ctx.s = tmp;
                }
                ctx.s = u2;
              } else {
                ctx.s = s2.slice(ctx.sl, i2);
                if (b2 || 1 + ctx.s.indexOf("\\")) {
                  ctx.s = JSON.parse('"' + ctx.s + '"');
                }
              }
              ctx.a = b2 = u2;
            }
            ++i2;
          } else {
            switch (c2) {
              case '"':
                ctx.sl = i2;
                w2 = true;
                break;
              case ":":
                ctx.ai = i2;
                ctx.a = true;
                break;
              case ",":
                if (ctx.a || ctx.at instanceof Array) {
                  if (tmp = s2.slice(ctx.ai, i2 - 1)) {
                    if (u2 !== (tmp = value(tmp))) {
                      if (ctx.at instanceof Array) {
                        ctx.at.push(tmp);
                      } else {
                        ctx.at[ctx.s] = tmp;
                      }
                    }
                  }
                }
                ctx.a = u2;
                if (ctx.at instanceof Array) {
                  ctx.a = true;
                  ctx.ai = i2;
                }
                break;
              case "{":
                ctx.up.push(ctx.at || (ctx.at = {}));
                if (ctx.at instanceof Array) {
                  ctx.at.push(ctx.at = {});
                } else if (u2 !== (tmp = ctx.s)) {
                  ctx.at[tmp] = ctx.at = {};
                }
                ctx.a = u2;
                break;
              case "}":
                if (ctx.a) {
                  if (tmp = s2.slice(ctx.ai, i2 - 1)) {
                    if (u2 !== (tmp = value(tmp))) {
                      if (ctx.at instanceof Array) {
                        ctx.at.push(tmp);
                      } else {
                        if (!ctx.at) {
                          ctx.end = j2 = M2;
                          tmp = u2;
                        }
                        (ctx.at || {})[ctx.s] = tmp;
                      }
                    }
                  }
                }
                ctx.a = u2;
                ctx.at = ctx.up.pop();
                break;
              case "[":
                if (u2 !== (tmp = ctx.s)) {
                  ctx.up.push(ctx.at);
                  ctx.at[tmp] = ctx.at = [];
                } else if (!ctx.at) {
                  ctx.up.push(ctx.at = []);
                }
                ctx.a = true;
                ctx.ai = i2;
                break;
              case "]":
                if (ctx.a) {
                  if (tmp = s2.slice(ctx.ai, i2 - 1)) {
                    if (u2 !== (tmp = value(tmp))) {
                      if (ctx.at instanceof Array) {
                        ctx.at.push(tmp);
                      } else {
                        ctx.at[ctx.s] = tmp;
                      }
                    }
                  }
                }
                ctx.a = u2;
                ctx.at = ctx.up.pop();
                break;
            }
          }
        }
        ctx.s = u2;
        ctx.i = i2;
        ctx.w = w2;
        if (ctx.end) {
          tmp = ctx.at;
          if (u2 === tmp) {
            try {
              tmp = JSON.parse(text3);
            } catch (e2) {
              return ctx.done(e2);
            }
          }
          ctx.done(u2, tmp);
        } else {
          sI(parse2);
        }
      }
    };
    function value(s2) {
      var n2 = parseFloat(s2);
      if (!isNaN(n2)) {
        return n2;
      }
      s2 = s2.trim();
      if ("true" == s2) {
        return true;
      }
      if ("false" == s2) {
        return false;
      }
      if ("null" == s2) {
        return null;
      }
    }
    yson2.stringifyAsync = function(data2, done, replacer2, space, ctx) {
      ctx = ctx || {};
      ctx.text = ctx.text || "";
      ctx.up = [ctx.at = { d: data2 }];
      ctx.done = done;
      ctx.i = 0;
      var j2 = 0;
      ify();
      function ify() {
        var at2 = ctx.at, data3 = at2.d, add3 = "", tmp;
        if (at2.i && at2.i - at2.j > 0) {
          add3 += ",";
        }
        if (u2 !== (tmp = at2.k)) {
          add3 += JSON.stringify(tmp) + ":";
        }
        switch (typeof data3) {
          case "boolean":
            add3 += "" + data3;
            break;
          case "string":
            add3 += JSON.stringify(data3);
            break;
          case "number":
            add3 += data3;
            break;
          case "object":
            if (!data3) {
              add3 += "null";
              break;
            }
            if (data3 instanceof Array) {
              add3 += "[";
              at2 = { i: -1, as: data3, up: at2, j: 0 };
              at2.l = data3.length;
              ctx.up.push(ctx.at = at2);
              break;
            }
            if ("function" != typeof (data3 || "").toJSON) {
              add3 += "{";
              at2 = { i: -1, ok: Object.keys(data3).sort(), as: data3, up: at2, j: 0 };
              at2.l = at2.ok.length;
              ctx.up.push(ctx.at = at2);
              break;
            }
            if (tmp = data3.toJSON()) {
              add3 += tmp;
              break;
            }
          case "function":
            if (at2.as instanceof Array) {
              add3 += "null";
              break;
            }
          default:
            add3 = "";
            at2.j++;
        }
        ctx.text += add3;
        while (1 + at2.i >= at2.l) {
          ctx.text += at2.ok ? "}" : "]";
          at2 = ctx.at = at2.up;
        }
        if (++at2.i < at2.l) {
          if (tmp = at2.ok) {
            at2.d = at2.as[at2.k = tmp[at2.i]];
          } else {
            at2.d = at2.as[at2.i];
          }
          if (++j2 < 9) {
            return ify();
          } else {
            j2 = 0;
          }
          sI(ify);
          return;
        }
        ctx.done(u2, ctx.text);
      }
    };
    if (typeof window != "" + u2) {
      window.YSON = yson2;
    }
    try {
      if ("object" != "" + u2) {
        module2.exports = yson2;
      }
    } catch (e2) {
    }
    if (typeof JSON != "" + u2) {
      JSON.parseAsync = yson2.parseAsync;
      JSON.stringifyAsync = yson2.stringifyAsync;
    }
  })();
})(yson);
(function() {
  function Radisk(opt) {
    opt = opt || {};
    opt.log = opt.log || console.log;
    opt.file = String(opt.file || "radata");
    var has2 = (Radisk.has || (Radisk.has = {}))[opt.file];
    if (has2) {
      return has2;
    }
    opt.max = opt.max || (opt.memory ? opt.memory * 999 * 999 : 3e8) * 0.3;
    opt.until = opt.until || opt.wait || 250;
    opt.batch = opt.batch || 10 * 1e3;
    opt.chunk = opt.chunk || 1024 * 1024 * 1;
    opt.code = opt.code || {};
    opt.code.from = opt.code.from || "!";
    opt.jsonify = true;
    function ename(t2) {
      return encodeURIComponent(t2).replace(/\*/g, "%2A");
    }
    function atomic(v2) {
      return u2 !== v2 && (!v2 || "object" != typeof v2);
    }
    var timediate = "" + u2 === typeof setImmediate ? setTimeout : setImmediate;
    var puff = setTimeout.turn || timediate, u2;
    var map2 = Radix.object;
    var ST = 0;
    if (!opt.store) {
      return opt.log("ERROR: Radisk needs `opt.store` interface with `{get: fn, put: fn (, list: fn)}`!");
    }
    if (!opt.store.put) {
      return opt.log("ERROR: Radisk needs `store.put` interface with `(file, data, cb)`!");
    }
    if (!opt.store.get) {
      return opt.log("ERROR: Radisk needs `store.get` interface with `(file, cb)`!");
    }
    if (!opt.store.list)
      ;
    var parse2 = JSON.parseAsync || function(t2, cb, r3) {
      var u3;
      try {
        cb(u3, JSON.parse(t2, r3));
      } catch (e2) {
        cb(e2);
      }
    };
    var r2 = function(key, data2, cb, tag, DBG) {
      if ("function" === typeof data2) {
        var o2 = cb || {};
        cb = data2;
        r2.read(key, cb, o2, DBG || tag);
        return;
      }
      r2.save(key, data2, cb, tag, DBG);
    };
    r2.save = function(key, data2, cb, tag, DBG) {
      var s2 = { key }, f2, q2;
      s2.find = function(file) {
        var tmp;
        s2.file = file || (file = opt.code.from);
        DBG && (DBG = DBG[file] = DBG[file] || {});
        DBG && (DBG.sf = DBG.sf || +new Date());
        if (tmp = r2.disk[file]) {
          s2.mix(u2, tmp);
          return;
        }
        r2.parse(file, s2.mix, u2, DBG);
      };
      s2.mix = function(err, disk) {
        DBG && (DBG.sml = +new Date());
        DBG && (DBG.sm = DBG.sm || +new Date());
        if (s2.err = err || s2.err) {
          cb(err);
          return;
        }
        var file = s2.file = (disk || "").file || s2.file, tmp;
        if (!disk && file !== opt.code.from) {
          r2.find.bad(file);
          r2.save(key, data2, cb, tag);
          return;
        }
        (disk = r2.disk[file] || (r2.disk[file] = disk || Radix())).file || (disk.file = file);
        if (opt.compare) {
          data2 = opt.compare(disk(key), data2, key, file);
          if (u2 === data2) {
            cb(err, -1);
            return;
          }
        }
        (s2.disk = disk)(key, data2);
        if (tag) {
          (tmp = (tmp = disk.tags || (disk.tags = {}))[tag] || (tmp[tag] = r2.tags[tag] || (r2.tags[tag] = {})))[file] || (tmp[file] = r2.one[tag] || (r2.one[tag] = cb));
          cb = null;
        }
        DBG && (DBG.st = DBG.st || +new Date());
        if (disk.Q) {
          cb && disk.Q.push(cb);
          return;
        }
        disk.Q = cb ? [cb] : [];
        disk.to = setTimeout(s2.write, opt.until);
      };
      s2.write = function() {
        DBG && (DBG.sto = DBG.sto || +new Date());
        var file = f2 = s2.file, disk = s2.disk;
        q2 = s2.q = disk.Q;
        s2.tags = disk.tags;
        delete disk.Q;
        delete r2.disk[file];
        delete disk.tags;
        r2.write(file, disk, s2.ack, u2, DBG);
      };
      s2.ack = function(err, ok) {
        DBG && (DBG.sa = DBG.sa || +new Date());
        DBG && (DBG.sal = q2.length);
        var ack, tmp;
        for (var id2 in r2.tags) {
          if (!r2.tags.hasOwnProperty(id2)) {
            continue;
          }
          var tag2 = r2.tags[id2];
          if ((tmp = r2.disk[f2]) && (tmp = tmp.tags) && tmp[tag2]) {
            continue;
          }
          ack = tag2[f2];
          delete tag2[f2];
          var ne2;
          for (var k2 in tag2) {
            if (tag2.hasOwnProperty(k2)) {
              ne2 = true;
              break;
            }
          }
          if (ne2) {
            continue;
          }
          delete r2.tags[tag2];
          ack && ack(err, ok);
        }
        !q2 && (q2 = "");
        var l2 = q2.length, i2 = 0;
        var S2 = +new Date();
        for (; i2 < l2; i2++) {
          (ack = q2[i2]) && ack(err, ok);
        }
        console.STAT && console.STAT(S2, +new Date() - S2, "rad acks", ename(s2.file));
        console.STAT && console.STAT(S2, q2.length, "rad acks #", ename(s2.file));
      };
      cb || (cb = function(err, ok) {
        if (!err) {
          return;
        }
      });
      r2.find(key, s2.find);
    };
    r2.disk = {};
    r2.one = {};
    r2.tags = {};
    var RWC = 0;
    r2.write = function(file, rad, cb, o2, DBG) {
      if (!rad) {
        cb("No radix!");
        return;
      }
      o2 = "object" == typeof o2 ? o2 : { force: o2 };
      var f2 = function Fractal() {
      }, a2, b2;
      f2.text = "";
      f2.file = file = rad.file || (rad.file = file);
      if (!file) {
        cb("What file?");
        return;
      }
      f2.write = function() {
        var text3 = rad.raw = f2.text;
        r2.disk[file = rad.file || f2.file || file] = rad;
        var S2 = +new Date();
        DBG && (DBG.wd = S2);
        r2.find.add(file, function add3(err) {
          DBG && (DBG.wa = +new Date());
          if (err) {
            cb(err);
            return;
          }
          opt.store.put(ename(file), text3, function safe(err2, ok) {
            DBG && (DBG.wp = +new Date());
            console.STAT && console.STAT(S2, ST = +new Date() - S2, "wrote disk", JSON.stringify(file), ++RWC, "total all writes.");
            cb(err2, ok || 1);
            if (!rad.Q) {
              delete r2.disk[file];
            }
          });
        });
      };
      f2.split = function() {
        var S2 = +new Date();
        DBG && (DBG.wf = S2);
        f2.text = "";
        if (!f2.count) {
          f2.count = 0;
          Radix.map(rad, function count2() {
            f2.count++;
          });
        }
        DBG && (DBG.wfc = f2.count);
        f2.limit = Math.ceil(f2.count / 2);
        var SC = f2.count;
        f2.count = 0;
        DBG && (DBG.wf1 = +new Date());
        f2.sub = Radix();
        Radix.map(rad, f2.slice, { reverse: 1 });
        DBG && (DBG.wf2 = +new Date());
        r2.write(f2.end, f2.sub, f2.both, o2);
        DBG && (DBG.wf3 = +new Date());
        f2.hub = Radix();
        Radix.map(rad, f2.stop);
        DBG && (DBG.wf4 = +new Date());
        r2.write(rad.file, f2.hub, f2.both, o2);
        DBG && (DBG.wf5 = +new Date());
        console.STAT && console.STAT(S2, +new Date() - S2, "rad split", ename(rad.file), SC);
        return true;
      };
      f2.slice = function(val, key) {
        f2.sub(f2.end = key, val);
        if (f2.limit <= ++f2.count) {
          return true;
        }
      };
      f2.stop = function(val, key) {
        if (key >= f2.end) {
          return true;
        }
        f2.hub(key, val);
      };
      f2.both = function(err, ok) {
        DBG && (DBG.wfd = +new Date());
        if (b2) {
          cb(err || b2);
          return;
        }
        if (a2) {
          cb(err, ok);
          return;
        }
        a2 = true;
        b2 = err;
      };
      f2.each = function(val, key, k2, pre2) {
        if (u2 !== val) {
          f2.count++;
        }
        if (opt.max <= (val || "").length) {
          return cb("Data too big!"), true;
        }
        var enc = Radisk.encode(pre2.length) + "#" + Radisk.encode(k2) + (u2 === val ? "" : ":" + Radisk.encode(val)) + "\n";
        if (opt.chunk < f2.text.length + enc.length && 1 < f2.count && !o2.force) {
          return f2.split();
        }
        f2.text += enc;
      };
      if (opt.jsonify) {
        r2.write.jsonify(f2, rad, cb, o2, DBG);
        return;
      }
      if (!Radix.map(rad, f2.each, true)) {
        f2.write();
      }
    };
    r2.write.jsonify = function(f2, rad, cb, o2, DBG) {
      var raw;
      var S2 = +new Date();
      DBG && (DBG.w = S2);
      try {
        raw = JSON.stringify(rad.$);
      } catch (e2) {
        cb("Cannot radisk!");
        return;
      }
      DBG && (DBG.ws = +new Date());
      console.STAT && console.STAT(S2, +new Date() - S2, "rad stringified JSON");
      if (opt.chunk < raw.length && !o2.force) {
        var c2 = 0;
        Radix.map(rad, function() {
          if (c2++) {
            return true;
          }
        });
        if (c2 > 1) {
          return f2.split();
        }
      }
      f2.text = raw;
      f2.write();
    };
    r2.range = function(tree, o2) {
      if (!tree || !o2) {
        return;
      }
      if (u2 === o2.start && u2 === o2.end) {
        return tree;
      }
      if (atomic(tree)) {
        return tree;
      }
      var sub2 = Radix();
      Radix.map(tree, function(v2, k2) {
        sub2(k2, v2);
      }, o2);
      return sub2("");
    };
    (function() {
      r2.read = function(key, cb, o2, DBG) {
        o2 = o2 || {};
        var g2 = { key };
        g2.find = function(file) {
          var tmp;
          g2.file = file || (file = opt.code.from);
          DBG && (DBG = DBG[file] = DBG[file] || {});
          DBG && (DBG.rf = DBG.rf || +new Date());
          if (tmp = r2.disk[g2.file = file]) {
            g2.check(u2, tmp);
            return;
          }
          r2.parse(file, g2.check, u2, DBG);
        };
        g2.get = function(err, disk, info) {
          DBG && (DBG.rgl = +new Date());
          DBG && (DBG.rg = DBG.rg || +new Date());
          if (g2.err = err || g2.err) {
            cb(err);
            return;
          }
          var file = g2.file = (disk || "").file || g2.file;
          if (!disk && file !== opt.code.from) {
            r2.find.bad(file);
            r2.read(key, cb, o2);
            return;
          }
          disk = r2.disk[file] || (r2.disk[file] = disk);
          if (!disk) {
            cb(file === opt.code.from ? u2 : "No file!");
            return;
          }
          disk.file || (disk.file = file);
          var data2 = r2.range(disk(key), o2);
          DBG && (DBG.rr = +new Date());
          o2.unit = disk.unit;
          o2.chunks = (o2.chunks || 0) + 1;
          o2.parsed = (o2.parsed || 0) + ((info || "").parsed || o2.chunks * opt.chunk);
          o2.more = 1;
          o2.next = u2;
          Radix.map(r2.list, function next2(v2, f2) {
            if (!v2 || file === f2) {
              return;
            }
            o2.next = f2;
            return 1;
          }, o2.reverse ? { reverse: 1, end: file } : { start: file });
          DBG && (DBG.rl = +new Date());
          if (!o2.next) {
            o2.more = 0;
          }
          if (o2.next) {
            if (!o2.reverse && (key < o2.next && 0 != o2.next.indexOf(key) || u2 !== o2.end && (o2.end || "\uFFFF") < o2.next)) {
              o2.more = 0;
            }
            if (o2.reverse && (key > o2.next && 0 != key.indexOf(o2.next) || u2 !== o2.start && (o2.start || "") > o2.next && file <= o2.start)) {
              o2.more = 0;
            }
          }
          if (!o2.more) {
            cb(g2.err, data2, o2);
            return;
          }
          if (data2) {
            cb(g2.err, data2, o2);
          }
          if (o2.parsed >= o2.limit) {
            return;
          }
          var S2 = +new Date();
          DBG && (DBG.rm = S2);
          var next = o2.next;
          timediate(function() {
            console.STAT && console.STAT(S2, +new Date() - S2, "rad more");
            r2.parse(next, g2.check);
          }, 0);
        };
        g2.check = function(err, disk, info) {
          g2.get(err, disk, info);
          if (!disk || disk.check) {
            return;
          }
          disk.check = 1;
          var S2 = +new Date();
          (info || (info = {})).file || (info.file = g2.file);
          Radix.map(disk, function(val, key2) {
            r2.find(key2, function(file) {
              if ((file || (file = opt.code.from)) === info.file) {
                return;
              }
              var id2 = ("" + Math.random()).slice(-3);
              puff(function() {
                r2.save(key2, val, function ack(err2, ok) {
                  if (err2) {
                    r2.save(key2, val, ack);
                    return;
                  }
                  console.STAT && console.STAT("MISLOCATED DATA CORRECTED", id2, ename(key2), ename(info.file), ename(file));
                });
              }, 0);
            });
          });
          console.STAT && console.STAT(S2, +new Date() - S2, "rad check");
        };
        r2.find(key || (o2.reverse ? o2.end || "" : o2.start || ""), g2.find);
      };
    })();
    (function() {
      var RPC = 0;
      var Q2 = {}, s2 = String.fromCharCode(31);
      r2.parse = function(file, cb, raw, DBG) {
        var q2;
        if (!file) {
          return cb();
        }
        if (q2 = Q2[file]) {
          q2.push(cb);
          return;
        }
        q2 = Q2[file] = [cb];
        var p2 = function Parse() {
        }, info = { file };
        (p2.disk = Radix()).file = file;
        p2.read = function(err, data2) {
          DBG && (DBG.rpg = +new Date());
          console.STAT && console.STAT(S2, +new Date() - S2, "read disk", JSON.stringify(file), ++RPC, "total all parses.");
          if ((p2.err = err) || (p2.not = !data2)) {
            delete Q2[file];
            p2.map(q2, p2.ack);
            return;
          }
          if ("string" !== typeof data2) {
            try {
              if (opt.max <= data2.length) {
                p2.err = "Chunk too big!";
              } else {
                data2 = data2.toString();
              }
            } catch (e2) {
              p2.err = e2;
            }
            if (p2.err) {
              delete Q2[file];
              p2.map(q2, p2.ack);
              return;
            }
          }
          info.parsed = data2.length;
          DBG && (DBG.rpl = info.parsed);
          DBG && (DBG.rpa = q2.length);
          S2 = +new Date();
          if (!(opt.jsonify || "{" === data2[0])) {
            p2.radec(err, data2);
            return;
          }
          parse2(data2, function(err2, tree) {
            if (!err2) {
              delete Q2[file];
              p2.disk.$ = tree;
              console.STAT && (ST = +new Date() - S2) > 9 && console.STAT(S2, ST, "rad parsed JSON");
              DBG && (DBG.rpd = +new Date());
              p2.map(q2, p2.ack);
              return;
            }
            if ("{" === data2[0]) {
              delete Q2[file];
              p2.err = "JSON error!";
              p2.map(q2, p2.ack);
              return;
            }
            p2.radec(err2, data2);
          });
        };
        p2.map = function() {
          if (!q2 || !q2.length) {
            return;
          }
          var S3 = +new Date();
          var err = p2.err, data2 = p2.not ? u2 : p2.disk;
          var i2 = 0, ack;
          while (i2 < 9 && (ack = q2[i2++])) {
            ack(err, data2, info);
          }
          console.STAT && console.STAT(S3, +new Date() - S3, "rad packs", ename(file));
          console.STAT && console.STAT(S3, i2, "rad packs #", ename(file));
          if (!(q2 = q2.slice(i2)).length) {
            return;
          }
          puff(p2.map, 0);
        };
        p2.ack = function(cb2) {
          if (!cb2) {
            return;
          }
          if (p2.err || p2.not) {
            cb2(p2.err, u2, info);
            return;
          }
          cb2(u2, p2.disk, info);
        };
        p2.radec = function(err, data2) {
          delete Q2[file];
          S2 = +new Date();
          var tmp = p2.split(data2), pre2 = [], i2, k2, v2;
          if (!tmp || 0 !== tmp[1]) {
            p2.err = "File '" + file + "' does not have root radix! ";
            p2.map(q2, p2.ack);
            return;
          }
          while (tmp) {
            k2 = v2 = u2;
            i2 = tmp[1];
            tmp = p2.split(tmp[2]) || "";
            if ("#" == tmp[0]) {
              k2 = tmp[1];
              pre2 = pre2.slice(0, i2);
              if (i2 <= pre2.length) {
                pre2.push(k2);
              }
            }
            tmp = p2.split(tmp[2]) || "";
            if ("\n" == tmp[0]) {
              continue;
            }
            if ("=" == tmp[0] || ":" == tmp[0]) {
              v2 = tmp[1];
            }
            if (u2 !== k2 && u2 !== v2) {
              p2.disk(pre2.join(""), v2);
            }
            tmp = p2.split(tmp[2]);
          }
          console.STAT && console.STAT(S2, +new Date() - S2, "parsed RAD");
          p2.map(q2, p2.ack);
        };
        p2.split = function(t2) {
          if (!t2) {
            return;
          }
          var l2 = [], o2 = {}, i2 = -1, a2 = "";
          i2 = t2.indexOf(s2);
          if (!t2[i2]) {
            return;
          }
          a2 = t2.slice(0, i2);
          l2[0] = a2;
          l2[1] = Radisk.decode(t2.slice(i2), o2);
          l2[2] = t2.slice(i2 + o2.i);
          return l2;
        };
        if (r2.disk) {
          raw || (raw = (r2.disk[file] || "").raw);
        }
        var S2 = +new Date();
        DBG && (DBG.rp = S2);
        if (raw) {
          return puff(function() {
            p2.read(u2, raw);
          }, 0);
        }
        opt.store.get(ename(file), p2.read);
      };
    })();
    (function() {
      var dir, f2 = String.fromCharCode(28), Q2;
      r2.find = function(key, cb) {
        if (!dir) {
          if (Q2) {
            Q2.push([key, cb]);
            return;
          }
          Q2 = [[key, cb]];
          r2.parse(f2, init4);
          return;
        }
        Radix.map(r2.list = dir, function(val, key2) {
          if (!val) {
            return;
          }
          return cb(key2) || true;
        }, { reverse: 1, end: key }) || cb(opt.code.from);
      };
      r2.find.add = function(file, cb) {
        var has3 = dir(file);
        if (has3 || file === f2) {
          cb(u2, 1);
          return;
        }
        dir(file, 1);
        cb.found = (cb.found || 0) + 1;
        r2.write(f2, dir, function(err, ok) {
          if (err) {
            cb(err);
            return;
          }
          cb.found = (cb.found || 0) - 1;
          if (0 !== cb.found) {
            return;
          }
          cb(u2, 1);
        }, true);
      };
      r2.find.bad = function(file, cb) {
        dir(file, 0);
        r2.write(f2, dir, cb || noop2);
      };
      function init4(err, disk) {
        if (err) {
          opt.log("list", err);
          setTimeout(function() {
            r2.parse(f2, init4);
          }, 1e3);
          return;
        }
        if (disk) {
          drain(disk);
          return;
        }
        dir = dir || disk || Radix();
        if (!opt.store.list) {
          drain(dir);
          return;
        }
        opt.store.list(function(file) {
          if (!file) {
            drain(dir);
            return;
          }
          r2.find.add(file, noop2);
        });
      }
      function drain(rad, tmp) {
        dir = dir || rad;
        dir.file = f2;
        tmp = Q2;
        Q2 = null;
        map2(tmp, function(arg) {
          r2.find(arg[0], arg[1]);
        });
      }
    })();
    try {
      !Gun2.window && require("./radmigtmp")(r2);
    } catch (e2) {
    }
    var noop2 = function() {
    }, u2;
    Radisk.has[opt.file] = r2;
    return r2;
  }
  (function() {
    var _2 = String.fromCharCode(31);
    Radisk.encode = function(d2, o2, s2) {
      s2 = s2 || _2;
      var t2 = s2, tmp;
      if (typeof d2 == "string") {
        var i2 = d2.indexOf(s2);
        while (i2 != -1) {
          t2 += s2;
          i2 = d2.indexOf(s2, i2 + 1);
        }
        return t2 + '"' + d2 + s2;
      } else if (d2 && d2["#"] && 1 == Object.keys(d2).length) {
        return t2 + "#" + tmp + t2;
      } else if ("number" == typeof d2) {
        return t2 + "+" + (d2 || 0) + t2;
      } else if (null === d2) {
        return t2 + " " + t2;
      } else if (true === d2) {
        return t2 + "+" + t2;
      } else if (false === d2) {
        return t2 + "-" + t2;
      }
    };
    Radisk.decode = function(t2, o2, s2) {
      s2 = s2 || _2;
      var d2 = "", i2 = -1, n2 = 0, c2, p2;
      if (s2 !== t2[0]) {
        return;
      }
      while (s2 === t2[++i2]) {
        ++n2;
      }
      p2 = t2[c2 = n2] || true;
      while (--n2 >= 0) {
        i2 = t2.indexOf(s2, i2 + 1);
      }
      if (i2 == -1) {
        i2 = t2.length;
      }
      d2 = t2.slice(c2 + 1, i2);
      if (o2) {
        o2.i = i2 + 1;
      }
      if ('"' === p2) {
        return d2;
      } else if ("#" === p2) {
        return { "#": d2 };
      } else if ("+" === p2) {
        if (0 === d2.length) {
          return true;
        }
        return parseFloat(d2);
      } else if (" " === p2) {
        return null;
      } else if ("-" === p2) {
        return false;
      }
    };
  })();
  if (typeof window !== "undefined") {
    var Gun2 = window.Gun;
    var Radix = window.Radix;
    window.Radisk = Radisk;
  } else {
    var Gun2 = gun.exports;
    var Radix = radix.exports;
    try {
      radisk.exports = Radisk;
    } catch (e2) {
    }
  }
  Radisk.Radix = Radix;
})();
var Gun$1 = typeof window !== "undefined" ? window.Gun : gun.exports;
Gun$1.on("create", function(root2) {
  if (Gun$1.TESTING) {
    root2.opt.file = "radatatest";
  }
  this.to.next(root2);
  var opt = root2.opt, u2;
  if (false === opt.rad || false === opt.radisk) {
    return;
  }
  if (u2 + "" != typeof process && "false" === "" + (process.env || "").RAD) {
    return;
  }
  var Radisk = Gun$1.window && Gun$1.window.Radisk || radisk.exports;
  var Radix = Radisk.Radix;
  var dare = Radisk(opt), esc = String.fromCharCode(27);
  var ST = 0;
  root2.on("put", function(msg) {
    this.to.next(msg);
    if ((msg._ || "").rad) {
      return;
    }
    var id2 = msg["#"], put = msg.put, soul = put["#"], key = put["."], val = put[":"], state = put[">"];
    var DBG = (msg._ || "").DBG;
    DBG && (DBG.sp = DBG.sp || +new Date());
    var S2 = (msg._ || "").RPS || ((msg._ || "").RPS = +new Date());
    dare(soul + esc + key, { ":": val, ">": state }, function(err, ok) {
      DBG && (DBG.spd = DBG.spd || +new Date());
      console.STAT && console.STAT(S2, +new Date() - S2, "put");
      if (err) {
        root2.on("in", { "@": id2, err, DBG });
        return;
      }
      root2.on("in", { "@": id2, ok, DBG });
    }, false, DBG && (DBG.r = DBG.r || {}));
    DBG && (DBG.sps = DBG.sps || +new Date());
  });
  root2.on("get", function(msg) {
    this.to.next(msg);
    var ctx = msg._ || "", DBG = ctx.DBG = msg.DBG;
    DBG && (DBG.sg = +new Date());
    var id2 = msg["#"], get2 = msg.get, soul = msg.get["#"], has2 = msg.get["."] || "", o2 = {}, graph, key, tmp, force;
    if ("string" == typeof soul) {
      key = soul;
    } else if (soul) {
      if (u2 !== (tmp = soul["*"])) {
        o2.limit = force = 1;
      }
      if (u2 !== soul[">"]) {
        o2.start = soul[">"];
      }
      if (u2 !== soul["<"]) {
        o2.end = soul["<"];
      }
      key = force ? "" + tmp : tmp || soul["="];
      force = null;
    }
    if (key && !o2.limit) {
      if ("string" == typeof has2) {
        key = key + esc + (o2.atom = has2);
      } else if (has2) {
        if (u2 !== has2[">"]) {
          o2.start = has2[">"];
          o2.limit = 1;
        }
        if (u2 !== has2["<"]) {
          o2.end = has2["<"];
          o2.limit = 1;
        }
        if (u2 !== (tmp = has2["*"])) {
          o2.limit = force = 1;
        }
        if (key) {
          key = key + esc + (force ? "" + (tmp || "") : tmp || (o2.atom = has2["="] || ""));
        }
      }
    }
    if ((tmp = get2["%"]) || o2.limit) {
      o2.limit = tmp <= (o2.pack || 1e3 * 100) ? tmp : 1;
    }
    if (has2["-"] || (soul || {})["-"] || get2["-"]) {
      o2.reverse = true;
    }
    if ((tmp = (root2.next || "")[soul]) && tmp.put) {
      if (o2.atom) {
        tmp = (tmp.next || "")[o2.atom];
        if (tmp && tmp.rad) {
          return;
        }
      } else if (tmp && tmp.rad) {
        return;
      }
    }
    var now2 = Gun$1.state();
    var S2 = +new Date(), C2 = 0;
    DBG && (DBG.sgm = S2);
    dare(key || "", function(err, data2, info) {
      DBG && (DBG.sgr = +new Date());
      DBG && (DBG.sgi = info);
      try {
        opt.store.stats.get.time[statg % 50] = +new Date() - S2;
        ++statg;
        opt.store.stats.get.count++;
        if (err) {
          opt.store.stats.get.err = err;
        }
      } catch (e2) {
      }
      console.STAT && console.STAT(S2, +new Date() - S2, "got", JSON.stringify(key));
      S2 = +new Date();
      info = info || "";
      var va2, ve;
      if (info.unit && data2 && u2 !== (va2 = data2[":"]) && u2 !== (ve = data2[">"])) {
        var tmp2 = key.split(esc), so = tmp2[0], ha2 = tmp2[1];
        (graph = graph || {})[so] = Gun$1.state.ify(graph[so], ha2, ve, va2, so);
        root2.$.get(so).get(ha2)._.rad = now2;
      } else if (data2) {
        if (typeof data2 !== "string") {
          if (o2.atom) {
            data2 = u2;
          } else {
            Radix.map(data2, each, o2);
          }
        }
        if (!graph && data2) {
          each(data2, "");
        }
        if (!o2.atom && !has2 & "string" == typeof soul && !o2.limit && !o2.more) {
          root2.$.get(soul)._.rad = now2;
        }
      }
      DBG && (DBG.sgp = +new Date());
      if (console.STAT && (ST = +new Date() - S2) > 9) {
        console.STAT(S2, ST, "got prep time");
        console.STAT(S2, C2, "got prep #");
      }
      C2 = 0;
      S2 = +new Date();
      var faith = function() {
      };
      faith.faith = true;
      faith.rad = get2;
      root2.on("in", { "@": id2, put: graph, "%": info.more ? 1 : u2, err: err ? err : u2, _: faith, DBG });
      console.STAT && (ST = +new Date() - S2) > 9 && console.STAT(S2, ST, "got emit", Object.keys(graph || {}).length);
      graph = u2;
    }, o2, DBG && (DBG.r = DBG.r || {}));
    DBG && (DBG.sgd = +new Date());
    console.STAT && (ST = +new Date() - S2) > 9 && console.STAT(S2, ST, "get call");
    function each(val, has3, a2, b2) {
      C2++;
      if (!val) {
        return;
      }
      has3 = (key + has3).split(esc);
      var soul2 = has3.slice(0, 1)[0];
      has3 = has3.slice(-1)[0];
      if (o2.limit && o2.limit <= o2.count) {
        return true;
      }
      var va2, ve, so = soul2, ha2 = has3;
      if ("string" != typeof val) {
        va2 = val[":"];
        ve = val[">"];
        (graph = graph || {})[so] = Gun$1.state.ify(graph[so], ha2, ve, va2, so);
        o2.count = (o2.count || 0) + ((va2 || "").length || 9);
        return;
      }
      o2.count = (o2.count || 0) + val.length;
      var tmp2 = val.lastIndexOf(">");
      var state = Radisk.decode(val.slice(tmp2 + 1), null, esc);
      val = Radisk.decode(val.slice(0, tmp2), null, esc);
      (graph = graph || {})[soul2] = Gun$1.state.ify(graph[soul2], has3, state, val, soul2);
    }
  });
  Gun$1.valid;
  (opt.store || {}).stats = { get: { time: {}, count: 0 }, put: { time: {}, count: 0 } };
  var statg = 0;
});
var rindexed = { exports: {} };
(function() {
  function Store(opt) {
    opt = opt || {};
    opt.file = String(opt.file || "radata");
    var store = Store[opt.file], db = null, u2;
    if (store) {
      console.log("Warning: reusing same IndexedDB store and options as 1st.");
      return Store[opt.file];
    }
    store = Store[opt.file] = function() {
    };
    try {
      opt.indexedDB = opt.indexedDB || Store.indexedDB || indexedDB;
    } catch (e2) {
    }
    try {
      if (!opt.indexedDB || "file:" == location.protocol) {
        var s2 = store.d || (store.d = {});
        store.put = function(f2, d2, cb) {
          s2[f2] = d2;
          setTimeout(function() {
            cb(null, 1);
          }, 250);
        };
        store.get = function(f2, cb) {
          setTimeout(function() {
            cb(null, s2[f2] || u2);
          }, 5);
        };
        console.log("Warning: No indexedDB exists to persist data to!");
        return store;
      }
    } catch (e2) {
    }
    store.start = function() {
      var o2 = indexedDB.open(opt.file, 1);
      o2.onupgradeneeded = function(eve) {
        eve.target.result.createObjectStore(opt.file);
      };
      o2.onsuccess = function() {
        db = o2.result;
      };
      o2.onerror = function(eve) {
        console.log(eve || 1);
      };
    };
    store.start();
    store.put = function(key, data2, cb) {
      if (!db) {
        setTimeout(function() {
          store.put(key, data2, cb);
        }, 1);
        return;
      }
      var tx = db.transaction([opt.file], "readwrite");
      var obj = tx.objectStore(opt.file);
      var req = obj.put(data2, "" + key);
      req.onsuccess = obj.onsuccess = tx.onsuccess = function() {
        cb(null, 1);
      };
      req.onabort = obj.onabort = tx.onabort = function(eve) {
        cb(eve || "put.tx.abort");
      };
      req.onerror = obj.onerror = tx.onerror = function(eve) {
        cb(eve || "put.tx.error");
      };
    };
    store.get = function(key, cb) {
      if (!db) {
        setTimeout(function() {
          store.get(key, cb);
        }, 9);
        return;
      }
      var tx = db.transaction([opt.file], "readonly");
      var obj = tx.objectStore(opt.file);
      var req = obj.get("" + key);
      req.onsuccess = function() {
        cb(null, req.result);
      };
      req.onabort = function(eve) {
        cb(eve || 4);
      };
      req.onerror = function(eve) {
        cb(eve || 5);
      };
    };
    setInterval(function() {
      db && db.close();
      db = null;
      store.start();
    }, 1e3 * 15);
    return store;
  }
  if (typeof window !== "undefined") {
    (Store.window = window).RindexedDB = Store;
    Store.indexedDB = window.indexedDB;
  } else {
    try {
      rindexed.exports = Store;
    } catch (e2) {
    }
  }
  try {
    var Gun2 = Store.window.Gun || require("../gun");
    Gun2.on("create", function(root2) {
      this.to.next(root2);
      root2.opt.store = root2.opt.store || Store(root2.opt);
    });
  } catch (e2) {
  }
})();
(function() {
  var Gun2 = typeof window !== "undefined" ? window.Gun : gun.exports;
  Gun2.on("opt", function(root2) {
    this.to.next(root2);
    var opt = root2.opt;
    if (root2.once) {
      return;
    }
    if (!Gun2.Mesh) {
      return;
    }
    if (false === opt.RTCPeerConnection) {
      return;
    }
    var env;
    if (typeof window !== "undefined") {
      env = window;
    }
    if (typeof commonjsGlobal !== "undefined") {
      env = commonjsGlobal;
    }
    env = env || {};
    var rtcpc = opt.RTCPeerConnection || env.RTCPeerConnection || env.webkitRTCPeerConnection || env.mozRTCPeerConnection;
    var rtcsd = opt.RTCSessionDescription || env.RTCSessionDescription || env.webkitRTCSessionDescription || env.mozRTCSessionDescription;
    var rtcic = opt.RTCIceCandidate || env.RTCIceCandidate || env.webkitRTCIceCandidate || env.mozRTCIceCandidate;
    if (!rtcpc || !rtcsd || !rtcic) {
      return;
    }
    opt.RTCPeerConnection = rtcpc;
    opt.RTCSessionDescription = rtcsd;
    opt.RTCIceCandidate = rtcic;
    opt.rtc = opt.rtc || { "iceServers": [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun.sipgate.net:3478" }
    ] };
    opt.rtc.dataChannel = opt.rtc.dataChannel || { ordered: false, maxRetransmits: 2 };
    opt.rtc.sdp = opt.rtc.sdp || { mandatory: { OfferToReceiveAudio: false, OfferToReceiveVideo: false } };
    opt.announce = function(to2) {
      root2.on("out", { rtc: { id: opt.pid, to: to2 } });
    };
    var mesh = opt.mesh = opt.mesh || Gun2.Mesh(root2);
    root2.on("create", function(at2) {
      this.to.next(at2);
      setTimeout(opt.announce, 1);
    });
    root2.on("in", function(msg) {
      if (msg.rtc) {
        open2(msg);
      }
      this.to.next(msg);
    });
    function open2(msg) {
      var rtc = msg.rtc, peer, tmp;
      if (!rtc || !rtc.id) {
        return;
      }
      delete opt.announce[rtc.id];
      if (tmp = rtc.answer) {
        if (!(peer = opt.peers[rtc.id] || open2[rtc.id]) || peer.remoteSet) {
          return;
        }
        tmp.sdp = tmp.sdp.replace(/\\r\\n/g, "\r\n");
        return peer.setRemoteDescription(peer.remoteSet = new opt.RTCSessionDescription(tmp));
      }
      if (tmp = rtc.candidate) {
        peer = opt.peers[rtc.id] || open2[rtc.id] || open2({ rtc: { id: rtc.id } });
        return peer.addIceCandidate(new opt.RTCIceCandidate(tmp));
      }
      if (open2[rtc.id]) {
        return;
      }
      (peer = new opt.RTCPeerConnection(opt.rtc)).id = rtc.id;
      var wire = peer.wire = peer.createDataChannel("dc", opt.rtc.dataChannel);
      open2[rtc.id] = peer;
      wire.onclose = function() {
        delete open2[rtc.id];
        mesh.bye(peer);
      };
      wire.onerror = function(err) {
      };
      wire.onopen = function(e2) {
        mesh.hi(peer);
      };
      wire.onmessage = function(msg2) {
        if (!msg2) {
          return;
        }
        mesh.hear(msg2.data || msg2, peer);
      };
      peer.onicecandidate = function(e2) {
        if (!e2.candidate) {
          return;
        }
        root2.on("out", { "@": msg["#"], rtc: { candidate: e2.candidate, id: opt.pid } });
      };
      peer.ondatachannel = function(e2) {
        var rc = e2.channel;
        rc.onmessage = wire.onmessage;
        rc.onopen = wire.onopen;
        rc.onclose = wire.onclose;
      };
      if (tmp = rtc.offer) {
        rtc.offer.sdp = rtc.offer.sdp.replace(/\\r\\n/g, "\r\n");
        peer.setRemoteDescription(new opt.RTCSessionDescription(tmp));
        peer.createAnswer(function(answer) {
          peer.setLocalDescription(answer);
          root2.on("out", { "@": msg["#"], rtc: { answer, id: opt.pid } });
        }, function() {
        }, opt.rtc.sdp);
        return;
      }
      peer.createOffer(function(offer) {
        peer.setLocalDescription(offer);
        root2.on("out", { "@": msg["#"], rtc: { offer, id: opt.pid } });
      }, function() {
      }, opt.rtc.sdp);
      return peer;
    }
  });
})();
(function() {
  var Gun2 = typeof window !== "undefined" ? window.Gun : gun.exports;
  Gun2.on("create", function(root2) {
    return;
  });
})();
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code$1.length; i$2 < len; ++i$2) {
  lookup[i$2] = code$1[i$2];
  revLookup[code$1.charCodeAt(i$2)] = i$2;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num2) {
  return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
}
function encodeChunk(uint8, start2, end) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto2 = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto2, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf2 = value.valueOf && value.valueOf();
    if (valueOf2 != null && valueOf2 !== value) {
      return Buffer2.from(valueOf2, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from2(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string2, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string2, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array2) {
    const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf = createBuffer(length);
    for (let i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array2);
    } else if (length === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list3, length) {
    if (!Array.isArray(list3)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list3.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list3.length; ++i2) {
        length += list3[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i2 = 0; i2 < list3.length; ++i2) {
      let buf = list3[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start2, end) {
    let loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start2 >>>= 0;
    if (end <= start2) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end);
        case "ascii":
          return asciiSlice(this, start2, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end);
        case "base64":
          return base64Slice(this, start2, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap2(b2, n2, m2) {
    const i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap2(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap322() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap2(this, i2, i2 + 3);
      swap2(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap2(this, i2, i2 + 7);
      swap2(this, i2 + 1, i2 + 6);
      swap2(this, i2 + 2, i2 + 5);
      swap2(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target2, start2, end, thisStart, thisEnd) {
    if (isInstance(target2, Uint8Array)) {
      target2 = Buffer2.from(target2, target2.offset, target2.byteLength);
    }
    if (!Buffer2.isBuffer(target2)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target2);
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end === void 0) {
      end = target2 ? target2.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end > target2.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end) {
      return 1;
    }
    start2 >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target2)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start2;
    const len2 = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target2.slice(start2, end);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read2(arr, i2 + j2) !== read2(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset2, length) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string2.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset2 + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset2, length) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset2), buf, offset2, length);
  }
  function asciiWrite(buf, string2, offset2, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset2, length);
  }
  function base64Write(buf, string2, offset2, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset2, length);
  }
  function ucs2Write(buf, string2, offset2, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
  }
  Buffer2.prototype.write = function write(string2, offset2, length, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length = this.length;
      offset2 = 0;
    } else if (length === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset2;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset2, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset2, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset2, length);
        case "base64":
          return base64Write(this, string2, offset2, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset2, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end) {
    if (start2 === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start2, end));
    }
  }
  function utf8Slice(buf, start2, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start2;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start2, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start2; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start2; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end) {
    const len2 = buf.length;
    if (!start2 || start2 < 0)
      start2 = 0;
    if (!end || end < 0 || end > len2)
      end = len2;
    let out = "";
    for (let i2 = start2; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end) {
    const bytes = buf.slice(start2, end);
    let res = "";
    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start2, end) {
    const len2 = this.length;
    start2 = ~~start2;
    end = end === void 0 ? len2 : ~~end;
    if (start2 < 0) {
      start2 += len2;
      if (start2 < 0)
        start2 = 0;
    } else if (start2 > len2) {
      start2 = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0)
        end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start2)
      end = start2;
    const newBuf = this.subarray(start2, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length) {
    if (offset2 % 1 !== 0 || offset2 < 0)
      throw new RangeError("offset is not uint");
    if (offset2 + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset2 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val = this[offset2 + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset2 + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128))
      return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset2 + i2] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset2 + i2] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi;
    hi = hi >> 8;
    buf[offset2 + 2] = hi;
    hi = hi >> 8;
    buf[offset2 + 1] = hi;
    hi = hi >> 8;
    buf[offset2] = hi;
    return offset2 + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub2 = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset2 + i2 - 1] !== 0) {
        sub2 = 1;
      }
      this[offset2 + i2] = (value / mul >> 0) - sub2 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub2 = 0;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset2 + i2 + 1] !== 0) {
        sub2 = 1;
      }
      this[offset2 + i2] = (value / mul >> 0) - sub2 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max2, min2) {
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset2 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target2, targetStart, start2, end) {
    if (!Buffer2.isBuffer(target2))
      throw new TypeError("argument should be a Buffer");
    if (!start2)
      start2 = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target2.length)
      targetStart = target2.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start2)
      end = start2;
    if (end === start2)
      return 0;
    if (target2.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target2.length - targetStart < end - start2) {
      end = target2.length - targetStart + start2;
    }
    const len2 = end - start2;
    if (this === target2 && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end);
    } else {
      Uint8Array.prototype.set.call(target2, this.subarray(start2, end), targetStart);
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start2, end, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code3 = val.charCodeAt(0);
        if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
          val = code3;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start2; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start2; ++i2) {
        this[i2 + start2] = bytes[i2 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) {
      return `${name} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E2("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E2("ERR_OUT_OF_RANGE", function(str, range2, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range2}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start2 = val[0] === "-" ? 1 : 0;
    for (; i2 >= start2 + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset2, byteLength3) {
    if (value > max2 || value < min2) {
      const n2 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      if (byteLength3 > 3) {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range2 = `>= ${min2}${n2} and <= ${max2}${n2}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length = string2.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset2, length) {
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset2 >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset2] = src[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table3 = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table3[i16 + j2] = alphabet[i2] + alphabet[j2];
      }
    }
    return table3;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
var sea = { exports: {} };
(function(module2) {
  (function() {
    function USE(arg, req) {
      return req ? commonjsRequire(arg) : arg.slice ? USE[R2(arg)] : function(mod2, path2) {
        arg(mod2 = { exports: {} });
        USE[R2(path2)] = mod2.exports;
      };
      function R2(p2) {
        return p2.split("/").slice(-1).toString().replace(".js", "");
      }
    }
    {
      var MODULE = module2;
    }
    USE(function(module3) {
      if (typeof window !== "undefined") {
        module3.window = window;
      }
      var tmp = module3.window || module3, u2;
      var SEA2 = tmp.SEA || {};
      if (SEA2.window = module3.window) {
        SEA2.window.SEA = SEA2;
      }
      try {
        if (u2 + "" !== typeof MODULE) {
          MODULE.exports = SEA2;
        }
      } catch (e2) {
      }
      module3.exports = SEA2;
    })(USE, "./root");
    USE(function(module3) {
      var SEA2 = USE("./root");
      try {
        if (SEA2.window) {
          if (location.protocol.indexOf("s") < 0 && location.host.indexOf("localhost") < 0 && !/^127\.\d+\.\d+\.\d+$/.test(location.hostname) && location.protocol.indexOf("file:") < 0) {
            console.warn("HTTPS needed for WebCrypto in SEA, redirecting...");
            location.protocol = "https:";
          }
        }
      } catch (e2) {
      }
    })(USE, "./https");
    USE(function(module3) {
      var u2;
      if (u2 + "" == typeof btoa) {
        if (u2 + "" == typeof Buffer) {
          try {
            commonjsGlobal.Buffer = USE("buffer", 1).Buffer;
          } catch (e2) {
            console.log("Please `npm install buffer` or add it to your package.json !");
          }
        }
        commonjsGlobal.btoa = function(data2) {
          return Buffer.from(data2, "binary").toString("base64");
        };
        commonjsGlobal.atob = function(data2) {
          return Buffer.from(data2, "base64").toString("binary");
        };
      }
    })(USE, "./base64");
    USE(function(module3) {
      USE("./base64");
      function SeaArray() {
      }
      Object.assign(SeaArray, { from: Array.from });
      SeaArray.prototype = Object.create(Array.prototype);
      SeaArray.prototype.toString = function(enc, start2, end) {
        enc = enc || "utf8";
        start2 = start2 || 0;
        const length = this.length;
        if (enc === "hex") {
          const buf = new Uint8Array(this);
          return [...Array((end && end + 1 || length) - start2).keys()].map((i2) => buf[i2 + start2].toString(16).padStart(2, "0")).join("");
        }
        if (enc === "utf8") {
          return Array.from({ length: (end || length) - start2 }, (_2, i2) => String.fromCharCode(this[i2 + start2])).join("");
        }
        if (enc === "base64") {
          return btoa(this);
        }
      };
      module3.exports = SeaArray;
    })(USE, "./array");
    USE(function(module3) {
      USE("./base64");
      var SeaArray = USE("./array");
      function SafeBuffer(...props) {
        console.warn("new SafeBuffer() is depreciated, please use SafeBuffer.from()");
        return SafeBuffer.from(...props);
      }
      SafeBuffer.prototype = Object.create(Array.prototype);
      Object.assign(SafeBuffer, {
        from() {
          if (!Object.keys(arguments).length || arguments[0] == null) {
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
          }
          const input = arguments[0];
          let buf;
          if (typeof input === "string") {
            const enc = arguments[1] || "utf8";
            if (enc === "hex") {
              const bytes = input.match(/([\da-fA-F]{2})/g).map((byte) => parseInt(byte, 16));
              if (!bytes || !bytes.length) {
                throw new TypeError("Invalid first argument for type 'hex'.");
              }
              buf = SeaArray.from(bytes);
            } else if (enc === "utf8" || "binary" === enc) {
              const length2 = input.length;
              const words = new Uint16Array(length2);
              Array.from({ length: length2 }, (_2, i2) => words[i2] = input.charCodeAt(i2));
              buf = SeaArray.from(words);
            } else if (enc === "base64") {
              const dec = atob(input);
              const length2 = dec.length;
              const bytes = new Uint8Array(length2);
              Array.from({ length: length2 }, (_2, i2) => bytes[i2] = dec.charCodeAt(i2));
              buf = SeaArray.from(bytes);
            } else if (enc === "binary") {
              buf = SeaArray.from(input);
            } else {
              console.info("SafeBuffer.from unknown encoding: " + enc);
            }
            return buf;
          }
          input.byteLength;
          const length = input.byteLength ? input.byteLength : input.length;
          if (length) {
            let buf2;
            if (input instanceof ArrayBuffer) {
              buf2 = new Uint8Array(input);
            }
            return SeaArray.from(buf2 || input);
          }
        },
        alloc(length, fill = 0) {
          return SeaArray.from(new Uint8Array(Array.from({ length }, () => fill)));
        },
        allocUnsafe(length) {
          return SeaArray.from(new Uint8Array(Array.from({ length })));
        },
        concat(arr) {
          if (!Array.isArray(arr)) {
            throw new TypeError("First argument must be Array containing ArrayBuffer or Uint8Array instances.");
          }
          return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []));
        }
      });
      SafeBuffer.prototype.from = SafeBuffer.from;
      SafeBuffer.prototype.toString = SeaArray.prototype.toString;
      module3.exports = SafeBuffer;
    })(USE, "./buffer");
    USE(function(module3) {
      const SEA2 = USE("./root");
      const api = { Buffer: USE("./buffer") };
      var o2 = {}, u2;
      JSON.parseAsync = JSON.parseAsync || function(t2, cb, r2) {
        var u3;
        try {
          cb(u3, JSON.parse(t2, r2));
        } catch (e2) {
          cb(e2);
        }
      };
      JSON.stringifyAsync = JSON.stringifyAsync || function(v2, cb, r2, s2) {
        var u3;
        try {
          cb(u3, JSON.stringify(v2, r2, s2));
        } catch (e2) {
          cb(e2);
        }
      };
      api.parse = function(t2, r2) {
        return new Promise(function(res, rej) {
          JSON.parseAsync(t2, function(err, raw) {
            err ? rej(err) : res(raw);
          }, r2);
        });
      };
      api.stringify = function(v2, r2, s2) {
        return new Promise(function(res, rej) {
          JSON.stringifyAsync(v2, function(err, raw) {
            err ? rej(err) : res(raw);
          }, r2, s2);
        });
      };
      if (SEA2.window) {
        api.crypto = window.crypto || window.msCrypto;
        api.subtle = (api.crypto || o2).subtle || (api.crypto || o2).webkitSubtle;
        api.TextEncoder = window.TextEncoder;
        api.TextDecoder = window.TextDecoder;
        api.random = (len2) => api.Buffer.from(api.crypto.getRandomValues(new Uint8Array(api.Buffer.alloc(len2))));
      }
      if (!api.TextDecoder) {
        const { TextEncoder, TextDecoder: TextDecoder2 } = USE((u2 + "" == typeof MODULE ? "." : "") + "./lib/text-encoding", 1);
        api.TextDecoder = TextDecoder2;
        api.TextEncoder = TextEncoder;
      }
      if (!api.crypto) {
        try {
          var crypto = USE("crypto", 1);
          Object.assign(api, {
            crypto,
            random: (len2) => api.Buffer.from(crypto.randomBytes(len2))
          });
          const { Crypto: WebCrypto } = USE("@peculiar/webcrypto", 1);
          api.ossl = api.subtle = new WebCrypto({ directory: "ossl" }).subtle;
        } catch (e2) {
          console.log("Please `npm install @peculiar/webcrypto` or add it to your package.json !");
        }
      }
      module3.exports = api;
    })(USE, "./shim");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      var s2 = {};
      s2.pbkdf2 = { hash: { name: "SHA-256" }, iter: 1e5, ks: 64 };
      s2.ecdsa = {
        pair: { name: "ECDSA", namedCurve: "P-256" },
        sign: { name: "ECDSA", hash: { name: "SHA-256" } }
      };
      s2.ecdh = { name: "ECDH", namedCurve: "P-256" };
      s2.jwk = function(pub, d2) {
        pub = pub.split(".");
        var x2 = pub[0], y2 = pub[1];
        var jwk = { kty: "EC", crv: "P-256", x: x2, y: y2, ext: true };
        jwk.key_ops = d2 ? ["sign"] : ["verify"];
        if (d2) {
          jwk.d = d2;
        }
        return jwk;
      };
      s2.keyToJwk = function(keyBytes) {
        const keyB64 = keyBytes.toString("base64");
        const k2 = keyB64.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
        return { kty: "oct", k: k2, ext: false, alg: "A256GCM" };
      };
      s2.recall = {
        validity: 12 * 60 * 60,
        hook: function(props) {
          return props;
        }
      };
      s2.check = function(t2) {
        return typeof t2 == "string" && "SEA{" === t2.slice(0, 4);
      };
      s2.parse = async function p2(t2) {
        try {
          var yes = typeof t2 == "string";
          if (yes && "SEA{" === t2.slice(0, 4)) {
            t2 = t2.slice(3);
          }
          return yes ? await shim.parse(t2) : t2;
        } catch (e2) {
        }
        return t2;
      };
      SEA2.opt = s2;
      module3.exports = s2;
    })(USE, "./settings");
    USE(function(module3) {
      var shim = USE("./shim");
      module3.exports = async function(d2, o2) {
        var t2 = typeof d2 == "string" ? d2 : await shim.stringify(d2);
        var hash2 = await shim.subtle.digest({ name: o2 || "SHA-256" }, new shim.TextEncoder().encode(t2));
        return shim.Buffer.from(hash2);
      };
    })(USE, "./sha256");
    USE(function(module3) {
      const __shim = USE("./shim");
      const subtle = __shim.subtle;
      const ossl = __shim.ossl ? __shim.ossl : subtle;
      const sha1hash2 = (b2) => ossl.digest({ name: "SHA-1" }, new ArrayBuffer(b2));
      module3.exports = sha1hash2;
    })(USE, "./sha1");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      var S2 = USE("./settings");
      var sha = USE("./sha256");
      var u2;
      SEA2.work = SEA2.work || (async (data2, pair, cb, opt) => {
        try {
          var salt = (pair || {}).epub || pair;
          opt = opt || {};
          if (salt instanceof Function) {
            cb = salt;
            salt = u2;
          }
          data2 = typeof data2 == "string" ? data2 : await shim.stringify(data2);
          if ("sha" === (opt.name || "").toLowerCase().slice(0, 3)) {
            var rsha = shim.Buffer.from(await sha(data2, opt.name), "binary").toString(opt.encode || "base64");
            if (cb) {
              try {
                cb(rsha);
              } catch (e2) {
                console.log(e2);
              }
            }
            return rsha;
          }
          salt = salt || shim.random(9);
          var key = await (shim.ossl || shim.subtle).importKey("raw", new shim.TextEncoder().encode(data2), { name: opt.name || "PBKDF2" }, false, ["deriveBits"]);
          var work = await (shim.ossl || shim.subtle).deriveBits({
            name: opt.name || "PBKDF2",
            iterations: opt.iterations || S2.pbkdf2.iter,
            salt: new shim.TextEncoder().encode(opt.salt || salt),
            hash: opt.hash || S2.pbkdf2.hash
          }, key, opt.length || S2.pbkdf2.ks * 8);
          data2 = shim.random(data2.length);
          var r2 = shim.Buffer.from(work, "binary").toString(opt.encode || "base64");
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      module3.exports = SEA2.work;
    })(USE, "./work");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      USE("./settings");
      SEA2.name = SEA2.name || (async (cb, opt) => {
        try {
          if (cb) {
            try {
              cb();
            } catch (e2) {
              console.log(e2);
            }
          }
          return;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      SEA2.pair = SEA2.pair || (async (cb, opt) => {
        try {
          var ecdhSubtle = shim.ossl || shim.subtle;
          var sa2 = await shim.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, true, ["sign", "verify"]).then(async (keys2) => {
            var key = {};
            key.priv = (await shim.subtle.exportKey("jwk", keys2.privateKey)).d;
            var pub = await shim.subtle.exportKey("jwk", keys2.publicKey);
            key.pub = pub.x + "." + pub.y;
            return key;
          });
          try {
            var dh = await ecdhSubtle.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey"]).then(async (keys2) => {
              var key = {};
              key.epriv = (await ecdhSubtle.exportKey("jwk", keys2.privateKey)).d;
              var pub = await ecdhSubtle.exportKey("jwk", keys2.publicKey);
              key.epub = pub.x + "." + pub.y;
              return key;
            });
          } catch (e2) {
            if (SEA2.window) {
              throw e2;
            }
            if (e2 == "Error: ECDH is not a supported algorithm") {
              console.log("Ignoring ECDH...");
            } else {
              throw e2;
            }
          }
          dh = dh || {};
          var r2 = { pub: sa2.pub, priv: sa2.priv, epub: dh.epub, epriv: dh.epriv };
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      module3.exports = SEA2.pair;
    })(USE, "./pair");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      var S2 = USE("./settings");
      var sha = USE("./sha256");
      var u2;
      SEA2.sign = SEA2.sign || (async (data2, pair, cb, opt) => {
        try {
          opt = opt || {};
          if (!(pair || opt).priv) {
            if (!SEA2.I) {
              throw "No signing key.";
            }
            pair = await SEA2.I(null, { what: data2, how: "sign", why: opt.why });
          }
          if (u2 === data2) {
            throw "`undefined` not allowed.";
          }
          var json = await S2.parse(data2);
          var check2 = opt.check = opt.check || json;
          if (SEA2.verify && (SEA2.opt.check(check2) || check2 && check2.s && check2.m) && u2 !== await SEA2.verify(check2, pair)) {
            var r2 = await S2.parse(check2);
            if (!opt.raw) {
              r2 = "SEA" + await shim.stringify(r2);
            }
            if (cb) {
              try {
                cb(r2);
              } catch (e2) {
                console.log(e2);
              }
            }
            return r2;
          }
          var pub = pair.pub;
          var priv = pair.priv;
          var jwk = S2.jwk(pub, priv);
          var hash2 = await sha(json);
          var sig = await (shim.ossl || shim.subtle).importKey("jwk", jwk, { name: "ECDSA", namedCurve: "P-256" }, false, ["sign"]).then((key) => (shim.ossl || shim.subtle).sign({ name: "ECDSA", hash: { name: "SHA-256" } }, key, new Uint8Array(hash2)));
          var r2 = { m: json, s: shim.Buffer.from(sig, "binary").toString(opt.encode || "base64") };
          if (!opt.raw) {
            r2 = "SEA" + await shim.stringify(r2);
          }
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      module3.exports = SEA2.sign;
    })(USE, "./sign");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      var S2 = USE("./settings");
      var sha = USE("./sha256");
      var u2;
      SEA2.verify = SEA2.verify || (async (data2, pair, cb, opt) => {
        try {
          var json = await S2.parse(data2);
          if (false === pair) {
            var raw = await S2.parse(json.m);
            if (cb) {
              try {
                cb(raw);
              } catch (e2) {
                console.log(e2);
              }
            }
            return raw;
          }
          opt = opt || {};
          var pub = pair.pub || pair;
          var key = SEA2.opt.slow_leak ? await SEA2.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey("jwk", S2.jwk(pub), { name: "ECDSA", namedCurve: "P-256" }, false, ["verify"]);
          var hash2 = await sha(json.m);
          var buf, sig, check2, tmp;
          try {
            buf = shim.Buffer.from(json.s, opt.encode || "base64");
            sig = new Uint8Array(buf);
            check2 = await (shim.ossl || shim.subtle).verify({ name: "ECDSA", hash: { name: "SHA-256" } }, key, sig, new Uint8Array(hash2));
            if (!check2) {
              throw "Signature did not match.";
            }
          } catch (e2) {
            if (SEA2.opt.fallback) {
              return await SEA2.opt.fall_verify(data2, pair, cb, opt);
            }
          }
          var r2 = check2 ? await S2.parse(json.m) : u2;
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      module3.exports = SEA2.verify;
      var knownKeys = {};
      SEA2.opt.slow_leak = (pair) => {
        if (knownKeys[pair])
          return knownKeys[pair];
        var jwk = S2.jwk(pair);
        knownKeys[pair] = (shim.ossl || shim.subtle).importKey("jwk", jwk, { name: "ECDSA", namedCurve: "P-256" }, false, ["verify"]);
        return knownKeys[pair];
      };
      var O2 = SEA2.opt;
      SEA2.opt.fall_verify = async function(data2, pair, cb, opt, f2) {
        if (f2 === SEA2.opt.fallback) {
          throw "Signature did not match";
        }
        f2 = f2 || 1;
        var tmp = data2 || "";
        data2 = SEA2.opt.unpack(data2) || data2;
        var json = await S2.parse(data2), pub = pair.pub || pair, key = await SEA2.opt.slow_leak(pub);
        var hash2 = f2 <= SEA2.opt.fallback ? shim.Buffer.from(await shim.subtle.digest({ name: "SHA-256" }, new shim.TextEncoder().encode(await S2.parse(json.m)))) : await sha(json.m);
        var buf;
        var sig;
        var check2;
        try {
          buf = shim.Buffer.from(json.s, opt.encode || "base64");
          sig = new Uint8Array(buf);
          check2 = await (shim.ossl || shim.subtle).verify({ name: "ECDSA", hash: { name: "SHA-256" } }, key, sig, new Uint8Array(hash2));
          if (!check2) {
            throw "Signature did not match.";
          }
        } catch (e2) {
          try {
            buf = shim.Buffer.from(json.s, "utf8");
            sig = new Uint8Array(buf);
            check2 = await (shim.ossl || shim.subtle).verify({ name: "ECDSA", hash: { name: "SHA-256" } }, key, sig, new Uint8Array(hash2));
          } catch (e3) {
            if (!check2) {
              throw "Signature did not match.";
            }
          }
        }
        var r2 = check2 ? await S2.parse(json.m) : u2;
        O2.fall_soul = tmp["#"];
        O2.fall_key = tmp["."];
        O2.fall_val = data2;
        O2.fall_state = tmp[">"];
        if (cb) {
          try {
            cb(r2);
          } catch (e2) {
            console.log(e2);
          }
        }
        return r2;
      };
      SEA2.opt.fallback = 2;
    })(USE, "./verify");
    USE(function(module3) {
      var shim = USE("./shim");
      var S2 = USE("./settings");
      var sha256hash = USE("./sha256");
      const importGen = async (key, salt, opt) => {
        const combo = key + (salt || shim.random(8)).toString("utf8");
        const hash2 = shim.Buffer.from(await sha256hash(combo), "binary");
        const jwkKey = S2.keyToJwk(hash2);
        return await shim.subtle.importKey("jwk", jwkKey, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
      };
      module3.exports = importGen;
    })(USE, "./aeskey");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      USE("./settings");
      var aeskey = USE("./aeskey");
      var u2;
      SEA2.encrypt = SEA2.encrypt || (async (data2, pair, cb, opt) => {
        try {
          opt = opt || {};
          var key = (pair || opt).epriv || pair;
          if (u2 === data2) {
            throw "`undefined` not allowed.";
          }
          if (!key) {
            if (!SEA2.I) {
              throw "No encryption key.";
            }
            pair = await SEA2.I(null, { what: data2, how: "encrypt", why: opt.why });
            key = pair.epriv || pair;
          }
          var msg = typeof data2 == "string" ? data2 : await shim.stringify(data2);
          var rand = { s: shim.random(9), iv: shim.random(15) };
          var ct = await aeskey(key, rand.s, opt).then((aes) => shim.subtle.encrypt({
            name: opt.name || "AES-GCM",
            iv: new Uint8Array(rand.iv)
          }, aes, new shim.TextEncoder().encode(msg)));
          var r2 = {
            ct: shim.Buffer.from(ct, "binary").toString(opt.encode || "base64"),
            iv: rand.iv.toString(opt.encode || "base64"),
            s: rand.s.toString(opt.encode || "base64")
          };
          if (!opt.raw) {
            r2 = "SEA" + await shim.stringify(r2);
          }
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      module3.exports = SEA2.encrypt;
    })(USE, "./encrypt");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      var S2 = USE("./settings");
      var aeskey = USE("./aeskey");
      SEA2.decrypt = SEA2.decrypt || (async (data2, pair, cb, opt) => {
        try {
          opt = opt || {};
          var key = (pair || opt).epriv || pair;
          if (!key) {
            if (!SEA2.I) {
              throw "No decryption key.";
            }
            pair = await SEA2.I(null, { what: data2, how: "decrypt", why: opt.why });
            key = pair.epriv || pair;
          }
          var json = await S2.parse(data2);
          var buf, bufiv, bufct;
          try {
            buf = shim.Buffer.from(json.s, opt.encode || "base64");
            bufiv = shim.Buffer.from(json.iv, opt.encode || "base64");
            bufct = shim.Buffer.from(json.ct, opt.encode || "base64");
            var ct = await aeskey(key, buf, opt).then((aes) => shim.subtle.decrypt({
              name: opt.name || "AES-GCM",
              iv: new Uint8Array(bufiv),
              tagLength: 128
            }, aes, new Uint8Array(bufct)));
          } catch (e2) {
            if ("utf8" === opt.encode) {
              throw "Could not decrypt";
            }
            if (SEA2.opt.fallback) {
              opt.encode = "utf8";
              return await SEA2.decrypt(data2, pair, cb, opt);
            }
          }
          var r2 = await S2.parse(new shim.TextDecoder("utf8").decode(ct));
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      module3.exports = SEA2.decrypt;
    })(USE, "./decrypt");
    USE(function(module3) {
      var SEA2 = USE("./root");
      var shim = USE("./shim");
      USE("./settings");
      SEA2.secret = SEA2.secret || (async (key, pair, cb, opt) => {
        try {
          opt = opt || {};
          if (!pair || !pair.epriv || !pair.epub) {
            if (!SEA2.I) {
              throw "No secret mix.";
            }
            pair = await SEA2.I(null, { what: key, how: "secret", why: opt.why });
          }
          var pub = key.epub || key;
          var epub = pair.epub;
          var epriv = pair.epriv;
          var ecdhSubtle = shim.ossl || shim.subtle;
          var pubKeyData = keysToEcdhJwk(pub);
          var props = Object.assign({ public: await ecdhSubtle.importKey(...pubKeyData, true, []) }, { name: "ECDH", namedCurve: "P-256" });
          var privKeyData = keysToEcdhJwk(epub, epriv);
          var derived = await ecdhSubtle.importKey(...privKeyData, false, ["deriveBits"]).then(async (privKey) => {
            var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);
            var rawBits = new Uint8Array(derivedBits);
            var derivedKey = await ecdhSubtle.importKey("raw", rawBits, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
            return ecdhSubtle.exportKey("jwk", derivedKey).then(({ k: k2 }) => k2);
          });
          var r2 = derived;
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          console.log(e2);
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      var keysToEcdhJwk = (pub, d2) => {
        var [x2, y2] = pub.split(".");
        var jwk = d2 ? { d: d2 } : {};
        return [
          "jwk",
          Object.assign(jwk, { x: x2, y: y2, kty: "EC", crv: "P-256", ext: true }),
          { name: "ECDH", namedCurve: "P-256" }
        ];
      };
      module3.exports = SEA2.secret;
    })(USE, "./secret");
    USE(function(module3) {
      var SEA2 = USE("./root");
      SEA2.certify = SEA2.certify || (async (certificants, policy = {}, authority, cb, opt = {}) => {
        try {
          console.log("SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.");
          certificants = (() => {
            var data3 = [];
            if (certificants) {
              if ((typeof certificants === "string" || Array.isArray(certificants)) && certificants.indexOf("*") > -1)
                return "*";
              if (typeof certificants === "string")
                return certificants;
              if (Array.isArray(certificants)) {
                if (certificants.length === 1 && certificants[0])
                  return typeof certificants[0] === "object" && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === "string" ? certificants[0] : null;
                certificants.map((certificant) => {
                  if (typeof certificant === "string")
                    data3.push(certificant);
                  else if (typeof certificant === "object" && certificant.pub)
                    data3.push(certificant.pub);
                });
              }
              if (typeof certificants === "object" && certificants.pub)
                return certificants.pub;
              return data3.length > 0 ? data3 : null;
            }
            return;
          })();
          if (!certificants)
            return console.log("No certificant found.");
          const expiry = opt.expiry && (typeof opt.expiry === "number" || typeof opt.expiry === "string") ? parseFloat(opt.expiry) : null;
          const readPolicy = (policy || {}).read ? policy.read : null;
          const writePolicy = (policy || {}).write ? policy.write : typeof policy === "string" || Array.isArray(policy) || policy["+"] || policy["#"] || policy["."] || policy["="] || policy["*"] || policy[">"] || policy["<"] ? policy : null;
          const block3 = (opt || {}).block || (opt || {}).blacklist || (opt || {}).ban || {};
          const readBlock = block3.read && (typeof block3.read === "string" || (block3.read || {})["#"]) ? block3.read : null;
          const writeBlock = typeof block3 === "string" ? block3 : block3.write && (typeof block3.write === "string" || block3.write["#"]) ? block3.write : null;
          if (!readPolicy && !writePolicy)
            return console.log("No policy found.");
          const data2 = JSON.stringify({
            c: certificants,
            ...expiry ? { e: expiry } : {},
            ...readPolicy ? { r: readPolicy } : {},
            ...writePolicy ? { w: writePolicy } : {},
            ...readBlock ? { rb: readBlock } : {},
            ...writeBlock ? { wb: writeBlock } : {}
          });
          const certificate = await SEA2.sign(data2, authority, null, { raw: 1 });
          var r2 = certificate;
          if (!opt.raw) {
            r2 = "SEA" + JSON.stringify(r2);
          }
          if (cb) {
            try {
              cb(r2);
            } catch (e2) {
              console.log(e2);
            }
          }
          return r2;
        } catch (e2) {
          SEA2.err = e2;
          if (SEA2.throw) {
            throw e2;
          }
          if (cb) {
            cb();
          }
          return;
        }
      });
      module3.exports = SEA2.certify;
    })(USE, "./certify");
    USE(function(module3) {
      var shim = USE("./shim");
      var SEA2 = USE("./root");
      SEA2.work = USE("./work");
      SEA2.sign = USE("./sign");
      SEA2.verify = USE("./verify");
      SEA2.encrypt = USE("./encrypt");
      SEA2.decrypt = USE("./decrypt");
      SEA2.certify = USE("./certify");
      SEA2.random = SEA2.random || shim.random;
      SEA2.Buffer = SEA2.Buffer || USE("./buffer");
      SEA2.keyid = SEA2.keyid || (async (pub) => {
        try {
          const pb = shim.Buffer.concat(pub.replace(/-/g, "+").replace(/_/g, "/").split(".").map((t2) => shim.Buffer.from(t2, "base64")));
          const id2 = shim.Buffer.concat([
            shim.Buffer.from([153, pb.length / 256, pb.length % 256]),
            pb
          ]);
          const sha1 = await sha1hash(id2);
          const hash2 = shim.Buffer.from(sha1, "binary");
          return hash2.toString("hex", hash2.length - 8);
        } catch (e2) {
          console.log(e2);
          throw e2;
        }
      });
      ((SEA2.window || {}).GUN || {}).SEA = SEA2;
      module3.exports = SEA2;
    })(USE, "./sea");
    USE(function(module3) {
      var SEA2 = USE("./sea"), Gun2, u2;
      if (SEA2.window) {
        Gun2 = SEA2.window.GUN || { chain: {} };
      } else {
        Gun2 = USE((u2 + "" == typeof MODULE ? "." : "") + "./gun", 1);
      }
      SEA2.GUN = Gun2;
      function User(root2) {
        this._ = { $: this };
      }
      User.prototype = function() {
        function F2() {
        }
        F2.prototype = Gun2.chain;
        return new F2();
      }();
      User.prototype.constructor = User;
      Gun2.chain.user = function(pub) {
        var gun2 = this, root2 = gun2.back(-1), user;
        if (pub) {
          pub = SEA2.opt.pub((pub._ || "")["#"]) || pub;
          return root2.get("~" + pub);
        }
        if (user = root2.back("user")) {
          return user;
        }
        var root2 = root2._, at2 = root2, uuid = at2.opt.uuid || lex;
        (at2 = (user = at2.user = gun2.chain(new User()))._).opt = {};
        at2.opt.uuid = function(cb) {
          var id2 = uuid(), pub2 = root2.user;
          if (!pub2 || !(pub2 = pub2.is) || !(pub2 = pub2.pub)) {
            return id2;
          }
          id2 = "~" + pub2 + "/" + id2;
          if (cb && cb.call) {
            cb(null, id2);
          }
          return id2;
        };
        return user;
      };
      function lex() {
        return Gun2.state().toString(36).replace(".", "");
      }
      Gun2.User = User;
      User.GUN = Gun2;
      User.SEA = Gun2.SEA = SEA2;
      module3.exports = User;
    })(USE, "./user");
    USE(function(module3) {
      var u2, Gun2 = "" + u2 != typeof window ? window.Gun || { chain: {} } : USE(("" + u2 === typeof MODULE ? "." : "") + "./gun", 1);
      Gun2.chain.then = function(cb, opt) {
        var gun2 = this, p2 = new Promise(function(res, rej) {
          gun2.once(res, opt);
        });
        return cb ? p2.then(cb) : p2;
      };
    })(USE, "./then");
    USE(function(module3) {
      var User = USE("./user"), SEA2 = User.SEA, Gun2 = User.GUN, noop2 = function() {
      };
      User.prototype.create = function(...args) {
        var pair = typeof args[0] === "object" && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === "object" && (args[1].pub || args[1].epub) ? args[1] : null;
        var alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === "string" ? args[0] : null;
        var pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === "string" ? args[1] : null;
        var cb = args.filter((arg) => typeof arg === "function")[0] || null;
        var opt = args && args.length > 1 && typeof args[args.length - 1] === "object" ? args[args.length - 1] : {};
        var gun2 = this, cat = gun2._, root2 = gun2.back(-1);
        cb = cb || noop2;
        opt = opt || {};
        if (false !== opt.check) {
          var err;
          if (!alias) {
            err = "No user.";
          }
          if ((pass || "").length < 8) {
            err = "Password too short!";
          }
          if (err) {
            cb({ err: Gun2.log(err) });
            return gun2;
          }
        }
        if (cat.ing) {
          (cb || noop2)({ err: Gun2.log("User is already being created or authenticated!"), wait: true });
          return gun2;
        }
        cat.ing = true;
        var act = {};
        act.a = function(pubs) {
          act.pubs = pubs;
          if (pubs && !opt.already) {
            var ack = { err: Gun2.log("User already created!") };
            cat.ing = false;
            (cb || noop2)(ack);
            gun2.leave();
            return;
          }
          act.salt = String.random(64);
          SEA2.work(pass, act.salt, act.b);
        };
        act.b = function(proof) {
          act.proof = proof;
          pair ? act.c(pair) : SEA2.pair(act.c);
        };
        act.c = function(pair2) {
          var tmp;
          act.pair = pair2 || {};
          if (tmp = cat.root.user) {
            tmp._.sea = pair2;
            tmp.is = { pub: pair2.pub, epub: pair2.epub, alias };
          }
          act.data = { pub: pair2.pub };
          act.d();
        };
        act.d = function() {
          act.data.alias = alias;
          act.e();
        };
        act.e = function() {
          act.data.epub = act.pair.epub;
          SEA2.encrypt({ priv: act.pair.priv, epriv: act.pair.epriv }, act.proof, act.f, { raw: 1 });
        };
        act.f = function(auth) {
          act.data.auth = JSON.stringify({ ek: auth, s: act.salt });
          act.g(act.data.auth);
        };
        act.g = function(auth) {
          var tmp;
          act.data.auth = act.data.auth || auth;
          root2.get(tmp = "~" + act.pair.pub).put(act.data).on(act.h);
          var link3 = {};
          link3[tmp] = { "#": tmp };
          root2.get("~@" + alias).put(link3).get(tmp).on(act.i);
        };
        act.h = function(data2, key, msg, eve) {
          eve.off();
          act.h.ok = 1;
          act.i();
        };
        act.i = function(data2, key, msg, eve) {
          if (eve) {
            act.i.ok = 1;
            eve.off();
          }
          if (!act.h.ok || !act.i.ok) {
            return;
          }
          cat.ing = false;
          cb({ ok: 0, pub: act.pair.pub });
          if (noop2 === cb) {
            pair ? gun2.auth(pair) : gun2.auth(alias, pass);
          }
        };
        root2.get("~@" + alias).once(act.a);
        return gun2;
      };
      User.prototype.leave = function(opt, cb) {
        var gun2 = this, user = gun2.back(-1)._.user;
        if (user) {
          delete user.is;
          delete user._.is;
          delete user._.sea;
        }
        if (SEA2.window) {
          try {
            var sS = {};
            sS = window.sessionStorage;
            delete sS.recall;
            delete sS.pair;
          } catch (e2) {
          }
        }
        return gun2;
      };
    })(USE, "./create");
    USE(function(module3) {
      var User = USE("./user"), SEA2 = User.SEA, Gun2 = User.GUN, noop2 = function() {
      };
      User.prototype.auth = function(...args) {
        var pair = typeof args[0] === "object" && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === "object" && (args[1].pub || args[1].epub) ? args[1] : null;
        var alias = !pair && typeof args[0] === "string" ? args[0] : null;
        var pass = alias && typeof args[1] === "string" ? args[1] : null;
        var cb = args.filter((arg) => typeof arg === "function")[0] || null;
        var opt = args && args.length > 1 && typeof args[args.length - 1] === "object" ? args[args.length - 1] : {};
        var gun2 = this, cat = gun2._, root2 = gun2.back(-1);
        if (cat.ing) {
          (cb || noop2)({ err: Gun2.log("User is already being created or authenticated!"), wait: true });
          return gun2;
        }
        cat.ing = true;
        var act = {}, u2;
        act.a = function(data2) {
          if (!data2) {
            return act.b();
          }
          if (!data2.pub) {
            var tmp = [];
            Object.keys(data2).forEach(function(k2) {
              if ("_" == k2) {
                return;
              }
              tmp.push(data2[k2]);
            });
            return act.b(tmp);
          }
          if (act.name) {
            return act.f(data2);
          }
          act.c((act.data = data2).auth);
        };
        act.b = function(list3) {
          var get2 = (act.list = (act.list || []).concat(list3 || [])).shift();
          if (u2 === get2) {
            if (act.name) {
              return act.err("Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.");
            }
            return act.err("Wrong user or password.");
          }
          root2.get(get2).once(act.a);
        };
        act.c = function(auth) {
          if (u2 === auth) {
            return act.b();
          }
          if ("string" == typeof auth) {
            return act.c(obj_ify(auth));
          }
          SEA2.work(pass, (act.auth = auth).s, act.d, act.enc);
        };
        act.d = function(proof) {
          SEA2.decrypt(act.auth.ek, proof, act.e, act.enc);
        };
        act.e = function(half2) {
          if (u2 === half2) {
            if (!act.enc) {
              act.enc = { encode: "utf8" };
              return act.c(act.auth);
            }
            act.enc = null;
            return act.b();
          }
          act.half = half2;
          act.f(act.data);
        };
        act.f = function(pair2) {
          var half2 = act.half || {}, data2 = act.data || {};
          act.g(act.lol = { pub: pair2.pub || data2.pub, epub: pair2.epub || data2.epub, priv: pair2.priv || half2.priv, epriv: pair2.epriv || half2.epriv });
        };
        act.g = function(pair2) {
          if (!pair2 || !pair2.pub || !pair2.epub) {
            return act.b();
          }
          act.pair = pair2;
          var user = root2._.user, at2 = user._;
          at2.tag;
          var upt = at2.opt;
          at2 = user._ = root2.get("~" + pair2.pub)._;
          at2.opt = upt;
          user.is = { pub: pair2.pub, epub: pair2.epub, alias: alias || pair2.pub };
          at2.sea = act.pair;
          cat.ing = false;
          try {
            if (pass && u2 == (obj_ify(cat.root.graph["~" + pair2.pub].auth) || "")[":"]) {
              opt.shuffle = opt.change = pass;
            }
          } catch (e2) {
          }
          opt.change ? act.z() : (cb || noop2)(at2);
          if (SEA2.window && (gun2.back("user")._.opt || opt).remember) {
            try {
              var sS = {};
              sS = window.sessionStorage;
              sS.recall = true;
              sS.pair = JSON.stringify(pair2);
            } catch (e2) {
            }
          }
          try {
            if (root2._.tag.auth) {
              root2._.on("auth", at2);
            } else {
              setTimeout(function() {
                root2._.on("auth", at2);
              }, 1);
            }
          } catch (e2) {
            Gun2.log("Your 'auth' callback crashed with:", e2);
          }
        };
        act.z = function() {
          act.salt = String.random(64);
          SEA2.work(opt.change, act.salt, act.y);
        };
        act.y = function(proof) {
          SEA2.encrypt({ priv: act.pair.priv, epriv: act.pair.epriv }, proof, act.x, { raw: 1 });
        };
        act.x = function(auth) {
          act.w(JSON.stringify({ ek: auth, s: act.salt }));
        };
        act.w = function(auth) {
          if (opt.shuffle) {
            console.log("migrate core account from UTF8 & shuffle");
            var tmp = {};
            Object.keys(act.data).forEach(function(k2) {
              tmp[k2] = act.data[k2];
            });
            delete tmp._;
            tmp.auth = auth;
            root2.get("~" + act.pair.pub).put(tmp);
          }
          root2.get("~" + act.pair.pub).get("auth").put(auth, cb || noop2);
        };
        act.err = function(e2) {
          var ack = { err: Gun2.log(e2 || "User cannot be found!") };
          cat.ing = false;
          (cb || noop2)(ack);
        };
        act.plugin = function(name) {
          if (!(act.name = name)) {
            return act.err();
          }
          var tmp = [name];
          if ("~" !== name[0]) {
            tmp[1] = "~" + name;
            tmp[2] = "~@" + name;
          }
          act.b(tmp);
        };
        if (pair) {
          act.g(pair);
        } else if (alias) {
          root2.get("~@" + alias).once(act.a);
        } else if (!alias && !pass) {
          SEA2.name(act.plugin);
        }
        return gun2;
      };
      function obj_ify(o2) {
        if ("string" != typeof o2) {
          return o2;
        }
        try {
          o2 = JSON.parse(o2);
        } catch (e2) {
          o2 = {};
        }
        return o2;
      }
    })(USE, "./auth");
    USE(function(module3) {
      var User = USE("./user"), SEA2 = User.SEA;
      User.GUN;
      User.prototype.recall = function(opt, cb) {
        var gun2 = this, root2 = gun2.back(-1);
        opt = opt || {};
        if (opt && opt.sessionStorage) {
          if (SEA2.window) {
            try {
              var sS = {};
              sS = window.sessionStorage;
              if (sS) {
                root2._.opt.remember = true;
                (gun2.back("user")._.opt || opt).remember = true;
                if (sS.recall || sS.pair)
                  root2.user().auth(JSON.parse(sS.pair), cb);
              }
            } catch (e2) {
            }
          }
          return gun2;
        }
        return gun2;
      };
    })(USE, "./recall");
    USE(function(module3) {
      var User = USE("./user"), SEA2 = User.SEA, Gun2 = User.GUN, noop2 = function() {
      };
      User.prototype.pair = function() {
        var user = this, proxy;
        try {
          proxy = new Proxy({ DANGER: "\u2620" }, { get: function(t2, p2, r2) {
            if (!user.is || !(user._ || "").sea) {
              return;
            }
            return user._.sea[p2];
          } });
        } catch (e2) {
        }
        return proxy;
      };
      User.prototype.delete = async function(alias, pass, cb) {
        console.log("user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!");
        var gun2 = this;
        gun2.back(-1);
        var user = gun2.back("user");
        try {
          user.auth(alias, pass, function(ack) {
            var pub = (user.is || {}).pub;
            user.map().once(function() {
              this.put(null);
            });
            user.leave();
            (cb || noop2)({ ok: 0 });
          });
        } catch (e2) {
          Gun2.log("User.delete failed! Error:", e2);
        }
        return gun2;
      };
      User.prototype.alive = async function() {
        console.log("user.alive() IS DEPRECATED!!!");
        const gunRoot = this.back(-1);
        try {
          await authRecall(gunRoot);
          return gunRoot._.user._;
        } catch (e2) {
          const err = "No session!";
          Gun2.log(err);
          throw { err };
        }
      };
      User.prototype.trust = async function(user) {
        console.log("`.trust` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!");
        if (Gun2.is(user)) {
          user.get("pub").get((ctx, ev) => {
            console.log(ctx, ev);
          });
        }
        user.get("trust").get(path).put(theirPubkey);
      };
      User.prototype.grant = function(to2, cb) {
        console.log("`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!");
        var gun2 = this, user = gun2.back(-1).user(), pair = user._.sea, path2 = "";
        gun2.back(function(at2) {
          if (at2.is) {
            return;
          }
          path2 += at2.get || "";
        });
        (async function() {
          var enc, sec = await user.get("grant").get(pair.pub).get(path2).then();
          sec = await SEA2.decrypt(sec, pair);
          if (!sec) {
            sec = SEA2.random(16).toString();
            enc = await SEA2.encrypt(sec, pair);
            user.get("grant").get(pair.pub).get(path2).put(enc);
          }
          var pub = to2.get("pub").then();
          var epub = to2.get("epub").then();
          pub = await pub;
          epub = await epub;
          var dh = await SEA2.secret(epub, pair);
          enc = await SEA2.encrypt(sec, dh);
          user.get("grant").get(pub).get(path2).put(enc, cb);
        })();
        return gun2;
      };
      User.prototype.secret = function(data2, cb) {
        console.log("`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!");
        var gun2 = this, user = gun2.back(-1).user(), pair = user.pair(), path2 = "";
        gun2.back(function(at2) {
          if (at2.is) {
            return;
          }
          path2 += at2.get || "";
        });
        (async function() {
          var enc, sec = await user.get("trust").get(pair.pub).get(path2).then();
          sec = await SEA2.decrypt(sec, pair);
          if (!sec) {
            sec = SEA2.random(16).toString();
            enc = await SEA2.encrypt(sec, pair);
            user.get("trust").get(pair.pub).get(path2).put(enc);
          }
          enc = await SEA2.encrypt(data2, sec);
          gun2.put(enc, cb);
        })();
        return gun2;
      };
      module3.exports = User;
    })(USE, "./share");
    USE(function(module3) {
      var SEA2 = USE("./sea"), S2 = USE("./settings"), noop2 = function() {
      }, u2;
      var Gun2 = "" + u2 != typeof window ? window.Gun || { on: noop2 } : USE(("" + u2 === typeof MODULE ? "." : "") + "./gun", 1);
      Gun2.on("opt", function(at2) {
        if (!at2.sea) {
          at2.sea = { own: {} };
          at2.on("put", check2, at2);
        }
        this.to.next(at2);
      });
      function check2(msg) {
        var eve = this, at2 = eve.as, put = msg.put, soul = put["#"], key = put["."], val = put[":"], state = put[">"], id2 = msg["#"], tmp;
        if (!soul || !key) {
          return;
        }
        if ((msg._ || "").faith && (at2.opt || "").faith && "function" == typeof msg._) {
          SEA2.opt.pack(put, function(raw) {
            SEA2.verify(raw, false, function(data2) {
              put["="] = SEA2.opt.unpack(data2);
              eve.to.next(msg);
            });
          });
          return;
        }
        var no = function(why) {
          at2.on("in", { "@": id2, err: msg.err = why });
        };
        (msg._ || "").DBG && ((msg._ || "").DBG.c = +new Date());
        if (0 <= soul.indexOf("<?")) {
          tmp = parseFloat(soul.split("<?")[1] || "");
          if (tmp && state < Gun2.state() - tmp * 1e3) {
            (tmp = msg._) && tmp.stun && tmp.stun--;
            return;
          }
        }
        if ("~@" === soul) {
          check2.alias(eve, msg, val, key, soul, at2, no);
          return;
        }
        if ("~@" === soul.slice(0, 2)) {
          check2.pubs(eve, msg, val, key, soul, at2, no);
          return;
        }
        if (tmp = SEA2.opt.pub(soul)) {
          check2.pub(eve, msg, val, key, soul, at2, no, at2.user || "", tmp);
          return;
        }
        if (0 <= soul.indexOf("#")) {
          check2.hash(eve, msg, val, key, soul, at2, no);
          return;
        }
        check2.any(eve, msg, val, key, soul, at2, no, at2.user || "");
        return;
      }
      check2.hash = function(eve, msg, val, key, soul, at2, no) {
        SEA2.work(val, null, function(data2) {
          if (data2 && data2 === key.split("#").slice(-1)[0]) {
            return eve.to.next(msg);
          }
          no("Data hash not same as hash!");
        }, { name: "SHA-256" });
      };
      check2.alias = function(eve, msg, val, key, soul, at2, no) {
        if (!val) {
          return no("Data must exist!");
        }
        if ("~@" + key === link_is(val)) {
          return eve.to.next(msg);
        }
        no("Alias not same!");
      };
      check2.pubs = function(eve, msg, val, key, soul, at2, no) {
        if (!val) {
          return no("Alias must exist!");
        }
        if (key === link_is(val)) {
          return eve.to.next(msg);
        }
        no("Alias not same!");
      };
      check2.pub = async function(eve, msg, val, key, soul, at2, no, user, pub) {
        var tmp;
        const raw = await S2.parse(val) || {};
        const verify = (certificate, certificant, cb) => {
          if (certificate.m && certificate.s && certificant && pub)
            return SEA2.verify(certificate, pub, (data2) => {
              if (u2 !== data2 && u2 !== data2.e && msg.put[">"] && msg.put[">"] > parseFloat(data2.e))
                return no("Certificate expired.");
              if (u2 !== data2 && data2.c && data2.w && (data2.c === certificant || data2.c.indexOf("*") > -1)) {
                let path2 = soul.indexOf("/") > -1 ? soul.replace(soul.substring(0, soul.indexOf("/") + 1), "") : "";
                String.match = String.match || Gun2.text.match;
                const w2 = Array.isArray(data2.w) ? data2.w : typeof data2.w === "object" || typeof data2.w === "string" ? [data2.w] : [];
                for (const lex of w2) {
                  if (String.match(path2, lex["#"]) && String.match(key, lex["."]) || !lex["."] && String.match(path2, lex["#"]) || !lex["#"] && String.match(key, lex["."]) || String.match(path2 ? path2 + "/" + key : key, lex["#"] || lex)) {
                    if (lex["+"] && lex["+"].indexOf("*") > -1 && path2 && path2.indexOf(certificant) == -1 && key.indexOf(certificant) == -1)
                      return no(`Path "${path2}" or key "${key}" must contain string "${certificant}".`);
                    if (data2.wb && (typeof data2.wb === "string" || (data2.wb || {})["#"])) {
                      var root2 = eve.as.root.$.back(-1);
                      if (typeof data2.wb === "string" && "~" !== data2.wb.slice(0, 1))
                        root2 = root2.get("~" + pub);
                      return root2.get(data2.wb).get(certificant).once((value) => {
                        if (value && (value === 1 || value === true))
                          return no(`Certificant ${certificant} blocked.`);
                        return cb(data2);
                      });
                    }
                    return cb(data2);
                  }
                }
                return no("Certificate verification fail.");
              }
            });
          return;
        };
        if ("pub" === key && "~" + pub === soul) {
          if (val === pub)
            return eve.to.next(msg);
          return no("Account not same!");
        }
        if ((tmp = user.is) && tmp.pub && !raw["*"] && !raw["+"] && (pub === tmp.pub || pub !== tmp.pub && ((msg._.msg || {}).opt || {}).cert)) {
          SEA2.opt.pack(msg.put, (packed) => {
            SEA2.sign(packed, user._.sea, async function(data2) {
              if (u2 === data2)
                return no(SEA2.err || "Signature fail.");
              msg.put[":"] = { ":": tmp = SEA2.opt.unpack(data2.m), "~": data2.s };
              msg.put["="] = tmp;
              if (pub === user.is.pub) {
                if (tmp = link_is(val))
                  (at2.sea.own[tmp] = at2.sea.own[tmp] || {})[pub] = 1;
                JSON.stringifyAsync(msg.put[":"], function(err, s2) {
                  if (err) {
                    return no(err || "Stringify error.");
                  }
                  msg.put[":"] = s2;
                  return eve.to.next(msg);
                });
                return;
              }
              if (pub !== user.is.pub && ((msg._.msg || {}).opt || {}).cert) {
                const cert = await S2.parse(msg._.msg.opt.cert);
                if (cert && cert.m && cert.s)
                  verify(cert, user.is.pub, (_2) => {
                    msg.put[":"]["+"] = cert;
                    msg.put[":"]["*"] = user.is.pub;
                    JSON.stringifyAsync(msg.put[":"], function(err, s2) {
                      if (err) {
                        return no(err || "Stringify error.");
                      }
                      msg.put[":"] = s2;
                      return eve.to.next(msg);
                    });
                    return;
                  });
              }
            }, { raw: 1 });
          });
          return;
        }
        SEA2.opt.pack(msg.put, (packed) => {
          SEA2.verify(packed, raw["*"] || pub, function(data2) {
            var tmp2;
            data2 = SEA2.opt.unpack(data2);
            if (u2 === data2)
              return no("Unverified data.");
            if ((tmp2 = link_is(data2)) && pub === SEA2.opt.pub(tmp2))
              (at2.sea.own[tmp2] = at2.sea.own[tmp2] || {})[pub] = 1;
            if (raw["+"] && raw["+"]["m"] && raw["+"]["s"] && raw["*"])
              verify(raw["+"], raw["*"], (_2) => {
                msg.put["="] = data2;
                return eve.to.next(msg);
              });
            else {
              msg.put["="] = data2;
              return eve.to.next(msg);
            }
          });
        });
        return;
      };
      check2.any = function(eve, msg, val, key, soul, at2, no, user) {
        if (at2.opt.secure) {
          return no("Soul missing public key at '" + key + "'.");
        }
        at2.on("secure", function(msg2) {
          this.off();
          if (!at2.opt.secure) {
            return eve.to.next(msg2);
          }
          no("Data cannot be changed.");
        }).on.on("secure", msg);
        return;
      };
      var valid = Gun2.valid, link_is = function(d2, l2) {
        return "string" == typeof (l2 = valid(d2)) && l2;
      };
      (Gun2.state || "").ify;
      var pubcut = /[^\w_-]/;
      SEA2.opt.pub = function(s2) {
        if (!s2) {
          return;
        }
        s2 = s2.split("~");
        if (!s2 || !(s2 = s2[1])) {
          return;
        }
        s2 = s2.split(pubcut).slice(0, 2);
        if (!s2 || 2 != s2.length) {
          return;
        }
        if ("@" === (s2[0] || "")[0]) {
          return;
        }
        s2 = s2.slice(0, 2).join(".");
        return s2;
      };
      SEA2.opt.stringy = function(t2) {
      };
      SEA2.opt.pack = function(d2, cb, k2, n2, s2) {
        var tmp, f2;
        if (SEA2.opt.check(d2)) {
          return cb(d2);
        }
        if (d2 && d2["#"] && d2["."] && d2[">"]) {
          tmp = d2[":"];
          f2 = 1;
        }
        JSON.parseAsync(f2 ? tmp : d2, function(err, meta2) {
          var sig = u2 !== (meta2 || "")[":"] && (meta2 || "")["~"];
          if (!sig) {
            cb(d2);
            return;
          }
          cb({ m: { "#": s2 || d2["#"], ".": k2 || d2["."], ":": (meta2 || "")[":"], ">": d2[">"] || Gun2.state.is(n2, k2) }, s: sig });
        });
      };
      var O2 = SEA2.opt;
      SEA2.opt.unpack = function(d2, k2, n2) {
        var tmp;
        if (u2 === d2) {
          return;
        }
        if (d2 && u2 !== (tmp = d2[":"])) {
          return tmp;
        }
        k2 = k2 || O2.fall_key;
        if (!n2 && O2.fall_val) {
          n2 = {};
          n2[k2] = O2.fall_val;
        }
        if (!k2 || !n2) {
          return;
        }
        if (d2 === n2[k2]) {
          return d2;
        }
        if (!SEA2.opt.check(n2[k2])) {
          return d2;
        }
        var soul = n2 && n2._ && n2._["#"] || O2.fall_soul, s2 = Gun2.state.is(n2, k2) || O2.fall_state;
        if (d2 && 4 === d2.length && soul === d2[0] && k2 === d2[1] && fl(s2) === fl(d2[3])) {
          return d2[2];
        }
        if (s2 < SEA2.opt.shuffle_attack) {
          return d2;
        }
      };
      SEA2.opt.shuffle_attack = 15463296e5;
      var fl = Math.floor;
    })(USE, "./index");
  })();
})(sea);
var SEA = sea.exports;
const word = "[a-fA-F\\d:]";
const b$1 = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
const v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
const v6seg = "[a-fA-F\\d]{1,4}";
const v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);
const ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b$1(options)}${v4}${b$1(options)})|(?:${b$1(options)}${v6}${b$1(options)})`, "g");
ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b$1(options)}${v4}${b$1(options)}`, "g");
ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b$1(options)}${v6}${b$1(options)}`, "g");
var ipRegex$1 = ip;
var require$$1$1 = [
  "aaa",
  "aarp",
  "abarth",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "ac",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "ad",
  "adac",
  "ads",
  "adult",
  "ae",
  "aeg",
  "aero",
  "aetna",
  "af",
  "afl",
  "africa",
  "ag",
  "agakhan",
  "agency",
  "ai",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "al",
  "alfaromeo",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "am",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "ao",
  "aol",
  "apartments",
  "app",
  "apple",
  "aq",
  "aquarelle",
  "ar",
  "arab",
  "aramco",
  "archi",
  "army",
  "arpa",
  "art",
  "arte",
  "as",
  "asda",
  "asia",
  "associates",
  "at",
  "athleta",
  "attorney",
  "au",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "avianca",
  "aw",
  "aws",
  "ax",
  "axa",
  "az",
  "azure",
  "ba",
  "baby",
  "baidu",
  "banamex",
  "bananarepublic",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bb",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "bd",
  "be",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bf",
  "bg",
  "bh",
  "bharti",
  "bi",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "biz",
  "bj",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bm",
  "bms",
  "bmw",
  "bn",
  "bnpparibas",
  "bo",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "br",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bs",
  "bt",
  "bugatti",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bv",
  "bw",
  "by",
  "bz",
  "bzh",
  "ca",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "cancerresearch",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "cat",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cbs",
  "cc",
  "cd",
  "center",
  "ceo",
  "cern",
  "cf",
  "cfa",
  "cfd",
  "cg",
  "ch",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "ci",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "cityeats",
  "ck",
  "cl",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "cm",
  "cn",
  "co",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "com",
  "comcast",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cookingchannel",
  "cool",
  "coop",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "cr",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "cu",
  "cuisinella",
  "cv",
  "cw",
  "cx",
  "cy",
  "cymru",
  "cyou",
  "cz",
  "dabur",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "de",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dj",
  "dk",
  "dm",
  "dnp",
  "do",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "dz",
  "earth",
  "eat",
  "ec",
  "eco",
  "edeka",
  "edu",
  "education",
  "ee",
  "eg",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "er",
  "ericsson",
  "erni",
  "es",
  "esq",
  "estate",
  "et",
  "etisalat",
  "eu",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fi",
  "fiat",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "fj",
  "fk",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "fm",
  "fo",
  "foo",
  "food",
  "foodnetwork",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "fr",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontdoor",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "ga",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gb",
  "gbiz",
  "gd",
  "gdn",
  "ge",
  "gea",
  "gent",
  "genting",
  "george",
  "gf",
  "gg",
  "ggee",
  "gh",
  "gi",
  "gift",
  "gifts",
  "gives",
  "giving",
  "gl",
  "glass",
  "gle",
  "global",
  "globo",
  "gm",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "gn",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "gov",
  "gp",
  "gq",
  "gr",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "gs",
  "gt",
  "gu",
  "guardian",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "gw",
  "gy",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hgtv",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hk",
  "hkt",
  "hm",
  "hn",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hoteles",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hr",
  "hsbc",
  "ht",
  "hu",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "id",
  "ie",
  "ieee",
  "ifm",
  "ikano",
  "il",
  "im",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "in",
  "inc",
  "industries",
  "infiniti",
  "info",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "int",
  "international",
  "intuit",
  "investments",
  "io",
  "ipiranga",
  "iq",
  "ir",
  "irish",
  "is",
  "ismaili",
  "ist",
  "istanbul",
  "it",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "je",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jm",
  "jmp",
  "jnj",
  "jo",
  "jobs",
  "joburg",
  "jot",
  "joy",
  "jp",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "ke",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kg",
  "kh",
  "ki",
  "kia",
  "kids",
  "kim",
  "kinder",
  "kindle",
  "kitchen",
  "kiwi",
  "km",
  "kn",
  "koeln",
  "komatsu",
  "kosher",
  "kp",
  "kpmg",
  "kpn",
  "kr",
  "krd",
  "kred",
  "kuokgroup",
  "kw",
  "ky",
  "kyoto",
  "kz",
  "la",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "lancia",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lb",
  "lc",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "li",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "linde",
  "link",
  "lipsy",
  "live",
  "living",
  "lk",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "loft",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "lr",
  "ls",
  "lt",
  "ltd",
  "ltda",
  "lu",
  "lundbeck",
  "luxe",
  "luxury",
  "lv",
  "ly",
  "ma",
  "macys",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "maserati",
  "mattel",
  "mba",
  "mc",
  "mckinsey",
  "md",
  "me",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "mg",
  "mh",
  "miami",
  "microsoft",
  "mil",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mk",
  "ml",
  "mlb",
  "mls",
  "mm",
  "mma",
  "mn",
  "mo",
  "mobi",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "mp",
  "mq",
  "mr",
  "ms",
  "msd",
  "mt",
  "mtn",
  "mtr",
  "mu",
  "museum",
  "music",
  "mutual",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "nab",
  "nagoya",
  "name",
  "natura",
  "navy",
  "nba",
  "nc",
  "ne",
  "nec",
  "net",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nf",
  "nfl",
  "ng",
  "ngo",
  "nhk",
  "ni",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nl",
  "no",
  "nokia",
  "northwesternmutual",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "np",
  "nr",
  "nra",
  "nrw",
  "ntt",
  "nu",
  "nyc",
  "nz",
  "obi",
  "observer",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "oldnavy",
  "ollo",
  "om",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "org",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "pa",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "passagens",
  "pay",
  "pccw",
  "pe",
  "pet",
  "pf",
  "pfizer",
  "pg",
  "ph",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "pk",
  "pl",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pm",
  "pn",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "post",
  "pr",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "pro",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "ps",
  "pt",
  "pub",
  "pw",
  "pwc",
  "py",
  "qa",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "re",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "ro",
  "rocher",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rs",
  "rsvp",
  "ru",
  "rugby",
  "ruhr",
  "run",
  "rw",
  "rwe",
  "ryukyu",
  "sa",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sb",
  "sbi",
  "sbs",
  "sc",
  "sca",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scot",
  "sd",
  "se",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "ses",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "sg",
  "sh",
  "shangrila",
  "sharp",
  "shaw",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "showtime",
  "si",
  "silk",
  "sina",
  "singles",
  "site",
  "sj",
  "sk",
  "ski",
  "skin",
  "sky",
  "skype",
  "sl",
  "sling",
  "sm",
  "smart",
  "smile",
  "sn",
  "sncf",
  "so",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "sr",
  "srl",
  "ss",
  "st",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "su",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "sv",
  "swatch",
  "swiss",
  "sx",
  "sy",
  "sydney",
  "systems",
  "sz",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tc",
  "tci",
  "td",
  "tdk",
  "team",
  "tech",
  "technology",
  "tel",
  "temasek",
  "tennis",
  "teva",
  "tf",
  "tg",
  "th",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tiffany",
  "tips",
  "tires",
  "tirol",
  "tj",
  "tjmaxx",
  "tjx",
  "tk",
  "tkmaxx",
  "tl",
  "tm",
  "tmall",
  "tn",
  "to",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "tr",
  "trade",
  "trading",
  "training",
  "travel",
  "travelchannel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tt",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tv",
  "tvs",
  "tw",
  "tz",
  "ua",
  "ubank",
  "ubs",
  "ug",
  "uk",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "us",
  "uy",
  "uz",
  "va",
  "vacations",
  "vana",
  "vanguard",
  "vc",
  "ve",
  "vegas",
  "ventures",
  "verisign",
  "verm\xF6gensberater",
  "verm\xF6gensberatung",
  "versicherung",
  "vet",
  "vg",
  "vi",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vn",
  "vodka",
  "volkswagen",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vu",
  "vuelos",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wed",
  "wedding",
  "weibo",
  "weir",
  "wf",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "ws",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xfinity",
  "xihuan",
  "xin",
  "xxx",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "ye",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yt",
  "yun",
  "za",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zm",
  "zone",
  "zuerich",
  "zw",
  "\u03B5\u03BB",
  "\u03B5\u03C5",
  "\u0431\u0433",
  "\u0431\u0435\u043B",
  "\u0434\u0435\u0442\u0438",
  "\u0435\u044E",
  "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
  "\u043A\u043E\u043C",
  "\u043C\u043A\u0434",
  "\u043C\u043E\u043D",
  "\u043C\u043E\u0441\u043A\u0432\u0430",
  "\u043E\u043D\u043B\u0430\u0439\u043D",
  "\u043E\u0440\u0433",
  "\u0440\u0443\u0441",
  "\u0440\u0444",
  "\u0441\u0430\u0439\u0442",
  "\u0441\u0440\u0431",
  "\u0443\u043A\u0440",
  "\u049B\u0430\u0437",
  "\u0570\u0561\u0575",
  "\u05D9\u05E9\u05E8\u05D0\u05DC",
  "\u05E7\u05D5\u05DD",
  "\u0627\u0628\u0648\u0638\u0628\u064A",
  "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
  "\u0627\u0631\u0627\u0645\u0643\u0648",
  "\u0627\u0644\u0627\u0631\u062F\u0646",
  "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
  "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
  "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
  "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
  "\u0627\u0644\u0645\u063A\u0631\u0628",
  "\u0627\u0645\u0627\u0631\u0627\u062A",
  "\u0627\u06CC\u0631\u0627\u0646",
  "\u0628\u0627\u0631\u062A",
  "\u0628\u0627\u0632\u0627\u0631",
  "\u0628\u064A\u062A\u0643",
  "\u0628\u06BE\u0627\u0631\u062A",
  "\u062A\u0648\u0646\u0633",
  "\u0633\u0648\u062F\u0627\u0646",
  "\u0633\u0648\u0631\u064A\u0629",
  "\u0634\u0628\u0643\u0629",
  "\u0639\u0631\u0627\u0642",
  "\u0639\u0631\u0628",
  "\u0639\u0645\u0627\u0646",
  "\u0641\u0644\u0633\u0637\u064A\u0646",
  "\u0642\u0637\u0631",
  "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
  "\u0643\u0648\u0645",
  "\u0645\u0635\u0631",
  "\u0645\u0644\u064A\u0633\u064A\u0627",
  "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
  "\u0645\u0648\u0642\u0639",
  "\u0647\u0645\u0631\u0627\u0647",
  "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
  "\u0680\u0627\u0631\u062A",
  "\u0915\u0949\u092E",
  "\u0928\u0947\u091F",
  "\u092D\u093E\u0930\u0924",
  "\u092D\u093E\u0930\u0924\u092E\u094D",
  "\u092D\u093E\u0930\u094B\u0924",
  "\u0938\u0902\u0917\u0920\u0928",
  "\u09AC\u09BE\u0982\u09B2\u09BE",
  "\u09AD\u09BE\u09B0\u09A4",
  "\u09AD\u09BE\u09F0\u09A4",
  "\u0A2D\u0A3E\u0A30\u0A24",
  "\u0AAD\u0ABE\u0AB0\u0AA4",
  "\u0B2D\u0B3E\u0B30\u0B24",
  "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
  "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
  "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
  "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
  "\u0CAD\u0CBE\u0CB0\u0CA4",
  "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
  "\u0DBD\u0D82\u0D9A\u0DCF",
  "\u0E04\u0E2D\u0E21",
  "\u0E44\u0E17\u0E22",
  "\u0EA5\u0EB2\u0EA7",
  "\u10D2\u10D4",
  "\u307F\u3093\u306A",
  "\u30A2\u30DE\u30BE\u30F3",
  "\u30AF\u30E9\u30A6\u30C9",
  "\u30B0\u30FC\u30B0\u30EB",
  "\u30B3\u30E0",
  "\u30B9\u30C8\u30A2",
  "\u30BB\u30FC\u30EB",
  "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
  "\u30DD\u30A4\u30F3\u30C8",
  "\u4E16\u754C",
  "\u4E2D\u4FE1",
  "\u4E2D\u56FD",
  "\u4E2D\u570B",
  "\u4E2D\u6587\u7F51",
  "\u4E9A\u9A6C\u900A",
  "\u4F01\u4E1A",
  "\u4F5B\u5C71",
  "\u4FE1\u606F",
  "\u5065\u5EB7",
  "\u516B\u5366",
  "\u516C\u53F8",
  "\u516C\u76CA",
  "\u53F0\u6E7E",
  "\u53F0\u7063",
  "\u5546\u57CE",
  "\u5546\u5E97",
  "\u5546\u6807",
  "\u5609\u91CC",
  "\u5609\u91CC\u5927\u9152\u5E97",
  "\u5728\u7EBF",
  "\u5927\u62FF",
  "\u5929\u4E3B\u6559",
  "\u5A31\u4E50",
  "\u5BB6\u96FB",
  "\u5E7F\u4E1C",
  "\u5FAE\u535A",
  "\u6148\u5584",
  "\u6211\u7231\u4F60",
  "\u624B\u673A",
  "\u62DB\u8058",
  "\u653F\u52A1",
  "\u653F\u5E9C",
  "\u65B0\u52A0\u5761",
  "\u65B0\u95FB",
  "\u65F6\u5C1A",
  "\u66F8\u7C4D",
  "\u673A\u6784",
  "\u6DE1\u9A6C\u9521",
  "\u6E38\u620F",
  "\u6FB3\u9580",
  "\u70B9\u770B",
  "\u79FB\u52A8",
  "\u7EC4\u7EC7\u673A\u6784",
  "\u7F51\u5740",
  "\u7F51\u5E97",
  "\u7F51\u7AD9",
  "\u7F51\u7EDC",
  "\u8054\u901A",
  "\u8BFA\u57FA\u4E9A",
  "\u8C37\u6B4C",
  "\u8D2D\u7269",
  "\u901A\u8CA9",
  "\u96C6\u56E2",
  "\u96FB\u8A0A\u76C8\u79D1",
  "\u98DE\u5229\u6D66",
  "\u98DF\u54C1",
  "\u9910\u5385",
  "\u9999\u683C\u91CC\u62C9",
  "\u9999\u6E2F",
  "\uB2F7\uB137",
  "\uB2F7\uCEF4",
  "\uC0BC\uC131",
  "\uD55C\uAD6D"
];
const ipRegex = ipRegex$1;
const tlds = require$$1$1;
var urlRegex = (options) => {
  options = {
    strict: true,
    ...options
  };
  const protocol = `(?:(?:[a-z]+:)?//)${options.strict ? "" : "?"}`;
  const auth = "(?:\\S+(?::\\S*)?@)?";
  const ip2 = ipRegex.v4().source;
  const host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  const domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  const tld = `(?:\\.${options.strict ? "(?:[a-z\\u00a1-\\uffff]{2,})" : `(?:${tlds.sort((a2, b2) => b2.length - a2.length).join("|")})`})\\.?`;
  const port = "(?::\\d{2,5})?";
  const path2 = '(?:[/?#][^\\s"]*)?';
  const regex2 = `(?:${protocol}|www\\.)${auth}(?:localhost|${ip2}|${host}${domain}${tld})${port}${path2}`;
  return options.exact ? new RegExp(`(?:^${regex2}$)`, "i") : new RegExp(regex2, "ig");
};
function isArray$1(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
function isString$2(value) {
  return typeof value === "string";
}
function isNumber$1(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike$1(value) && getTag(value) == "[object Boolean]";
}
function isObject$3(value) {
  return typeof value === "object";
}
function isObjectLike$1(value) {
  return isObject$3(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys2) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys2.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path2 = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString$2(key) || isArray$1(key)) {
    src = key;
    path2 = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path2 = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path: path2, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray$1(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray$1(key) ? key.join(".") : key;
}
function get$3(obj, path2) {
  let list3 = [];
  let arr = false;
  const deepGet = (obj2, path3, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path3[index2]) {
      list3.push(obj2);
    } else {
      let key = path3[index2];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index2 === path3.length - 1 && (isString$2(value) || isNumber$1(value) || isBoolean(value))) {
        list3.push(toString$1(value));
      } else if (isArray$1(value)) {
        arr = true;
        for (let i2 = 0, len2 = value.length; i2 < len2; i2 += 1) {
          deepGet(value[i2], path3, index2 + 1);
        }
      } else if (path3.length) {
        deepGet(value, path3, index2 + 1);
      }
    }
  };
  deepGet(obj, isString$2(path2) ? path2.split(".") : path2, 0);
  return arr ? list3 : list3[0];
}
const MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
const BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
};
const FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
const AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get$3,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache2 = /* @__PURE__ */ new Map();
  const m2 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache2.has(numTokens)) {
        return cache2.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n2 = parseFloat(Math.round(norm2 * m2) / m2);
      cache2.set(numTokens, n2);
      return n2;
    },
    clear() {
      cache2.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys2 = []) {
    this.keys = keys2;
    this._keysMap = {};
    keys2.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString$2(this.docs[0])) {
      this.docs.forEach((doc2, docIndex) => {
        this._addString(doc2, docIndex);
      });
    } else {
      this.docs.forEach((doc2, docIndex) => {
        this._addObject(doc2, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc2) {
    const idx = this.size();
    if (isString$2(doc2)) {
      this._addString(doc2, idx);
    } else {
      this._addObject(doc2, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len2 = this.size(); i2 < len2; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc2, docIndex) {
    if (!isDefined(doc2) || isBlank(doc2)) {
      return;
    }
    let record = {
      v: doc2,
      i: docIndex,
      n: this.norm.get(doc2)
    };
    this.records.push(record);
  }
  _addObject(doc2, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc2) : this.getFn(doc2, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray$1(value)) {
        let subRecords = [];
        const stack2 = [{ nestedArrIndex: -1, value }];
        while (stack2.length) {
          const { nestedArrIndex, value: value2 } = stack2.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString$2(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray$1(value2)) {
            value2.forEach((item, k2) => {
              stack2.push({
                nestedArrIndex: k2,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString$2(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data2, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys: keys2, records } = data2;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors: errors2 = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors2 / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end = -1;
  let i2 = 0;
  for (let len2 = matchmask.length; i2 < len2; i2 += 1) {
    let match5 = matchmask[i2];
    if (match5 && start2 === -1) {
      start2 = i2;
    } else if (!match5 && start2 !== -1) {
      end = i2 - 1;
      if (end - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start2 >= minMatchCharLength) {
    indices.push([start2, i2 - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text3, pattern, patternAlphabet, {
  location: location2 = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text3.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text3.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index2 + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i2) - 1;
    for (let j2 = finish; j2 >= start2; j2 -= 1) {
      let currentLocation = j2 - 1;
      let charMatch = patternAlphabet[text3.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];
      }
      if (bitArr[j2] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i2 = 0, len2 = pattern.length; i2 < len2; i2 += 1) {
    const char = pattern.charAt(i2);
    mask[char] = (mask[char] || 0) | 1 << len2 - i2 - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len2 = this.pattern.length;
    if (len2 > MAX_BITS) {
      let i2 = 0;
      const remainder = len2 % MAX_BITS;
      const end = len2 - remainder;
      while (i2 < end) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len2 - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text3) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text3 = text3.toLowerCase();
    }
    if (this.pattern === text3) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text3.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text3, pattern, alphabet, {
        location: location2 + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches2 = pattern.match(exp);
  return matches2 ? matches2[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text3) {
    const isMatch = text3 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text3) {
    const index2 = text3.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text3.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text3) {
    const isMatch = text3.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text3) {
    const isMatch = !text3.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text3.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text3) {
    const isMatch = text3.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text3.length - this.pattern.length, text3.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text3) {
    const isMatch = !text3.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text3.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text3) {
    return this._bitapSearch.searchIn(text3);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text3) {
    let location2 = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text3.indexOf(this.pattern, location2)) > -1) {
      location2 = index2 + patternLen;
      indices.push([index2, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i2 = 0, len2 = query.length; i2 < len2; i2 += 1) {
      const queryItem = query[i2];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isMultiMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isSingleMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_2, options) {
    return options.useExtendedSearch;
  }
  searchIn(text3) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text3 = isCaseSensitive ? text3 : text3.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {
        const searcher = searchers2[j2];
        const { isMatch, indices, score } = searcher.search(text3);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i2 = 0, len2 = registeredSearchers.length; i2 < len2; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray$1(query) && isObject$3(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse$2(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys2 = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString$2(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys2[0]
    };
    keys2.forEach((key) => {
      const value = query2[key];
      if (isArray$1(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data2) {
  const matches2 = result.matches;
  data2.matches = [];
  if (!isDefined(matches2)) {
    return;
  }
  matches2.forEach((match5) => {
    if (!isDefined(match5.indices) || !match5.indices.length) {
      return;
    }
    const { indices, value } = match5;
    let obj = {
      indices,
      value
    };
    if (match5.key) {
      obj.key = match5.key.src;
    }
    if (match5.idx > -1) {
      obj.refIndex = match5.idx;
    }
    data2.matches.push(obj);
  });
}
function transformScore(result, data2) {
  data2.score = result.score;
}
function format$2(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data2 = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data2);
      });
    }
    return data2;
  });
}
class Fuse {
  constructor(docs, options = {}, index2) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc2) {
    if (!isDefined(doc2)) {
      return;
    }
    this._docs.push(doc2);
    this._myIndex.add(doc2);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len2 = this._docs.length; i2 < len2; i2 += 1) {
      const doc2 = this._docs[i2];
      if (predicate(doc2, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len2 -= 1;
        results.push(doc2);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString$2(query) ? isString$2(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber$1(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format$2(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text3, i: idx, n: norm2 }) => {
      if (!isDefined(text3)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text3);
      if (isMatch) {
        results.push({
          item: text3,
          idx,
          matches: [{ score, value: text3, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse$2(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches2 = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches2 && matches2.length) {
          return [
            {
              idx,
              item,
              matches: matches2
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len2 = node.children.length; i2 < len2; i2 += 1) {
        const child = node.children[i2];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches: matches2 }) => {
            resultMap[idx].matches.push(...matches2);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys: keys2, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches2 = [];
      keys2.forEach((key, keyIndex) => {
        matches2.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches2.length) {
        results.push({
          idx,
          item,
          matches: matches2
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches2 = [];
    if (isArray$1(value)) {
      value.forEach(({ v: text3, i: idx, n: norm2 }) => {
        if (!isDefined(text3)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text3);
        if (isMatch) {
          matches2.push({
            score,
            key,
            value: text3,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text3, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text3);
      if (isMatch) {
        matches2.push({ score, key, value: text3, norm: norm2, indices });
      }
    }
    return matches2;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse$2;
}
{
  register(ExtendedSearch);
}
var jszip_min = { exports: {} };
/*!

JSZip v3.10.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(module2, exports2) {
  !function(e2) {
    module2.exports = e2();
  }(function() {
    return function s2(a2, o2, h2) {
      function u2(r2, e3) {
        if (!o2[r2]) {
          if (!a2[r2]) {
            var t2 = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e3 && t2)
              return t2(r2, true);
            if (l2)
              return l2(r2, true);
            var n2 = new Error("Cannot find module '" + r2 + "'");
            throw n2.code = "MODULE_NOT_FOUND", n2;
          }
          var i2 = o2[r2] = { exports: {} };
          a2[r2][0].call(i2.exports, function(e4) {
            var t3 = a2[r2][1][e4];
            return u2(t3 || e4);
          }, i2, i2.exports, s2, a2, o2, h2);
        }
        return o2[r2].exports;
      }
      for (var l2 = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < h2.length; e2++)
        u2(h2[e2]);
      return u2;
    }({ 1: [function(e2, t2, r2) {
      var d2 = e2("./utils"), c2 = e2("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r2.encode = function(e3) {
        for (var t3, r3, n2, i2, s2, a2, o2, h2 = [], u2 = 0, l2 = e3.length, f2 = l2, c3 = "string" !== d2.getTypeOf(e3); u2 < e3.length; )
          f2 = l2 - u2, n2 = c3 ? (t3 = e3[u2++], r3 = u2 < l2 ? e3[u2++] : 0, u2 < l2 ? e3[u2++] : 0) : (t3 = e3.charCodeAt(u2++), r3 = u2 < l2 ? e3.charCodeAt(u2++) : 0, u2 < l2 ? e3.charCodeAt(u2++) : 0), i2 = t3 >> 2, s2 = (3 & t3) << 4 | r3 >> 4, a2 = 1 < f2 ? (15 & r3) << 2 | n2 >> 6 : 64, o2 = 2 < f2 ? 63 & n2 : 64, h2.push(p2.charAt(i2) + p2.charAt(s2) + p2.charAt(a2) + p2.charAt(o2));
        return h2.join("");
      }, r2.decode = function(e3) {
        var t3, r3, n2, i2, s2, a2, o2 = 0, h2 = 0, u2 = "data:";
        if (e3.substr(0, u2.length) === u2)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l2, f2 = 3 * (e3 = e3.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
        if (e3.charAt(e3.length - 1) === p2.charAt(64) && f2--, e3.charAt(e3.length - 2) === p2.charAt(64) && f2--, f2 % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l2 = c2.uint8array ? new Uint8Array(0 | f2) : new Array(0 | f2); o2 < e3.length; )
          t3 = p2.indexOf(e3.charAt(o2++)) << 2 | (i2 = p2.indexOf(e3.charAt(o2++))) >> 4, r3 = (15 & i2) << 4 | (s2 = p2.indexOf(e3.charAt(o2++))) >> 2, n2 = (3 & s2) << 6 | (a2 = p2.indexOf(e3.charAt(o2++))), l2[h2++] = t3, 64 !== s2 && (l2[h2++] = r3), 64 !== a2 && (l2[h2++] = n2);
        return l2;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t2, r2) {
      var n2 = e2("./external"), i2 = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), a2 = e2("./stream/DataLengthProbe");
      function o2(e3, t3, r3, n3, i3) {
        this.compressedSize = e3, this.uncompressedSize = t3, this.crc32 = r3, this.compression = n3, this.compressedContent = i3;
      }
      o2.prototype = { getContentWorker: function() {
        var e3 = new i2(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a2("data_length")), t3 = this;
        return e3.on("end", function() {
          if (this.streamInfo.data_length !== t3.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e3;
      }, getCompressedWorker: function() {
        return new i2(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o2.createWorkerFrom = function(e3, t3, r3) {
        return e3.pipe(new s2()).pipe(new a2("uncompressedSize")).pipe(t3.compressWorker(r3)).pipe(new a2("compressedSize")).withStreamInfo("compression", t3);
      }, t2.exports = o2;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t2, r2) {
      var n2 = e2("./stream/GenericWorker");
      r2.STORE = { magic: "\0\0", compressWorker: function(e3) {
        return new n2("STORE compression");
      }, uncompressWorker: function() {
        return new n2("STORE decompression");
      } }, r2.DEFLATE = e2("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t2, r2) {
      var n2 = e2("./utils");
      var o2 = function() {
        for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
          e3 = r3;
          for (var n3 = 0; n3 < 8; n3++)
            e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
          t3[r3] = e3;
        }
        return t3;
      }();
      t2.exports = function(e3, t3) {
        return void 0 !== e3 && e3.length ? "string" !== n2.getTypeOf(e3) ? function(e4, t4, r3, n3) {
          var i2 = o2, s2 = n3 + r3;
          e4 ^= -1;
          for (var a2 = n3; a2 < s2; a2++)
            e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t4[a2])];
          return -1 ^ e4;
        }(0 | t3, e3, e3.length, 0) : function(e4, t4, r3, n3) {
          var i2 = o2, s2 = n3 + r3;
          e4 ^= -1;
          for (var a2 = n3; a2 < s2; a2++)
            e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t4.charCodeAt(a2))];
          return -1 ^ e4;
        }(0 | t3, e3, e3.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e2, t2, r2) {
      r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
    }, {}], 6: [function(e2, t2, r2) {
      var n2 = null;
      n2 = "undefined" != typeof Promise ? Promise : e2("lie"), t2.exports = { Promise: n2 };
    }, { lie: 37 }], 7: [function(e2, t2, r2) {
      var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i2 = e2("pako"), s2 = e2("./utils"), a2 = e2("./stream/GenericWorker"), o2 = n2 ? "uint8array" : "array";
      function h2(e3, t3) {
        a2.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t3, this.meta = {};
      }
      r2.magic = "\b\0", s2.inherits(h2, a2), h2.prototype.processChunk = function(e3) {
        this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(o2, e3.data), false);
      }, h2.prototype.flush = function() {
        a2.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
      }, h2.prototype.cleanUp = function() {
        a2.prototype.cleanUp.call(this), this._pako = null;
      }, h2.prototype._createPako = function() {
        this._pako = new i2[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t3 = this;
        this._pako.onData = function(e3) {
          t3.push({ data: e3, meta: t3.meta });
        };
      }, r2.compressWorker = function(e3) {
        return new h2("Deflate", e3);
      }, r2.uncompressWorker = function() {
        return new h2("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t2, r2) {
      function A2(e3, t3) {
        var r3, n3 = "";
        for (r3 = 0; r3 < t3; r3++)
          n3 += String.fromCharCode(255 & e3), e3 >>>= 8;
        return n3;
      }
      function n2(e3, t3, r3, n3, i3, s3) {
        var a2, o2, h2 = e3.file, u2 = e3.compression, l2 = s3 !== O2.utf8encode, f2 = I2.transformTo("string", s3(h2.name)), c2 = I2.transformTo("string", O2.utf8encode(h2.name)), d2 = h2.comment, p2 = I2.transformTo("string", s3(d2)), m2 = I2.transformTo("string", O2.utf8encode(d2)), _2 = c2.length !== h2.name.length, g2 = m2.length !== d2.length, b2 = "", v2 = "", y2 = "", w2 = h2.dir, k2 = h2.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t3 && !r3 || (x2.crc32 = e3.crc32, x2.compressedSize = e3.compressedSize, x2.uncompressedSize = e3.uncompressedSize);
        var S2 = 0;
        t3 && (S2 |= 8), l2 || !_2 && !g2 || (S2 |= 2048);
        var z2 = 0, C2 = 0;
        w2 && (z2 |= 16), "UNIX" === i3 ? (C2 = 798, z2 |= function(e4, t4) {
          var r4 = e4;
          return e4 || (r4 = t4 ? 16893 : 33204), (65535 & r4) << 16;
        }(h2.unixPermissions, w2)) : (C2 = 20, z2 |= function(e4) {
          return 63 & (e4 || 0);
        }(h2.dosPermissions)), a2 = k2.getUTCHours(), a2 <<= 6, a2 |= k2.getUTCMinutes(), a2 <<= 5, a2 |= k2.getUTCSeconds() / 2, o2 = k2.getUTCFullYear() - 1980, o2 <<= 4, o2 |= k2.getUTCMonth() + 1, o2 <<= 5, o2 |= k2.getUTCDate(), _2 && (v2 = A2(1, 1) + A2(B2(f2), 4) + c2, b2 += "up" + A2(v2.length, 2) + v2), g2 && (y2 = A2(1, 1) + A2(B2(p2), 4) + m2, b2 += "uc" + A2(y2.length, 2) + y2);
        var E2 = "";
        return E2 += "\n\0", E2 += A2(S2, 2), E2 += u2.magic, E2 += A2(a2, 2), E2 += A2(o2, 2), E2 += A2(x2.crc32, 4), E2 += A2(x2.compressedSize, 4), E2 += A2(x2.uncompressedSize, 4), E2 += A2(f2.length, 2), E2 += A2(b2.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E2 + f2 + b2, dirRecord: R2.CENTRAL_FILE_HEADER + A2(C2, 2) + E2 + A2(p2.length, 2) + "\0\0\0\0" + A2(z2, 4) + A2(n3, 4) + f2 + b2 + p2 };
      }
      var I2 = e2("../utils"), i2 = e2("../stream/GenericWorker"), O2 = e2("../utf8"), B2 = e2("../crc32"), R2 = e2("../signature");
      function s2(e3, t3, r3, n3) {
        i2.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r3, this.encodeFileName = n3, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I2.inherits(s2, i2), s2.prototype.push = function(e3) {
        var t3 = e3.meta.percent || 0, r3 = this.entriesCount, n3 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i2.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r3 ? (t3 + 100 * (r3 - n3 - 1)) / r3 : 100 } }));
      }, s2.prototype.openedSource = function(e3) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
        var t3 = this.streamFiles && !e3.file.dir;
        if (t3) {
          var r3 = n2(e3, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r3.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s2.prototype.closedSource = function(e3) {
        this.accumulate = false;
        var t3 = this.streamFiles && !e3.file.dir, r3 = n2(e3, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r3.dirRecord), t3)
          this.push({ data: function(e4) {
            return R2.DATA_DESCRIPTOR + A2(e4.crc32, 4) + A2(e4.compressedSize, 4) + A2(e4.uncompressedSize, 4);
          }(e3), meta: { percent: 100 } });
        else
          for (this.push({ data: r3.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s2.prototype.flush = function() {
        for (var e3 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
          this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
        var r3 = this.bytesWritten - e3, n3 = function(e4, t4, r4, n4, i3) {
          var s3 = I2.transformTo("string", i3(n4));
          return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e4, 2) + A2(e4, 2) + A2(t4, 4) + A2(r4, 4) + A2(s3.length, 2) + s3;
        }(this.dirRecords.length, r3, e3, this.zipComment, this.encodeFileName);
        this.push({ data: n3, meta: { percent: 100 } });
      }, s2.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s2.prototype.registerPrevious = function(e3) {
        this._sources.push(e3);
        var t3 = this;
        return e3.on("data", function(e4) {
          t3.processChunk(e4);
        }), e3.on("end", function() {
          t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
        }), e3.on("error", function(e4) {
          t3.error(e4);
        }), this;
      }, s2.prototype.resume = function() {
        return !!i2.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s2.prototype.error = function(e3) {
        var t3 = this._sources;
        if (!i2.prototype.error.call(this, e3))
          return false;
        for (var r3 = 0; r3 < t3.length; r3++)
          try {
            t3[r3].error(e3);
          } catch (e4) {
          }
        return true;
      }, s2.prototype.lock = function() {
        i2.prototype.lock.call(this);
        for (var e3 = this._sources, t3 = 0; t3 < e3.length; t3++)
          e3[t3].lock();
      }, t2.exports = s2;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t2, r2) {
      var u2 = e2("../compressions"), n2 = e2("./ZipFileWorker");
      r2.generateWorker = function(e3, a2, t3) {
        var o2 = new n2(a2.streamFiles, t3, a2.platform, a2.encodeFileName), h2 = 0;
        try {
          e3.forEach(function(e4, t4) {
            h2++;
            var r3 = function(e5, t5) {
              var r4 = e5 || t5, n4 = u2[r4];
              if (!n4)
                throw new Error(r4 + " is not a valid compression method !");
              return n4;
            }(t4.options.compression, a2.compression), n3 = t4.options.compressionOptions || a2.compressionOptions || {}, i2 = t4.dir, s2 = t4.date;
            t4._compressWorker(r3, n3).withStreamInfo("file", { name: e4, dir: i2, date: s2, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o2);
          }), o2.entriesCount = h2;
        } catch (e4) {
          o2.error(e4);
        }
        return o2;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t2, r2) {
      function n2() {
        if (!(this instanceof n2))
          return new n2();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e3 = new n2();
          for (var t3 in this)
            "function" != typeof this[t3] && (e3[t3] = this[t3]);
          return e3;
        };
      }
      (n2.prototype = e2("./object")).loadAsync = e2("./load"), n2.support = e2("./support"), n2.defaults = e2("./defaults"), n2.version = "3.10.0", n2.loadAsync = function(e3, t3) {
        return new n2().loadAsync(e3, t3);
      }, n2.external = e2("./external"), t2.exports = n2;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t2, r2) {
      var u2 = e2("./utils"), i2 = e2("./external"), n2 = e2("./utf8"), s2 = e2("./zipEntries"), a2 = e2("./stream/Crc32Probe"), l2 = e2("./nodejsUtils");
      function f2(n3) {
        return new i2.Promise(function(e3, t3) {
          var r3 = n3.decompressed.getContentWorker().pipe(new a2());
          r3.on("error", function(e4) {
            t3(e4);
          }).on("end", function() {
            r3.streamInfo.crc32 !== n3.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e3();
          }).resume();
        });
      }
      t2.exports = function(e3, o2) {
        var h2 = this;
        return o2 = u2.extend(o2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l2.isNode && l2.isStream(e3) ? i2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u2.prepareContent("the loaded zip file", e3, true, o2.optimizedBinaryString, o2.base64).then(function(e4) {
          var t3 = new s2(o2);
          return t3.load(e4), t3;
        }).then(function(e4) {
          var t3 = [i2.Promise.resolve(e4)], r3 = e4.files;
          if (o2.checkCRC32)
            for (var n3 = 0; n3 < r3.length; n3++)
              t3.push(f2(r3[n3]));
          return i2.Promise.all(t3);
        }).then(function(e4) {
          for (var t3 = e4.shift(), r3 = t3.files, n3 = 0; n3 < r3.length; n3++) {
            var i3 = r3[n3], s3 = i3.fileNameStr, a3 = u2.resolve(i3.fileNameStr);
            h2.file(a3, i3.decompressed, { binary: true, optimizedBinaryString: true, date: i3.date, dir: i3.dir, comment: i3.fileCommentStr.length ? i3.fileCommentStr : null, unixPermissions: i3.unixPermissions, dosPermissions: i3.dosPermissions, createFolders: o2.createFolders }), i3.dir || (h2.file(a3).unsafeOriginalName = s3);
          }
          return t3.zipComment.length && (h2.comment = t3.zipComment), h2;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i2 = e2("../stream/GenericWorker");
      function s2(e3, t3) {
        i2.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t3);
      }
      n2.inherits(s2, i2), s2.prototype._bindStream = function(e3) {
        var t3 = this;
        (this._stream = e3).pause(), e3.on("data", function(e4) {
          t3.push({ data: e4, meta: { percent: 0 } });
        }).on("error", function(e4) {
          t3.isPaused ? this.generatedError = e4 : t3.error(e4);
        }).on("end", function() {
          t3.isPaused ? t3._upstreamEnded = true : t3.end();
        });
      }, s2.prototype.pause = function() {
        return !!i2.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s2.prototype.resume = function() {
        return !!i2.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t2.exports = s2;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t2, r2) {
      var i2 = e2("readable-stream").Readable;
      function n2(e3, t3, r3) {
        i2.call(this, t3), this._helper = e3;
        var n3 = this;
        e3.on("data", function(e4, t4) {
          n3.push(e4) || n3._helper.pause(), r3 && r3(t4);
        }).on("error", function(e4) {
          n3.emit("error", e4);
        }).on("end", function() {
          n3.push(null);
        });
      }
      e2("../utils").inherits(n2, i2), n2.prototype._read = function() {
        this._helper.resume();
      }, t2.exports = n2;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t2, r2) {
      t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t3) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e3, t3);
        if ("number" == typeof e3)
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e3, t3);
      }, allocBuffer: function(e3) {
        if (Buffer.alloc)
          return Buffer.alloc(e3);
        var t3 = new Buffer(e3);
        return t3.fill(0), t3;
      }, isBuffer: function(e3) {
        return Buffer.isBuffer(e3);
      }, isStream: function(e3) {
        return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
      } };
    }, {}], 15: [function(e2, t2, r2) {
      function s2(e3, t3, r3) {
        var n3, i3 = u2.getTypeOf(t3), s3 = u2.extend(r3 || {}, f2);
        s3.date = s3.date || new Date(), null !== s3.compression && (s3.compression = s3.compression.toUpperCase()), "string" == typeof s3.unixPermissions && (s3.unixPermissions = parseInt(s3.unixPermissions, 8)), s3.unixPermissions && 16384 & s3.unixPermissions && (s3.dir = true), s3.dosPermissions && 16 & s3.dosPermissions && (s3.dir = true), s3.dir && (e3 = g2(e3)), s3.createFolders && (n3 = _2(e3)) && b2.call(this, n3, true);
        var a3 = "string" === i3 && false === s3.binary && false === s3.base64;
        r3 && void 0 !== r3.binary || (s3.binary = !a3), (t3 instanceof c2 && 0 === t3.uncompressedSize || s3.dir || !t3 || 0 === t3.length) && (s3.base64 = false, s3.binary = true, t3 = "", s3.compression = "STORE", i3 = "string");
        var o3 = null;
        o3 = t3 instanceof c2 || t3 instanceof l2 ? t3 : p2.isNode && p2.isStream(t3) ? new m2(e3, t3) : u2.prepareContent(e3, t3, s3.binary, s3.optimizedBinaryString, s3.base64);
        var h3 = new d2(e3, o3, s3);
        this.files[e3] = h3;
      }
      var i2 = e2("./utf8"), u2 = e2("./utils"), l2 = e2("./stream/GenericWorker"), a2 = e2("./stream/StreamHelper"), f2 = e2("./defaults"), c2 = e2("./compressedObject"), d2 = e2("./zipObject"), o2 = e2("./generate"), p2 = e2("./nodejsUtils"), m2 = e2("./nodejs/NodejsStreamInputAdapter"), _2 = function(e3) {
        "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
        var t3 = e3.lastIndexOf("/");
        return 0 < t3 ? e3.substring(0, t3) : "";
      }, g2 = function(e3) {
        return "/" !== e3.slice(-1) && (e3 += "/"), e3;
      }, b2 = function(e3, t3) {
        return t3 = void 0 !== t3 ? t3 : f2.createFolders, e3 = g2(e3), this.files[e3] || s2.call(this, e3, null, { dir: true, createFolders: t3 }), this.files[e3];
      };
      function h2(e3) {
        return "[object RegExp]" === Object.prototype.toString.call(e3);
      }
      var n2 = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e3) {
        var t3, r3, n3;
        for (t3 in this.files)
          n3 = this.files[t3], (r3 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e3(r3, n3);
      }, filter: function(r3) {
        var n3 = [];
        return this.forEach(function(e3, t3) {
          r3(e3, t3) && n3.push(t3);
        }), n3;
      }, file: function(e3, t3, r3) {
        if (1 !== arguments.length)
          return e3 = this.root + e3, s2.call(this, e3, t3, r3), this;
        if (h2(e3)) {
          var n3 = e3;
          return this.filter(function(e4, t4) {
            return !t4.dir && n3.test(e4);
          });
        }
        var i3 = this.files[this.root + e3];
        return i3 && !i3.dir ? i3 : null;
      }, folder: function(r3) {
        if (!r3)
          return this;
        if (h2(r3))
          return this.filter(function(e4, t4) {
            return t4.dir && r3.test(e4);
          });
        var e3 = this.root + r3, t3 = b2.call(this, e3), n3 = this.clone();
        return n3.root = t3.name, n3;
      }, remove: function(r3) {
        r3 = this.root + r3;
        var e3 = this.files[r3];
        if (e3 || ("/" !== r3.slice(-1) && (r3 += "/"), e3 = this.files[r3]), e3 && !e3.dir)
          delete this.files[r3];
        else
          for (var t3 = this.filter(function(e4, t4) {
            return t4.name.slice(0, r3.length) === r3;
          }), n3 = 0; n3 < t3.length; n3++)
            delete this.files[t3[n3].name];
        return this;
      }, generate: function(e3) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e3) {
        var t3, r3 = {};
        try {
          if ((r3 = u2.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i2.utf8encode })).type = r3.type.toLowerCase(), r3.compression = r3.compression.toUpperCase(), "binarystring" === r3.type && (r3.type = "string"), !r3.type)
            throw new Error("No output type specified.");
          u2.checkSupport(r3.type), "darwin" !== r3.platform && "freebsd" !== r3.platform && "linux" !== r3.platform && "sunos" !== r3.platform || (r3.platform = "UNIX"), "win32" === r3.platform && (r3.platform = "DOS");
          var n3 = r3.comment || this.comment || "";
          t3 = o2.generateWorker(this, r3, n3);
        } catch (e4) {
          (t3 = new l2("error")).error(e4);
        }
        return new a2(t3, r3.type || "string", r3.mimeType);
      }, generateAsync: function(e3, t3) {
        return this.generateInternalStream(e3).accumulate(t3);
      }, generateNodeStream: function(e3, t3) {
        return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t3);
      } };
      t2.exports = n2;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t2, r2) {
      t2.exports = e2("stream");
    }, { stream: void 0 }], 17: [function(e2, t2, r2) {
      var n2 = e2("./DataReader");
      function i2(e3) {
        n2.call(this, e3);
        for (var t3 = 0; t3 < this.data.length; t3++)
          e3[t3] = 255 & e3[t3];
      }
      e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
        return this.data[this.zero + e3];
      }, i2.prototype.lastIndexOfSignature = function(e3) {
        for (var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2)
          if (this.data[s2] === t3 && this.data[s2 + 1] === r3 && this.data[s2 + 2] === n3 && this.data[s2 + 3] === i3)
            return s2 - this.zero;
        return -1;
      }, i2.prototype.readAndCheckSignature = function(e3) {
        var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.readData(4);
        return t3 === s2[0] && r3 === s2[1] && n3 === s2[2] && i3 === s2[3];
      }, i2.prototype.readData = function(e3) {
        if (this.checkOffset(e3), 0 === e3)
          return [];
        var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i2;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t2, r2) {
      var n2 = e2("../utils");
      function i2(e3) {
        this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
      }
      i2.prototype = { checkOffset: function(e3) {
        this.checkIndex(this.index + e3);
      }, checkIndex: function(e3) {
        if (this.length < this.zero + e3 || e3 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
      }, setIndex: function(e3) {
        this.checkIndex(e3), this.index = e3;
      }, skip: function(e3) {
        this.setIndex(this.index + e3);
      }, byteAt: function(e3) {
      }, readInt: function(e3) {
        var t3, r3 = 0;
        for (this.checkOffset(e3), t3 = this.index + e3 - 1; t3 >= this.index; t3--)
          r3 = (r3 << 8) + this.byteAt(t3);
        return this.index += e3, r3;
      }, readString: function(e3) {
        return n2.transformTo("string", this.readData(e3));
      }, readData: function(e3) {
      }, lastIndexOfSignature: function(e3) {
      }, readAndCheckSignature: function(e3) {
      }, readDate: function() {
        var e3 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
      } }, t2.exports = i2;
    }, { "../utils": 32 }], 19: [function(e2, t2, r2) {
      var n2 = e2("./Uint8ArrayReader");
      function i2(e3) {
        n2.call(this, e3);
      }
      e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
        this.checkOffset(e3);
        var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i2;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t2, r2) {
      var n2 = e2("./DataReader");
      function i2(e3) {
        n2.call(this, e3);
      }
      e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
        return this.data.charCodeAt(this.zero + e3);
      }, i2.prototype.lastIndexOfSignature = function(e3) {
        return this.data.lastIndexOf(e3) - this.zero;
      }, i2.prototype.readAndCheckSignature = function(e3) {
        return e3 === this.readData(4);
      }, i2.prototype.readData = function(e3) {
        this.checkOffset(e3);
        var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i2;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t2, r2) {
      var n2 = e2("./ArrayReader");
      function i2(e3) {
        n2.call(this, e3);
      }
      e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
        if (this.checkOffset(e3), 0 === e3)
          return new Uint8Array(0);
        var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
        return this.index += e3, t3;
      }, t2.exports = i2;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i2 = e2("../support"), s2 = e2("./ArrayReader"), a2 = e2("./StringReader"), o2 = e2("./NodeBufferReader"), h2 = e2("./Uint8ArrayReader");
      t2.exports = function(e3) {
        var t3 = n2.getTypeOf(e3);
        return n2.checkSupport(t3), "string" !== t3 || i2.uint8array ? "nodebuffer" === t3 ? new o2(e3) : i2.uint8array ? new h2(n2.transformTo("uint8array", e3)) : new s2(n2.transformTo("array", e3)) : new a2(e3);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t2, r2) {
      r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e2, t2, r2) {
      var n2 = e2("./GenericWorker"), i2 = e2("../utils");
      function s2(e3) {
        n2.call(this, "ConvertWorker to " + e3), this.destType = e3;
      }
      i2.inherits(s2, n2), s2.prototype.processChunk = function(e3) {
        this.push({ data: i2.transformTo(this.destType, e3.data), meta: e3.meta });
      }, t2.exports = s2;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t2, r2) {
      var n2 = e2("./GenericWorker"), i2 = e2("../crc32");
      function s2() {
        n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e2("../utils").inherits(s2, n2), s2.prototype.processChunk = function(e3) {
        this.streamInfo.crc32 = i2(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
      }, t2.exports = s2;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i2 = e2("./GenericWorker");
      function s2(e3) {
        i2.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
      }
      n2.inherits(s2, i2), s2.prototype.processChunk = function(e3) {
        if (e3) {
          var t3 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t3 + e3.data.length;
        }
        i2.prototype.processChunk.call(this, e3);
      }, t2.exports = s2;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t2, r2) {
      var n2 = e2("../utils"), i2 = e2("./GenericWorker");
      function s2(e3) {
        i2.call(this, "DataWorker");
        var t3 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
          t3.dataIsReady = true, t3.data = e4, t3.max = e4 && e4.length || 0, t3.type = n2.getTypeOf(e4), t3.isPaused || t3._tickAndRepeat();
        }, function(e4) {
          t3.error(e4);
        });
      }
      n2.inherits(s2, i2), s2.prototype.cleanUp = function() {
        i2.prototype.cleanUp.call(this), this.data = null;
      }, s2.prototype.resume = function() {
        return !!i2.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
      }, s2.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s2.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e3 = null, t3 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e3 = this.data.substring(this.index, t3);
            break;
          case "uint8array":
            e3 = this.data.subarray(this.index, t3);
            break;
          case "array":
          case "nodebuffer":
            e3 = this.data.slice(this.index, t3);
        }
        return this.index = t3, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t2.exports = s2;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t2, r2) {
      function n2(e3) {
        this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n2.prototype = { push: function(e3) {
        this.emit("data", e3);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e3) {
          this.emit("error", e3);
        }
        return true;
      }, error: function(e3) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
      }, on: function(e3, t3) {
        return this._listeners[e3].push(t3), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e3, t3) {
        if (this._listeners[e3])
          for (var r3 = 0; r3 < this._listeners[e3].length; r3++)
            this._listeners[e3][r3].call(this, t3);
      }, pipe: function(e3) {
        return e3.registerPrevious(this);
      }, registerPrevious: function(e3) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
        var t3 = this;
        return e3.on("data", function(e4) {
          t3.processChunk(e4);
        }), e3.on("end", function() {
          t3.end();
        }), e3.on("error", function(e4) {
          t3.error(e4);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e3 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
      }, flush: function() {
      }, processChunk: function(e3) {
        this.push(e3);
      }, withStreamInfo: function(e3, t3) {
        return this.extraStreamInfo[e3] = t3, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e3 in this.extraStreamInfo)
          this.extraStreamInfo.hasOwnProperty(e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e3 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e3 : e3;
      } }, t2.exports = n2;
    }, {}], 29: [function(e2, t2, r2) {
      var h2 = e2("../utils"), i2 = e2("./ConvertWorker"), s2 = e2("./GenericWorker"), u2 = e2("../base64"), n2 = e2("../support"), a2 = e2("../external"), o2 = null;
      if (n2.nodestream)
        try {
          o2 = e2("../nodejs/NodejsStreamOutputAdapter");
        } catch (e3) {
        }
      function l2(e3, o3) {
        return new a2.Promise(function(t3, r3) {
          var n3 = [], i3 = e3._internalType, s3 = e3._outputType, a3 = e3._mimeType;
          e3.on("data", function(e4, t4) {
            n3.push(e4), o3 && o3(t4);
          }).on("error", function(e4) {
            n3 = [], r3(e4);
          }).on("end", function() {
            try {
              var e4 = function(e5, t4, r4) {
                switch (e5) {
                  case "blob":
                    return h2.newBlob(h2.transformTo("arraybuffer", t4), r4);
                  case "base64":
                    return u2.encode(t4);
                  default:
                    return h2.transformTo(e5, t4);
                }
              }(s3, function(e5, t4) {
                var r4, n4 = 0, i4 = null, s4 = 0;
                for (r4 = 0; r4 < t4.length; r4++)
                  s4 += t4[r4].length;
                switch (e5) {
                  case "string":
                    return t4.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t4);
                  case "uint8array":
                    for (i4 = new Uint8Array(s4), r4 = 0; r4 < t4.length; r4++)
                      i4.set(t4[r4], n4), n4 += t4[r4].length;
                    return i4;
                  case "nodebuffer":
                    return Buffer.concat(t4);
                  default:
                    throw new Error("concat : unsupported type '" + e5 + "'");
                }
              }(i3, n3), a3);
              t3(e4);
            } catch (e5) {
              r3(e5);
            }
            n3 = [];
          }).resume();
        });
      }
      function f2(e3, t3, r3) {
        var n3 = t3;
        switch (t3) {
          case "blob":
          case "arraybuffer":
            n3 = "uint8array";
            break;
          case "base64":
            n3 = "string";
        }
        try {
          this._internalType = n3, this._outputType = t3, this._mimeType = r3, h2.checkSupport(n3), this._worker = e3.pipe(new i2(n3)), e3.lock();
        } catch (e4) {
          this._worker = new s2("error"), this._worker.error(e4);
        }
      }
      f2.prototype = { accumulate: function(e3) {
        return l2(this, e3);
      }, on: function(e3, t3) {
        var r3 = this;
        return "data" === e3 ? this._worker.on(e3, function(e4) {
          t3.call(r3, e4.data, e4.meta);
        }) : this._worker.on(e3, function() {
          h2.delay(t3, arguments, r3);
        }), this;
      }, resume: function() {
        return h2.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e3) {
        if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
          throw new Error(this._outputType + " is not supported by this method");
        return new o2(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
      } }, t2.exports = f2;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t2, r2) {
      if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
        r2.blob = false;
      else {
        var n2 = new ArrayBuffer(0);
        try {
          r2.blob = 0 === new Blob([n2], { type: "application/zip" }).size;
        } catch (e3) {
          try {
            var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i2.append(n2), r2.blob = 0 === i2.getBlob("application/zip").size;
          } catch (e4) {
            r2.blob = false;
          }
        }
      }
      try {
        r2.nodestream = !!e2("readable-stream").Readable;
      } catch (e3) {
        r2.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e2, t2, s2) {
      for (var o2 = e2("./utils"), h2 = e2("./support"), r2 = e2("./nodejsUtils"), n2 = e2("./stream/GenericWorker"), u2 = new Array(256), i2 = 0; i2 < 256; i2++)
        u2[i2] = 252 <= i2 ? 6 : 248 <= i2 ? 5 : 240 <= i2 ? 4 : 224 <= i2 ? 3 : 192 <= i2 ? 2 : 1;
      u2[254] = u2[254] = 1;
      function a2() {
        n2.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l2() {
        n2.call(this, "utf-8 encode");
      }
      s2.utf8encode = function(e3) {
        return h2.nodebuffer ? r2.newBufferFrom(e3, "utf-8") : function(e4) {
          var t3, r3, n3, i3, s3, a3 = e4.length, o3 = 0;
          for (i3 = 0; i3 < a3; i3++)
            55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          for (t3 = h2.uint8array ? new Uint8Array(o3) : new Array(o3), i3 = s3 = 0; s3 < o3; i3++)
            55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
          return t3;
        }(e3);
      }, s2.utf8decode = function(e3) {
        return h2.nodebuffer ? o2.transformTo("nodebuffer", e3).toString("utf-8") : function(e4) {
          var t3, r3, n3, i3, s3 = e4.length, a3 = new Array(2 * s3);
          for (t3 = r3 = 0; t3 < s3; )
            if ((n3 = e4[t3++]) < 128)
              a3[r3++] = n3;
            else if (4 < (i3 = u2[n3]))
              a3[r3++] = 65533, t3 += i3 - 1;
            else {
              for (n3 &= 2 === i3 ? 31 : 3 === i3 ? 15 : 7; 1 < i3 && t3 < s3; )
                n3 = n3 << 6 | 63 & e4[t3++], i3--;
              1 < i3 ? a3[r3++] = 65533 : n3 < 65536 ? a3[r3++] = n3 : (n3 -= 65536, a3[r3++] = 55296 | n3 >> 10 & 1023, a3[r3++] = 56320 | 1023 & n3);
            }
          return a3.length !== r3 && (a3.subarray ? a3 = a3.subarray(0, r3) : a3.length = r3), o2.applyFromCharCode(a3);
        }(e3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3));
      }, o2.inherits(a2, n2), a2.prototype.processChunk = function(e3) {
        var t3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3.data);
        if (this.leftOver && this.leftOver.length) {
          if (h2.uint8array) {
            var r3 = t3;
            (t3 = new Uint8Array(r3.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r3, this.leftOver.length);
          } else
            t3 = this.leftOver.concat(t3);
          this.leftOver = null;
        }
        var n3 = function(e4, t4) {
          var r4;
          for ((t4 = t4 || e4.length) > e4.length && (t4 = e4.length), r4 = t4 - 1; 0 <= r4 && 128 == (192 & e4[r4]); )
            r4--;
          return r4 < 0 ? t4 : 0 === r4 ? t4 : r4 + u2[e4[r4]] > t4 ? r4 : t4;
        }(t3), i3 = t3;
        n3 !== t3.length && (h2.uint8array ? (i3 = t3.subarray(0, n3), this.leftOver = t3.subarray(n3, t3.length)) : (i3 = t3.slice(0, n3), this.leftOver = t3.slice(n3, t3.length))), this.push({ data: s2.utf8decode(i3), meta: e3.meta });
      }, a2.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s2.Utf8DecodeWorker = a2, o2.inherits(l2, n2), l2.prototype.processChunk = function(e3) {
        this.push({ data: s2.utf8encode(e3.data), meta: e3.meta });
      }, s2.Utf8EncodeWorker = l2;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t2, a2) {
      var o2 = e2("./support"), h2 = e2("./base64"), r2 = e2("./nodejsUtils"), u2 = e2("./external");
      function n2(e3) {
        return e3;
      }
      function l2(e3, t3) {
        for (var r3 = 0; r3 < e3.length; ++r3)
          t3[r3] = 255 & e3.charCodeAt(r3);
        return t3;
      }
      e2("setimmediate"), a2.newBlob = function(t3, r3) {
        a2.checkSupport("blob");
        try {
          return new Blob([t3], { type: r3 });
        } catch (e3) {
          try {
            var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n3.append(t3), n3.getBlob(r3);
          } catch (e4) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i2 = { stringifyByChunk: function(e3, t3, r3) {
        var n3 = [], i3 = 0, s3 = e3.length;
        if (s3 <= r3)
          return String.fromCharCode.apply(null, e3);
        for (; i3 < s3; )
          "array" === t3 || "nodebuffer" === t3 ? n3.push(String.fromCharCode.apply(null, e3.slice(i3, Math.min(i3 + r3, s3)))) : n3.push(String.fromCharCode.apply(null, e3.subarray(i3, Math.min(i3 + r3, s3)))), i3 += r3;
        return n3.join("");
      }, stringifyByChar: function(e3) {
        for (var t3 = "", r3 = 0; r3 < e3.length; r3++)
          t3 += String.fromCharCode(e3[r3]);
        return t3;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o2.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
        } catch (e3) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o2.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
        } catch (e3) {
          return false;
        }
      }() } };
      function s2(e3) {
        var t3 = 65536, r3 = a2.getTypeOf(e3), n3 = true;
        if ("uint8array" === r3 ? n3 = i2.applyCanBeUsed.uint8array : "nodebuffer" === r3 && (n3 = i2.applyCanBeUsed.nodebuffer), n3)
          for (; 1 < t3; )
            try {
              return i2.stringifyByChunk(e3, r3, t3);
            } catch (e4) {
              t3 = Math.floor(t3 / 2);
            }
        return i2.stringifyByChar(e3);
      }
      function f2(e3, t3) {
        for (var r3 = 0; r3 < e3.length; r3++)
          t3[r3] = e3[r3];
        return t3;
      }
      a2.applyFromCharCode = s2;
      var c2 = {};
      c2.string = { string: n2, array: function(e3) {
        return l2(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return c2.string.uint8array(e3).buffer;
      }, uint8array: function(e3) {
        return l2(e3, new Uint8Array(e3.length));
      }, nodebuffer: function(e3) {
        return l2(e3, r2.allocBuffer(e3.length));
      } }, c2.array = { string: s2, array: n2, arraybuffer: function(e3) {
        return new Uint8Array(e3).buffer;
      }, uint8array: function(e3) {
        return new Uint8Array(e3);
      }, nodebuffer: function(e3) {
        return r2.newBufferFrom(e3);
      } }, c2.arraybuffer = { string: function(e3) {
        return s2(new Uint8Array(e3));
      }, array: function(e3) {
        return f2(new Uint8Array(e3), new Array(e3.byteLength));
      }, arraybuffer: n2, uint8array: function(e3) {
        return new Uint8Array(e3);
      }, nodebuffer: function(e3) {
        return r2.newBufferFrom(new Uint8Array(e3));
      } }, c2.uint8array = { string: s2, array: function(e3) {
        return f2(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return e3.buffer;
      }, uint8array: n2, nodebuffer: function(e3) {
        return r2.newBufferFrom(e3);
      } }, c2.nodebuffer = { string: s2, array: function(e3) {
        return f2(e3, new Array(e3.length));
      }, arraybuffer: function(e3) {
        return c2.nodebuffer.uint8array(e3).buffer;
      }, uint8array: function(e3) {
        return f2(e3, new Uint8Array(e3.length));
      }, nodebuffer: n2 }, a2.transformTo = function(e3, t3) {
        if (t3 = t3 || "", !e3)
          return t3;
        a2.checkSupport(e3);
        var r3 = a2.getTypeOf(t3);
        return c2[r3][e3](t3);
      }, a2.resolve = function(e3) {
        for (var t3 = e3.split("/"), r3 = [], n3 = 0; n3 < t3.length; n3++) {
          var i3 = t3[n3];
          "." === i3 || "" === i3 && 0 !== n3 && n3 !== t3.length - 1 || (".." === i3 ? r3.pop() : r3.push(i3));
        }
        return r3.join("/");
      }, a2.getTypeOf = function(e3) {
        return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o2.nodebuffer && r2.isBuffer(e3) ? "nodebuffer" : o2.uint8array && e3 instanceof Uint8Array ? "uint8array" : o2.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a2.checkSupport = function(e3) {
        if (!o2[e3.toLowerCase()])
          throw new Error(e3 + " is not supported by this platform");
      }, a2.MAX_VALUE_16BITS = 65535, a2.MAX_VALUE_32BITS = -1, a2.pretty = function(e3) {
        var t3, r3, n3 = "";
        for (r3 = 0; r3 < (e3 || "").length; r3++)
          n3 += "\\x" + ((t3 = e3.charCodeAt(r3)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
        return n3;
      }, a2.delay = function(e3, t3, r3) {
        setImmediate(function() {
          e3.apply(r3 || null, t3 || []);
        });
      }, a2.inherits = function(e3, t3) {
        function r3() {
        }
        r3.prototype = t3.prototype, e3.prototype = new r3();
      }, a2.extend = function() {
        var e3, t3, r3 = {};
        for (e3 = 0; e3 < arguments.length; e3++)
          for (t3 in arguments[e3])
            arguments[e3].hasOwnProperty(t3) && void 0 === r3[t3] && (r3[t3] = arguments[e3][t3]);
        return r3;
      }, a2.prepareContent = function(r3, e3, n3, i3, s3) {
        return u2.Promise.resolve(e3).then(function(n4) {
          return o2.blob && (n4 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4))) && "undefined" != typeof FileReader ? new u2.Promise(function(t3, r4) {
            var e4 = new FileReader();
            e4.onload = function(e5) {
              t3(e5.target.result);
            }, e4.onerror = function(e5) {
              r4(e5.target.error);
            }, e4.readAsArrayBuffer(n4);
          }) : n4;
        }).then(function(e4) {
          var t3 = a2.getTypeOf(e4);
          return t3 ? ("arraybuffer" === t3 ? e4 = a2.transformTo("uint8array", e4) : "string" === t3 && (s3 ? e4 = h2.decode(e4) : n3 && true !== i3 && (e4 = function(e5) {
            return l2(e5, o2.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
          }(e4))), e4) : u2.Promise.reject(new Error("Can't read the data of '" + r3 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t2, r2) {
      var n2 = e2("./reader/readerFor"), i2 = e2("./utils"), s2 = e2("./signature"), a2 = e2("./zipEntry"), o2 = (e2("./utf8"), e2("./support"));
      function h2(e3) {
        this.files = [], this.loadOptions = e3;
      }
      h2.prototype = { checkSignature: function(e3) {
        if (!this.reader.readAndCheckSignature(e3)) {
          this.reader.index -= 4;
          var t3 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i2.pretty(t3) + ", expected " + i2.pretty(e3) + ")");
        }
      }, isSignature: function(e3, t3) {
        var r3 = this.reader.index;
        this.reader.setIndex(e3);
        var n3 = this.reader.readString(4) === t3;
        return this.reader.setIndex(r3), n3;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e3 = this.reader.readData(this.zipCommentLength), t3 = o2.uint8array ? "uint8array" : "array", r3 = i2.transformTo(t3, e3);
        this.zipComment = this.loadOptions.decodeFileName(r3);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e3, t3, r3, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
          e3 = this.reader.readInt(2), t3 = this.reader.readInt(4), r3 = this.reader.readData(t3), this.zip64ExtensibleData[e3] = { id: e3, length: t3, value: r3 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e3, t3;
        for (e3 = 0; e3 < this.files.length; e3++)
          t3 = this.files[e3], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
      }, readCentralDir: function() {
        var e3;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); )
          (e3 = new a2({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e3 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
        if (e3 < 0)
          throw !this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e3);
        var t3 = e3;
        if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i2.MAX_VALUE_16BITS || this.centralDirRecords === i2.MAX_VALUE_16BITS || this.centralDirSize === i2.MAX_VALUE_32BITS || this.centralDirOffset === i2.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e3), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r3 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r3 += 20, r3 += 12 + this.zip64EndOfCentralSize);
        var n3 = t3 - r3;
        if (0 < n3)
          this.isSignature(t3, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
        else if (n3 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
      }, prepareReader: function(e3) {
        this.reader = n2(e3);
      }, load: function(e3) {
        this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t2.exports = h2;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t2, r2) {
      var n2 = e2("./reader/readerFor"), s2 = e2("./utils"), i2 = e2("./compressedObject"), a2 = e2("./crc32"), o2 = e2("./utf8"), h2 = e2("./compressions"), u2 = e2("./support");
      function l2(e3, t3) {
        this.options = e3, this.loadOptions = t3;
      }
      l2.prototype = { isEncrypted: function() {
        return 1 == (1 & this.bitFlag);
      }, useUTF8: function() {
        return 2048 == (2048 & this.bitFlag);
      }, readLocalPart: function(e3) {
        var t3, r3;
        if (e3.skip(22), this.fileNameLength = e3.readInt(2), r3 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r3), -1 === this.compressedSize || -1 === this.uncompressedSize)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if (null === (t3 = function(e4) {
          for (var t4 in h2)
            if (h2.hasOwnProperty(t4) && h2[t4].magic === e4)
              return h2[t4];
          return null;
        }(this.compressionMethod)))
          throw new Error("Corrupted zip : compression " + s2.pretty(this.compressionMethod) + " unknown (inner file : " + s2.transformTo("string", this.fileName) + ")");
        this.decompressed = new i2(this.compressedSize, this.uncompressedSize, this.crc32, t3, e3.readData(this.compressedSize));
      }, readCentralPart: function(e3) {
        this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
        var t3 = e3.readInt(2);
        if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e3.skip(t3), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e3 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
      }, parseZIP64ExtraField: function(e3) {
        if (this.extraFields[1]) {
          var t3 = n2(this.extraFields[1].value);
          this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = t3.readInt(8)), this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = t3.readInt(8)), this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = t3.readInt(8)), this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = t3.readInt(4));
        }
      }, readExtraFields: function(e3) {
        var t3, r3, n3, i3 = e3.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i3; )
          t3 = e3.readInt(2), r3 = e3.readInt(2), n3 = e3.readData(r3), this.extraFields[t3] = { id: t3, length: r3, value: n3 };
        e3.setIndex(i3);
      }, handleUTF8: function() {
        var e3 = u2.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o2.utf8decode(this.fileName), this.fileCommentStr = o2.utf8decode(this.fileComment);
        else {
          var t3 = this.findExtraFieldUnicodePath();
          if (null !== t3)
            this.fileNameStr = t3;
          else {
            var r3 = s2.transformTo(e3, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r3);
          }
          var n3 = this.findExtraFieldUnicodeComment();
          if (null !== n3)
            this.fileCommentStr = n3;
          else {
            var i3 = s2.transformTo(e3, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i3);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e3 = this.extraFields[28789];
        if (e3) {
          var t3 = n2(e3.value);
          return 1 !== t3.readInt(1) ? null : a2(this.fileName) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e3 = this.extraFields[25461];
        if (e3) {
          var t3 = n2(e3.value);
          return 1 !== t3.readInt(1) ? null : a2(this.fileComment) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
        }
        return null;
      } }, t2.exports = l2;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t2, r2) {
      function n2(e3, t3, r3) {
        this.name = e3, this.dir = r3.dir, this.date = r3.date, this.comment = r3.comment, this.unixPermissions = r3.unixPermissions, this.dosPermissions = r3.dosPermissions, this._data = t3, this._dataBinary = r3.binary, this.options = { compression: r3.compression, compressionOptions: r3.compressionOptions };
      }
      var s2 = e2("./stream/StreamHelper"), i2 = e2("./stream/DataWorker"), a2 = e2("./utf8"), o2 = e2("./compressedObject"), h2 = e2("./stream/GenericWorker");
      n2.prototype = { internalStream: function(e3) {
        var t3 = null, r3 = "string";
        try {
          if (!e3)
            throw new Error("No output type specified.");
          var n3 = "string" === (r3 = e3.toLowerCase()) || "text" === r3;
          "binarystring" !== r3 && "text" !== r3 || (r3 = "string"), t3 = this._decompressWorker();
          var i3 = !this._dataBinary;
          i3 && !n3 && (t3 = t3.pipe(new a2.Utf8EncodeWorker())), !i3 && n3 && (t3 = t3.pipe(new a2.Utf8DecodeWorker()));
        } catch (e4) {
          (t3 = new h2("error")).error(e4);
        }
        return new s2(t3, r3, "");
      }, async: function(e3, t3) {
        return this.internalStream(e3).accumulate(t3);
      }, nodeStream: function(e3, t3) {
        return this.internalStream(e3 || "nodebuffer").toNodejsStream(t3);
      }, _compressWorker: function(e3, t3) {
        if (this._data instanceof o2 && this._data.compression.magic === e3.magic)
          return this._data.getCompressedWorker();
        var r3 = this._decompressWorker();
        return this._dataBinary || (r3 = r3.pipe(new a2.Utf8EncodeWorker())), o2.createWorkerFrom(r3, e3, t3);
      }, _decompressWorker: function() {
        return this._data instanceof o2 ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i2(this._data);
      } };
      for (var u2 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l2 = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f2 = 0; f2 < u2.length; f2++)
        n2.prototype[u2[f2]] = l2;
      t2.exports = n2;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l2, t2) {
      (function(t3) {
        var r2, n2, e3 = t3.MutationObserver || t3.WebKitMutationObserver;
        if (e3) {
          var i2 = 0, s2 = new e3(u2), a2 = t3.document.createTextNode("");
          s2.observe(a2, { characterData: true }), r2 = function() {
            a2.data = i2 = ++i2 % 2;
          };
        } else if (t3.setImmediate || void 0 === t3.MessageChannel)
          r2 = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
            var e4 = t3.document.createElement("script");
            e4.onreadystatechange = function() {
              u2(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
            }, t3.document.documentElement.appendChild(e4);
          } : function() {
            setTimeout(u2, 0);
          };
        else {
          var o2 = new t3.MessageChannel();
          o2.port1.onmessage = u2, r2 = function() {
            o2.port2.postMessage(0);
          };
        }
        var h2 = [];
        function u2() {
          var e4, t4;
          n2 = true;
          for (var r3 = h2.length; r3; ) {
            for (t4 = h2, h2 = [], e4 = -1; ++e4 < r3; )
              t4[e4]();
            r3 = h2.length;
          }
          n2 = false;
        }
        l2.exports = function(e4) {
          1 !== h2.push(e4) || n2 || r2();
        };
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 37: [function(e2, t2, r2) {
      var i2 = e2("immediate");
      function u2() {
      }
      var l2 = {}, s2 = ["REJECTED"], a2 = ["FULFILLED"], n2 = ["PENDING"];
      function o2(e3) {
        if ("function" != typeof e3)
          throw new TypeError("resolver must be a function");
        this.state = n2, this.queue = [], this.outcome = void 0, e3 !== u2 && d2(this, e3);
      }
      function h2(e3, t3, r3) {
        this.promise = e3, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r3 && (this.onRejected = r3, this.callRejected = this.otherCallRejected);
      }
      function f2(t3, r3, n3) {
        i2(function() {
          var e3;
          try {
            e3 = r3(n3);
          } catch (e4) {
            return l2.reject(t3, e4);
          }
          e3 === t3 ? l2.reject(t3, new TypeError("Cannot resolve promise with itself")) : l2.resolve(t3, e3);
        });
      }
      function c2(e3) {
        var t3 = e3 && e3.then;
        if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t3)
          return function() {
            t3.apply(e3, arguments);
          };
      }
      function d2(t3, e3) {
        var r3 = false;
        function n3(e4) {
          r3 || (r3 = true, l2.reject(t3, e4));
        }
        function i3(e4) {
          r3 || (r3 = true, l2.resolve(t3, e4));
        }
        var s3 = p2(function() {
          e3(i3, n3);
        });
        "error" === s3.status && n3(s3.value);
      }
      function p2(e3, t3) {
        var r3 = {};
        try {
          r3.value = e3(t3), r3.status = "success";
        } catch (e4) {
          r3.status = "error", r3.value = e4;
        }
        return r3;
      }
      (t2.exports = o2).prototype.finally = function(t3) {
        if ("function" != typeof t3)
          return this;
        var r3 = this.constructor;
        return this.then(function(e3) {
          return r3.resolve(t3()).then(function() {
            return e3;
          });
        }, function(e3) {
          return r3.resolve(t3()).then(function() {
            throw e3;
          });
        });
      }, o2.prototype.catch = function(e3) {
        return this.then(null, e3);
      }, o2.prototype.then = function(e3, t3) {
        if ("function" != typeof e3 && this.state === a2 || "function" != typeof t3 && this.state === s2)
          return this;
        var r3 = new this.constructor(u2);
        this.state !== n2 ? f2(r3, this.state === a2 ? e3 : t3, this.outcome) : this.queue.push(new h2(r3, e3, t3));
        return r3;
      }, h2.prototype.callFulfilled = function(e3) {
        l2.resolve(this.promise, e3);
      }, h2.prototype.otherCallFulfilled = function(e3) {
        f2(this.promise, this.onFulfilled, e3);
      }, h2.prototype.callRejected = function(e3) {
        l2.reject(this.promise, e3);
      }, h2.prototype.otherCallRejected = function(e3) {
        f2(this.promise, this.onRejected, e3);
      }, l2.resolve = function(e3, t3) {
        var r3 = p2(c2, t3);
        if ("error" === r3.status)
          return l2.reject(e3, r3.value);
        var n3 = r3.value;
        if (n3)
          d2(e3, n3);
        else {
          e3.state = a2, e3.outcome = t3;
          for (var i3 = -1, s3 = e3.queue.length; ++i3 < s3; )
            e3.queue[i3].callFulfilled(t3);
        }
        return e3;
      }, l2.reject = function(e3, t3) {
        e3.state = s2, e3.outcome = t3;
        for (var r3 = -1, n3 = e3.queue.length; ++r3 < n3; )
          e3.queue[r3].callRejected(t3);
        return e3;
      }, o2.resolve = function(e3) {
        if (e3 instanceof this)
          return e3;
        return l2.resolve(new this(u2), e3);
      }, o2.reject = function(e3) {
        var t3 = new this(u2);
        return l2.reject(t3, e3);
      }, o2.all = function(e3) {
        var r3 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e3))
          return this.reject(new TypeError("must be an array"));
        var n3 = e3.length, i3 = false;
        if (!n3)
          return this.resolve([]);
        var s3 = new Array(n3), a3 = 0, t3 = -1, o3 = new this(u2);
        for (; ++t3 < n3; )
          h3(e3[t3], t3);
        return o3;
        function h3(e4, t4) {
          r3.resolve(e4).then(function(e5) {
            s3[t4] = e5, ++a3 !== n3 || i3 || (i3 = true, l2.resolve(o3, s3));
          }, function(e5) {
            i3 || (i3 = true, l2.reject(o3, e5));
          });
        }
      }, o2.race = function(e3) {
        var t3 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e3))
          return this.reject(new TypeError("must be an array"));
        var r3 = e3.length, n3 = false;
        if (!r3)
          return this.resolve([]);
        var i3 = -1, s3 = new this(u2);
        for (; ++i3 < r3; )
          a3 = e3[i3], t3.resolve(a3).then(function(e4) {
            n3 || (n3 = true, l2.resolve(s3, e4));
          }, function(e4) {
            n3 || (n3 = true, l2.reject(s3, e4));
          });
        var a3;
        return s3;
      };
    }, { immediate: 36 }], 38: [function(e2, t2, r2) {
      var n2 = {};
      (0, e2("./lib/utils/common").assign)(n2, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t2.exports = n2;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t2, r2) {
      var a2 = e2("./zlib/deflate"), o2 = e2("./utils/common"), h2 = e2("./utils/strings"), i2 = e2("./zlib/messages"), s2 = e2("./zlib/zstream"), u2 = Object.prototype.toString, l2 = 0, f2 = -1, c2 = 0, d2 = 8;
      function p2(e3) {
        if (!(this instanceof p2))
          return new p2(e3);
        this.options = o2.assign({ level: f2, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e3 || {});
        var t3 = this.options;
        t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s2(), this.strm.avail_out = 0;
        var r3 = a2.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
        if (r3 !== l2)
          throw new Error(i2[r3]);
        if (t3.header && a2.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
          var n3;
          if (n3 = "string" == typeof t3.dictionary ? h2.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u2.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r3 = a2.deflateSetDictionary(this.strm, n3)) !== l2)
            throw new Error(i2[r3]);
          this._dict_set = true;
        }
      }
      function n2(e3, t3) {
        var r3 = new p2(t3);
        if (r3.push(e3, true), r3.err)
          throw r3.msg || i2[r3.err];
        return r3.result;
      }
      p2.prototype.push = function(e3, t3) {
        var r3, n3, i3 = this.strm, s3 = this.options.chunkSize;
        if (this.ended)
          return false;
        n3 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e3 ? i3.input = h2.string2buf(e3) : "[object ArrayBuffer]" === u2.call(e3) ? i3.input = new Uint8Array(e3) : i3.input = e3, i3.next_in = 0, i3.avail_in = i3.input.length;
        do {
          if (0 === i3.avail_out && (i3.output = new o2.Buf8(s3), i3.next_out = 0, i3.avail_out = s3), 1 !== (r3 = a2.deflate(i3, n3)) && r3 !== l2)
            return this.onEnd(r3), !(this.ended = true);
          0 !== i3.avail_out && (0 !== i3.avail_in || 4 !== n3 && 2 !== n3) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o2.shrinkBuf(i3.output, i3.next_out))) : this.onData(o2.shrinkBuf(i3.output, i3.next_out)));
        } while ((0 < i3.avail_in || 0 === i3.avail_out) && 1 !== r3);
        return 4 === n3 ? (r3 = a2.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === l2) : 2 !== n3 || (this.onEnd(l2), !(i3.avail_out = 0));
      }, p2.prototype.onData = function(e3) {
        this.chunks.push(e3);
      }, p2.prototype.onEnd = function(e3) {
        e3 === l2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
      }, r2.Deflate = p2, r2.deflate = n2, r2.deflateRaw = function(e3, t3) {
        return (t3 = t3 || {}).raw = true, n2(e3, t3);
      }, r2.gzip = function(e3, t3) {
        return (t3 = t3 || {}).gzip = true, n2(e3, t3);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t2, r2) {
      var c2 = e2("./zlib/inflate"), d2 = e2("./utils/common"), p2 = e2("./utils/strings"), m2 = e2("./zlib/constants"), n2 = e2("./zlib/messages"), i2 = e2("./zlib/zstream"), s2 = e2("./zlib/gzheader"), _2 = Object.prototype.toString;
      function a2(e3) {
        if (!(this instanceof a2))
          return new a2(e3);
        this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
        var t3 = this.options;
        t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e3 && e3.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i2(), this.strm.avail_out = 0;
        var r3 = c2.inflateInit2(this.strm, t3.windowBits);
        if (r3 !== m2.Z_OK)
          throw new Error(n2[r3]);
        this.header = new s2(), c2.inflateGetHeader(this.strm, this.header);
      }
      function o2(e3, t3) {
        var r3 = new a2(t3);
        if (r3.push(e3, true), r3.err)
          throw r3.msg || n2[r3.err];
        return r3.result;
      }
      a2.prototype.push = function(e3, t3) {
        var r3, n3, i3, s3, a3, o3, h2 = this.strm, u2 = this.options.chunkSize, l2 = this.options.dictionary, f2 = false;
        if (this.ended)
          return false;
        n3 = t3 === ~~t3 ? t3 : true === t3 ? m2.Z_FINISH : m2.Z_NO_FLUSH, "string" == typeof e3 ? h2.input = p2.binstring2buf(e3) : "[object ArrayBuffer]" === _2.call(e3) ? h2.input = new Uint8Array(e3) : h2.input = e3, h2.next_in = 0, h2.avail_in = h2.input.length;
        do {
          if (0 === h2.avail_out && (h2.output = new d2.Buf8(u2), h2.next_out = 0, h2.avail_out = u2), (r3 = c2.inflate(h2, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT && l2 && (o3 = "string" == typeof l2 ? p2.string2buf(l2) : "[object ArrayBuffer]" === _2.call(l2) ? new Uint8Array(l2) : l2, r3 = c2.inflateSetDictionary(this.strm, o3)), r3 === m2.Z_BUF_ERROR && true === f2 && (r3 = m2.Z_OK, f2 = false), r3 !== m2.Z_STREAM_END && r3 !== m2.Z_OK)
            return this.onEnd(r3), !(this.ended = true);
          h2.next_out && (0 !== h2.avail_out && r3 !== m2.Z_STREAM_END && (0 !== h2.avail_in || n3 !== m2.Z_FINISH && n3 !== m2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i3 = p2.utf8border(h2.output, h2.next_out), s3 = h2.next_out - i3, a3 = p2.buf2string(h2.output, i3), h2.next_out = s3, h2.avail_out = u2 - s3, s3 && d2.arraySet(h2.output, h2.output, i3, s3, 0), this.onData(a3)) : this.onData(d2.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f2 = true);
        } while ((0 < h2.avail_in || 0 === h2.avail_out) && r3 !== m2.Z_STREAM_END);
        return r3 === m2.Z_STREAM_END && (n3 = m2.Z_FINISH), n3 === m2.Z_FINISH ? (r3 = c2.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === m2.Z_OK) : n3 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h2.avail_out = 0));
      }, a2.prototype.onData = function(e3) {
        this.chunks.push(e3);
      }, a2.prototype.onEnd = function(e3) {
        e3 === m2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
      }, r2.Inflate = a2, r2.inflate = o2, r2.inflateRaw = function(e3, t3) {
        return (t3 = t3 || {}).raw = true, o2(e3, t3);
      }, r2.ungzip = o2;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t2, r2) {
      var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      r2.assign = function(e3) {
        for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
          var r3 = t3.shift();
          if (r3) {
            if ("object" != typeof r3)
              throw new TypeError(r3 + "must be non-object");
            for (var n3 in r3)
              r3.hasOwnProperty(n3) && (e3[n3] = r3[n3]);
          }
        }
        return e3;
      }, r2.shrinkBuf = function(e3, t3) {
        return e3.length === t3 ? e3 : e3.subarray ? e3.subarray(0, t3) : (e3.length = t3, e3);
      };
      var i2 = { arraySet: function(e3, t3, r3, n3, i3) {
        if (t3.subarray && e3.subarray)
          e3.set(t3.subarray(r3, r3 + n3), i3);
        else
          for (var s3 = 0; s3 < n3; s3++)
            e3[i3 + s3] = t3[r3 + s3];
      }, flattenChunks: function(e3) {
        var t3, r3, n3, i3, s3, a2;
        for (t3 = n3 = 0, r3 = e3.length; t3 < r3; t3++)
          n3 += e3[t3].length;
        for (a2 = new Uint8Array(n3), t3 = i3 = 0, r3 = e3.length; t3 < r3; t3++)
          s3 = e3[t3], a2.set(s3, i3), i3 += s3.length;
        return a2;
      } }, s2 = { arraySet: function(e3, t3, r3, n3, i3) {
        for (var s3 = 0; s3 < n3; s3++)
          e3[i3 + s3] = t3[r3 + s3];
      }, flattenChunks: function(e3) {
        return [].concat.apply([], e3);
      } };
      r2.setTyped = function(e3) {
        e3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i2)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
      }, r2.setTyped(n2);
    }, {}], 42: [function(e2, t2, r2) {
      var h2 = e2("./common"), i2 = true, s2 = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e3) {
        i2 = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e3) {
        s2 = false;
      }
      for (var u2 = new h2.Buf8(256), n2 = 0; n2 < 256; n2++)
        u2[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
      function l2(e3, t3) {
        if (t3 < 65537 && (e3.subarray && s2 || !e3.subarray && i2))
          return String.fromCharCode.apply(null, h2.shrinkBuf(e3, t3));
        for (var r3 = "", n3 = 0; n3 < t3; n3++)
          r3 += String.fromCharCode(e3[n3]);
        return r3;
      }
      u2[254] = u2[254] = 1, r2.string2buf = function(e3) {
        var t3, r3, n3, i3, s3, a2 = e3.length, o2 = 0;
        for (i3 = 0; i3 < a2; i3++)
          55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        for (t3 = new h2.Buf8(o2), i3 = s3 = 0; s3 < o2; i3++)
          55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
        return t3;
      }, r2.buf2binstring = function(e3) {
        return l2(e3, e3.length);
      }, r2.binstring2buf = function(e3) {
        for (var t3 = new h2.Buf8(e3.length), r3 = 0, n3 = t3.length; r3 < n3; r3++)
          t3[r3] = e3.charCodeAt(r3);
        return t3;
      }, r2.buf2string = function(e3, t3) {
        var r3, n3, i3, s3, a2 = t3 || e3.length, o2 = new Array(2 * a2);
        for (r3 = n3 = 0; r3 < a2; )
          if ((i3 = e3[r3++]) < 128)
            o2[n3++] = i3;
          else if (4 < (s3 = u2[i3]))
            o2[n3++] = 65533, r3 += s3 - 1;
          else {
            for (i3 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && r3 < a2; )
              i3 = i3 << 6 | 63 & e3[r3++], s3--;
            1 < s3 ? o2[n3++] = 65533 : i3 < 65536 ? o2[n3++] = i3 : (i3 -= 65536, o2[n3++] = 55296 | i3 >> 10 & 1023, o2[n3++] = 56320 | 1023 & i3);
          }
        return l2(o2, n3);
      }, r2.utf8border = function(e3, t3) {
        var r3;
        for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
          r3--;
        return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u2[e3[r3]] > t3 ? r3 : t3;
      };
    }, { "./common": 41 }], 43: [function(e2, t2, r2) {
      t2.exports = function(e3, t3, r3, n2) {
        for (var i2 = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, a2 = 0; 0 !== r3; ) {
          for (r3 -= a2 = 2e3 < r3 ? 2e3 : r3; s2 = s2 + (i2 = i2 + t3[n2++] | 0) | 0, --a2; )
            ;
          i2 %= 65521, s2 %= 65521;
        }
        return i2 | s2 << 16 | 0;
      };
    }, {}], 44: [function(e2, t2, r2) {
      t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e2, t2, r2) {
      var o2 = function() {
        for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
          e3 = r3;
          for (var n2 = 0; n2 < 8; n2++)
            e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
          t3[r3] = e3;
        }
        return t3;
      }();
      t2.exports = function(e3, t3, r3, n2) {
        var i2 = o2, s2 = n2 + r3;
        e3 ^= -1;
        for (var a2 = n2; a2 < s2; a2++)
          e3 = e3 >>> 8 ^ i2[255 & (e3 ^ t3[a2])];
        return -1 ^ e3;
      };
    }, {}], 46: [function(e2, t2, r2) {
      var h2, c2 = e2("../utils/common"), u2 = e2("./trees"), d2 = e2("./adler32"), p2 = e2("./crc32"), n2 = e2("./messages"), l2 = 0, f2 = 4, m2 = 0, _2 = -2, g2 = -1, b2 = 4, i2 = 2, v2 = 8, y2 = 9, s2 = 286, a2 = 30, o2 = 19, w2 = 2 * s2 + 1, k2 = 15, x2 = 3, S2 = 258, z2 = S2 + x2 + 1, C2 = 42, E2 = 113, A2 = 1, I2 = 2, O2 = 3, B2 = 4;
      function R2(e3, t3) {
        return e3.msg = n2[t3], t3;
      }
      function T2(e3) {
        return (e3 << 1) - (4 < e3 ? 9 : 0);
      }
      function D2(e3) {
        for (var t3 = e3.length; 0 <= --t3; )
          e3[t3] = 0;
      }
      function F2(e3) {
        var t3 = e3.state, r3 = t3.pending;
        r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (c2.arraySet(e3.output, t3.pending_buf, t3.pending_out, r3, e3.next_out), e3.next_out += r3, t3.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t3.pending -= r3, 0 === t3.pending && (t3.pending_out = 0));
      }
      function N2(e3, t3) {
        u2._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t3), e3.block_start = e3.strstart, F2(e3.strm);
      }
      function U2(e3, t3) {
        e3.pending_buf[e3.pending++] = t3;
      }
      function P2(e3, t3) {
        e3.pending_buf[e3.pending++] = t3 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t3;
      }
      function L2(e3, t3) {
        var r3, n3, i3 = e3.max_chain_length, s3 = e3.strstart, a3 = e3.prev_length, o3 = e3.nice_match, h3 = e3.strstart > e3.w_size - z2 ? e3.strstart - (e3.w_size - z2) : 0, u3 = e3.window, l3 = e3.w_mask, f3 = e3.prev, c3 = e3.strstart + S2, d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
        e3.prev_length >= e3.good_match && (i3 >>= 2), o3 > e3.lookahead && (o3 = e3.lookahead);
        do {
          if (u3[(r3 = t3) + a3] === p3 && u3[r3 + a3 - 1] === d3 && u3[r3] === u3[s3] && u3[++r3] === u3[s3 + 1]) {
            s3 += 2, r3++;
            do {
            } while (u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && s3 < c3);
            if (n3 = S2 - (c3 - s3), s3 = c3 - S2, a3 < n3) {
              if (e3.match_start = t3, o3 <= (a3 = n3))
                break;
              d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
            }
          }
        } while ((t3 = f3[t3 & l3]) > h3 && 0 != --i3);
        return a3 <= e3.lookahead ? a3 : e3.lookahead;
      }
      function j2(e3) {
        var t3, r3, n3, i3, s3, a3, o3, h3, u3, l3, f3 = e3.w_size;
        do {
          if (i3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f3 + (f3 - z2)) {
            for (c2.arraySet(e3.window, e3.window, f3, f3, 0), e3.match_start -= f3, e3.strstart -= f3, e3.block_start -= f3, t3 = r3 = e3.hash_size; n3 = e3.head[--t3], e3.head[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
              ;
            for (t3 = r3 = f3; n3 = e3.prev[--t3], e3.prev[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
              ;
            i3 += f3;
          }
          if (0 === e3.strm.avail_in)
            break;
          if (a3 = e3.strm, o3 = e3.window, h3 = e3.strstart + e3.lookahead, u3 = i3, l3 = void 0, l3 = a3.avail_in, u3 < l3 && (l3 = u3), r3 = 0 === l3 ? 0 : (a3.avail_in -= l3, c2.arraySet(o3, a3.input, a3.next_in, l3, h3), 1 === a3.state.wrap ? a3.adler = d2(a3.adler, o3, l3, h3) : 2 === a3.state.wrap && (a3.adler = p2(a3.adler, o3, l3, h3)), a3.next_in += l3, a3.total_in += l3, l3), e3.lookahead += r3, e3.lookahead + e3.insert >= x2)
            for (s3 = e3.strstart - e3.insert, e3.ins_h = e3.window[s3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + x2 - 1]) & e3.hash_mask, e3.prev[s3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s3, s3++, e3.insert--, !(e3.lookahead + e3.insert < x2)); )
              ;
        } while (e3.lookahead < z2 && 0 !== e3.strm.avail_in);
      }
      function Z2(e3, t3) {
        for (var r3, n3; ; ) {
          if (e3.lookahead < z2) {
            if (j2(e3), e3.lookahead < z2 && t3 === l2)
              return A2;
            if (0 === e3.lookahead)
              break;
          }
          if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3)), e3.match_length >= x2)
            if (n3 = u2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x2) {
              for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; )
                ;
              e3.strstart++;
            } else
              e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
          else
            n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
          if (n3 && (N2(e3, false), 0 === e3.strm.avail_out))
            return A2;
        }
        return e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
      }
      function W2(e3, t3) {
        for (var r3, n3, i3; ; ) {
          if (e3.lookahead < z2) {
            if (j2(e3), e3.lookahead < z2 && t3 === l2)
              return A2;
            if (0 === e3.lookahead)
              break;
          }
          if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x2 - 1, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x2 && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x2 - 1)), e3.prev_length >= x2 && e3.match_length <= e3.prev_length) {
            for (i3 = e3.strstart + e3.lookahead - x2, n3 = u2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x2), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; )
              ;
            if (e3.match_available = 0, e3.match_length = x2 - 1, e3.strstart++, n3 && (N2(e3, false), 0 === e3.strm.avail_out))
              return A2;
          } else if (e3.match_available) {
            if ((n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N2(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out)
              return A2;
          } else
            e3.match_available = 1, e3.strstart++, e3.lookahead--;
        }
        return e3.match_available && (n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
      }
      function M2(e3, t3, r3, n3, i3) {
        this.good_length = e3, this.max_lazy = t3, this.nice_length = r3, this.max_chain = n3, this.func = i3;
      }
      function H2() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w2), this.dyn_dtree = new c2.Buf16(2 * (2 * a2 + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o2 + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k2 + 1), this.heap = new c2.Buf16(2 * s2 + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s2 + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G2(e3) {
        var t3;
        return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i2, (t3 = e3.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C2 : E2, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l2, u2._tr_init(t3), m2) : R2(e3, _2);
      }
      function K2(e3) {
        var t3 = G2(e3);
        return t3 === m2 && function(e4) {
          e4.window_size = 2 * e4.w_size, D2(e4.head), e4.max_lazy_match = h2[e4.level].max_lazy, e4.good_match = h2[e4.level].good_length, e4.nice_match = h2[e4.level].nice_length, e4.max_chain_length = h2[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x2 - 1, e4.match_available = 0, e4.ins_h = 0;
        }(e3.state), t3;
      }
      function Y2(e3, t3, r3, n3, i3, s3) {
        if (!e3)
          return _2;
        var a3 = 1;
        if (t3 === g2 && (t3 = 6), n3 < 0 ? (a3 = 0, n3 = -n3) : 15 < n3 && (a3 = 2, n3 -= 16), i3 < 1 || y2 < i3 || r3 !== v2 || n3 < 8 || 15 < n3 || t3 < 0 || 9 < t3 || s3 < 0 || b2 < s3)
          return R2(e3, _2);
        8 === n3 && (n3 = 9);
        var o3 = new H2();
        return (e3.state = o3).strm = e3, o3.wrap = a3, o3.gzhead = null, o3.w_bits = n3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = i3 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + x2 - 1) / x2), o3.window = new c2.Buf8(2 * o3.w_size), o3.head = new c2.Buf16(o3.hash_size), o3.prev = new c2.Buf16(o3.w_size), o3.lit_bufsize = 1 << i3 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new c2.Buf8(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t3, o3.strategy = s3, o3.method = r3, K2(e3);
      }
      h2 = [new M2(0, 0, 0, 0, function(e3, t3) {
        var r3 = 65535;
        for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
          if (e3.lookahead <= 1) {
            if (j2(e3), 0 === e3.lookahead && t3 === l2)
              return A2;
            if (0 === e3.lookahead)
              break;
          }
          e3.strstart += e3.lookahead, e3.lookahead = 0;
          var n3 = e3.block_start + r3;
          if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, N2(e3, false), 0 === e3.strm.avail_out))
            return A2;
          if (e3.strstart - e3.block_start >= e3.w_size - z2 && (N2(e3, false), 0 === e3.strm.avail_out))
            return A2;
        }
        return e3.insert = 0, t3 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : (e3.strstart > e3.block_start && (N2(e3, false), e3.strm.avail_out), A2);
      }), new M2(4, 4, 8, 4, Z2), new M2(4, 5, 16, 8, Z2), new M2(4, 6, 32, 32, Z2), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r2.deflateInit = function(e3, t3) {
        return Y2(e3, t3, v2, 15, 8, 0);
      }, r2.deflateInit2 = Y2, r2.deflateReset = K2, r2.deflateResetKeep = G2, r2.deflateSetHeader = function(e3, t3) {
        return e3 && e3.state ? 2 !== e3.state.wrap ? _2 : (e3.state.gzhead = t3, m2) : _2;
      }, r2.deflate = function(e3, t3) {
        var r3, n3, i3, s3;
        if (!e3 || !e3.state || 5 < t3 || t3 < 0)
          return e3 ? R2(e3, _2) : _2;
        if (n3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n3.status && t3 !== f2)
          return R2(e3, 0 === e3.avail_out ? -5 : _2);
        if (n3.strm = e3, r3 = n3.last_flush, n3.last_flush = t3, n3.status === C2)
          if (2 === n3.wrap)
            e3.adler = 0, U2(n3, 31), U2(n3, 139), U2(n3, 8), n3.gzhead ? (U2(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U2(n3, 255 & n3.gzhead.time), U2(n3, n3.gzhead.time >> 8 & 255), U2(n3, n3.gzhead.time >> 16 & 255), U2(n3, n3.gzhead.time >> 24 & 255), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U2(n3, 255 & n3.gzhead.extra.length), U2(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 3), n3.status = E2);
          else {
            var a3 = v2 + (n3.w_bits - 8 << 4) << 8;
            a3 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : 6 === n3.level ? 2 : 3) << 6, 0 !== n3.strstart && (a3 |= 32), a3 += 31 - a3 % 31, n3.status = E2, P2(n3, a3), 0 !== n3.strstart && (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), e3.adler = 1;
          }
        if (69 === n3.status)
          if (n3.gzhead.extra) {
            for (i3 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending !== n3.pending_buf_size)); )
              U2(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
            n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
          } else
            n3.status = 73;
        if (73 === n3.status)
          if (n3.gzhead.name) {
            i3 = n3.pending;
            do {
              if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                s3 = 1;
                break;
              }
              s3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
            } while (0 !== s3);
            n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.gzindex = 0, n3.status = 91);
          } else
            n3.status = 91;
        if (91 === n3.status)
          if (n3.gzhead.comment) {
            i3 = n3.pending;
            do {
              if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                s3 = 1;
                break;
              }
              s3 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
            } while (0 !== s3);
            n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.status = 103);
          } else
            n3.status = 103;
        if (103 === n3.status && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F2(e3), n3.pending + 2 <= n3.pending_buf_size && (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), e3.adler = 0, n3.status = E2)) : n3.status = E2), 0 !== n3.pending) {
          if (F2(e3), 0 === e3.avail_out)
            return n3.last_flush = -1, m2;
        } else if (0 === e3.avail_in && T2(t3) <= T2(r3) && t3 !== f2)
          return R2(e3, -5);
        if (666 === n3.status && 0 !== e3.avail_in)
          return R2(e3, -5);
        if (0 !== e3.avail_in || 0 !== n3.lookahead || t3 !== l2 && 666 !== n3.status) {
          var o3 = 2 === n3.strategy ? function(e4, t4) {
            for (var r4; ; ) {
              if (0 === e4.lookahead && (j2(e4), 0 === e4.lookahead)) {
                if (t4 === l2)
                  return A2;
                break;
              }
              if (e4.match_length = 0, r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                return A2;
            }
            return e4.insert = 0, t4 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B2) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
          }(n3, t3) : 3 === n3.strategy ? function(e4, t4) {
            for (var r4, n4, i4, s4, a4 = e4.window; ; ) {
              if (e4.lookahead <= S2) {
                if (j2(e4), e4.lookahead <= S2 && t4 === l2)
                  return A2;
                if (0 === e4.lookahead)
                  break;
              }
              if (e4.match_length = 0, e4.lookahead >= x2 && 0 < e4.strstart && (n4 = a4[i4 = e4.strstart - 1]) === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4]) {
                s4 = e4.strstart + S2;
                do {
                } while (n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && i4 < s4);
                e4.match_length = S2 - (s4 - i4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
              }
              if (e4.match_length >= x2 ? (r4 = u2._tr_tally(e4, 1, e4.match_length - x2), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (N2(e4, false), 0 === e4.strm.avail_out))
                return A2;
            }
            return e4.insert = 0, t4 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B2) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
          }(n3, t3) : h2[n3.level].func(n3, t3);
          if (o3 !== O2 && o3 !== B2 || (n3.status = 666), o3 === A2 || o3 === O2)
            return 0 === e3.avail_out && (n3.last_flush = -1), m2;
          if (o3 === I2 && (1 === t3 ? u2._tr_align(n3) : 5 !== t3 && (u2._tr_stored_block(n3, 0, 0, false), 3 === t3 && (D2(n3.head), 0 === n3.lookahead && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F2(e3), 0 === e3.avail_out))
            return n3.last_flush = -1, m2;
        }
        return t3 !== f2 ? m2 : n3.wrap <= 0 ? 1 : (2 === n3.wrap ? (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), U2(n3, e3.adler >> 16 & 255), U2(n3, e3.adler >> 24 & 255), U2(n3, 255 & e3.total_in), U2(n3, e3.total_in >> 8 & 255), U2(n3, e3.total_in >> 16 & 255), U2(n3, e3.total_in >> 24 & 255)) : (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), F2(e3), 0 < n3.wrap && (n3.wrap = -n3.wrap), 0 !== n3.pending ? m2 : 1);
      }, r2.deflateEnd = function(e3) {
        var t3;
        return e3 && e3.state ? (t3 = e3.state.status) !== C2 && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E2 && 666 !== t3 ? R2(e3, _2) : (e3.state = null, t3 === E2 ? R2(e3, -3) : m2) : _2;
      }, r2.deflateSetDictionary = function(e3, t3) {
        var r3, n3, i3, s3, a3, o3, h3, u3, l3 = t3.length;
        if (!e3 || !e3.state)
          return _2;
        if (2 === (s3 = (r3 = e3.state).wrap) || 1 === s3 && r3.status !== C2 || r3.lookahead)
          return _2;
        for (1 === s3 && (e3.adler = d2(e3.adler, t3, l3, 0)), r3.wrap = 0, l3 >= r3.w_size && (0 === s3 && (D2(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u3 = new c2.Buf8(r3.w_size), c2.arraySet(u3, t3, l3 - r3.w_size, r3.w_size, 0), t3 = u3, l3 = r3.w_size), a3 = e3.avail_in, o3 = e3.next_in, h3 = e3.input, e3.avail_in = l3, e3.next_in = 0, e3.input = t3, j2(r3); r3.lookahead >= x2; ) {
          for (n3 = r3.strstart, i3 = r3.lookahead - (x2 - 1); r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + x2 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++, --i3; )
            ;
          r3.strstart = n3, r3.lookahead = x2 - 1, j2(r3);
        }
        return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = x2 - 1, r3.match_available = 0, e3.next_in = o3, e3.input = h3, e3.avail_in = a3, r3.wrap = s3, m2;
      }, r2.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t2, r2) {
      t2.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e2, t2, r2) {
      t2.exports = function(e3, t3) {
        var r3, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d2, p2, m2, _2, g2, b2, v2, y2, w2, k2, x2, S2, z2, C2;
        r3 = e3.state, n2 = e3.next_in, z2 = e3.input, i2 = n2 + (e3.avail_in - 5), s2 = e3.next_out, C2 = e3.output, a2 = s2 - (t3 - e3.avail_out), o2 = s2 + (e3.avail_out - 257), h2 = r3.dmax, u2 = r3.wsize, l2 = r3.whave, f2 = r3.wnext, c2 = r3.window, d2 = r3.hold, p2 = r3.bits, m2 = r3.lencode, _2 = r3.distcode, g2 = (1 << r3.lenbits) - 1, b2 = (1 << r3.distbits) - 1;
        e:
          do {
            p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = m2[d2 & g2];
            t:
              for (; ; ) {
                if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, 0 === (y2 = v2 >>> 16 & 255))
                  C2[s2++] = 65535 & v2;
                else {
                  if (!(16 & y2)) {
                    if (0 == (64 & y2)) {
                      v2 = m2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                      continue t;
                    }
                    if (32 & y2) {
                      r3.mode = 12;
                      break e;
                    }
                    e3.msg = "invalid literal/length code", r3.mode = 30;
                    break e;
                  }
                  w2 = 65535 & v2, (y2 &= 15) && (p2 < y2 && (d2 += z2[n2++] << p2, p2 += 8), w2 += d2 & (1 << y2) - 1, d2 >>>= y2, p2 -= y2), p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = _2[d2 & b2];
                  r:
                    for (; ; ) {
                      if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, !(16 & (y2 = v2 >>> 16 & 255))) {
                        if (0 == (64 & y2)) {
                          v2 = _2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                          continue r;
                        }
                        e3.msg = "invalid distance code", r3.mode = 30;
                        break e;
                      }
                      if (k2 = 65535 & v2, p2 < (y2 &= 15) && (d2 += z2[n2++] << p2, (p2 += 8) < y2 && (d2 += z2[n2++] << p2, p2 += 8)), h2 < (k2 += d2 & (1 << y2) - 1)) {
                        e3.msg = "invalid distance too far back", r3.mode = 30;
                        break e;
                      }
                      if (d2 >>>= y2, p2 -= y2, (y2 = s2 - a2) < k2) {
                        if (l2 < (y2 = k2 - y2) && r3.sane) {
                          e3.msg = "invalid distance too far back", r3.mode = 30;
                          break e;
                        }
                        if (S2 = c2, (x2 = 0) === f2) {
                          if (x2 += u2 - y2, y2 < w2) {
                            for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                              ;
                            x2 = s2 - k2, S2 = C2;
                          }
                        } else if (f2 < y2) {
                          if (x2 += u2 + f2 - y2, (y2 -= f2) < w2) {
                            for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                              ;
                            if (x2 = 0, f2 < w2) {
                              for (w2 -= y2 = f2; C2[s2++] = c2[x2++], --y2; )
                                ;
                              x2 = s2 - k2, S2 = C2;
                            }
                          }
                        } else if (x2 += f2 - y2, y2 < w2) {
                          for (w2 -= y2; C2[s2++] = c2[x2++], --y2; )
                            ;
                          x2 = s2 - k2, S2 = C2;
                        }
                        for (; 2 < w2; )
                          C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], w2 -= 3;
                        w2 && (C2[s2++] = S2[x2++], 1 < w2 && (C2[s2++] = S2[x2++]));
                      } else {
                        for (x2 = s2 - k2; C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], 2 < (w2 -= 3); )
                          ;
                        w2 && (C2[s2++] = C2[x2++], 1 < w2 && (C2[s2++] = C2[x2++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n2 < i2 && s2 < o2);
        n2 -= w2 = p2 >> 3, d2 &= (1 << (p2 -= w2 << 3)) - 1, e3.next_in = n2, e3.next_out = s2, e3.avail_in = n2 < i2 ? i2 - n2 + 5 : 5 - (n2 - i2), e3.avail_out = s2 < o2 ? o2 - s2 + 257 : 257 - (s2 - o2), r3.hold = d2, r3.bits = p2;
      };
    }, {}], 49: [function(e2, t2, r2) {
      var I2 = e2("../utils/common"), O2 = e2("./adler32"), B2 = e2("./crc32"), R2 = e2("./inffast"), T2 = e2("./inftrees"), D2 = 1, F2 = 2, N2 = 0, U2 = -2, P2 = 1, n2 = 852, i2 = 592;
      function L2(e3) {
        return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
      }
      function s2() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I2.Buf16(320), this.work = new I2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a2(e3) {
        var t3;
        return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = P2, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I2.Buf32(n2), t3.distcode = t3.distdyn = new I2.Buf32(i2), t3.sane = 1, t3.back = -1, N2) : U2;
      }
      function o2(e3) {
        var t3;
        return e3 && e3.state ? ((t3 = e3.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a2(e3)) : U2;
      }
      function h2(e3, t3) {
        var r3, n3;
        return e3 && e3.state ? (n3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U2 : (null !== n3.window && n3.wbits !== t3 && (n3.window = null), n3.wrap = r3, n3.wbits = t3, o2(e3))) : U2;
      }
      function u2(e3, t3) {
        var r3, n3;
        return e3 ? (n3 = new s2(), (e3.state = n3).window = null, (r3 = h2(e3, t3)) !== N2 && (e3.state = null), r3) : U2;
      }
      var l2, f2, c2 = true;
      function j2(e3) {
        if (c2) {
          var t3;
          for (l2 = new I2.Buf32(512), f2 = new I2.Buf32(32), t3 = 0; t3 < 144; )
            e3.lens[t3++] = 8;
          for (; t3 < 256; )
            e3.lens[t3++] = 9;
          for (; t3 < 280; )
            e3.lens[t3++] = 7;
          for (; t3 < 288; )
            e3.lens[t3++] = 8;
          for (T2(D2, e3.lens, 0, 288, l2, 0, e3.work, { bits: 9 }), t3 = 0; t3 < 32; )
            e3.lens[t3++] = 5;
          T2(F2, e3.lens, 0, 32, f2, 0, e3.work, { bits: 5 }), c2 = false;
        }
        e3.lencode = l2, e3.lenbits = 9, e3.distcode = f2, e3.distbits = 5;
      }
      function Z2(e3, t3, r3, n3) {
        var i3, s3 = e3.state;
        return null === s3.window && (s3.wsize = 1 << s3.wbits, s3.wnext = 0, s3.whave = 0, s3.window = new I2.Buf8(s3.wsize)), n3 >= s3.wsize ? (I2.arraySet(s3.window, t3, r3 - s3.wsize, s3.wsize, 0), s3.wnext = 0, s3.whave = s3.wsize) : (n3 < (i3 = s3.wsize - s3.wnext) && (i3 = n3), I2.arraySet(s3.window, t3, r3 - n3, i3, s3.wnext), (n3 -= i3) ? (I2.arraySet(s3.window, t3, r3 - n3, n3, 0), s3.wnext = n3, s3.whave = s3.wsize) : (s3.wnext += i3, s3.wnext === s3.wsize && (s3.wnext = 0), s3.whave < s3.wsize && (s3.whave += i3))), 0;
      }
      r2.inflateReset = o2, r2.inflateReset2 = h2, r2.inflateResetKeep = a2, r2.inflateInit = function(e3) {
        return u2(e3, 15);
      }, r2.inflateInit2 = u2, r2.inflate = function(e3, t3) {
        var r3, n3, i3, s3, a3, o3, h3, u3, l3, f3, c3, d2, p2, m2, _2, g2, b2, v2, y2, w2, k2, x2, S2, z2, C2 = 0, E2 = new I2.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in)
          return U2;
        12 === (r3 = e3.state).mode && (r3.mode = 13), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, f3 = o3, c3 = h3, x2 = N2;
        e:
          for (; ; )
            switch (r3.mode) {
              case P2:
                if (0 === r3.wrap) {
                  r3.mode = 13;
                  break;
                }
                for (; l3 < 16; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (2 & r3.wrap && 35615 === u3) {
                  E2[r3.check = 0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0), l3 = u3 = 0, r3.mode = 2;
                  break;
                }
                if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & u3) << 8) + (u3 >> 8)) % 31) {
                  e3.msg = "incorrect header check", r3.mode = 30;
                  break;
                }
                if (8 != (15 & u3)) {
                  e3.msg = "unknown compression method", r3.mode = 30;
                  break;
                }
                if (l3 -= 4, k2 = 8 + (15 & (u3 >>>= 4)), 0 === r3.wbits)
                  r3.wbits = k2;
                else if (k2 > r3.wbits) {
                  e3.msg = "invalid window size", r3.mode = 30;
                  break;
                }
                r3.dmax = 1 << k2, e3.adler = r3.check = 1, r3.mode = 512 & u3 ? 10 : 12, l3 = u3 = 0;
                break;
              case 2:
                for (; l3 < 16; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (r3.flags = u3, 8 != (255 & r3.flags)) {
                  e3.msg = "unknown compression method", r3.mode = 30;
                  break;
                }
                if (57344 & r3.flags) {
                  e3.msg = "unknown header flags set", r3.mode = 30;
                  break;
                }
                r3.head && (r3.head.text = u3 >> 8 & 1), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l3 = u3 = 0, r3.mode = 3;
              case 3:
                for (; l3 < 32; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.head && (r3.head.time = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, E2[2] = u3 >>> 16 & 255, E2[3] = u3 >>> 24 & 255, r3.check = B2(r3.check, E2, 4, 0)), l3 = u3 = 0, r3.mode = 4;
              case 4:
                for (; l3 < 16; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.head && (r3.head.xflags = 255 & u3, r3.head.os = u3 >> 8), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l3 = u3 = 0, r3.mode = 5;
              case 5:
                if (1024 & r3.flags) {
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.length = u3, r3.head && (r3.head.extra_len = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B2(r3.check, E2, 2, 0)), l3 = u3 = 0;
                } else
                  r3.head && (r3.head.extra = null);
                r3.mode = 6;
              case 6:
                if (1024 & r3.flags && (o3 < (d2 = r3.length) && (d2 = o3), d2 && (r3.head && (k2 = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), I2.arraySet(r3.head.extra, n3, s3, d2, k2)), 512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, r3.length -= d2), r3.length))
                  break e;
                r3.length = 0, r3.mode = 7;
              case 7:
                if (2048 & r3.flags) {
                  if (0 === o3)
                    break e;
                  for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.name += String.fromCharCode(k2)), k2 && d2 < o3; )
                    ;
                  if (512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2)
                    break e;
                } else
                  r3.head && (r3.head.name = null);
                r3.length = 0, r3.mode = 8;
              case 8:
                if (4096 & r3.flags) {
                  if (0 === o3)
                    break e;
                  for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.comment += String.fromCharCode(k2)), k2 && d2 < o3; )
                    ;
                  if (512 & r3.flags && (r3.check = B2(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2)
                    break e;
                } else
                  r3.head && (r3.head.comment = null);
                r3.mode = 9;
              case 9:
                if (512 & r3.flags) {
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (u3 !== (65535 & r3.check)) {
                    e3.msg = "header crc mismatch", r3.mode = 30;
                    break;
                  }
                  l3 = u3 = 0;
                }
                r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = 12;
                break;
              case 10:
                for (; l3 < 32; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                e3.adler = r3.check = L2(u3), l3 = u3 = 0, r3.mode = 11;
              case 11:
                if (0 === r3.havedict)
                  return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, 2;
                e3.adler = r3.check = 1, r3.mode = 12;
              case 12:
                if (5 === t3 || 6 === t3)
                  break e;
              case 13:
                if (r3.last) {
                  u3 >>>= 7 & l3, l3 -= 7 & l3, r3.mode = 27;
                  break;
                }
                for (; l3 < 3; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                switch (r3.last = 1 & u3, l3 -= 1, 3 & (u3 >>>= 1)) {
                  case 0:
                    r3.mode = 14;
                    break;
                  case 1:
                    if (j2(r3), r3.mode = 20, 6 !== t3)
                      break;
                    u3 >>>= 2, l3 -= 2;
                    break e;
                  case 2:
                    r3.mode = 17;
                    break;
                  case 3:
                    e3.msg = "invalid block type", r3.mode = 30;
                }
                u3 >>>= 2, l3 -= 2;
                break;
              case 14:
                for (u3 >>>= 7 & l3, l3 -= 7 & l3; l3 < 32; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if ((65535 & u3) != (u3 >>> 16 ^ 65535)) {
                  e3.msg = "invalid stored block lengths", r3.mode = 30;
                  break;
                }
                if (r3.length = 65535 & u3, l3 = u3 = 0, r3.mode = 15, 6 === t3)
                  break e;
              case 15:
                r3.mode = 16;
              case 16:
                if (d2 = r3.length) {
                  if (o3 < d2 && (d2 = o3), h3 < d2 && (d2 = h3), 0 === d2)
                    break e;
                  I2.arraySet(i3, n3, s3, d2, a3), o3 -= d2, s3 += d2, h3 -= d2, a3 += d2, r3.length -= d2;
                  break;
                }
                r3.mode = 12;
                break;
              case 17:
                for (; l3 < 14; ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (r3.nlen = 257 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ndist = 1 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ncode = 4 + (15 & u3), u3 >>>= 4, l3 -= 4, 286 < r3.nlen || 30 < r3.ndist) {
                  e3.msg = "too many length or distance symbols", r3.mode = 30;
                  break;
                }
                r3.have = 0, r3.mode = 18;
              case 18:
                for (; r3.have < r3.ncode; ) {
                  for (; l3 < 3; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.lens[A2[r3.have++]] = 7 & u3, u3 >>>= 3, l3 -= 3;
                }
                for (; r3.have < 19; )
                  r3.lens[A2[r3.have++]] = 0;
                if (r3.lencode = r3.lendyn, r3.lenbits = 7, S2 = { bits: r3.lenbits }, x2 = T2(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                  e3.msg = "invalid code lengths set", r3.mode = 30;
                  break;
                }
                r3.have = 0, r3.mode = 19;
              case 19:
                for (; r3.have < r3.nlen + r3.ndist; ) {
                  for (; g2 = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (b2 < 16)
                    u3 >>>= _2, l3 -= _2, r3.lens[r3.have++] = b2;
                  else {
                    if (16 === b2) {
                      for (z2 = _2 + 2; l3 < z2; ) {
                        if (0 === o3)
                          break e;
                        o3--, u3 += n3[s3++] << l3, l3 += 8;
                      }
                      if (u3 >>>= _2, l3 -= _2, 0 === r3.have) {
                        e3.msg = "invalid bit length repeat", r3.mode = 30;
                        break;
                      }
                      k2 = r3.lens[r3.have - 1], d2 = 3 + (3 & u3), u3 >>>= 2, l3 -= 2;
                    } else if (17 === b2) {
                      for (z2 = _2 + 3; l3 < z2; ) {
                        if (0 === o3)
                          break e;
                        o3--, u3 += n3[s3++] << l3, l3 += 8;
                      }
                      l3 -= _2, k2 = 0, d2 = 3 + (7 & (u3 >>>= _2)), u3 >>>= 3, l3 -= 3;
                    } else {
                      for (z2 = _2 + 7; l3 < z2; ) {
                        if (0 === o3)
                          break e;
                        o3--, u3 += n3[s3++] << l3, l3 += 8;
                      }
                      l3 -= _2, k2 = 0, d2 = 11 + (127 & (u3 >>>= _2)), u3 >>>= 7, l3 -= 7;
                    }
                    if (r3.have + d2 > r3.nlen + r3.ndist) {
                      e3.msg = "invalid bit length repeat", r3.mode = 30;
                      break;
                    }
                    for (; d2--; )
                      r3.lens[r3.have++] = k2;
                  }
                }
                if (30 === r3.mode)
                  break;
                if (0 === r3.lens[256]) {
                  e3.msg = "invalid code -- missing end-of-block", r3.mode = 30;
                  break;
                }
                if (r3.lenbits = 9, S2 = { bits: r3.lenbits }, x2 = T2(D2, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                  e3.msg = "invalid literal/lengths set", r3.mode = 30;
                  break;
                }
                if (r3.distbits = 6, r3.distcode = r3.distdyn, S2 = { bits: r3.distbits }, x2 = T2(F2, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, S2), r3.distbits = S2.bits, x2) {
                  e3.msg = "invalid distances set", r3.mode = 30;
                  break;
                }
                if (r3.mode = 20, 6 === t3)
                  break e;
              case 20:
                r3.mode = 21;
              case 21:
                if (6 <= o3 && 258 <= h3) {
                  e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, R2(e3, c3), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, 12 === r3.mode && (r3.back = -1);
                  break;
                }
                for (r3.back = 0; g2 = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l3); ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (g2 && 0 == (240 & g2)) {
                  for (v2 = _2, y2 = g2, w2 = b2; g2 = (C2 = r3.lencode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  u3 >>>= v2, l3 -= v2, r3.back += v2;
                }
                if (u3 >>>= _2, l3 -= _2, r3.back += _2, r3.length = b2, 0 === g2) {
                  r3.mode = 26;
                  break;
                }
                if (32 & g2) {
                  r3.back = -1, r3.mode = 12;
                  break;
                }
                if (64 & g2) {
                  e3.msg = "invalid literal/length code", r3.mode = 30;
                  break;
                }
                r3.extra = 15 & g2, r3.mode = 22;
              case 22:
                if (r3.extra) {
                  for (z2 = r3.extra; l3 < z2; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.length += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                }
                r3.was = r3.length, r3.mode = 23;
              case 23:
                for (; g2 = (C2 = r3.distcode[u3 & (1 << r3.distbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l3); ) {
                  if (0 === o3)
                    break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (0 == (240 & g2)) {
                  for (v2 = _2, y2 = g2, w2 = b2; g2 = (C2 = r3.distcode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  u3 >>>= v2, l3 -= v2, r3.back += v2;
                }
                if (u3 >>>= _2, l3 -= _2, r3.back += _2, 64 & g2) {
                  e3.msg = "invalid distance code", r3.mode = 30;
                  break;
                }
                r3.offset = b2, r3.extra = 15 & g2, r3.mode = 24;
              case 24:
                if (r3.extra) {
                  for (z2 = r3.extra; l3 < z2; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.offset += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                }
                if (r3.offset > r3.dmax) {
                  e3.msg = "invalid distance too far back", r3.mode = 30;
                  break;
                }
                r3.mode = 25;
              case 25:
                if (0 === h3)
                  break e;
                if (d2 = c3 - h3, r3.offset > d2) {
                  if ((d2 = r3.offset - d2) > r3.whave && r3.sane) {
                    e3.msg = "invalid distance too far back", r3.mode = 30;
                    break;
                  }
                  p2 = d2 > r3.wnext ? (d2 -= r3.wnext, r3.wsize - d2) : r3.wnext - d2, d2 > r3.length && (d2 = r3.length), m2 = r3.window;
                } else
                  m2 = i3, p2 = a3 - r3.offset, d2 = r3.length;
                for (h3 < d2 && (d2 = h3), h3 -= d2, r3.length -= d2; i3[a3++] = m2[p2++], --d2; )
                  ;
                0 === r3.length && (r3.mode = 21);
                break;
              case 26:
                if (0 === h3)
                  break e;
                i3[a3++] = r3.length, h3--, r3.mode = 21;
                break;
              case 27:
                if (r3.wrap) {
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 |= n3[s3++] << l3, l3 += 8;
                  }
                  if (c3 -= h3, e3.total_out += c3, r3.total += c3, c3 && (e3.adler = r3.check = r3.flags ? B2(r3.check, i3, c3, a3 - c3) : O2(r3.check, i3, c3, a3 - c3)), c3 = h3, (r3.flags ? u3 : L2(u3)) !== r3.check) {
                    e3.msg = "incorrect data check", r3.mode = 30;
                    break;
                  }
                  l3 = u3 = 0;
                }
                r3.mode = 28;
              case 28:
                if (r3.wrap && r3.flags) {
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u3 += n3[s3++] << l3, l3 += 8;
                  }
                  if (u3 !== (4294967295 & r3.total)) {
                    e3.msg = "incorrect length check", r3.mode = 30;
                    break;
                  }
                  l3 = u3 = 0;
                }
                r3.mode = 29;
              case 29:
                x2 = 1;
                break e;
              case 30:
                x2 = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U2;
            }
        return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, (r3.wsize || c3 !== e3.avail_out && r3.mode < 30 && (r3.mode < 27 || 4 !== t3)) && Z2(e3, e3.output, e3.next_out, c3 - e3.avail_out) ? (r3.mode = 31, -4) : (f3 -= e3.avail_in, c3 -= e3.avail_out, e3.total_in += f3, e3.total_out += c3, r3.total += c3, r3.wrap && c3 && (e3.adler = r3.check = r3.flags ? B2(r3.check, i3, c3, e3.next_out - c3) : O2(r3.check, i3, c3, e3.next_out - c3)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (12 === r3.mode ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 == f3 && 0 === c3 || 4 === t3) && x2 === N2 && (x2 = -5), x2);
      }, r2.inflateEnd = function(e3) {
        if (!e3 || !e3.state)
          return U2;
        var t3 = e3.state;
        return t3.window && (t3.window = null), e3.state = null, N2;
      }, r2.inflateGetHeader = function(e3, t3) {
        var r3;
        return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? U2 : ((r3.head = t3).done = false, N2) : U2;
      }, r2.inflateSetDictionary = function(e3, t3) {
        var r3, n3 = t3.length;
        return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? U2 : 11 === r3.mode && O2(1, t3, n3, 0) !== r3.check ? -3 : Z2(e3, t3, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, N2) : U2;
      }, r2.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t2, r2) {
      var D2 = e2("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t2.exports = function(e3, t3, r3, n2, i2, s2, a2, o2) {
        var h2, u2, l2, f2, c2, d2, p2, m2, _2, g2 = o2.bits, b2 = 0, v2 = 0, y2 = 0, w2 = 0, k2 = 0, x2 = 0, S2 = 0, z2 = 0, C2 = 0, E2 = 0, A2 = null, I2 = 0, O2 = new D2.Buf16(16), B2 = new D2.Buf16(16), R2 = null, T2 = 0;
        for (b2 = 0; b2 <= 15; b2++)
          O2[b2] = 0;
        for (v2 = 0; v2 < n2; v2++)
          O2[t3[r3 + v2]]++;
        for (k2 = g2, w2 = 15; 1 <= w2 && 0 === O2[w2]; w2--)
          ;
        if (w2 < k2 && (k2 = w2), 0 === w2)
          return i2[s2++] = 20971520, i2[s2++] = 20971520, o2.bits = 1, 0;
        for (y2 = 1; y2 < w2 && 0 === O2[y2]; y2++)
          ;
        for (k2 < y2 && (k2 = y2), b2 = z2 = 1; b2 <= 15; b2++)
          if (z2 <<= 1, (z2 -= O2[b2]) < 0)
            return -1;
        if (0 < z2 && (0 === e3 || 1 !== w2))
          return -1;
        for (B2[1] = 0, b2 = 1; b2 < 15; b2++)
          B2[b2 + 1] = B2[b2] + O2[b2];
        for (v2 = 0; v2 < n2; v2++)
          0 !== t3[r3 + v2] && (a2[B2[t3[r3 + v2]]++] = v2);
        if (d2 = 0 === e3 ? (A2 = R2 = a2, 19) : 1 === e3 ? (A2 = F2, I2 -= 257, R2 = N2, T2 -= 257, 256) : (A2 = U2, R2 = P2, -1), b2 = y2, c2 = s2, S2 = v2 = E2 = 0, l2 = -1, f2 = (C2 = 1 << (x2 = k2)) - 1, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2)
          return 1;
        for (; ; ) {
          for (p2 = b2 - S2, _2 = a2[v2] < d2 ? (m2 = 0, a2[v2]) : a2[v2] > d2 ? (m2 = R2[T2 + a2[v2]], A2[I2 + a2[v2]]) : (m2 = 96, 0), h2 = 1 << b2 - S2, y2 = u2 = 1 << x2; i2[c2 + (E2 >> S2) + (u2 -= h2)] = p2 << 24 | m2 << 16 | _2 | 0, 0 !== u2; )
            ;
          for (h2 = 1 << b2 - 1; E2 & h2; )
            h2 >>= 1;
          if (0 !== h2 ? (E2 &= h2 - 1, E2 += h2) : E2 = 0, v2++, 0 == --O2[b2]) {
            if (b2 === w2)
              break;
            b2 = t3[r3 + a2[v2]];
          }
          if (k2 < b2 && (E2 & f2) !== l2) {
            for (0 === S2 && (S2 = k2), c2 += y2, z2 = 1 << (x2 = b2 - S2); x2 + S2 < w2 && !((z2 -= O2[x2 + S2]) <= 0); )
              x2++, z2 <<= 1;
            if (C2 += 1 << x2, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2)
              return 1;
            i2[l2 = E2 & f2] = k2 << 24 | x2 << 16 | c2 - s2 | 0;
          }
        }
        return 0 !== E2 && (i2[c2 + E2] = b2 - S2 << 24 | 64 << 16 | 0), o2.bits = k2, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e2, t2, r2) {
      t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e2, t2, r2) {
      var i2 = e2("../utils/common"), o2 = 0, h2 = 1;
      function n2(e3) {
        for (var t3 = e3.length; 0 <= --t3; )
          e3[t3] = 0;
      }
      var s2 = 0, a2 = 29, u2 = 256, l2 = u2 + 1 + a2, f2 = 30, c2 = 19, _2 = 2 * l2 + 1, g2 = 15, d2 = 16, p2 = 7, m2 = 256, b2 = 16, v2 = 17, y2 = 18, w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l2 + 2));
      n2(z2);
      var C2 = new Array(2 * f2);
      n2(C2);
      var E2 = new Array(512);
      n2(E2);
      var A2 = new Array(256);
      n2(A2);
      var I2 = new Array(a2);
      n2(I2);
      var O2, B2, R2, T2 = new Array(f2);
      function D2(e3, t3, r3, n3, i3) {
        this.static_tree = e3, this.extra_bits = t3, this.extra_base = r3, this.elems = n3, this.max_length = i3, this.has_stree = e3 && e3.length;
      }
      function F2(e3, t3) {
        this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t3;
      }
      function N2(e3) {
        return e3 < 256 ? E2[e3] : E2[256 + (e3 >>> 7)];
      }
      function U2(e3, t3) {
        e3.pending_buf[e3.pending++] = 255 & t3, e3.pending_buf[e3.pending++] = t3 >>> 8 & 255;
      }
      function P2(e3, t3, r3) {
        e3.bi_valid > d2 - r3 ? (e3.bi_buf |= t3 << e3.bi_valid & 65535, U2(e3, e3.bi_buf), e3.bi_buf = t3 >> d2 - e3.bi_valid, e3.bi_valid += r3 - d2) : (e3.bi_buf |= t3 << e3.bi_valid & 65535, e3.bi_valid += r3);
      }
      function L2(e3, t3, r3) {
        P2(e3, r3[2 * t3], r3[2 * t3 + 1]);
      }
      function j2(e3, t3) {
        for (var r3 = 0; r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1, 0 < --t3; )
          ;
        return r3 >>> 1;
      }
      function Z2(e3, t3, r3) {
        var n3, i3, s3 = new Array(g2 + 1), a3 = 0;
        for (n3 = 1; n3 <= g2; n3++)
          s3[n3] = a3 = a3 + r3[n3 - 1] << 1;
        for (i3 = 0; i3 <= t3; i3++) {
          var o3 = e3[2 * i3 + 1];
          0 !== o3 && (e3[2 * i3] = j2(s3[o3]++, o3));
        }
      }
      function W2(e3) {
        var t3;
        for (t3 = 0; t3 < l2; t3++)
          e3.dyn_ltree[2 * t3] = 0;
        for (t3 = 0; t3 < f2; t3++)
          e3.dyn_dtree[2 * t3] = 0;
        for (t3 = 0; t3 < c2; t3++)
          e3.bl_tree[2 * t3] = 0;
        e3.dyn_ltree[2 * m2] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
      }
      function M2(e3) {
        8 < e3.bi_valid ? U2(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
      }
      function H2(e3, t3, r3, n3) {
        var i3 = 2 * t3, s3 = 2 * r3;
        return e3[i3] < e3[s3] || e3[i3] === e3[s3] && n3[t3] <= n3[r3];
      }
      function G2(e3, t3, r3) {
        for (var n3 = e3.heap[r3], i3 = r3 << 1; i3 <= e3.heap_len && (i3 < e3.heap_len && H2(t3, e3.heap[i3 + 1], e3.heap[i3], e3.depth) && i3++, !H2(t3, n3, e3.heap[i3], e3.depth)); )
          e3.heap[r3] = e3.heap[i3], r3 = i3, i3 <<= 1;
        e3.heap[r3] = n3;
      }
      function K2(e3, t3, r3) {
        var n3, i3, s3, a3, o3 = 0;
        if (0 !== e3.last_lit)
          for (; n3 = e3.pending_buf[e3.d_buf + 2 * o3] << 8 | e3.pending_buf[e3.d_buf + 2 * o3 + 1], i3 = e3.pending_buf[e3.l_buf + o3], o3++, 0 === n3 ? L2(e3, i3, t3) : (L2(e3, (s3 = A2[i3]) + u2 + 1, t3), 0 !== (a3 = w2[s3]) && P2(e3, i3 -= I2[s3], a3), L2(e3, s3 = N2(--n3), r3), 0 !== (a3 = k2[s3]) && P2(e3, n3 -= T2[s3], a3)), o3 < e3.last_lit; )
            ;
        L2(e3, m2, t3);
      }
      function Y2(e3, t3) {
        var r3, n3, i3, s3 = t3.dyn_tree, a3 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, h3 = t3.stat_desc.elems, u3 = -1;
        for (e3.heap_len = 0, e3.heap_max = _2, r3 = 0; r3 < h3; r3++)
          0 !== s3[2 * r3] ? (e3.heap[++e3.heap_len] = u3 = r3, e3.depth[r3] = 0) : s3[2 * r3 + 1] = 0;
        for (; e3.heap_len < 2; )
          s3[2 * (i3 = e3.heap[++e3.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e3.depth[i3] = 0, e3.opt_len--, o3 && (e3.static_len -= a3[2 * i3 + 1]);
        for (t3.max_code = u3, r3 = e3.heap_len >> 1; 1 <= r3; r3--)
          G2(e3, s3, r3);
        for (i3 = h3; r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G2(e3, s3, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, s3[2 * i3] = s3[2 * r3] + s3[2 * n3], e3.depth[i3] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, s3[2 * r3 + 1] = s3[2 * n3 + 1] = i3, e3.heap[1] = i3++, G2(e3, s3, 1), 2 <= e3.heap_len; )
          ;
        e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t4) {
          var r4, n4, i4, s4, a4, o4, h4 = t4.dyn_tree, u4 = t4.max_code, l3 = t4.stat_desc.static_tree, f3 = t4.stat_desc.has_stree, c3 = t4.stat_desc.extra_bits, d3 = t4.stat_desc.extra_base, p3 = t4.stat_desc.max_length, m3 = 0;
          for (s4 = 0; s4 <= g2; s4++)
            e4.bl_count[s4] = 0;
          for (h4[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < _2; r4++)
            p3 < (s4 = h4[2 * h4[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) && (s4 = p3, m3++), h4[2 * n4 + 1] = s4, u4 < n4 || (e4.bl_count[s4]++, a4 = 0, d3 <= n4 && (a4 = c3[n4 - d3]), o4 = h4[2 * n4], e4.opt_len += o4 * (s4 + a4), f3 && (e4.static_len += o4 * (l3[2 * n4 + 1] + a4)));
          if (0 !== m3) {
            do {
              for (s4 = p3 - 1; 0 === e4.bl_count[s4]; )
                s4--;
              e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[p3]--, m3 -= 2;
            } while (0 < m3);
            for (s4 = p3; 0 !== s4; s4--)
              for (n4 = e4.bl_count[s4]; 0 !== n4; )
                u4 < (i4 = e4.heap[--r4]) || (h4[2 * i4 + 1] !== s4 && (e4.opt_len += (s4 - h4[2 * i4 + 1]) * h4[2 * i4], h4[2 * i4 + 1] = s4), n4--);
          }
        }(e3, t3), Z2(s3, u3, e3.bl_count);
      }
      function X2(e3, t3, r3) {
        var n3, i3, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
        for (0 === a3 && (h3 = 138, u3 = 3), t3[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++)
          i3 = a3, a3 = t3[2 * (n3 + 1) + 1], ++o3 < h3 && i3 === a3 || (o3 < u3 ? e3.bl_tree[2 * i3] += o3 : 0 !== i3 ? (i3 !== s3 && e3.bl_tree[2 * i3]++, e3.bl_tree[2 * b2]++) : o3 <= 10 ? e3.bl_tree[2 * v2]++ : e3.bl_tree[2 * y2]++, s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4));
      }
      function V2(e3, t3, r3) {
        var n3, i3, s3 = -1, a3 = t3[1], o3 = 0, h3 = 7, u3 = 4;
        for (0 === a3 && (h3 = 138, u3 = 3), n3 = 0; n3 <= r3; n3++)
          if (i3 = a3, a3 = t3[2 * (n3 + 1) + 1], !(++o3 < h3 && i3 === a3)) {
            if (o3 < u3)
              for (; L2(e3, i3, e3.bl_tree), 0 != --o3; )
                ;
            else
              0 !== i3 ? (i3 !== s3 && (L2(e3, i3, e3.bl_tree), o3--), L2(e3, b2, e3.bl_tree), P2(e3, o3 - 3, 2)) : o3 <= 10 ? (L2(e3, v2, e3.bl_tree), P2(e3, o3 - 3, 3)) : (L2(e3, y2, e3.bl_tree), P2(e3, o3 - 11, 7));
            s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4);
          }
      }
      n2(T2);
      var q2 = false;
      function J2(e3, t3, r3, n3) {
        P2(e3, (s2 << 1) + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
          M2(e4), n4 && (U2(e4, r4), U2(e4, ~r4)), i2.arraySet(e4.pending_buf, e4.window, t4, r4, e4.pending), e4.pending += r4;
        }(e3, t3, r3, true);
      }
      r2._tr_init = function(e3) {
        q2 || (function() {
          var e4, t3, r3, n3, i3, s3 = new Array(g2 + 1);
          for (n3 = r3 = 0; n3 < a2 - 1; n3++)
            for (I2[n3] = r3, e4 = 0; e4 < 1 << w2[n3]; e4++)
              A2[r3++] = n3;
          for (A2[r3 - 1] = n3, n3 = i3 = 0; n3 < 16; n3++)
            for (T2[n3] = i3, e4 = 0; e4 < 1 << k2[n3]; e4++)
              E2[i3++] = n3;
          for (i3 >>= 7; n3 < f2; n3++)
            for (T2[n3] = i3 << 7, e4 = 0; e4 < 1 << k2[n3] - 7; e4++)
              E2[256 + i3++] = n3;
          for (t3 = 0; t3 <= g2; t3++)
            s3[t3] = 0;
          for (e4 = 0; e4 <= 143; )
            z2[2 * e4 + 1] = 8, e4++, s3[8]++;
          for (; e4 <= 255; )
            z2[2 * e4 + 1] = 9, e4++, s3[9]++;
          for (; e4 <= 279; )
            z2[2 * e4 + 1] = 7, e4++, s3[7]++;
          for (; e4 <= 287; )
            z2[2 * e4 + 1] = 8, e4++, s3[8]++;
          for (Z2(z2, l2 + 1, s3), e4 = 0; e4 < f2; e4++)
            C2[2 * e4 + 1] = 5, C2[2 * e4] = j2(e4, 5);
          O2 = new D2(z2, w2, u2 + 1, l2, g2), B2 = new D2(C2, k2, 0, f2, g2), R2 = new D2(new Array(0), x2, 0, c2, p2);
        }(), q2 = true), e3.l_desc = new F2(e3.dyn_ltree, O2), e3.d_desc = new F2(e3.dyn_dtree, B2), e3.bl_desc = new F2(e3.bl_tree, R2), e3.bi_buf = 0, e3.bi_valid = 0, W2(e3);
      }, r2._tr_stored_block = J2, r2._tr_flush_block = function(e3, t3, r3, n3) {
        var i3, s3, a3 = 0;
        0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
          var t4, r4 = 4093624447;
          for (t4 = 0; t4 <= 31; t4++, r4 >>>= 1)
            if (1 & r4 && 0 !== e4.dyn_ltree[2 * t4])
              return o2;
          if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26])
            return h2;
          for (t4 = 32; t4 < u2; t4++)
            if (0 !== e4.dyn_ltree[2 * t4])
              return h2;
          return o2;
        }(e3)), Y2(e3, e3.l_desc), Y2(e3, e3.d_desc), a3 = function(e4) {
          var t4;
          for (X2(e4, e4.dyn_ltree, e4.l_desc.max_code), X2(e4, e4.dyn_dtree, e4.d_desc.max_code), Y2(e4, e4.bl_desc), t4 = c2 - 1; 3 <= t4 && 0 === e4.bl_tree[2 * S2[t4] + 1]; t4--)
            ;
          return e4.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
        }(e3), i3 = e3.opt_len + 3 + 7 >>> 3, (s3 = e3.static_len + 3 + 7 >>> 3) <= i3 && (i3 = s3)) : i3 = s3 = r3 + 5, r3 + 4 <= i3 && -1 !== t3 ? J2(e3, t3, r3, n3) : 4 === e3.strategy || s3 === i3 ? (P2(e3, 2 + (n3 ? 1 : 0), 3), K2(e3, z2, C2)) : (P2(e3, 4 + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
          var i4;
          for (P2(e4, t4 - 257, 5), P2(e4, r4 - 1, 5), P2(e4, n4 - 4, 4), i4 = 0; i4 < n4; i4++)
            P2(e4, e4.bl_tree[2 * S2[i4] + 1], 3);
          V2(e4, e4.dyn_ltree, t4 - 1), V2(e4, e4.dyn_dtree, r4 - 1);
        }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a3 + 1), K2(e3, e3.dyn_ltree, e3.dyn_dtree)), W2(e3), n3 && M2(e3);
      }, r2._tr_tally = function(e3, t3, r3) {
        return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t3 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t3, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t3 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t3--, e3.dyn_ltree[2 * (A2[r3] + u2 + 1)]++, e3.dyn_dtree[2 * N2(t3)]++), e3.last_lit === e3.lit_bufsize - 1;
      }, r2._tr_align = function(e3) {
        P2(e3, 2, 3), L2(e3, m2, z2), function(e4) {
          16 === e4.bi_valid ? (U2(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
        }(e3);
      };
    }, { "../utils/common": 41 }], 53: [function(e2, t2, r2) {
      t2.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e2, t2, r2) {
      (function(e3) {
        !function(r3, n2) {
          if (!r3.setImmediate) {
            var i2, s2, t3, a2, o2 = 1, h2 = {}, u2 = false, l2 = r3.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r3);
            e4 = e4 && e4.setTimeout ? e4 : r3, i2 = "[object process]" === {}.toString.call(r3.process) ? function(e5) {
              process.nextTick(function() {
                c2(e5);
              });
            } : function() {
              if (r3.postMessage && !r3.importScripts) {
                var e5 = true, t4 = r3.onmessage;
                return r3.onmessage = function() {
                  e5 = false;
                }, r3.postMessage("", "*"), r3.onmessage = t4, e5;
              }
            }() ? (a2 = "setImmediate$" + Math.random() + "$", r3.addEventListener ? r3.addEventListener("message", d2, false) : r3.attachEvent("onmessage", d2), function(e5) {
              r3.postMessage(a2 + e5, "*");
            }) : r3.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e5) {
              c2(e5.data);
            }, function(e5) {
              t3.port2.postMessage(e5);
            }) : l2 && "onreadystatechange" in l2.createElement("script") ? (s2 = l2.documentElement, function(e5) {
              var t4 = l2.createElement("script");
              t4.onreadystatechange = function() {
                c2(e5), t4.onreadystatechange = null, s2.removeChild(t4), t4 = null;
              }, s2.appendChild(t4);
            }) : function(e5) {
              setTimeout(c2, 0, e5);
            }, e4.setImmediate = function(e5) {
              "function" != typeof e5 && (e5 = new Function("" + e5));
              for (var t4 = new Array(arguments.length - 1), r4 = 0; r4 < t4.length; r4++)
                t4[r4] = arguments[r4 + 1];
              var n3 = { callback: e5, args: t4 };
              return h2[o2] = n3, i2(o2), o2++;
            }, e4.clearImmediate = f2;
          }
          function f2(e5) {
            delete h2[e5];
          }
          function c2(e5) {
            if (u2)
              setTimeout(c2, 0, e5);
            else {
              var t4 = h2[e5];
              if (t4) {
                u2 = true;
                try {
                  !function(e6) {
                    var t5 = e6.callback, r4 = e6.args;
                    switch (r4.length) {
                      case 0:
                        t5();
                        break;
                      case 1:
                        t5(r4[0]);
                        break;
                      case 2:
                        t5(r4[0], r4[1]);
                        break;
                      case 3:
                        t5(r4[0], r4[1], r4[2]);
                        break;
                      default:
                        t5.apply(n2, r4);
                    }
                  }(t4);
                } finally {
                  f2(e5), u2 = false;
                }
              }
            }
          }
          function d2(e5) {
            e5.source === r3 && "string" == typeof e5.data && 0 === e5.data.indexOf(a2) && c2(+e5.data.slice(a2.length));
          }
        }("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var JSZip = jszip_min.exports;
const ALIAS = Symbol.for("yaml.alias");
const DOC = Symbol.for("yaml.document");
const MAP = Symbol.for("yaml.map");
const PAIR = Symbol.for("yaml.pair");
const SCALAR$1 = Symbol.for("yaml.scalar");
const SEQ = Symbol.for("yaml.seq");
const NODE_TYPE = Symbol.for("yaml.node.type");
const isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
const isScalar$1 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR$1;
const isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection$1(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
const hasAnchor = (node) => (isScalar$1(node) || isCollection$1(node)) && !!node.anchor;
class NodeBase {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  clone() {
    const copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy2.range = this.range.slice();
    return copy2;
  }
}
const BREAK$1 = Symbol("break visit");
const SKIP$1 = Symbol("skip children");
const REMOVE$1 = Symbol("remove node");
function visit$1(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE$1)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit$1.BREAK = BREAK$1;
visit$1.SKIP = SKIP$1;
visit$1.REMOVE = REMOVE$1;
function visit_(key, node, visitor, path2) {
  const ctrl = callVisitor(key, node, visitor, path2);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path2, ctrl);
    return visit_(key, ctrl, visitor, path2);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node)) {
      path2 = Object.freeze(path2.concat(node));
      for (let i2 = 0; i2 < node.items.length; ++i2) {
        const ci = visit_(i2, node.items[i2], visitor, path2);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node)) {
      path2 = Object.freeze(path2.concat(node));
      const ck = visit_("key", node.key, visitor, path2);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path2);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE$1)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK$1;
visitAsync.SKIP = SKIP$1;
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(key, node, visitor, path2) {
  const ctrl = await callVisitor(key, node, visitor, path2);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path2, ctrl);
    return visitAsync_(key, ctrl, visitor, path2);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node)) {
      path2 = Object.freeze(path2.concat(node));
      for (let i2 = 0; i2 < node.items.length; ++i2) {
        const ci = await visitAsync_(i2, node.items[i2], visitor, path2);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node)) {
      path2 = Object.freeze(path2.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path2);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path2);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path2) {
  var _a2, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path2);
  if (isMap(node))
    return (_a2 = visitor.Map) == null ? void 0 : _a2.call(visitor, key, node, path2);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path2);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path2);
  if (isScalar$1(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path2);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path2);
  return void 0;
}
function replaceNode(key, path2, node) {
  const parent = path2[path2.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
const escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
class Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy2 = new Directives(this.yaml, this.tags);
    copy2.docStart = this.docStart;
    return copy2;
  }
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  add(line2, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line2.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version2] = parts;
        if (version2 === "1.1" || version2 === "1.2") {
          this.yaml.version = version2;
          return true;
        } else {
          const isValid2 = /^\d+\.\d+$/.test(version2);
          onError(6, `Unsupported YAML version ${version2}`, isValid2);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc2) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc2 && tagEntries.length > 0 && isNode(doc2.contents)) {
      const tags = {};
      visit$1(doc2.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc2 || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
}
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa2 = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa2}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root2) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root2, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i2 = 1; true; ++i2) {
    const name = `${prefix}${i2}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc2, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc2);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref2 = sourceObjects.get(source);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar$1(ref2.node) || isCollection$1(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error2 = new Error("Failed to resolve repeated object (this should not happen)");
          error2.source = source;
          throw error2;
        }
      }
    },
    sourceObjects
  };
}
class Alias extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  resolve(doc2) {
    let found = void 0;
    visit$1(doc2, {
      Node: (_key, node) => {
        if (node === this)
          return visit$1.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc: doc2, maxAliasCount } = ctx;
    const source = this.resolve(doc2);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data2 = anchors.get(source);
    if (!data2 || data2.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data2.count += 1;
      if (data2.aliasCount === 0)
        data2.aliasCount = getAliasCount(doc2, source, anchors);
      if (data2.count * data2.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data2.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
}
function getAliasCount(doc2, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc2);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node)) {
    let count2 = 0;
    for (const item of node.items) {
      const c2 = getAliasCount(doc2, item, anchors);
      if (c2 > count2)
        count2 = c2;
    }
    return count2;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc2, node.key, anchors);
    const vc = getAliasCount(doc2, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v2, i2) => toJS(v2, String(i2), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data2 = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data2);
    ctx.onCreate = (res2) => {
      data2.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}
const isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
class Scalar extends NodeBase {
  constructor(value) {
    super(SCALAR$1);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
}
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
const defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a2;
  if (tagName) {
    const match5 = tags.filter((t2) => t2.tag === tagName);
    const tagObj = (_a2 = match5.find((t2) => !t2.format)) != null ? _a2 : match5[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t2) => {
    var _a3;
    return ((_a3 = t2.identify) == null ? void 0 : _a3.call(t2, value)) && !t2.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a2, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a2 = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a2, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref2 = sourceObjects.get(value);
    if (ref2) {
      if (!ref2.anchor)
        ref2.anchor = onAnchor(value);
      return new Alias(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value, ref2);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema2.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref2)
        ref2.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref2)
    ref2.node = node;
  return node;
}
function collectionFromPath(schema2, path2, value) {
  let v2 = value;
  for (let i2 = path2.length - 1; i2 >= 0; --i2) {
    const k2 = path2[i2];
    if (typeof k2 === "number" && Number.isInteger(k2) && k2 >= 0) {
      const a2 = [];
      a2[k2] = v2;
      v2 = a2;
    } else {
      v2 = /* @__PURE__ */ new Map([[k2, v2]]);
    }
  }
  return createNode(v2, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
class Collection extends NodeBase {
  constructor(type, schema2) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  clone(schema2) {
    const copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy2.schema = schema2;
    copy2.items = copy2.items.map((it2) => isNode(it2) || isPair(it2) ? it2.clone(schema2) : it2);
    if (this.range)
      copy2.range = this.range.slice();
    return copy2;
  }
  addIn(path2, value) {
    if (isEmptyPath(path2))
      this.add(value);
    else {
      const [key, ...rest] = path2;
      const node = this.get(key, true);
      if (isCollection$1(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  deleteIn(path2) {
    const [key, ...rest] = path2;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection$1(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  getIn(path2, keepScalar) {
    const [key, ...rest] = path2;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar$1(node) ? node.value : node;
    else
      return isCollection$1(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n2 = node.value;
      return n2 == null || allowScalar && isScalar$1(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
    });
  }
  hasIn(path2) {
    const [key, ...rest] = path2;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection$1(node) ? node.hasIn(rest) : false;
  }
  setIn(path2, value) {
    const [key, ...rest] = path2;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection$1(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
}
Collection.maxFlowStringSingleLineLength = 60;
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment2, indent2) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent2 ? comment2.replace(/^(?! *$)/gm, indent2) : comment2;
}
const lineComment = (str, indent2, comment2) => str.endsWith("\n") ? indentComment(comment2, indent2) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent2) : (str.endsWith(" ") ? "" : " ") + comment2;
const FOLD_FLOW = "flow";
const FOLD_BLOCK = "block";
const FOLD_QUOTED = "quoted";
function foldFlowLines(text3, indent2, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text3;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent2.length);
  if (text3.length <= endStep)
    return text3;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent2.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i2 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i2 = consumeMoreIndentedLines(text3, i2);
    if (i2 !== -1)
      end = i2 + endStep;
  }
  for (let ch; ch = text3[i2 += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i2;
      switch (text3[i2 + 1]) {
        case "x":
          i2 += 3;
          break;
        case "u":
          i2 += 5;
          break;
        case "U":
          i2 += 9;
          break;
        default:
          i2 += 1;
      }
      escEnd = i2;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i2 = consumeMoreIndentedLines(text3, i2);
      end = i2 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text3[i2 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i2;
      }
      if (i2 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text3[i2 += 1];
            overflow = true;
          }
          const j2 = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
          if (escapedFolds[j2])
            return text3;
          folds.push(j2);
          escapedFolds[j2] = true;
          end = j2 + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text3;
  if (onFold)
    onFold();
  let res = text3.slice(0, folds[0]);
  for (let i3 = 0; i3 < folds.length; ++i3) {
    const fold = folds[i3];
    const end2 = folds[i3 + 1] || text3.length;
    if (fold === 0)
      res = `
${indent2}${text3.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text3[fold]}\\`;
      res += `
${indent2}${text3.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text3, i2) {
  let ch = text3[i2 + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text3[i2 += 1];
    } while (ch && ch !== "\n");
    ch = text3[i2 + 1];
  }
  return i2;
}
const getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i2 = 0, start2 = 0; i2 < strLen; ++i2) {
    if (str[i2] === "\n") {
      if (i2 - start2 > limit)
        return true;
      start2 = i2 + 1;
      if (strLen - start2 <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start2 = 0;
  for (let i2 = 0, ch = json[i2]; ch; ch = json[++i2]) {
    if (ch === " " && json[i2 + 1] === "\\" && json[i2 + 2] === "n") {
      str += json.slice(start2, i2) + "\\ ";
      i2 += 1;
      start2 = i2;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i2 + 1]) {
        case "u":
          {
            str += json.slice(start2, i2);
            const code3 = json.substr(i2 + 2, 4);
            switch (code3) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code3.substr(0, 2) === "00")
                  str += "\\x" + code3.substr(2);
                else
                  str += json.substr(i2, 6);
            }
            i2 += 5;
            start2 = i2 + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i2 + 2] === '"' || json.length < minMultiLineLength) {
            i2 += 1;
          } else {
            str += json.slice(start2, i2) + "\n\n";
            while (json[i2 + 2] === "\\" && json[i2 + 3] === "n" && json[i2 + 4] !== '"') {
              str += "\n";
              i2 += 2;
            }
            str += indent2;
            if (json[i2 + 2] === " ")
              str += "\\";
            i2 += 1;
            start2 = i2 + 1;
          }
          break;
        default:
          i2 += 1;
      }
  }
  str = start2 ? str + json.slice(start2) : json;
  return implicitKey ? str : foldFlowLines(str, indent2, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent2}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent2, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent2 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent2.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent2}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start2 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start2) {
    value = value.substring(start2.length);
    start2 = start2.replace(/\n+/g, `$&${indent2}`);
  }
  const indentSize = indent2 ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent2}`);
    return `${header}
${indent2}${start2}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent2}`);
  const body = foldFlowLines(`${start2}${value}${end}`, indent2, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent2}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent: indent2, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent2 === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&
${indent2}`);
  if (actualString) {
    const test2 = (tag) => {
      var _a2;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a2 = tag.test) == null ? void 0 : _a2.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test2) || (compat == null ? void 0 : compat.some(test2)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent2, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t2 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t2);
    if (res === null)
      throw new Error(`Unsupported default string type ${t2}`);
  }
  return res;
}
function createStringifyContext(doc2, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc2.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: doc2,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a2, _b, _c, _d;
  if (item.tag) {
    const match5 = tags.filter((t2) => t2.tag === item.tag);
    if (match5.length > 0)
      return (_a2 = match5.find((t2) => t2.format === item.format)) != null ? _a2 : match5[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    const match5 = tags.filter((t2) => {
      var _a3;
      return (_a3 = t2.identify) == null ? void 0 : _a3.call(t2, obj);
    });
    tagObj = (_b = match5.find((t2) => t2.format === item.format)) != null ? _b : match5.find((t2) => !t2.format);
  } else {
    obj = item;
    tagObj = tags.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc: doc2 }) {
  if (!doc2.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node) || isCollection$1(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc2.directives.tagString(tag));
  return props.join(" ");
}
function stringify$2(item, ctx, onComment, onChompKeep) {
  var _a2, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a2 = ctx.resolvedAliases) == null ? void 0 : _a2.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o2) => tagObj = o2 });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar$1(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar$1(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc: doc2, indent: indent2, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection$1(key) || (isScalar$1(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent2 + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify$2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent2}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value)) {
    if (value.spaceBefore)
      vcb = "\n";
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === "object") {
    value = doc2.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$2(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    if (valueStr === "" && !ctx.inFlow)
      ws = vcb === "\n" ? "\n\n" : vcb;
    else
      ws = `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection$1(value)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
function warn$1(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
const MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if ((ctx == null ? void 0 : ctx.doc.schema.merge) && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it2 of value.items)
        mergeToJSMap(ctx, map2, it2);
    else if (Array.isArray(value))
      for (const it2 of value)
        mergeToJSMap(ctx, map2, it2);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
const isMergeKey = (key) => key === MERGE_KEY || isScalar$1(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn$1(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value, ctx) {
  const k2 = createNode(key, void 0, ctx);
  const v2 = createNode(value, void 0, ctx);
  return new Pair(k2, v2);
}
class Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema2) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema2);
    if (isNode(value))
      value = value.clone(schema2);
    return new Pair(key, value);
  }
  toJSON(_2, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
}
function stringifyCollection(collection, ctx, options) {
  var _a2;
  const flow = (_a2 = ctx.inFlow) != null ? _a2 : collection.flow;
  const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify2(collection, ctx, options);
}
function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent: indent2, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment3 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify$2(item, itemCtx, () => comment3 = null, () => chompKeep = true);
    if (comment3)
      str2 += lineComment(str2, itemIndent, commentString(comment3));
    if (chompKeep && comment3)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i2 = 1; i2 < lines.length; ++i2) {
      const line2 = lines[i2];
      str += line2 ? `
${indent2}${line2}` : "\n";
    }
  }
  if (comment2) {
    str += "\n" + indentComment(commentString(comment2), indent2);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment: comment2, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent: indent2, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment3 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment3 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment3 = ik.comment;
      }
    }
    if (comment3)
      reqNewline = true;
    let str2 = stringify$2(item, itemCtx, () => comment3 = null);
    if (i2 < items.length - 1)
      str2 += ",";
    if (comment3)
      str2 += lineComment(str2, itemIndent, commentString(comment3));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start: start2, end } = flowChars;
  if (lines.length === 0) {
    str = start2 + end;
  } else {
    if (!reqNewline) {
      const len2 = lines.reduce((sum2, line2) => sum2 + line2.length + 2, 2);
      reqNewline = len2 > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start2;
      for (const line2 of lines)
        str += line2 ? `
${indentStep}${indent2}${line2}` : "\n";
      str += `
${indent2}${end}`;
    } else {
      str = `${start2} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment2) {
    str += lineComment(str, commentString(comment2), indent2);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent: indent2, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic2 = indentComment(commentString(comment2), indent2);
    lines.push(ic2.trimStart());
  }
}
function findPair(items, key) {
  const k2 = isScalar$1(key) ? key.value : key;
  for (const it2 of items) {
    if (isPair(it2)) {
      if (it2.key === key || it2.key === k2)
        return it2;
      if (isScalar$1(it2.key) && it2.key.value === k2)
        return it2;
    }
  }
  return void 0;
}
class YAMLMap extends Collection {
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  add(pair, overwrite) {
    var _a2;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a2 = this.schema) == null ? void 0 : _a2.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar$1(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i2 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i2 === -1)
        this.items.push(_pair);
      else
        this.items.splice(i2, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it2 = findPair(this.items, key);
    if (!it2)
      return false;
    const del2 = this.items.splice(this.items.indexOf(it2), 1);
    return del2.length > 0;
  }
  get(key, keepScalar) {
    var _a2;
    const it2 = findPair(this.items, key);
    const node = it2 == null ? void 0 : it2.value;
    return (_a2 = !keepScalar && isScalar$1(node) ? node.value : node) != null ? _a2 : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  toJSON(_2, ctx, Type) {
    const map2 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
}
function createMap(schema2, obj, ctx) {
  const { keepUndefined, replacer: replacer2 } = ctx;
  const map2 = new YAMLMap(schema2);
  const add3 = (key, value) => {
    if (typeof replacer2 === "function")
      value = replacer2.call(obj, key, value);
    else if (Array.isArray(replacer2) && !replacer2.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add3(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add3(key, obj[key]);
  }
  if (typeof schema2.sortMapEntries === "function") {
    map2.items.sort(schema2.sortMapEntries);
  }
  return map2;
}
const map$3 = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};
class YAMLSeq extends Collection {
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value) {
    this.items.push(value);
  }
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del2 = this.items.splice(idx, 1);
    return del2.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it2 = this.items[idx];
    return !keepScalar && isScalar$1(it2) ? it2.value : it2;
  }
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar$1(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_2, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i2 = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i2++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
}
function asItemIndex(key) {
  let idx = isScalar$1(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function createSeq(schema2, obj, ctx) {
  const { replacer: replacer2 } = ctx;
  const seq2 = new YAMLSeq(schema2);
  if (obj && Symbol.iterator in Object(obj)) {
    let i2 = 0;
    for (let it2 of obj) {
      if (typeof replacer2 === "function") {
        const key = obj instanceof Set ? it2 : String(i2++);
        it2 = replacer2.call(obj, key, it2);
      }
      seq2.items.push(createNode(it2, void 0, ctx));
    }
  }
  return seq2;
}
const seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};
const string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};
const nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};
const boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
function stringifyNumber({ format: format3, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num2 = typeof value === "number" ? value : Number(value);
  if (!isFinite(num2))
    return isNaN(num2) ? ".nan" : num2 < 0 ? "-.inf" : ".inf";
  let n2 = JSON.stringify(value);
  if (!format3 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i2 = n2.indexOf(".");
    if (i2 < 0) {
      i2 = n2.length;
      n2 += ".";
    }
    let d2 = minFractionDigits - (n2.length - i2 - 1);
    while (d2-- > 0)
      n2 += "0";
  }
  return n2;
}
const floatNaN$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num2 = Number(node.value);
    return isFinite(num2) ? num2.toExponential() : stringifyNumber(node);
  }
};
const float$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot2 = str.indexOf(".");
    if (dot2 !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot2 - 1;
    return node;
  },
  stringify: stringifyNumber
};
const intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
const intResolve$1 = (str, offset2, radix2, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset2), radix2);
function intStringify$1(node, radix2, prefix) {
  const { value } = node;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix2);
  return stringifyNumber(node);
}
const intOct$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
  stringify: (node) => intStringify$1(node, 8, "0o")
};
const int$2 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
  stringify: (node) => intStringify$1(node, 16, "0x")
};
const schema$2 = [
  map$3,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$2,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
const jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
const schema$1 = [map$3, seq].concat(jsonScalars, jsonError);
const binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer2 = new Uint8Array(str.length);
      for (let i2 = 0; i2 < str.length; ++i2)
        buffer2[i2] = str.charCodeAt(i2);
      return buffer2;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s2 = "";
      for (let i2 = 0; i2 < buf.length; ++i2)
        s2 += String.fromCharCode(buf[i2]);
      str = btoa(s2);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n2 = Math.ceil(str.length / lineWidth);
      const lines = new Array(n2);
      for (let i2 = 0, o2 = 0; i2 < n2; ++i2, o2 += lineWidth) {
        lines[i2] = str.substr(o2, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type, value: str }, ctx, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  var _a2;
  if (isSeq(seq2)) {
    for (let i2 = 0; i2 < seq2.items.length; ++i2) {
      let item = seq2.items[i2];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a2 = pair.value) != null ? _a2 : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i2] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer: replacer2 } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i2 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it2 of iterable) {
      if (typeof replacer2 === "function")
        it2 = replacer2.call(iterable, String(i2++), it2);
      let key, value;
      if (Array.isArray(it2)) {
        if (it2.length === 2) {
          key = it2[0];
          value = it2[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it2}`);
      } else if (it2 && it2 instanceof Object) {
        const keys2 = Object.keys(it2);
        if (keys2.length === 1) {
          key = keys2[0];
          value = it2[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it2}`);
      } else {
        key = it2;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
const pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
class YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  toJSON(_2, ctx) {
    if (!ctx)
      return super.toJSON(_2);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
}
YAMLOMap.tag = "tag:yaml.org,2002:omap";
const omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar$1(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema2, iterable, ctx) {
    const pairs2 = createPairs(schema2, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
const falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};
const floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num2 = Number(node.value);
    return isFinite(num2) ? num2.toExponential() : stringifyNumber(node);
  }
};
const float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot2 = str.indexOf(".");
    if (dot2 !== -1) {
      const f2 = str.substring(dot2 + 1).replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node.minFractionDigits = f2.length;
    }
    return node;
  },
  stringify: stringifyNumber
};
const intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve(str, offset2, radix2, { intAsBigInt }) {
  const sign2 = str[0];
  if (sign2 === "-" || sign2 === "+")
    offset2 += 1;
  str = str.substring(offset2).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix2) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n3 = BigInt(str);
    return sign2 === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str, radix2);
  return sign2 === "-" ? -1 * n2 : n2;
}
function intStringify(node, radix2, prefix) {
  const { value } = node;
  if (intIdentify(value)) {
    const str = value.toString(radix2);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
const intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
  stringify: (node) => intStringify(node, 2, "0b")
};
const intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
  stringify: (node) => intStringify(node, 8, "0")
};
const int$1 = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};
class YAMLSet extends YAMLMap {
  constructor(schema2) {
    super(schema2);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_2, ctx) {
    return super.toJSON(_2, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
}
YAMLSet.tag = "tag:yaml.org,2002:set";
const set$3 = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema2, iterable, ctx) {
    const { replacer: replacer2 } = ctx;
    const set3 = new YAMLSet(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer2 === "function")
          value = replacer2.call(iterable, value, value);
        set3.items.push(createPair(value, null, ctx));
      }
    return set3;
  }
};
function parseSexagesimal(str, asBigInt) {
  const sign2 = str[0];
  const parts = sign2 === "-" || sign2 === "+" ? str.substring(1) : str;
  const num2 = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num2(60) + num2(p2), num2(0));
  return sign2 === "-" ? num2(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num2 = (n2) => n2;
  if (typeof value === "bigint")
    num2 = (n2) => BigInt(n2);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign2 = "";
  if (value < 0) {
    sign2 = "-";
    value *= num2(-1);
  }
  const _60 = num2(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign2 + parts.map((n2) => n2 < 10 ? "0" + String(n2) : String(n2)).join(":").replace(/000000\d*$/, "");
}
const intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match5 = str.match(timestamp.test);
    if (!match5)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour2, minute, second] = match5.map(Number);
    const millisec = match5[7] ? Number((match5[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour2 || 0, minute || 0, second || 0, millisec);
    const tz = match5[8];
    if (tz && tz !== "Z") {
      let d2 = parseSexagesimal(tz, false);
      if (Math.abs(d2) < 30)
        d2 *= 60;
      date -= 6e4 * d2;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};
const schema = [
  map$3,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int$1,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  omap,
  pairs,
  set$3,
  intTime,
  floatTime,
  timestamp
];
const schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map$3, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
const tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$2,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map: map$3,
  null: nullTag,
  omap,
  pairs,
  seq,
  set: set$3,
  timestamp
};
const coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set$3,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys2 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys2} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys2 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys2}`);
  });
}
const sortMapEntriesByKey = (a2, b2) => a2.key < b2.key ? -1 : a2.key > b2.key ? 1 : 0;
class Schema {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map$3 });
    Object.defineProperty(this, SCALAR$1, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy2 = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy2.tags = this.tags.slice();
    return copy2;
  }
}
function stringifyDocument(doc2, options) {
  var _a2;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc2.directives) {
    const dir = doc2.directives.toString(doc2);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc2.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc2, options);
  const { commentString } = ctx.options;
  if (doc2.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc2.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc2.contents) {
    if (isNode(doc2.contents)) {
      if (doc2.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc2.contents.commentBefore) {
        const cs = commentString(doc2.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc2.comment;
      contentComment = doc2.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$2(doc2.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$2(doc2.contents, ctx));
  }
  if ((_a2 = doc2.directives) == null ? void 0 : _a2.docEnd) {
    if (doc2.comment) {
      const cs = commentString(doc2.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc2.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i2 = 0, len2 = val.length; i2 < len2; ++i2) {
        const v0 = val[i2];
        const v1 = applyReviver(reviver, val, String(i2), v0);
        if (v1 === void 0)
          delete val[i2];
        else if (v1 !== v0)
          val[i2] = v1;
      }
    } else if (val instanceof Map) {
      for (const k2 of Array.from(val.keys())) {
        const v0 = val.get(k2);
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          val.delete(k2);
        else if (v1 !== v0)
          val.set(k2, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k2, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k2, v0);
        if (v1 === void 0)
          delete val[k2];
        else if (v1 !== v0)
          val[k2] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
class Document {
  constructor(value, replacer2, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer2 === "function" || Array.isArray(replacer2)) {
      _replacer = replacer2;
    } else if (options === void 0 && replacer2) {
      options = replacer2;
      replacer2 = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version: version2 } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version2 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version2 });
    this.setSchema(version2, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  clone() {
    const copy2 = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy2.commentBefore = this.commentBefore;
    copy2.comment = this.comment;
    copy2.errors = this.errors.slice();
    copy2.warnings = this.warnings.slice();
    copy2.options = Object.assign({}, this.options);
    if (this.directives)
      copy2.directives = this.directives.clone();
    copy2.schema = this.schema.clone();
    copy2.contents = isNode(this.contents) ? this.contents.clone(copy2.schema) : this.contents;
    if (this.range)
      copy2.range = this.range.slice();
    return copy2;
  }
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  addIn(path2, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path2, value);
  }
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer2, options) {
    let _replacer = void 0;
    if (typeof replacer2 === "function") {
      value = replacer2.call({ "": value }, "", value);
      _replacer = replacer2;
    } else if (Array.isArray(replacer2)) {
      const keyToStr = (v2) => typeof v2 === "number" || v2 instanceof String || v2 instanceof Number;
      const asStr = replacer2.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer2 = replacer2.concat(asStr);
      _replacer = replacer2;
    } else if (options === void 0 && replacer2) {
      options = replacer2;
      replacer2 = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection$1(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  createPair(key, value, options = {}) {
    const k2 = this.createNode(key, null, options);
    const v2 = this.createNode(value, null, options);
    return new Pair(k2, v2);
  }
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  deleteIn(path2) {
    if (isEmptyPath(path2)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
  }
  get(key, keepScalar) {
    return isCollection$1(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  getIn(path2, keepScalar) {
    if (isEmptyPath(path2))
      return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
    return isCollection$1(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
  }
  has(key) {
    return isCollection$1(this.contents) ? this.contents.has(key) : false;
  }
  hasIn(path2) {
    if (isEmptyPath(path2))
      return this.contents !== void 0;
    return isCollection$1(this.contents) ? this.contents.hasIn(path2) : false;
  }
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  setIn(path2, value) {
    if (isEmptyPath(path2))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path2), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path2, value);
    }
  }
  setSchema(version2, options = {}) {
    if (typeof version2 === "number")
      version2 = String(version2);
    let opt;
    switch (version2) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version2;
        else
          this.directives = new Directives({ version: version2 });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version2);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify: stringify$2
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count: count2, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count2);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s2 = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s2}`);
    }
    return stringifyDocument(this, options);
  }
}
function assertCollection(contents) {
  if (isCollection$1(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
class YAMLError extends Error {
  constructor(name, pos, code3, message) {
    super();
    this.name = name;
    this.code = code3;
    this.message = message;
    this.pos = pos;
  }
}
class YAMLParseError extends YAMLError {
  constructor(pos, code3, message) {
    super("YAMLParseError", pos, code3, message);
  }
}
class YAMLWarning extends YAMLError {
  constructor(pos, code3, message) {
    super("YAMLWarning", pos, code3, message);
  }
}
const prettifyError = (src, lc) => (error2) => {
  if (error2.pos[0] === -1)
    return;
  error2.linePos = error2.pos.map((pos) => lc.linePos(pos));
  const { line: line2, col } = error2.linePos[0];
  error2.message += ` at line ${line2}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line2 - 1], lc.lineStarts[line2]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line2 > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line2 - 2], lc.lineStarts[line2 - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count2 = 1;
    const end = error2.linePos[1];
    if (end && end.line === line2 && end.col > col) {
      count2 = Math.min(end.col - col, 80 - ci);
    }
    const pointer2 = " ".repeat(ci) + "^".repeat(count2);
    error2.message += `:

${lineStr}
${pointer2}
`;
  }
};
function resolveProps(tokens2, { flow, indicator, next, offset: offset2, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma2 = null;
  let found = null;
  let start2 = null;
  for (const token2 of tokens2) {
    if (reqSpace) {
      if (token2.type !== "space" && token2.type !== "newline" && token2.type !== "comma")
        onError(token2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token2.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token2.source[0] === "	")
          onError(token2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token2.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token2.source;
          else
            spaceBefore = true;
        } else
          commentSep += token2.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token2, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token2.source.endsWith(":"))
          onError(token2.offset + token2.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token2;
        if (start2 === null)
          start2 = token2.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token2, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token2;
        if (start2 === null)
          start2 = token2.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token2, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token2.source} indicator`);
        if (found)
          onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.source} in ${flow != null ? flow : "collection"}`);
        found = token2;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma2)
            onError(token2, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma2 = token2;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens2[tokens2.length - 1];
  const end = last ? last.offset + last.source.length : offset2;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma: comma2,
    found,
    spaceBefore,
    comment: comment2,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start2 != null ? start2 : end
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it2 of key.items) {
        for (const st of it2.start)
          if (st.type === "newline")
            return true;
        if (it2.sep) {
          for (const st of it2.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it2.key) || containsNewline(it2.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent2, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent2 && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx, items, search2) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b2) => a2 === b2 || isScalar$1(a2) && isScalar$1(b2) && a2.value === b2.value && !(a2.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search2));
}
const startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a2;
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset2 = bm.offset;
  for (const collItem of bm.items) {
    const { start: start2, key, sep, value } = collItem;
    const keyProps = resolveProps(start2, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset: offset2,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset2, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start2[start2.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a2 = keyProps.found) == null ? void 0 : _a2.indent) !== bm.indent) {
      onError(offset2, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start2, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep != null ? sep : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset2 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset2, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset2 = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset2, offset2];
  return map2;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset2 = bs.offset;
  for (const { start: start2, value } of bs.items) {
    const props = resolveProps(start2, {
      indicator: "seq-item-ind",
      next: value,
      offset: offset2,
      onError,
      startOnNewline: true
    });
    offset2 = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(offset2, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset2, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, offset2, start2, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset2 = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset2, offset2];
  return seq2;
}
function resolveEnd(end, offset2, reqSpace, onError) {
  let comment2 = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token2 of end) {
      const { source, type } = token2;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment2)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset2 += source.length;
    }
  }
  return { comment: comment2, offset: offset2 };
}
const blockMsg = "Block collections are not allowed within flow collections";
const isBlock = (token2) => token2 && (token2.type === "block-map" || token2.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  var _a2;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset2 = fc.offset + fc.start.source.length;
  for (let i2 = 0; i2 < fc.items.length; ++i2) {
    const collItem = fc.items[i2];
    const { start: start2, key, sep, value } = collItem;
    const props = resolveProps(start2, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset: offset2,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i2 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i2 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset2 = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
    }
    if (i2 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start2) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_a2 = prev.value) != null ? _a2 : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset2 = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start2, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep != null ? sep : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset2 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce2, ...ee2] = fc.end;
  let cePos = offset2;
  if (ce2 && ce2.source === expectedEnd)
    cePos = ce2.offset + ce2.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset2, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce2 && ce2.source.length !== 1)
      ee2.unshift(ce2);
  }
  if (ee2.length > 0) {
    const end = resolveEnd(ee2, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function composeCollection(CN2, ctx, token2, tagToken, onError) {
  let coll;
  switch (token2.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token2, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token2, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token2, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx.schema.tags.find((t2) => t2.collection === expType && t2.tag === tagName);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}
function resolveBlockScalar(scalar, strict, onError) {
  const start2 = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start2, start2, start2] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i2 = lines.length - 1; i2 >= 0; --i2) {
    const content = lines[i2][1];
    if (content === "" || content === "\r")
      chompStart = i2;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start2 + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start2, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset2 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i2 = 0; i2 < chompStart; ++i2) {
    const [indent2, content] = lines[i2];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent2.length > trimIndent)
        trimIndent = indent2.length;
    } else {
      if (indent2.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset2 + indent2.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent2.length;
      contentStart = i2;
      break;
    }
    offset2 += indent2.length + content.length + 1;
  }
  for (let i2 = lines.length - 1; i2 >= chompStart; --i2) {
    if (lines[i2][0].length > trimIndent)
      chompStart = i2 + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i2 = 0; i2 < contentStart; ++i2)
    value += lines[i2][0].slice(trimIndent) + "\n";
  for (let i2 = contentStart; i2 < chompStart; ++i2) {
    let [indent2, content] = lines[i2];
    offset2 += indent2.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent2.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset2 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent2 = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent2.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent2.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent2.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i2 = chompStart; i2 < lines.length; ++i2)
        value += "\n" + lines[i2][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start2 + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start2, end, end] };
}
function parseBlockScalarHeader({ offset: offset2, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent2 = 0;
  let chomp = "";
  let error2 = -1;
  for (let i2 = 1; i2 < source.length; ++i2) {
    const ch = source[i2];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n2 = Number(ch);
      if (!indent2 && n2)
        indent2 = n2;
      else if (error2 === -1)
        error2 = offset2 + i2;
    }
  }
  if (error2 !== -1)
    onError(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment2 = "";
  let length = source.length;
  for (let i2 = 1; i2 < props.length; ++i2) {
    const token2 = props[i2];
    switch (token2.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token2.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token2, "MISSING_CHAR", message);
        }
        length += token2.source.length;
        comment2 = token2.source.substring(1);
        break;
      case "error":
        onError(token2, "UNEXPECTED_TOKEN", token2.message);
        length += token2.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token2.type}`;
        onError(token2, "UNEXPECTED_TOKEN", message);
        const ts = token2.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent: indent2, chomp, comment: comment2, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m2 = first.match(/^( *)/);
  const line0 = (m2 == null ? void 0 : m2[1]) ? [m2[1], first.slice(m2[1].length)] : ["", first];
  const lines = [line0];
  for (let i2 = 1; i2 < split.length; i2 += 2)
    lines.push([split[i2], split[i2 + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
  const { offset: offset2, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code3, msg) => onError(offset2 + rel, code3, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset2, offset2 + source.length, offset2 + source.length]
      };
  }
  const valueEnd = offset2 + source.length;
  const re2 = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re2.comment,
    range: [offset2, valueEnd, re2.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a2;
  let first, line2;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line2 = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_2) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line2 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match5 = first.exec(source);
  if (!match5)
    return source;
  let res = match5[1];
  let sep = " ";
  let pos = first.lastIndex;
  line2.lastIndex = pos;
  while (match5 = line2.exec(source)) {
    if (match5[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match5[1];
      sep = " ";
    }
    pos = line2.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match5 = last.exec(source);
  return res + sep + ((_a2 = match5 == null ? void 0 : match5[1]) != null ? _a2 : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i2 = 1; i2 < source.length - 1; ++i2) {
    const ch = source[i2];
    if (ch === "\r" && source[i2 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset: offset2 } = foldNewline(source, i2);
      res += fold;
      i2 = offset2;
    } else if (ch === "\\") {
      let next = source[++i2];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "\r" && source[i2 + 1] === "\n") {
        next = source[++i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i2 + 1, length, onError);
        i2 += length;
      } else {
        const raw = source.substr(i2 - 1, 2);
        onError(i2 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i2;
      let next = source[i2 + 1];
      while (next === " " || next === "	")
        next = source[++i2 + 1];
      if (next !== "\n" && !(next === "\r" && source[i2 + 2] === "\n"))
        res += i2 > wsStart ? source.slice(wsStart, i2 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset2) {
  let fold = "";
  let ch = source[offset2 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset2 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset2 += 1;
    ch = source[offset2 + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset: offset2 };
}
const escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset2, length, onError) {
  const cc = source.substr(offset2, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code3 = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code3)) {
    const raw = source.substr(offset2 - 2, length + 2);
    onError(offset2 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code3);
}
function composeScalar(ctx, token2, tagToken, onError) {
  const { value, type, comment: comment2, range: range2 } = token2.type === "block-scalar" ? resolveBlockScalar(token2, ctx.options.strict, onError) : resolveFlowScalar(token2, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token2.type === "scalar" ? findScalarTagByTest(ctx, value, token2, onError) : ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token2, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error2) {
    const msg = error2 instanceof Error ? error2.message : String(error2);
    onError(tagToken != null ? tagToken : token2, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range2;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
function findScalarTagByName(schema2, value, tagName, tagToken, onError) {
  var _a2;
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema2.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a2 = tag.test) == null ? void 0 : _a2.test(value))
      return tag;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ directives: directives2, schema: schema2 }, value, token2, onError) {
  var _a2;
  const tag = schema2.tags.find((tag2) => {
    var _a3;
    return tag2.default && ((_a3 = tag2.test) == null ? void 0 : _a3.test(value));
  }) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = (_a2 = schema2.compat.find((tag2) => {
      var _a3;
      return tag2.default && ((_a3 = tag2.test) == null ? void 0 : _a3.test(value));
    })) != null ? _a2 : schema2[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives2.tagString(tag.tag);
      const cs = directives2.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token2, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
function emptyScalarPosition(offset2, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i2 = pos - 1; i2 >= 0; --i2) {
      let st = before[i2];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset2 -= st.source.length;
          continue;
      }
      st = before[++i2];
      while ((st == null ? void 0 : st.type) === "space") {
        offset2 += st.source.length;
        st = before[++i2];
      }
      break;
    }
  }
  return offset2;
}
const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token2, props, onError) {
  const { spaceBefore, comment: comment2, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token2.type) {
    case "alias":
      node = composeAlias(ctx, token2, onError);
      if (anchor || tag)
        onError(token2, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token2, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token2, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token2.type === "error" ? token2.message : `Unsupported token (type: ${token2.type})`;
      onError(token2, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token2.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2) {
    if (token2.type === "scalar" && token2.source === "")
      node.comment = comment2;
    else
      node.commentBefore = comment2;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token2;
  return node;
}
function composeEmptyNode(ctx, offset2, before, pos, { spaceBefore, comment: comment2, anchor, tag }, onError) {
  const token2 = {
    type: "scalar",
    offset: emptyScalarPosition(offset2, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token2, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2)
    node.comment = comment2;
  return node;
}
function composeAlias({ options }, { offset: offset2, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset2, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset2 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset2 + source.length;
  const re2 = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset2, valueEnd, re2.offset];
  if (re2.comment)
    alias.comment = re2.comment;
  return alias;
}
function composeDoc(options, directives2, { offset: offset2, start: start2, value, end }, onError) {
  const opts = Object.assign({ _directives: directives2 }, options);
  const doc2 = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc2.directives,
    options: doc2.options,
    schema: doc2.schema
  };
  const props = resolveProps(start2, {
    indicator: "doc-start",
    next: value != null ? value : end == null ? void 0 : end[0],
    offset: offset2,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc2.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc2.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start2, null, props, onError);
  const contentEnd = doc2.contents.range[2];
  const re2 = resolveEnd(end, contentEnd, false, onError);
  if (re2.comment)
    doc2.comment = re2.comment;
  doc2.range = [offset2, contentEnd, re2.offset];
  return doc2;
}
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset: offset2, source } = src;
  return [offset2, offset2 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a2;
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i2 = 0; i2 < prelude.length; ++i2) {
    const source = prelude[i2];
    switch (source[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a2 = prelude[i2 + 1]) == null ? void 0 : _a2[0]) !== "#")
          i2 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
class Composer {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code3, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code3, message));
      else
        this.errors.push(new YAMLParseError(pos, code3, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc2, afterDoc) {
    const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment2) {
      const dc = doc2.contents;
      if (afterDoc) {
        doc2.comment = doc2.comment ? `${doc2.comment}
${comment2}` : comment2;
      } else if (afterEmptyLine || doc2.directives.docStart || !dc) {
        doc2.commentBefore = comment2;
      } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
        let it2 = dc.items[0];
        if (isPair(it2))
          it2 = it2.key;
        const cb = it2.commentBefore;
        it2.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc2.errors, this.errors);
      Array.prototype.push.apply(doc2.warnings, this.warnings);
    } else {
      doc2.errors = this.errors;
      doc2.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  *compose(tokens2, forceDoc = false, endOffset = -1) {
    for (const token2 of tokens2)
      yield* this.next(token2);
    yield* this.end(forceDoc, endOffset);
  }
  *next(token2) {
    switch (token2.type) {
      case "directive":
        this.directives.add(token2.source, (offset2, message, warning) => {
          const pos = getErrorPos(token2);
          pos[0] += offset2;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token2.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc2 = composeDoc(this.options, this.directives, token2, this.onError);
        if (this.atDirectives && !doc2.directives.docStart)
          this.onError(token2, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc2, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc2;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token2.source);
        break;
      case "error": {
        const msg = token2.source ? `${token2.message}: ${JSON.stringify(token2.source)}` : token2.message;
        const error2 = new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error2);
        else
          this.doc.errors.push(error2);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token2.end, token2.offset + token2.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", `Unsupported token ${token2.type}`));
    }
  }
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc2 = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc2.range = [0, endOffset, endOffset];
      this.decorate(doc2, false);
      yield doc2;
    }
  }
}
function resolveAsScalar(token2, strict = true, onError) {
  if (token2) {
    const _onError = (pos, code3, message) => {
      const offset2 = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset2, code3, message);
      else
        throw new YAMLParseError([offset2, offset2 + 1], code3, message);
    };
    switch (token2.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token2, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token2, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  var _a2;
  const { implicitKey = false, indent: indent2, inFlow = false, offset: offset2 = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent2 > 0 ? " ".repeat(indent2) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = (_a2 = context.end) != null ? _a2 : [
    { type: "newline", offset: -1, indent: indent2, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset: offset2, indent: indent2, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
      return { type: "block-scalar", offset: offset2, indent: indent2, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: offset2, indent: indent2, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset: offset2, indent: indent2, source, end };
    default:
      return { type: "scalar", offset: offset2, indent: indent2, source, end };
  }
}
function setScalarValue(token2, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent2 = "indent" in token2 ? token2.indent : null;
  if (afterKey && typeof indent2 === "number")
    indent2 += 2;
  if (!type)
    switch (token2.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token2.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent2 === null,
    indent: indent2 !== null && indent2 > 0 ? " ".repeat(indent2) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token2, source);
      break;
    case '"':
      setFlowScalarValue(token2, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token2, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token2, source, "scalar");
  }
}
function setBlockScalarValue(token2, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token2.type === "block-scalar") {
    const header = token2.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token2.source = body;
  } else {
    const { offset: offset2 } = token2;
    const indent2 = "indent" in token2 ? token2.indent : -1;
    const props = [
      { type: "block-scalar-header", offset: offset2, indent: indent2, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token2 ? token2.end : void 0))
      props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
    for (const key of Object.keys(token2))
      if (key !== "type" && key !== "offset")
        delete token2[key];
    Object.assign(token2, { type: "block-scalar", indent: indent2, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token2, source, type) {
  switch (token2.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token2.type = type;
      token2.source = source;
      break;
    case "block-scalar": {
      const end = token2.props.slice(1);
      let oa2 = source.length;
      if (token2.props[0].type === "block-scalar-header")
        oa2 -= token2.props[0].source.length;
      for (const tok of end)
        tok.offset += oa2;
      delete token2.props;
      Object.assign(token2, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset2 = token2.offset + source.length;
      const nl = { type: "newline", offset: offset2, indent: token2.indent, source: "\n" };
      delete token2.items;
      Object.assign(token2, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent2 = "indent" in token2 ? token2.indent : -1;
      const end = "end" in token2 && Array.isArray(token2.end) ? token2.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token2))
        if (key !== "type" && key !== "offset")
          delete token2[key];
      Object.assign(token2, { type, indent: indent2, source, end });
    }
  }
}
const stringify$1 = (cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2);
function stringifyToken(token2) {
  switch (token2.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token2.props)
        res += stringifyToken(tok);
      return res + token2.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token2.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token2.start.source;
      for (const item of token2.items)
        res += stringifyItem(item);
      for (const st of token2.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token2);
      if (token2.end)
        for (const st of token2.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token2.source;
      if ("end" in token2 && token2.end)
        for (const st of token2.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start: start2, key, sep, value }) {
  let res = "";
  for (const st of start2)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}
const BREAK = Symbol("break visit");
const SKIP = Symbol("skip children");
const REMOVE = Symbol("remove item");
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
visit.itemAtPath = (cst2, path2) => {
  let item = cst2;
  for (const [field, index2] of path2) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit.parentCollection = (cst2, path2) => {
  const parent = visit.itemAtPath(cst2, path2.slice(0, -1));
  const field = path2[path2.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path2, item, visitor) {
  let ctrl = visitor(item, path2);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token2 = item[field];
    if (token2 && "items" in token2) {
      for (let i2 = 0; i2 < token2.items.length; ++i2) {
        const ci = _visit(Object.freeze(path2.concat([[field, i2]])), token2.items[i2], visitor);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token2.items.splice(i2, 1);
          i2 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path2);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path2) : ctrl;
}
const BOM = "\uFEFF";
const DOCUMENT = "";
const FLOW_END = "";
const SCALAR = "";
const isCollection = (token2) => !!token2 && "items" in token2;
const isScalar = (token2) => !!token2 && (token2.type === "scalar" || token2.type === "single-quoted-scalar" || token2.type === "double-quoted-scalar" || token2.type === "block-scalar");
function prettyToken(token2) {
  switch (token2) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token2);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var cst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM,
  DOCUMENT,
  FLOW_END,
  SCALAR,
  isCollection,
  isScalar,
  prettyToken,
  tokenType,
  createScalarToken,
  resolveAsScalar,
  setScalarValue,
  stringify: stringify$1,
  visit
}, Symbol.toStringTag, { value: "Module" }));
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
const hexDigits = "0123456789ABCDEFabcdef".split("");
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
const invalidFlowScalarChars = ",[]{}".split("");
const invalidAnchorChars = " ,[]{}\n\r	".split("");
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
class Lexer {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  *lex(source, incomplete = false) {
    var _a2;
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a2 = this.next) != null ? _a2 : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i2 = this.pos;
    let ch = this.buffer[i2];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i2];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i2 + 1] === "\n";
    return false;
  }
  charAt(n2) {
    return this.buffer[this.pos + n2];
  }
  continueScalar(offset2) {
    let ch = this.buffer[offset2];
    if (this.indentNext > 0) {
      let indent2 = 0;
      while (ch === " ")
        ch = this.buffer[++indent2 + offset2];
      if (ch === "\r") {
        const next = this.buffer[indent2 + offset2 + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset2 + indent2 + 1;
      }
      return ch === "\n" || indent2 >= this.indentNext || !ch && !this.atEnd ? offset2 + indent2 : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset2, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset2 + 3]))
        return -1;
    }
    return offset2;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n2) {
    return this.pos + n2 <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n2) {
    return this.buffer.substr(this.pos, n2);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line2 = this.getLine();
    if (line2 === null)
      return this.setNext("stream");
    if (line2[0] === BOM) {
      yield* this.pushCount(1);
      line2 = line2.substring(1);
    }
    if (line2[0] === "%") {
      let dirEnd = line2.length;
      const cs = line2.indexOf("#");
      if (cs !== -1) {
        const ch = line2[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line2[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line2.length - n2);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line2.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s2 = this.peek(3);
      if (s2 === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s2 === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n2;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line2 = this.getLine();
    if (line2 === null)
      return this.setNext("doc");
    let n2 = yield* this.pushIndicators();
    switch (line2[n2]) {
      case "#":
        yield* this.pushCount(line2.length - n2);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n2 += yield* this.parseBlockScalarHeader();
        n2 += yield* this.pushSpaces(true);
        yield* this.pushCount(line2.length - n2);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent2 = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent2 = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line2 = this.getLine();
    if (line2 === null)
      return this.setNext("flow");
    if (indent2 !== -1 && indent2 < this.indentNext && line2[0] !== "#" || indent2 === 0 && (line2.startsWith("---") || line2.startsWith("...")) && isEmpty(line2[3])) {
      const atFlowEndMarker = indent2 === this.indentNext - 1 && this.flowLevel === 1 && (line2[0] === "]" || line2[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n2 = 0;
    while (line2[n2] === ",") {
      n2 += yield* this.pushCount(1);
      n2 += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n2 += yield* this.pushIndicators();
    switch (line2[n2]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line2.length - n2);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n2 = 0;
        while (this.buffer[end - 1 - n2] === "\\")
          n2 += 1;
        if (n2 % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i2 = this.pos;
    while (true) {
      const ch = this.buffer[++i2];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent2 = 0;
    let ch;
    loop:
      for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
        switch (ch) {
          case " ":
            indent2 += 1;
            break;
          case "\n":
            nl = i2;
            indent2 = 0;
            break;
          case "\r": {
            const next = this.buffer[i2 + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent2 >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent2;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent2 > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i2 = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i2]) {
      if (ch === ":") {
        const next = this.buffer[i2 + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i2;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i2 + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i2 += 1;
            ch = "\n";
            next = this.buffer[i2 + 1];
          } else
            end = i2;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i2 + 1);
          if (cs === -1)
            break;
          i2 = Math.max(i2, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i2;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n2) {
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos += n2;
      return n2;
    }
    return 0;
  }
  *pushToIndex(i2, allowEmpty) {
    const s2 = this.buffer.slice(this.pos, i2);
    if (s2) {
      yield s2;
      this.pos += s2.length;
      return s2.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i2 = this.pos + 2;
      let ch = this.buffer[i2];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i2];
      return yield* this.pushToIndex(ch === ">" ? i2 + 1 : i2, false);
    } else {
      let i2 = this.pos + 1;
      let ch = this.buffer[i2];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i2];
        else if (ch === "%" && hexDigits.includes(this.buffer[i2 + 1]) && hexDigits.includes(this.buffer[i2 + 2])) {
          ch = this.buffer[i2 += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i2, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i2 = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i2];
    } while (ch === " " || allowTabs && ch === "	");
    const n2 = i2 - this.pos;
    if (n2 > 0) {
      yield this.buffer.substr(this.pos, n2);
      this.pos = i2;
    }
    return n2;
  }
  *pushUntil(test2) {
    let i2 = this.pos;
    let ch = this.buffer[i2];
    while (!test2(ch))
      ch = this.buffer[++i2];
    return yield* this.pushToIndex(i2, false);
  }
}
class LineCounter {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset2) => this.lineStarts.push(offset2);
    this.linePos = (offset2) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid2 = low + high >> 1;
        if (this.lineStarts[mid2] < offset2)
          low = mid2 + 1;
        else
          high = mid2;
      }
      if (this.lineStarts[low] === offset2)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset2 };
      const start2 = this.lineStarts[low - 1];
      return { line: low, col: offset2 - start2 + 1 };
    };
  }
}
function includesToken(list3, type) {
  for (let i2 = 0; i2 < list3.length; ++i2)
    if (list3[i2].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list3) {
  for (let i2 = 0; i2 < list3.length; ++i2) {
    switch (list3[i2].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i2;
    }
  }
  return -1;
}
function isFlowToken(token2) {
  switch (token2 == null ? void 0 : token2.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a2;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it2 = parent.items[parent.items.length - 1];
      return (_a2 = it2.sep) != null ? _a2 : it2.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a2;
  if (prev.length === 0)
    return [];
  let i2 = prev.length;
  loop:
    while (--i2 >= 0) {
      switch (prev[i2].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a2 = prev[++i2]) == null ? void 0 : _a2.type) === "space") {
  }
  return prev.splice(i2, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it2 of fc.items) {
      if (it2.sep && !it2.value && !includesToken(it2.start, "explicit-key-ind") && !includesToken(it2.sep, "map-value-ind")) {
        if (it2.key)
          it2.value = it2.key;
        delete it2.key;
        if (isFlowToken(it2.value)) {
          if (it2.value.end)
            Array.prototype.push.apply(it2.value.end, it2.sep);
          else
            it2.value.end = it2.sep;
        } else
          Array.prototype.push.apply(it2.start, it2.sep);
        delete it2.sep;
      }
    }
  }
}
class Parser {
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top2 = this.peek(1);
    if (this.type === "doc-end" && (!top2 || top2.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top2)
      return yield* this.stream();
    switch (top2.type) {
      case "document":
        return yield* this.document(top2);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top2);
      case "block-scalar":
        return yield* this.blockScalar(top2);
      case "block-map":
        return yield* this.blockMap(top2);
      case "block-seq":
        return yield* this.blockSequence(top2);
      case "flow-collection":
        return yield* this.flowCollection(top2);
      case "doc-end":
        return yield* this.documentEnd(top2);
    }
    yield* this.pop();
  }
  peek(n2) {
    return this.stack[this.stack.length - n2];
  }
  *pop(error2) {
    const token2 = error2 != null ? error2 : this.stack.pop();
    if (!token2) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token2;
    } else {
      const top2 = this.peek(1);
      if (token2.type === "block-scalar") {
        token2.indent = "indent" in top2 ? top2.indent : 0;
      } else if (token2.type === "flow-collection" && top2.type === "document") {
        token2.indent = 0;
      }
      if (token2.type === "flow-collection")
        fixFlowSeqItems(token2);
      switch (top2.type) {
        case "document":
          top2.value = token2;
          break;
        case "block-scalar":
          top2.props.push(token2);
          break;
        case "block-map": {
          const it2 = top2.items[top2.items.length - 1];
          if (it2.value) {
            top2.items.push({ start: [], key: token2, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it2.sep) {
            it2.value = token2;
          } else {
            Object.assign(it2, { key: token2, sep: [] });
            this.onKeyLine = !includesToken(it2.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it2 = top2.items[top2.items.length - 1];
          if (it2.value)
            top2.items.push({ start: [], value: token2 });
          else
            it2.value = token2;
          break;
        }
        case "flow-collection": {
          const it2 = top2.items[top2.items.length - 1];
          if (!it2 || it2.value)
            top2.items.push({ start: [], key: token2, sep: [] });
          else if (it2.sep)
            it2.value = token2;
          else
            Object.assign(it2, { key: token2, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token2);
      }
      if ((top2.type === "document" || top2.type === "block-map" || top2.type === "block-seq") && (token2.type === "block-map" || token2.type === "block-seq")) {
        const last = token2.items[token2.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token2.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token2.indent))) {
          if (top2.type === "document")
            top2.end = last.start;
          else
            top2.items.push({ start: last.start });
          token2.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc2 = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc2.start.push(this.sourceToken);
        this.stack.push(doc2);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc2) {
    if (doc2.value)
      return yield* this.lineEnd(doc2);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc2.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc2.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc2.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc2);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start2 = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start: start2, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a2;
    const it2 = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it2.value) {
          const end = "end" in it2.value ? it2.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it2.sep) {
          it2.sep.push(this.sourceToken);
        } else {
          it2.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it2.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it2.sep) {
          it2.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it2.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a2 = prev == null ? void 0 : prev.value) == null ? void 0 : _a2.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it2.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it2.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && it2.sep;
      let start2 = [];
      if (atNextItem && it2.sep && !it2.value) {
        const nl = [];
        for (let i2 = 0; i2 < it2.sep.length; ++i2) {
          const st = it2.sep[i2];
          switch (st.type) {
            case "newline":
              nl.push(i2);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start2 = it2.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it2.value) {
            start2.push(this.sourceToken);
            map2.items.push({ start: start2 });
            this.onKeyLine = true;
          } else if (it2.sep) {
            it2.sep.push(this.sourceToken);
          } else {
            it2.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it2.sep && !includesToken(it2.start, "explicit-key-ind")) {
            it2.start.push(this.sourceToken);
          } else if (atNextItem || it2.value) {
            start2.push(this.sourceToken);
            map2.items.push({ start: start2 });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (includesToken(it2.start, "explicit-key-ind")) {
            if (!it2.sep) {
              if (includesToken(it2.start, "newline")) {
                Object.assign(it2, { key: null, sep: [this.sourceToken] });
              } else {
                const start3 = getFirstKeyStartProps(it2.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it2.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it2.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it2.key) && !includesToken(it2.sep, "newline")) {
              const start3 = getFirstKeyStartProps(it2.start);
              const key = it2.key;
              const sep = it2.sep;
              sep.push(this.sourceToken);
              delete it2.key, delete it2.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start3, key, sep }]
              });
            } else if (start2.length > 0) {
              it2.sep = it2.sep.concat(start2, this.sourceToken);
            } else {
              it2.sep.push(this.sourceToken);
            }
          } else {
            if (!it2.sep) {
              Object.assign(it2, { key: null, sep: [this.sourceToken] });
            } else if (it2.value || atNextItem) {
              map2.items.push({ start: start2, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it2.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it2.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it2.value) {
            map2.items.push({ start: start2, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it2.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it2, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it2.start, "explicit-key-ind")) {
              map2.items.push({ start: start2 });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a2;
    const it2 = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it2.value) {
          const end = "end" in it2.value ? it2.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it2.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it2.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it2.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a2 = prev == null ? void 0 : prev.value) == null ? void 0 : _a2.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it2.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it2.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it2.value || this.indent <= seq2.indent)
          break;
        it2.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it2.value || includesToken(it2.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it2.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it2 = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top2;
      do {
        yield* this.pop();
        top2 = this.peek(1);
      } while (top2 && top2.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it2 || it2.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it2.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it2 || it2.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it2.sep)
            it2.sep.push(this.sourceToken);
          else
            Object.assign(it2, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it2 || it2.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it2.sep)
            it2.sep.push(this.sourceToken);
          else
            it2.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it2 || it2.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it2.sep)
            this.stack.push(fs);
          else
            Object.assign(it2, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start: start2, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        start2.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start2, indent2) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent2)
      return false;
    return start2.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token2) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token2.end)
          token2.end.push(this.sourceToken);
        else
          token2.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
}
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  const docs = Array.from(composer.compose(parser.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc2 of docs) {
      doc2.errors.forEach(prettifyError(source, lineCounter));
      doc2.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc2 = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc2)
      doc2 = _doc;
    else if (doc2.options.logLevel !== "silent") {
      doc2.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc2.errors.forEach(prettifyError(source, lineCounter));
    doc2.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc2;
}
function parse$1(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc2 = parseDocument(src, options);
  if (!doc2)
    return null;
  doc2.warnings.forEach((warning) => warn$1(doc2.options.logLevel, warning));
  if (doc2.errors.length > 0) {
    if (doc2.options.logLevel !== "silent")
      throw doc2.errors[0];
    else
      doc2.errors = [];
  }
  return doc2.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer2, options) {
  var _a2;
  let _replacer = null;
  if (typeof replacer2 === "function" || Array.isArray(replacer2)) {
    _replacer = replacer2;
  } else if (options === void 0 && replacer2) {
    options = replacer2;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent2 = Math.round(options);
    options = indent2 < 1 ? void 0 : indent2 > 8 ? { indent: 8 } : { indent: indent2 };
  }
  if (value === void 0) {
    const { keepUndefined } = (_a2 = options != null ? options : replacer2) != null ? _a2 : {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value, _replacer, options).toString(options);
}
var YAML = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CST: cst,
  Composer,
  Document,
  Schema,
  YAMLError,
  YAMLParseError,
  YAMLWarning,
  Alias,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  Pair,
  Scalar,
  YAMLMap,
  YAMLSeq,
  Lexer,
  LineCounter,
  Parser,
  parse: parse$1,
  parseAllDocuments,
  parseDocument,
  stringify,
  visit: visit$1,
  visitAsync
}, Symbol.toStringTag, { value: "Module" }));
var utils$2 = {};
const Aacute = "\xC1";
const aacute = "\xE1";
const Abreve = "\u0102";
const abreve = "\u0103";
const ac = "\u223E";
const acd = "\u223F";
const acE = "\u223E\u0333";
const Acirc = "\xC2";
const acirc = "\xE2";
const acute = "\xB4";
const Acy = "\u0410";
const acy = "\u0430";
const AElig = "\xC6";
const aelig = "\xE6";
const af = "\u2061";
const Afr = "\u{1D504}";
const afr = "\u{1D51E}";
const Agrave = "\xC0";
const agrave = "\xE0";
const alefsym = "\u2135";
const aleph = "\u2135";
const Alpha = "\u0391";
const alpha = "\u03B1";
const Amacr = "\u0100";
const amacr = "\u0101";
const amalg = "\u2A3F";
const amp = "&";
const AMP = "&";
const andand = "\u2A55";
const And = "\u2A53";
const and = "\u2227";
const andd = "\u2A5C";
const andslope = "\u2A58";
const andv = "\u2A5A";
const ang = "\u2220";
const ange = "\u29A4";
const angle = "\u2220";
const angmsdaa = "\u29A8";
const angmsdab = "\u29A9";
const angmsdac = "\u29AA";
const angmsdad = "\u29AB";
const angmsdae = "\u29AC";
const angmsdaf = "\u29AD";
const angmsdag = "\u29AE";
const angmsdah = "\u29AF";
const angmsd = "\u2221";
const angrt = "\u221F";
const angrtvb = "\u22BE";
const angrtvbd = "\u299D";
const angsph = "\u2222";
const angst = "\xC5";
const angzarr = "\u237C";
const Aogon = "\u0104";
const aogon = "\u0105";
const Aopf = "\u{1D538}";
const aopf = "\u{1D552}";
const apacir = "\u2A6F";
const ap = "\u2248";
const apE = "\u2A70";
const ape = "\u224A";
const apid = "\u224B";
const apos = "'";
const ApplyFunction = "\u2061";
const approx = "\u2248";
const approxeq = "\u224A";
const Aring = "\xC5";
const aring = "\xE5";
const Ascr = "\u{1D49C}";
const ascr = "\u{1D4B6}";
const Assign = "\u2254";
const ast = "*";
const asymp = "\u2248";
const asympeq = "\u224D";
const Atilde = "\xC3";
const atilde = "\xE3";
const Auml = "\xC4";
const auml = "\xE4";
const awconint = "\u2233";
const awint = "\u2A11";
const backcong = "\u224C";
const backepsilon = "\u03F6";
const backprime = "\u2035";
const backsim = "\u223D";
const backsimeq = "\u22CD";
const Backslash = "\u2216";
const Barv = "\u2AE7";
const barvee = "\u22BD";
const barwed = "\u2305";
const Barwed = "\u2306";
const barwedge = "\u2305";
const bbrk = "\u23B5";
const bbrktbrk = "\u23B6";
const bcong = "\u224C";
const Bcy = "\u0411";
const bcy = "\u0431";
const bdquo = "\u201E";
const becaus = "\u2235";
const because = "\u2235";
const Because = "\u2235";
const bemptyv = "\u29B0";
const bepsi = "\u03F6";
const bernou = "\u212C";
const Bernoullis = "\u212C";
const Beta = "\u0392";
const beta = "\u03B2";
const beth = "\u2136";
const between = "\u226C";
const Bfr = "\u{1D505}";
const bfr = "\u{1D51F}";
const bigcap = "\u22C2";
const bigcirc = "\u25EF";
const bigcup = "\u22C3";
const bigodot = "\u2A00";
const bigoplus = "\u2A01";
const bigotimes = "\u2A02";
const bigsqcup = "\u2A06";
const bigstar = "\u2605";
const bigtriangledown = "\u25BD";
const bigtriangleup = "\u25B3";
const biguplus = "\u2A04";
const bigvee = "\u22C1";
const bigwedge = "\u22C0";
const bkarow = "\u290D";
const blacklozenge = "\u29EB";
const blacksquare = "\u25AA";
const blacktriangle = "\u25B4";
const blacktriangledown = "\u25BE";
const blacktriangleleft = "\u25C2";
const blacktriangleright = "\u25B8";
const blank = "\u2423";
const blk12 = "\u2592";
const blk14 = "\u2591";
const blk34 = "\u2593";
const block$1 = "\u2588";
const bne = "=\u20E5";
const bnequiv = "\u2261\u20E5";
const bNot = "\u2AED";
const bnot = "\u2310";
const Bopf = "\u{1D539}";
const bopf = "\u{1D553}";
const bot = "\u22A5";
const bottom = "\u22A5";
const bowtie = "\u22C8";
const boxbox = "\u29C9";
const boxdl = "\u2510";
const boxdL = "\u2555";
const boxDl = "\u2556";
const boxDL = "\u2557";
const boxdr = "\u250C";
const boxdR = "\u2552";
const boxDr = "\u2553";
const boxDR = "\u2554";
const boxh = "\u2500";
const boxH = "\u2550";
const boxhd = "\u252C";
const boxHd = "\u2564";
const boxhD = "\u2565";
const boxHD = "\u2566";
const boxhu = "\u2534";
const boxHu = "\u2567";
const boxhU = "\u2568";
const boxHU = "\u2569";
const boxminus = "\u229F";
const boxplus = "\u229E";
const boxtimes = "\u22A0";
const boxul = "\u2518";
const boxuL = "\u255B";
const boxUl = "\u255C";
const boxUL = "\u255D";
const boxur = "\u2514";
const boxuR = "\u2558";
const boxUr = "\u2559";
const boxUR = "\u255A";
const boxv = "\u2502";
const boxV = "\u2551";
const boxvh = "\u253C";
const boxvH = "\u256A";
const boxVh = "\u256B";
const boxVH = "\u256C";
const boxvl = "\u2524";
const boxvL = "\u2561";
const boxVl = "\u2562";
const boxVL = "\u2563";
const boxvr = "\u251C";
const boxvR = "\u255E";
const boxVr = "\u255F";
const boxVR = "\u2560";
const bprime = "\u2035";
const breve = "\u02D8";
const Breve = "\u02D8";
const brvbar = "\xA6";
const bscr = "\u{1D4B7}";
const Bscr = "\u212C";
const bsemi = "\u204F";
const bsim = "\u223D";
const bsime = "\u22CD";
const bsolb = "\u29C5";
const bsol = "\\";
const bsolhsub = "\u27C8";
const bull = "\u2022";
const bullet = "\u2022";
const bump = "\u224E";
const bumpE = "\u2AAE";
const bumpe = "\u224F";
const Bumpeq = "\u224E";
const bumpeq = "\u224F";
const Cacute = "\u0106";
const cacute = "\u0107";
const capand = "\u2A44";
const capbrcup = "\u2A49";
const capcap = "\u2A4B";
const cap = "\u2229";
const Cap = "\u22D2";
const capcup = "\u2A47";
const capdot = "\u2A40";
const CapitalDifferentialD = "\u2145";
const caps = "\u2229\uFE00";
const caret = "\u2041";
const caron = "\u02C7";
const Cayleys = "\u212D";
const ccaps = "\u2A4D";
const Ccaron = "\u010C";
const ccaron = "\u010D";
const Ccedil = "\xC7";
const ccedil = "\xE7";
const Ccirc = "\u0108";
const ccirc = "\u0109";
const Cconint = "\u2230";
const ccups = "\u2A4C";
const ccupssm = "\u2A50";
const Cdot = "\u010A";
const cdot = "\u010B";
const cedil = "\xB8";
const Cedilla = "\xB8";
const cemptyv = "\u29B2";
const cent = "\xA2";
const centerdot = "\xB7";
const CenterDot = "\xB7";
const cfr = "\u{1D520}";
const Cfr = "\u212D";
const CHcy = "\u0427";
const chcy = "\u0447";
const check = "\u2713";
const checkmark = "\u2713";
const Chi = "\u03A7";
const chi = "\u03C7";
const circ = "\u02C6";
const circeq = "\u2257";
const circlearrowleft = "\u21BA";
const circlearrowright = "\u21BB";
const circledast = "\u229B";
const circledcirc = "\u229A";
const circleddash = "\u229D";
const CircleDot = "\u2299";
const circledR = "\xAE";
const circledS = "\u24C8";
const CircleMinus = "\u2296";
const CirclePlus = "\u2295";
const CircleTimes = "\u2297";
const cir = "\u25CB";
const cirE = "\u29C3";
const cire = "\u2257";
const cirfnint = "\u2A10";
const cirmid = "\u2AEF";
const cirscir = "\u29C2";
const ClockwiseContourIntegral = "\u2232";
const CloseCurlyDoubleQuote = "\u201D";
const CloseCurlyQuote = "\u2019";
const clubs = "\u2663";
const clubsuit = "\u2663";
const colon = ":";
const Colon = "\u2237";
const Colone = "\u2A74";
const colone = "\u2254";
const coloneq = "\u2254";
const comma = ",";
const commat = "@";
const comp = "\u2201";
const compfn = "\u2218";
const complement = "\u2201";
const complexes = "\u2102";
const cong = "\u2245";
const congdot = "\u2A6D";
const Congruent = "\u2261";
const conint = "\u222E";
const Conint = "\u222F";
const ContourIntegral = "\u222E";
const copf = "\u{1D554}";
const Copf = "\u2102";
const coprod = "\u2210";
const Coproduct = "\u2210";
const copy = "\xA9";
const COPY = "\xA9";
const copysr = "\u2117";
const CounterClockwiseContourIntegral = "\u2233";
const crarr = "\u21B5";
const cross = "\u2717";
const Cross = "\u2A2F";
const Cscr = "\u{1D49E}";
const cscr = "\u{1D4B8}";
const csub = "\u2ACF";
const csube = "\u2AD1";
const csup = "\u2AD0";
const csupe = "\u2AD2";
const ctdot = "\u22EF";
const cudarrl = "\u2938";
const cudarrr = "\u2935";
const cuepr = "\u22DE";
const cuesc = "\u22DF";
const cularr = "\u21B6";
const cularrp = "\u293D";
const cupbrcap = "\u2A48";
const cupcap = "\u2A46";
const CupCap = "\u224D";
const cup = "\u222A";
const Cup = "\u22D3";
const cupcup = "\u2A4A";
const cupdot = "\u228D";
const cupor = "\u2A45";
const cups = "\u222A\uFE00";
const curarr = "\u21B7";
const curarrm = "\u293C";
const curlyeqprec = "\u22DE";
const curlyeqsucc = "\u22DF";
const curlyvee = "\u22CE";
const curlywedge = "\u22CF";
const curren = "\xA4";
const curvearrowleft = "\u21B6";
const curvearrowright = "\u21B7";
const cuvee = "\u22CE";
const cuwed = "\u22CF";
const cwconint = "\u2232";
const cwint = "\u2231";
const cylcty = "\u232D";
const dagger = "\u2020";
const Dagger = "\u2021";
const daleth = "\u2138";
const darr = "\u2193";
const Darr = "\u21A1";
const dArr = "\u21D3";
const dash = "\u2010";
const Dashv = "\u2AE4";
const dashv = "\u22A3";
const dbkarow = "\u290F";
const dblac = "\u02DD";
const Dcaron = "\u010E";
const dcaron = "\u010F";
const Dcy = "\u0414";
const dcy = "\u0434";
const ddagger = "\u2021";
const ddarr = "\u21CA";
const DD = "\u2145";
const dd = "\u2146";
const DDotrahd = "\u2911";
const ddotseq = "\u2A77";
const deg = "\xB0";
const Del = "\u2207";
const Delta = "\u0394";
const delta = "\u03B4";
const demptyv = "\u29B1";
const dfisht = "\u297F";
const Dfr = "\u{1D507}";
const dfr = "\u{1D521}";
const dHar = "\u2965";
const dharl = "\u21C3";
const dharr = "\u21C2";
const DiacriticalAcute = "\xB4";
const DiacriticalDot = "\u02D9";
const DiacriticalDoubleAcute = "\u02DD";
const DiacriticalGrave = "`";
const DiacriticalTilde = "\u02DC";
const diam = "\u22C4";
const diamond = "\u22C4";
const Diamond = "\u22C4";
const diamondsuit = "\u2666";
const diams = "\u2666";
const die = "\xA8";
const DifferentialD = "\u2146";
const digamma = "\u03DD";
const disin = "\u22F2";
const div = "\xF7";
const divide = "\xF7";
const divideontimes = "\u22C7";
const divonx = "\u22C7";
const DJcy = "\u0402";
const djcy = "\u0452";
const dlcorn = "\u231E";
const dlcrop = "\u230D";
const dollar = "$";
const Dopf = "\u{1D53B}";
const dopf = "\u{1D555}";
const Dot = "\xA8";
const dot = "\u02D9";
const DotDot = "\u20DC";
const doteq = "\u2250";
const doteqdot = "\u2251";
const DotEqual = "\u2250";
const dotminus = "\u2238";
const dotplus = "\u2214";
const dotsquare = "\u22A1";
const doublebarwedge = "\u2306";
const DoubleContourIntegral = "\u222F";
const DoubleDot = "\xA8";
const DoubleDownArrow = "\u21D3";
const DoubleLeftArrow = "\u21D0";
const DoubleLeftRightArrow = "\u21D4";
const DoubleLeftTee = "\u2AE4";
const DoubleLongLeftArrow = "\u27F8";
const DoubleLongLeftRightArrow = "\u27FA";
const DoubleLongRightArrow = "\u27F9";
const DoubleRightArrow = "\u21D2";
const DoubleRightTee = "\u22A8";
const DoubleUpArrow = "\u21D1";
const DoubleUpDownArrow = "\u21D5";
const DoubleVerticalBar = "\u2225";
const DownArrowBar = "\u2913";
const downarrow = "\u2193";
const DownArrow = "\u2193";
const Downarrow = "\u21D3";
const DownArrowUpArrow = "\u21F5";
const DownBreve = "\u0311";
const downdownarrows = "\u21CA";
const downharpoonleft = "\u21C3";
const downharpoonright = "\u21C2";
const DownLeftRightVector = "\u2950";
const DownLeftTeeVector = "\u295E";
const DownLeftVectorBar = "\u2956";
const DownLeftVector = "\u21BD";
const DownRightTeeVector = "\u295F";
const DownRightVectorBar = "\u2957";
const DownRightVector = "\u21C1";
const DownTeeArrow = "\u21A7";
const DownTee = "\u22A4";
const drbkarow = "\u2910";
const drcorn = "\u231F";
const drcrop = "\u230C";
const Dscr = "\u{1D49F}";
const dscr = "\u{1D4B9}";
const DScy = "\u0405";
const dscy = "\u0455";
const dsol = "\u29F6";
const Dstrok = "\u0110";
const dstrok = "\u0111";
const dtdot = "\u22F1";
const dtri = "\u25BF";
const dtrif = "\u25BE";
const duarr = "\u21F5";
const duhar = "\u296F";
const dwangle = "\u29A6";
const DZcy = "\u040F";
const dzcy = "\u045F";
const dzigrarr = "\u27FF";
const Eacute = "\xC9";
const eacute = "\xE9";
const easter = "\u2A6E";
const Ecaron = "\u011A";
const ecaron = "\u011B";
const Ecirc = "\xCA";
const ecirc = "\xEA";
const ecir = "\u2256";
const ecolon = "\u2255";
const Ecy = "\u042D";
const ecy = "\u044D";
const eDDot = "\u2A77";
const Edot = "\u0116";
const edot = "\u0117";
const eDot = "\u2251";
const ee = "\u2147";
const efDot = "\u2252";
const Efr = "\u{1D508}";
const efr = "\u{1D522}";
const eg = "\u2A9A";
const Egrave = "\xC8";
const egrave = "\xE8";
const egs = "\u2A96";
const egsdot = "\u2A98";
const el = "\u2A99";
const Element$1 = "\u2208";
const elinters = "\u23E7";
const ell = "\u2113";
const els = "\u2A95";
const elsdot = "\u2A97";
const Emacr = "\u0112";
const emacr = "\u0113";
const empty$1 = "\u2205";
const emptyset = "\u2205";
const EmptySmallSquare = "\u25FB";
const emptyv = "\u2205";
const EmptyVerySmallSquare = "\u25AB";
const emsp13 = "\u2004";
const emsp14 = "\u2005";
const emsp = "\u2003";
const ENG = "\u014A";
const eng = "\u014B";
const ensp = "\u2002";
const Eogon = "\u0118";
const eogon = "\u0119";
const Eopf = "\u{1D53C}";
const eopf = "\u{1D556}";
const epar = "\u22D5";
const eparsl = "\u29E3";
const eplus = "\u2A71";
const epsi = "\u03B5";
const Epsilon = "\u0395";
const epsilon$1 = "\u03B5";
const epsiv = "\u03F5";
const eqcirc = "\u2256";
const eqcolon = "\u2255";
const eqsim = "\u2242";
const eqslantgtr = "\u2A96";
const eqslantless = "\u2A95";
const Equal = "\u2A75";
const equals = "=";
const EqualTilde = "\u2242";
const equest = "\u225F";
const Equilibrium = "\u21CC";
const equiv = "\u2261";
const equivDD = "\u2A78";
const eqvparsl = "\u29E5";
const erarr = "\u2971";
const erDot = "\u2253";
const escr = "\u212F";
const Escr = "\u2130";
const esdot = "\u2250";
const Esim = "\u2A73";
const esim = "\u2242";
const Eta = "\u0397";
const eta = "\u03B7";
const ETH = "\xD0";
const eth = "\xF0";
const Euml = "\xCB";
const euml = "\xEB";
const euro = "\u20AC";
const excl = "!";
const exist = "\u2203";
const Exists = "\u2203";
const expectation = "\u2130";
const exponentiale = "\u2147";
const ExponentialE = "\u2147";
const fallingdotseq = "\u2252";
const Fcy = "\u0424";
const fcy = "\u0444";
const female = "\u2640";
const ffilig = "\uFB03";
const fflig = "\uFB00";
const ffllig = "\uFB04";
const Ffr = "\u{1D509}";
const ffr = "\u{1D523}";
const filig = "\uFB01";
const FilledSmallSquare = "\u25FC";
const FilledVerySmallSquare = "\u25AA";
const fjlig = "fj";
const flat = "\u266D";
const fllig = "\uFB02";
const fltns = "\u25B1";
const fnof = "\u0192";
const Fopf = "\u{1D53D}";
const fopf = "\u{1D557}";
const forall = "\u2200";
const ForAll = "\u2200";
const fork = "\u22D4";
const forkv = "\u2AD9";
const Fouriertrf = "\u2131";
const fpartint = "\u2A0D";
const frac12 = "\xBD";
const frac13 = "\u2153";
const frac14 = "\xBC";
const frac15 = "\u2155";
const frac16 = "\u2159";
const frac18 = "\u215B";
const frac23 = "\u2154";
const frac25 = "\u2156";
const frac34 = "\xBE";
const frac35 = "\u2157";
const frac38 = "\u215C";
const frac45 = "\u2158";
const frac56 = "\u215A";
const frac58 = "\u215D";
const frac78 = "\u215E";
const frasl = "\u2044";
const frown = "\u2322";
const fscr = "\u{1D4BB}";
const Fscr = "\u2131";
const gacute = "\u01F5";
const Gamma = "\u0393";
const gamma$1 = "\u03B3";
const Gammad = "\u03DC";
const gammad = "\u03DD";
const gap = "\u2A86";
const Gbreve = "\u011E";
const gbreve = "\u011F";
const Gcedil = "\u0122";
const Gcirc = "\u011C";
const gcirc = "\u011D";
const Gcy = "\u0413";
const gcy = "\u0433";
const Gdot = "\u0120";
const gdot = "\u0121";
const ge$1 = "\u2265";
const gE = "\u2267";
const gEl = "\u2A8C";
const gel = "\u22DB";
const geq = "\u2265";
const geqq = "\u2267";
const geqslant = "\u2A7E";
const gescc = "\u2AA9";
const ges = "\u2A7E";
const gesdot = "\u2A80";
const gesdoto = "\u2A82";
const gesdotol = "\u2A84";
const gesl = "\u22DB\uFE00";
const gesles = "\u2A94";
const Gfr = "\u{1D50A}";
const gfr = "\u{1D524}";
const gg = "\u226B";
const Gg = "\u22D9";
const ggg = "\u22D9";
const gimel = "\u2137";
const GJcy = "\u0403";
const gjcy = "\u0453";
const gla = "\u2AA5";
const gl = "\u2277";
const glE = "\u2A92";
const glj = "\u2AA4";
const gnap = "\u2A8A";
const gnapprox = "\u2A8A";
const gne = "\u2A88";
const gnE = "\u2269";
const gneq = "\u2A88";
const gneqq = "\u2269";
const gnsim = "\u22E7";
const Gopf = "\u{1D53E}";
const gopf = "\u{1D558}";
const grave = "`";
const GreaterEqual = "\u2265";
const GreaterEqualLess = "\u22DB";
const GreaterFullEqual = "\u2267";
const GreaterGreater = "\u2AA2";
const GreaterLess = "\u2277";
const GreaterSlantEqual = "\u2A7E";
const GreaterTilde = "\u2273";
const Gscr = "\u{1D4A2}";
const gscr = "\u210A";
const gsim = "\u2273";
const gsime = "\u2A8E";
const gsiml = "\u2A90";
const gtcc = "\u2AA7";
const gtcir = "\u2A7A";
const gt = ">";
const GT = ">";
const Gt = "\u226B";
const gtdot = "\u22D7";
const gtlPar = "\u2995";
const gtquest = "\u2A7C";
const gtrapprox = "\u2A86";
const gtrarr = "\u2978";
const gtrdot = "\u22D7";
const gtreqless = "\u22DB";
const gtreqqless = "\u2A8C";
const gtrless = "\u2277";
const gtrsim = "\u2273";
const gvertneqq = "\u2269\uFE00";
const gvnE = "\u2269\uFE00";
const Hacek = "\u02C7";
const hairsp = "\u200A";
const half = "\xBD";
const hamilt = "\u210B";
const HARDcy = "\u042A";
const hardcy = "\u044A";
const harrcir = "\u2948";
const harr = "\u2194";
const hArr = "\u21D4";
const harrw = "\u21AD";
const Hat = "^";
const hbar = "\u210F";
const Hcirc = "\u0124";
const hcirc = "\u0125";
const hearts = "\u2665";
const heartsuit = "\u2665";
const hellip = "\u2026";
const hercon = "\u22B9";
const hfr = "\u{1D525}";
const Hfr = "\u210C";
const HilbertSpace = "\u210B";
const hksearow = "\u2925";
const hkswarow = "\u2926";
const hoarr = "\u21FF";
const homtht = "\u223B";
const hookleftarrow = "\u21A9";
const hookrightarrow = "\u21AA";
const hopf = "\u{1D559}";
const Hopf = "\u210D";
const horbar = "\u2015";
const HorizontalLine = "\u2500";
const hscr = "\u{1D4BD}";
const Hscr = "\u210B";
const hslash = "\u210F";
const Hstrok = "\u0126";
const hstrok = "\u0127";
const HumpDownHump = "\u224E";
const HumpEqual = "\u224F";
const hybull = "\u2043";
const hyphen = "\u2010";
const Iacute = "\xCD";
const iacute = "\xED";
const ic = "\u2063";
const Icirc = "\xCE";
const icirc = "\xEE";
const Icy = "\u0418";
const icy = "\u0438";
const Idot = "\u0130";
const IEcy = "\u0415";
const iecy = "\u0435";
const iexcl = "\xA1";
const iff = "\u21D4";
const ifr = "\u{1D526}";
const Ifr = "\u2111";
const Igrave = "\xCC";
const igrave = "\xEC";
const ii = "\u2148";
const iiiint = "\u2A0C";
const iiint = "\u222D";
const iinfin = "\u29DC";
const iiota = "\u2129";
const IJlig = "\u0132";
const ijlig = "\u0133";
const Imacr = "\u012A";
const imacr = "\u012B";
const image$1 = "\u2111";
const ImaginaryI = "\u2148";
const imagline = "\u2110";
const imagpart = "\u2111";
const imath = "\u0131";
const Im = "\u2111";
const imof = "\u22B7";
const imped = "\u01B5";
const Implies = "\u21D2";
const incare = "\u2105";
const infin = "\u221E";
const infintie = "\u29DD";
const inodot = "\u0131";
const intcal = "\u22BA";
const int = "\u222B";
const Int = "\u222C";
const integers = "\u2124";
const Integral = "\u222B";
const intercal = "\u22BA";
const Intersection = "\u22C2";
const intlarhk = "\u2A17";
const intprod = "\u2A3C";
const InvisibleComma = "\u2063";
const InvisibleTimes = "\u2062";
const IOcy = "\u0401";
const iocy = "\u0451";
const Iogon = "\u012E";
const iogon = "\u012F";
const Iopf = "\u{1D540}";
const iopf = "\u{1D55A}";
const Iota = "\u0399";
const iota = "\u03B9";
const iprod = "\u2A3C";
const iquest = "\xBF";
const iscr = "\u{1D4BE}";
const Iscr = "\u2110";
const isin = "\u2208";
const isindot = "\u22F5";
const isinE = "\u22F9";
const isins = "\u22F4";
const isinsv = "\u22F3";
const isinv = "\u2208";
const it$1 = "\u2062";
const Itilde = "\u0128";
const itilde = "\u0129";
const Iukcy = "\u0406";
const iukcy = "\u0456";
const Iuml = "\xCF";
const iuml = "\xEF";
const Jcirc = "\u0134";
const jcirc = "\u0135";
const Jcy = "\u0419";
const jcy = "\u0439";
const Jfr = "\u{1D50D}";
const jfr = "\u{1D527}";
const jmath = "\u0237";
const Jopf = "\u{1D541}";
const jopf = "\u{1D55B}";
const Jscr = "\u{1D4A5}";
const jscr = "\u{1D4BF}";
const Jsercy = "\u0408";
const jsercy = "\u0458";
const Jukcy = "\u0404";
const jukcy = "\u0454";
const Kappa = "\u039A";
const kappa = "\u03BA";
const kappav = "\u03F0";
const Kcedil = "\u0136";
const kcedil = "\u0137";
const Kcy = "\u041A";
const kcy = "\u043A";
const Kfr = "\u{1D50E}";
const kfr = "\u{1D528}";
const kgreen = "\u0138";
const KHcy = "\u0425";
const khcy = "\u0445";
const KJcy = "\u040C";
const kjcy = "\u045C";
const Kopf = "\u{1D542}";
const kopf = "\u{1D55C}";
const Kscr = "\u{1D4A6}";
const kscr = "\u{1D4C0}";
const lAarr = "\u21DA";
const Lacute = "\u0139";
const lacute = "\u013A";
const laemptyv = "\u29B4";
const lagran = "\u2112";
const Lambda = "\u039B";
const lambda = "\u03BB";
const lang$1 = "\u27E8";
const Lang = "\u27EA";
const langd = "\u2991";
const langle = "\u27E8";
const lap = "\u2A85";
const Laplacetrf = "\u2112";
const laquo = "\xAB";
const larrb = "\u21E4";
const larrbfs = "\u291F";
const larr = "\u2190";
const Larr = "\u219E";
const lArr = "\u21D0";
const larrfs = "\u291D";
const larrhk = "\u21A9";
const larrlp = "\u21AB";
const larrpl = "\u2939";
const larrsim = "\u2973";
const larrtl = "\u21A2";
const latail = "\u2919";
const lAtail = "\u291B";
const lat = "\u2AAB";
const late = "\u2AAD";
const lates = "\u2AAD\uFE00";
const lbarr = "\u290C";
const lBarr = "\u290E";
const lbbrk = "\u2772";
const lbrace = "{";
const lbrack = "[";
const lbrke = "\u298B";
const lbrksld = "\u298F";
const lbrkslu = "\u298D";
const Lcaron = "\u013D";
const lcaron = "\u013E";
const Lcedil = "\u013B";
const lcedil = "\u013C";
const lceil = "\u2308";
const lcub = "{";
const Lcy = "\u041B";
const lcy = "\u043B";
const ldca = "\u2936";
const ldquo = "\u201C";
const ldquor = "\u201E";
const ldrdhar = "\u2967";
const ldrushar = "\u294B";
const ldsh = "\u21B2";
const le$1 = "\u2264";
const lE = "\u2266";
const LeftAngleBracket = "\u27E8";
const LeftArrowBar = "\u21E4";
const leftarrow = "\u2190";
const LeftArrow = "\u2190";
const Leftarrow = "\u21D0";
const LeftArrowRightArrow = "\u21C6";
const leftarrowtail = "\u21A2";
const LeftCeiling = "\u2308";
const LeftDoubleBracket = "\u27E6";
const LeftDownTeeVector = "\u2961";
const LeftDownVectorBar = "\u2959";
const LeftDownVector = "\u21C3";
const LeftFloor = "\u230A";
const leftharpoondown = "\u21BD";
const leftharpoonup = "\u21BC";
const leftleftarrows = "\u21C7";
const leftrightarrow = "\u2194";
const LeftRightArrow = "\u2194";
const Leftrightarrow = "\u21D4";
const leftrightarrows = "\u21C6";
const leftrightharpoons = "\u21CB";
const leftrightsquigarrow = "\u21AD";
const LeftRightVector = "\u294E";
const LeftTeeArrow = "\u21A4";
const LeftTee = "\u22A3";
const LeftTeeVector = "\u295A";
const leftthreetimes = "\u22CB";
const LeftTriangleBar = "\u29CF";
const LeftTriangle = "\u22B2";
const LeftTriangleEqual = "\u22B4";
const LeftUpDownVector = "\u2951";
const LeftUpTeeVector = "\u2960";
const LeftUpVectorBar = "\u2958";
const LeftUpVector = "\u21BF";
const LeftVectorBar = "\u2952";
const LeftVector = "\u21BC";
const lEg = "\u2A8B";
const leg = "\u22DA";
const leq = "\u2264";
const leqq = "\u2266";
const leqslant = "\u2A7D";
const lescc = "\u2AA8";
const les = "\u2A7D";
const lesdot = "\u2A7F";
const lesdoto = "\u2A81";
const lesdotor = "\u2A83";
const lesg = "\u22DA\uFE00";
const lesges = "\u2A93";
const lessapprox = "\u2A85";
const lessdot = "\u22D6";
const lesseqgtr = "\u22DA";
const lesseqqgtr = "\u2A8B";
const LessEqualGreater = "\u22DA";
const LessFullEqual = "\u2266";
const LessGreater = "\u2276";
const lessgtr = "\u2276";
const LessLess = "\u2AA1";
const lesssim = "\u2272";
const LessSlantEqual = "\u2A7D";
const LessTilde = "\u2272";
const lfisht = "\u297C";
const lfloor = "\u230A";
const Lfr = "\u{1D50F}";
const lfr = "\u{1D529}";
const lg = "\u2276";
const lgE = "\u2A91";
const lHar = "\u2962";
const lhard = "\u21BD";
const lharu = "\u21BC";
const lharul = "\u296A";
const lhblk = "\u2584";
const LJcy = "\u0409";
const ljcy = "\u0459";
const llarr = "\u21C7";
const ll = "\u226A";
const Ll = "\u22D8";
const llcorner = "\u231E";
const Lleftarrow = "\u21DA";
const llhard = "\u296B";
const lltri = "\u25FA";
const Lmidot = "\u013F";
const lmidot = "\u0140";
const lmoustache = "\u23B0";
const lmoust = "\u23B0";
const lnap = "\u2A89";
const lnapprox = "\u2A89";
const lne = "\u2A87";
const lnE = "\u2268";
const lneq = "\u2A87";
const lneqq = "\u2268";
const lnsim = "\u22E6";
const loang = "\u27EC";
const loarr = "\u21FD";
const lobrk = "\u27E6";
const longleftarrow = "\u27F5";
const LongLeftArrow = "\u27F5";
const Longleftarrow = "\u27F8";
const longleftrightarrow = "\u27F7";
const LongLeftRightArrow = "\u27F7";
const Longleftrightarrow = "\u27FA";
const longmapsto = "\u27FC";
const longrightarrow = "\u27F6";
const LongRightArrow = "\u27F6";
const Longrightarrow = "\u27F9";
const looparrowleft = "\u21AB";
const looparrowright = "\u21AC";
const lopar = "\u2985";
const Lopf = "\u{1D543}";
const lopf = "\u{1D55D}";
const loplus = "\u2A2D";
const lotimes = "\u2A34";
const lowast = "\u2217";
const lowbar = "_";
const LowerLeftArrow = "\u2199";
const LowerRightArrow = "\u2198";
const loz = "\u25CA";
const lozenge = "\u25CA";
const lozf = "\u29EB";
const lpar = "(";
const lparlt = "\u2993";
const lrarr = "\u21C6";
const lrcorner = "\u231F";
const lrhar = "\u21CB";
const lrhard = "\u296D";
const lrm = "\u200E";
const lrtri = "\u22BF";
const lsaquo = "\u2039";
const lscr = "\u{1D4C1}";
const Lscr = "\u2112";
const lsh = "\u21B0";
const Lsh = "\u21B0";
const lsim = "\u2272";
const lsime = "\u2A8D";
const lsimg = "\u2A8F";
const lsqb = "[";
const lsquo = "\u2018";
const lsquor = "\u201A";
const Lstrok = "\u0141";
const lstrok = "\u0142";
const ltcc = "\u2AA6";
const ltcir = "\u2A79";
const lt = "<";
const LT = "<";
const Lt = "\u226A";
const ltdot = "\u22D6";
const lthree = "\u22CB";
const ltimes = "\u22C9";
const ltlarr = "\u2976";
const ltquest = "\u2A7B";
const ltri = "\u25C3";
const ltrie = "\u22B4";
const ltrif = "\u25C2";
const ltrPar = "\u2996";
const lurdshar = "\u294A";
const luruhar = "\u2966";
const lvertneqq = "\u2268\uFE00";
const lvnE = "\u2268\uFE00";
const macr = "\xAF";
const male = "\u2642";
const malt = "\u2720";
const maltese = "\u2720";
const map$2 = "\u21A6";
const mapsto = "\u21A6";
const mapstodown = "\u21A7";
const mapstoleft = "\u21A4";
const mapstoup = "\u21A5";
const marker = "\u25AE";
const mcomma = "\u2A29";
const Mcy = "\u041C";
const mcy = "\u043C";
const mdash = "\u2014";
const mDDot = "\u223A";
const measuredangle = "\u2221";
const MediumSpace = "\u205F";
const Mellintrf = "\u2133";
const Mfr = "\u{1D510}";
const mfr = "\u{1D52A}";
const mho = "\u2127";
const micro = "\xB5";
const midast = "*";
const midcir = "\u2AF0";
const mid = "\u2223";
const middot = "\xB7";
const minusb = "\u229F";
const minus = "\u2212";
const minusd = "\u2238";
const minusdu = "\u2A2A";
const MinusPlus = "\u2213";
const mlcp = "\u2ADB";
const mldr = "\u2026";
const mnplus = "\u2213";
const models = "\u22A7";
const Mopf = "\u{1D544}";
const mopf = "\u{1D55E}";
const mp = "\u2213";
const mscr = "\u{1D4C2}";
const Mscr = "\u2133";
const mstpos = "\u223E";
const Mu = "\u039C";
const mu = "\u03BC";
const multimap = "\u22B8";
const mumap = "\u22B8";
const nabla = "\u2207";
const Nacute = "\u0143";
const nacute = "\u0144";
const nang = "\u2220\u20D2";
const nap$1 = "\u2249";
const napE = "\u2A70\u0338";
const napid = "\u224B\u0338";
const napos = "\u0149";
const napprox = "\u2249";
const natural = "\u266E";
const naturals = "\u2115";
const natur = "\u266E";
const nbsp = "\xA0";
const nbump = "\u224E\u0338";
const nbumpe = "\u224F\u0338";
const ncap = "\u2A43";
const Ncaron = "\u0147";
const ncaron = "\u0148";
const Ncedil = "\u0145";
const ncedil = "\u0146";
const ncong = "\u2247";
const ncongdot = "\u2A6D\u0338";
const ncup = "\u2A42";
const Ncy = "\u041D";
const ncy = "\u043D";
const ndash = "\u2013";
const nearhk = "\u2924";
const nearr = "\u2197";
const neArr = "\u21D7";
const nearrow = "\u2197";
const ne$1 = "\u2260";
const nedot = "\u2250\u0338";
const NegativeMediumSpace = "\u200B";
const NegativeThickSpace = "\u200B";
const NegativeThinSpace = "\u200B";
const NegativeVeryThinSpace = "\u200B";
const nequiv = "\u2262";
const nesear = "\u2928";
const nesim = "\u2242\u0338";
const NestedGreaterGreater = "\u226B";
const NestedLessLess = "\u226A";
const NewLine = "\n";
const nexist = "\u2204";
const nexists = "\u2204";
const Nfr = "\u{1D511}";
const nfr = "\u{1D52B}";
const ngE = "\u2267\u0338";
const nge = "\u2271";
const ngeq = "\u2271";
const ngeqq = "\u2267\u0338";
const ngeqslant = "\u2A7E\u0338";
const nges = "\u2A7E\u0338";
const nGg = "\u22D9\u0338";
const ngsim = "\u2275";
const nGt = "\u226B\u20D2";
const ngt = "\u226F";
const ngtr = "\u226F";
const nGtv = "\u226B\u0338";
const nharr = "\u21AE";
const nhArr = "\u21CE";
const nhpar = "\u2AF2";
const ni = "\u220B";
const nis = "\u22FC";
const nisd = "\u22FA";
const niv = "\u220B";
const NJcy = "\u040A";
const njcy = "\u045A";
const nlarr = "\u219A";
const nlArr = "\u21CD";
const nldr = "\u2025";
const nlE = "\u2266\u0338";
const nle = "\u2270";
const nleftarrow = "\u219A";
const nLeftarrow = "\u21CD";
const nleftrightarrow = "\u21AE";
const nLeftrightarrow = "\u21CE";
const nleq = "\u2270";
const nleqq = "\u2266\u0338";
const nleqslant = "\u2A7D\u0338";
const nles = "\u2A7D\u0338";
const nless = "\u226E";
const nLl = "\u22D8\u0338";
const nlsim = "\u2274";
const nLt = "\u226A\u20D2";
const nlt = "\u226E";
const nltri = "\u22EA";
const nltrie = "\u22EC";
const nLtv = "\u226A\u0338";
const nmid = "\u2224";
const NoBreak = "\u2060";
const NonBreakingSpace = "\xA0";
const nopf = "\u{1D55F}";
const Nopf = "\u2115";
const Not = "\u2AEC";
const not = "\xAC";
const NotCongruent = "\u2262";
const NotCupCap = "\u226D";
const NotDoubleVerticalBar = "\u2226";
const NotElement = "\u2209";
const NotEqual = "\u2260";
const NotEqualTilde = "\u2242\u0338";
const NotExists = "\u2204";
const NotGreater = "\u226F";
const NotGreaterEqual = "\u2271";
const NotGreaterFullEqual = "\u2267\u0338";
const NotGreaterGreater = "\u226B\u0338";
const NotGreaterLess = "\u2279";
const NotGreaterSlantEqual = "\u2A7E\u0338";
const NotGreaterTilde = "\u2275";
const NotHumpDownHump = "\u224E\u0338";
const NotHumpEqual = "\u224F\u0338";
const notin = "\u2209";
const notindot = "\u22F5\u0338";
const notinE = "\u22F9\u0338";
const notinva = "\u2209";
const notinvb = "\u22F7";
const notinvc = "\u22F6";
const NotLeftTriangleBar = "\u29CF\u0338";
const NotLeftTriangle = "\u22EA";
const NotLeftTriangleEqual = "\u22EC";
const NotLess = "\u226E";
const NotLessEqual = "\u2270";
const NotLessGreater = "\u2278";
const NotLessLess = "\u226A\u0338";
const NotLessSlantEqual = "\u2A7D\u0338";
const NotLessTilde = "\u2274";
const NotNestedGreaterGreater = "\u2AA2\u0338";
const NotNestedLessLess = "\u2AA1\u0338";
const notni = "\u220C";
const notniva = "\u220C";
const notnivb = "\u22FE";
const notnivc = "\u22FD";
const NotPrecedes = "\u2280";
const NotPrecedesEqual = "\u2AAF\u0338";
const NotPrecedesSlantEqual = "\u22E0";
const NotReverseElement = "\u220C";
const NotRightTriangleBar = "\u29D0\u0338";
const NotRightTriangle = "\u22EB";
const NotRightTriangleEqual = "\u22ED";
const NotSquareSubset = "\u228F\u0338";
const NotSquareSubsetEqual = "\u22E2";
const NotSquareSuperset = "\u2290\u0338";
const NotSquareSupersetEqual = "\u22E3";
const NotSubset = "\u2282\u20D2";
const NotSubsetEqual = "\u2288";
const NotSucceeds = "\u2281";
const NotSucceedsEqual = "\u2AB0\u0338";
const NotSucceedsSlantEqual = "\u22E1";
const NotSucceedsTilde = "\u227F\u0338";
const NotSuperset = "\u2283\u20D2";
const NotSupersetEqual = "\u2289";
const NotTilde = "\u2241";
const NotTildeEqual = "\u2244";
const NotTildeFullEqual = "\u2247";
const NotTildeTilde = "\u2249";
const NotVerticalBar = "\u2224";
const nparallel = "\u2226";
const npar = "\u2226";
const nparsl = "\u2AFD\u20E5";
const npart = "\u2202\u0338";
const npolint = "\u2A14";
const npr = "\u2280";
const nprcue = "\u22E0";
const nprec = "\u2280";
const npreceq = "\u2AAF\u0338";
const npre = "\u2AAF\u0338";
const nrarrc = "\u2933\u0338";
const nrarr = "\u219B";
const nrArr = "\u21CF";
const nrarrw = "\u219D\u0338";
const nrightarrow = "\u219B";
const nRightarrow = "\u21CF";
const nrtri = "\u22EB";
const nrtrie = "\u22ED";
const nsc = "\u2281";
const nsccue = "\u22E1";
const nsce = "\u2AB0\u0338";
const Nscr = "\u{1D4A9}";
const nscr = "\u{1D4C3}";
const nshortmid = "\u2224";
const nshortparallel = "\u2226";
const nsim = "\u2241";
const nsime = "\u2244";
const nsimeq = "\u2244";
const nsmid = "\u2224";
const nspar = "\u2226";
const nsqsube = "\u22E2";
const nsqsupe = "\u22E3";
const nsub = "\u2284";
const nsubE = "\u2AC5\u0338";
const nsube = "\u2288";
const nsubset = "\u2282\u20D2";
const nsubseteq = "\u2288";
const nsubseteqq = "\u2AC5\u0338";
const nsucc = "\u2281";
const nsucceq = "\u2AB0\u0338";
const nsup = "\u2285";
const nsupE = "\u2AC6\u0338";
const nsupe = "\u2289";
const nsupset = "\u2283\u20D2";
const nsupseteq = "\u2289";
const nsupseteqq = "\u2AC6\u0338";
const ntgl = "\u2279";
const Ntilde = "\xD1";
const ntilde = "\xF1";
const ntlg = "\u2278";
const ntriangleleft = "\u22EA";
const ntrianglelefteq = "\u22EC";
const ntriangleright = "\u22EB";
const ntrianglerighteq = "\u22ED";
const Nu = "\u039D";
const nu = "\u03BD";
const num = "#";
const numero = "\u2116";
const numsp = "\u2007";
const nvap = "\u224D\u20D2";
const nvdash = "\u22AC";
const nvDash = "\u22AD";
const nVdash = "\u22AE";
const nVDash = "\u22AF";
const nvge = "\u2265\u20D2";
const nvgt = ">\u20D2";
const nvHarr = "\u2904";
const nvinfin = "\u29DE";
const nvlArr = "\u2902";
const nvle = "\u2264\u20D2";
const nvlt = "<\u20D2";
const nvltrie = "\u22B4\u20D2";
const nvrArr = "\u2903";
const nvrtrie = "\u22B5\u20D2";
const nvsim = "\u223C\u20D2";
const nwarhk = "\u2923";
const nwarr = "\u2196";
const nwArr = "\u21D6";
const nwarrow = "\u2196";
const nwnear = "\u2927";
const Oacute = "\xD3";
const oacute = "\xF3";
const oast = "\u229B";
const Ocirc = "\xD4";
const ocirc = "\xF4";
const ocir = "\u229A";
const Ocy = "\u041E";
const ocy = "\u043E";
const odash = "\u229D";
const Odblac = "\u0150";
const odblac = "\u0151";
const odiv = "\u2A38";
const odot = "\u2299";
const odsold = "\u29BC";
const OElig = "\u0152";
const oelig = "\u0153";
const ofcir = "\u29BF";
const Ofr = "\u{1D512}";
const ofr = "\u{1D52C}";
const ogon = "\u02DB";
const Ograve = "\xD2";
const ograve = "\xF2";
const ogt = "\u29C1";
const ohbar = "\u29B5";
const ohm = "\u03A9";
const oint = "\u222E";
const olarr = "\u21BA";
const olcir = "\u29BE";
const olcross = "\u29BB";
const oline = "\u203E";
const olt = "\u29C0";
const Omacr = "\u014C";
const omacr = "\u014D";
const Omega = "\u03A9";
const omega = "\u03C9";
const Omicron = "\u039F";
const omicron = "\u03BF";
const omid = "\u29B6";
const ominus = "\u2296";
const Oopf = "\u{1D546}";
const oopf = "\u{1D560}";
const opar = "\u29B7";
const OpenCurlyDoubleQuote = "\u201C";
const OpenCurlyQuote = "\u2018";
const operp = "\u29B9";
const oplus = "\u2295";
const orarr = "\u21BB";
const Or = "\u2A54";
const or = "\u2228";
const ord = "\u2A5D";
const order = "\u2134";
const orderof = "\u2134";
const ordf = "\xAA";
const ordm = "\xBA";
const origof = "\u22B6";
const oror = "\u2A56";
const orslope = "\u2A57";
const orv = "\u2A5B";
const oS = "\u24C8";
const Oscr = "\u{1D4AA}";
const oscr = "\u2134";
const Oslash = "\xD8";
const oslash = "\xF8";
const osol = "\u2298";
const Otilde = "\xD5";
const otilde = "\xF5";
const otimesas = "\u2A36";
const Otimes = "\u2A37";
const otimes = "\u2297";
const Ouml = "\xD6";
const ouml = "\xF6";
const ovbar = "\u233D";
const OverBar = "\u203E";
const OverBrace = "\u23DE";
const OverBracket = "\u23B4";
const OverParenthesis = "\u23DC";
const para = "\xB6";
const parallel = "\u2225";
const par = "\u2225";
const parsim = "\u2AF3";
const parsl = "\u2AFD";
const part = "\u2202";
const PartialD = "\u2202";
const Pcy = "\u041F";
const pcy = "\u043F";
const percnt = "%";
const period = ".";
const permil = "\u2030";
const perp = "\u22A5";
const pertenk = "\u2031";
const Pfr = "\u{1D513}";
const pfr = "\u{1D52D}";
const Phi = "\u03A6";
const phi = "\u03C6";
const phiv = "\u03D5";
const phmmat = "\u2133";
const phone = "\u260E";
const Pi = "\u03A0";
const pi$2 = "\u03C0";
const pitchfork = "\u22D4";
const piv = "\u03D6";
const planck = "\u210F";
const planckh = "\u210E";
const plankv = "\u210F";
const plusacir = "\u2A23";
const plusb = "\u229E";
const pluscir = "\u2A22";
const plus = "+";
const plusdo = "\u2214";
const plusdu = "\u2A25";
const pluse = "\u2A72";
const PlusMinus = "\xB1";
const plusmn = "\xB1";
const plussim = "\u2A26";
const plustwo = "\u2A27";
const pm = "\xB1";
const Poincareplane = "\u210C";
const pointint = "\u2A15";
const popf = "\u{1D561}";
const Popf = "\u2119";
const pound = "\xA3";
const prap = "\u2AB7";
const Pr = "\u2ABB";
const pr = "\u227A";
const prcue = "\u227C";
const precapprox = "\u2AB7";
const prec = "\u227A";
const preccurlyeq = "\u227C";
const Precedes = "\u227A";
const PrecedesEqual = "\u2AAF";
const PrecedesSlantEqual = "\u227C";
const PrecedesTilde = "\u227E";
const preceq = "\u2AAF";
const precnapprox = "\u2AB9";
const precneqq = "\u2AB5";
const precnsim = "\u22E8";
const pre = "\u2AAF";
const prE = "\u2AB3";
const precsim = "\u227E";
const prime = "\u2032";
const Prime = "\u2033";
const primes = "\u2119";
const prnap = "\u2AB9";
const prnE = "\u2AB5";
const prnsim = "\u22E8";
const prod = "\u220F";
const Product = "\u220F";
const profalar = "\u232E";
const profline = "\u2312";
const profsurf = "\u2313";
const prop = "\u221D";
const Proportional = "\u221D";
const Proportion = "\u2237";
const propto = "\u221D";
const prsim = "\u227E";
const prurel = "\u22B0";
const Pscr = "\u{1D4AB}";
const pscr = "\u{1D4C5}";
const Psi = "\u03A8";
const psi = "\u03C8";
const puncsp = "\u2008";
const Qfr = "\u{1D514}";
const qfr = "\u{1D52E}";
const qint = "\u2A0C";
const qopf = "\u{1D562}";
const Qopf = "\u211A";
const qprime = "\u2057";
const Qscr = "\u{1D4AC}";
const qscr = "\u{1D4C6}";
const quaternions = "\u210D";
const quatint = "\u2A16";
const quest = "?";
const questeq = "\u225F";
const quot = '"';
const QUOT = '"';
const rAarr = "\u21DB";
const race = "\u223D\u0331";
const Racute = "\u0154";
const racute = "\u0155";
const radic = "\u221A";
const raemptyv = "\u29B3";
const rang = "\u27E9";
const Rang = "\u27EB";
const rangd = "\u2992";
const range = "\u29A5";
const rangle = "\u27E9";
const raquo = "\xBB";
const rarrap = "\u2975";
const rarrb = "\u21E5";
const rarrbfs = "\u2920";
const rarrc = "\u2933";
const rarr = "\u2192";
const Rarr = "\u21A0";
const rArr = "\u21D2";
const rarrfs = "\u291E";
const rarrhk = "\u21AA";
const rarrlp = "\u21AC";
const rarrpl = "\u2945";
const rarrsim = "\u2974";
const Rarrtl = "\u2916";
const rarrtl = "\u21A3";
const rarrw = "\u219D";
const ratail = "\u291A";
const rAtail = "\u291C";
const ratio = "\u2236";
const rationals = "\u211A";
const rbarr = "\u290D";
const rBarr = "\u290F";
const RBarr = "\u2910";
const rbbrk = "\u2773";
const rbrace = "}";
const rbrack = "]";
const rbrke = "\u298C";
const rbrksld = "\u298E";
const rbrkslu = "\u2990";
const Rcaron = "\u0158";
const rcaron = "\u0159";
const Rcedil = "\u0156";
const rcedil = "\u0157";
const rceil = "\u2309";
const rcub = "}";
const Rcy = "\u0420";
const rcy = "\u0440";
const rdca = "\u2937";
const rdldhar = "\u2969";
const rdquo = "\u201D";
const rdquor = "\u201D";
const rdsh = "\u21B3";
const real = "\u211C";
const realine = "\u211B";
const realpart = "\u211C";
const reals = "\u211D";
const Re = "\u211C";
const rect = "\u25AD";
const reg = "\xAE";
const REG = "\xAE";
const ReverseElement = "\u220B";
const ReverseEquilibrium = "\u21CB";
const ReverseUpEquilibrium = "\u296F";
const rfisht = "\u297D";
const rfloor = "\u230B";
const rfr = "\u{1D52F}";
const Rfr = "\u211C";
const rHar = "\u2964";
const rhard = "\u21C1";
const rharu = "\u21C0";
const rharul = "\u296C";
const Rho = "\u03A1";
const rho = "\u03C1";
const rhov = "\u03F1";
const RightAngleBracket = "\u27E9";
const RightArrowBar = "\u21E5";
const rightarrow = "\u2192";
const RightArrow = "\u2192";
const Rightarrow = "\u21D2";
const RightArrowLeftArrow = "\u21C4";
const rightarrowtail = "\u21A3";
const RightCeiling = "\u2309";
const RightDoubleBracket = "\u27E7";
const RightDownTeeVector = "\u295D";
const RightDownVectorBar = "\u2955";
const RightDownVector = "\u21C2";
const RightFloor = "\u230B";
const rightharpoondown = "\u21C1";
const rightharpoonup = "\u21C0";
const rightleftarrows = "\u21C4";
const rightleftharpoons = "\u21CC";
const rightrightarrows = "\u21C9";
const rightsquigarrow = "\u219D";
const RightTeeArrow = "\u21A6";
const RightTee = "\u22A2";
const RightTeeVector = "\u295B";
const rightthreetimes = "\u22CC";
const RightTriangleBar = "\u29D0";
const RightTriangle = "\u22B3";
const RightTriangleEqual = "\u22B5";
const RightUpDownVector = "\u294F";
const RightUpTeeVector = "\u295C";
const RightUpVectorBar = "\u2954";
const RightUpVector = "\u21BE";
const RightVectorBar = "\u2953";
const RightVector = "\u21C0";
const ring = "\u02DA";
const risingdotseq = "\u2253";
const rlarr = "\u21C4";
const rlhar = "\u21CC";
const rlm = "\u200F";
const rmoustache = "\u23B1";
const rmoust = "\u23B1";
const rnmid = "\u2AEE";
const roang = "\u27ED";
const roarr = "\u21FE";
const robrk = "\u27E7";
const ropar = "\u2986";
const ropf = "\u{1D563}";
const Ropf = "\u211D";
const roplus = "\u2A2E";
const rotimes = "\u2A35";
const RoundImplies = "\u2970";
const rpar = ")";
const rpargt = "\u2994";
const rppolint = "\u2A12";
const rrarr = "\u21C9";
const Rrightarrow = "\u21DB";
const rsaquo = "\u203A";
const rscr = "\u{1D4C7}";
const Rscr = "\u211B";
const rsh = "\u21B1";
const Rsh = "\u21B1";
const rsqb = "]";
const rsquo = "\u2019";
const rsquor = "\u2019";
const rthree = "\u22CC";
const rtimes = "\u22CA";
const rtri = "\u25B9";
const rtrie = "\u22B5";
const rtrif = "\u25B8";
const rtriltri = "\u29CE";
const RuleDelayed = "\u29F4";
const ruluhar = "\u2968";
const rx = "\u211E";
const Sacute = "\u015A";
const sacute = "\u015B";
const sbquo = "\u201A";
const scap = "\u2AB8";
const Scaron = "\u0160";
const scaron = "\u0161";
const Sc = "\u2ABC";
const sc = "\u227B";
const sccue = "\u227D";
const sce = "\u2AB0";
const scE = "\u2AB4";
const Scedil = "\u015E";
const scedil = "\u015F";
const Scirc = "\u015C";
const scirc = "\u015D";
const scnap = "\u2ABA";
const scnE = "\u2AB6";
const scnsim = "\u22E9";
const scpolint = "\u2A13";
const scsim = "\u227F";
const Scy = "\u0421";
const scy = "\u0441";
const sdotb = "\u22A1";
const sdot = "\u22C5";
const sdote = "\u2A66";
const searhk = "\u2925";
const searr = "\u2198";
const seArr = "\u21D8";
const searrow = "\u2198";
const sect = "\xA7";
const semi = ";";
const seswar = "\u2929";
const setminus = "\u2216";
const setmn = "\u2216";
const sext = "\u2736";
const Sfr = "\u{1D516}";
const sfr = "\u{1D530}";
const sfrown = "\u2322";
const sharp = "\u266F";
const SHCHcy = "\u0429";
const shchcy = "\u0449";
const SHcy = "\u0428";
const shcy = "\u0448";
const ShortDownArrow = "\u2193";
const ShortLeftArrow = "\u2190";
const shortmid = "\u2223";
const shortparallel = "\u2225";
const ShortRightArrow = "\u2192";
const ShortUpArrow = "\u2191";
const shy = "\xAD";
const Sigma = "\u03A3";
const sigma = "\u03C3";
const sigmaf = "\u03C2";
const sigmav = "\u03C2";
const sim = "\u223C";
const simdot = "\u2A6A";
const sime = "\u2243";
const simeq = "\u2243";
const simg = "\u2A9E";
const simgE = "\u2AA0";
const siml = "\u2A9D";
const simlE = "\u2A9F";
const simne = "\u2246";
const simplus = "\u2A24";
const simrarr = "\u2972";
const slarr = "\u2190";
const SmallCircle = "\u2218";
const smallsetminus = "\u2216";
const smashp = "\u2A33";
const smeparsl = "\u29E4";
const smid = "\u2223";
const smile = "\u2323";
const smt = "\u2AAA";
const smte = "\u2AAC";
const smtes = "\u2AAC\uFE00";
const SOFTcy = "\u042C";
const softcy = "\u044C";
const solbar = "\u233F";
const solb = "\u29C4";
const sol = "/";
const Sopf = "\u{1D54A}";
const sopf = "\u{1D564}";
const spades = "\u2660";
const spadesuit = "\u2660";
const spar = "\u2225";
const sqcap = "\u2293";
const sqcaps = "\u2293\uFE00";
const sqcup = "\u2294";
const sqcups = "\u2294\uFE00";
const Sqrt = "\u221A";
const sqsub = "\u228F";
const sqsube = "\u2291";
const sqsubset = "\u228F";
const sqsubseteq = "\u2291";
const sqsup = "\u2290";
const sqsupe = "\u2292";
const sqsupset = "\u2290";
const sqsupseteq = "\u2292";
const square = "\u25A1";
const Square = "\u25A1";
const SquareIntersection = "\u2293";
const SquareSubset = "\u228F";
const SquareSubsetEqual = "\u2291";
const SquareSuperset = "\u2290";
const SquareSupersetEqual = "\u2292";
const SquareUnion = "\u2294";
const squarf = "\u25AA";
const squ = "\u25A1";
const squf = "\u25AA";
const srarr = "\u2192";
const Sscr = "\u{1D4AE}";
const sscr = "\u{1D4C8}";
const ssetmn = "\u2216";
const ssmile = "\u2323";
const sstarf = "\u22C6";
const Star = "\u22C6";
const star = "\u2606";
const starf = "\u2605";
const straightepsilon = "\u03F5";
const straightphi = "\u03D5";
const strns = "\xAF";
const sub = "\u2282";
const Sub = "\u22D0";
const subdot = "\u2ABD";
const subE = "\u2AC5";
const sube = "\u2286";
const subedot = "\u2AC3";
const submult = "\u2AC1";
const subnE = "\u2ACB";
const subne = "\u228A";
const subplus = "\u2ABF";
const subrarr = "\u2979";
const subset = "\u2282";
const Subset = "\u22D0";
const subseteq = "\u2286";
const subseteqq = "\u2AC5";
const SubsetEqual = "\u2286";
const subsetneq = "\u228A";
const subsetneqq = "\u2ACB";
const subsim = "\u2AC7";
const subsub = "\u2AD5";
const subsup = "\u2AD3";
const succapprox = "\u2AB8";
const succ = "\u227B";
const succcurlyeq = "\u227D";
const Succeeds = "\u227B";
const SucceedsEqual = "\u2AB0";
const SucceedsSlantEqual = "\u227D";
const SucceedsTilde = "\u227F";
const succeq = "\u2AB0";
const succnapprox = "\u2ABA";
const succneqq = "\u2AB6";
const succnsim = "\u22E9";
const succsim = "\u227F";
const SuchThat = "\u220B";
const sum = "\u2211";
const Sum = "\u2211";
const sung = "\u266A";
const sup1 = "\xB9";
const sup2 = "\xB2";
const sup3 = "\xB3";
const sup = "\u2283";
const Sup = "\u22D1";
const supdot = "\u2ABE";
const supdsub = "\u2AD8";
const supE = "\u2AC6";
const supe = "\u2287";
const supedot = "\u2AC4";
const Superset = "\u2283";
const SupersetEqual = "\u2287";
const suphsol = "\u27C9";
const suphsub = "\u2AD7";
const suplarr = "\u297B";
const supmult = "\u2AC2";
const supnE = "\u2ACC";
const supne = "\u228B";
const supplus = "\u2AC0";
const supset = "\u2283";
const Supset = "\u22D1";
const supseteq = "\u2287";
const supseteqq = "\u2AC6";
const supsetneq = "\u228B";
const supsetneqq = "\u2ACC";
const supsim = "\u2AC8";
const supsub = "\u2AD4";
const supsup = "\u2AD6";
const swarhk = "\u2926";
const swarr = "\u2199";
const swArr = "\u21D9";
const swarrow = "\u2199";
const swnwar = "\u292A";
const szlig = "\xDF";
const Tab = "	";
const target = "\u2316";
const Tau = "\u03A4";
const tau$1 = "\u03C4";
const tbrk = "\u23B4";
const Tcaron = "\u0164";
const tcaron = "\u0165";
const Tcedil = "\u0162";
const tcedil = "\u0163";
const Tcy = "\u0422";
const tcy = "\u0442";
const tdot = "\u20DB";
const telrec = "\u2315";
const Tfr = "\u{1D517}";
const tfr = "\u{1D531}";
const there4 = "\u2234";
const therefore = "\u2234";
const Therefore = "\u2234";
const Theta = "\u0398";
const theta = "\u03B8";
const thetasym = "\u03D1";
const thetav = "\u03D1";
const thickapprox = "\u2248";
const thicksim = "\u223C";
const ThickSpace = "\u205F\u200A";
const ThinSpace = "\u2009";
const thinsp = "\u2009";
const thkap = "\u2248";
const thksim = "\u223C";
const THORN = "\xDE";
const thorn = "\xFE";
const tilde = "\u02DC";
const Tilde = "\u223C";
const TildeEqual = "\u2243";
const TildeFullEqual = "\u2245";
const TildeTilde = "\u2248";
const timesbar = "\u2A31";
const timesb = "\u22A0";
const times = "\xD7";
const timesd = "\u2A30";
const tint = "\u222D";
const toea = "\u2928";
const topbot = "\u2336";
const topcir = "\u2AF1";
const top = "\u22A4";
const Topf = "\u{1D54B}";
const topf = "\u{1D565}";
const topfork = "\u2ADA";
const tosa = "\u2929";
const tprime = "\u2034";
const trade = "\u2122";
const TRADE = "\u2122";
const triangle = "\u25B5";
const triangledown = "\u25BF";
const triangleleft = "\u25C3";
const trianglelefteq = "\u22B4";
const triangleq = "\u225C";
const triangleright = "\u25B9";
const trianglerighteq = "\u22B5";
const tridot = "\u25EC";
const trie$1 = "\u225C";
const triminus = "\u2A3A";
const TripleDot = "\u20DB";
const triplus = "\u2A39";
const trisb = "\u29CD";
const tritime = "\u2A3B";
const trpezium = "\u23E2";
const Tscr = "\u{1D4AF}";
const tscr = "\u{1D4C9}";
const TScy = "\u0426";
const tscy = "\u0446";
const TSHcy = "\u040B";
const tshcy = "\u045B";
const Tstrok = "\u0166";
const tstrok = "\u0167";
const twixt = "\u226C";
const twoheadleftarrow = "\u219E";
const twoheadrightarrow = "\u21A0";
const Uacute = "\xDA";
const uacute = "\xFA";
const uarr = "\u2191";
const Uarr = "\u219F";
const uArr = "\u21D1";
const Uarrocir = "\u2949";
const Ubrcy = "\u040E";
const ubrcy = "\u045E";
const Ubreve = "\u016C";
const ubreve = "\u016D";
const Ucirc = "\xDB";
const ucirc = "\xFB";
const Ucy = "\u0423";
const ucy = "\u0443";
const udarr = "\u21C5";
const Udblac = "\u0170";
const udblac = "\u0171";
const udhar = "\u296E";
const ufisht = "\u297E";
const Ufr = "\u{1D518}";
const ufr = "\u{1D532}";
const Ugrave = "\xD9";
const ugrave = "\xF9";
const uHar = "\u2963";
const uharl = "\u21BF";
const uharr = "\u21BE";
const uhblk = "\u2580";
const ulcorn = "\u231C";
const ulcorner = "\u231C";
const ulcrop = "\u230F";
const ultri = "\u25F8";
const Umacr = "\u016A";
const umacr = "\u016B";
const uml = "\xA8";
const UnderBar = "_";
const UnderBrace = "\u23DF";
const UnderBracket = "\u23B5";
const UnderParenthesis = "\u23DD";
const Union = "\u22C3";
const UnionPlus = "\u228E";
const Uogon = "\u0172";
const uogon = "\u0173";
const Uopf = "\u{1D54C}";
const uopf = "\u{1D566}";
const UpArrowBar = "\u2912";
const uparrow = "\u2191";
const UpArrow = "\u2191";
const Uparrow = "\u21D1";
const UpArrowDownArrow = "\u21C5";
const updownarrow = "\u2195";
const UpDownArrow = "\u2195";
const Updownarrow = "\u21D5";
const UpEquilibrium = "\u296E";
const upharpoonleft = "\u21BF";
const upharpoonright = "\u21BE";
const uplus = "\u228E";
const UpperLeftArrow = "\u2196";
const UpperRightArrow = "\u2197";
const upsi = "\u03C5";
const Upsi = "\u03D2";
const upsih = "\u03D2";
const Upsilon = "\u03A5";
const upsilon = "\u03C5";
const UpTeeArrow = "\u21A5";
const UpTee = "\u22A5";
const upuparrows = "\u21C8";
const urcorn = "\u231D";
const urcorner = "\u231D";
const urcrop = "\u230E";
const Uring = "\u016E";
const uring = "\u016F";
const urtri = "\u25F9";
const Uscr = "\u{1D4B0}";
const uscr = "\u{1D4CA}";
const utdot = "\u22F0";
const Utilde = "\u0168";
const utilde = "\u0169";
const utri = "\u25B5";
const utrif = "\u25B4";
const uuarr = "\u21C8";
const Uuml = "\xDC";
const uuml = "\xFC";
const uwangle = "\u29A7";
const vangrt = "\u299C";
const varepsilon = "\u03F5";
const varkappa = "\u03F0";
const varnothing = "\u2205";
const varphi = "\u03D5";
const varpi = "\u03D6";
const varpropto = "\u221D";
const varr = "\u2195";
const vArr = "\u21D5";
const varrho = "\u03F1";
const varsigma = "\u03C2";
const varsubsetneq = "\u228A\uFE00";
const varsubsetneqq = "\u2ACB\uFE00";
const varsupsetneq = "\u228B\uFE00";
const varsupsetneqq = "\u2ACC\uFE00";
const vartheta = "\u03D1";
const vartriangleleft = "\u22B2";
const vartriangleright = "\u22B3";
const vBar = "\u2AE8";
const Vbar = "\u2AEB";
const vBarv = "\u2AE9";
const Vcy = "\u0412";
const vcy = "\u0432";
const vdash = "\u22A2";
const vDash = "\u22A8";
const Vdash = "\u22A9";
const VDash = "\u22AB";
const Vdashl = "\u2AE6";
const veebar = "\u22BB";
const vee = "\u2228";
const Vee = "\u22C1";
const veeeq = "\u225A";
const vellip = "\u22EE";
const verbar = "|";
const Verbar = "\u2016";
const vert = "|";
const Vert = "\u2016";
const VerticalBar = "\u2223";
const VerticalLine = "|";
const VerticalSeparator = "\u2758";
const VerticalTilde = "\u2240";
const VeryThinSpace = "\u200A";
const Vfr = "\u{1D519}";
const vfr = "\u{1D533}";
const vltri = "\u22B2";
const vnsub = "\u2282\u20D2";
const vnsup = "\u2283\u20D2";
const Vopf = "\u{1D54D}";
const vopf = "\u{1D567}";
const vprop = "\u221D";
const vrtri = "\u22B3";
const Vscr = "\u{1D4B1}";
const vscr = "\u{1D4CB}";
const vsubnE = "\u2ACB\uFE00";
const vsubne = "\u228A\uFE00";
const vsupnE = "\u2ACC\uFE00";
const vsupne = "\u228B\uFE00";
const Vvdash = "\u22AA";
const vzigzag = "\u299A";
const Wcirc = "\u0174";
const wcirc = "\u0175";
const wedbar = "\u2A5F";
const wedge = "\u2227";
const Wedge = "\u22C0";
const wedgeq = "\u2259";
const weierp = "\u2118";
const Wfr = "\u{1D51A}";
const wfr = "\u{1D534}";
const Wopf = "\u{1D54E}";
const wopf = "\u{1D568}";
const wp = "\u2118";
const wr = "\u2240";
const wreath = "\u2240";
const Wscr = "\u{1D4B2}";
const wscr = "\u{1D4CC}";
const xcap = "\u22C2";
const xcirc = "\u25EF";
const xcup = "\u22C3";
const xdtri = "\u25BD";
const Xfr = "\u{1D51B}";
const xfr = "\u{1D535}";
const xharr = "\u27F7";
const xhArr = "\u27FA";
const Xi = "\u039E";
const xi = "\u03BE";
const xlarr = "\u27F5";
const xlArr = "\u27F8";
const xmap = "\u27FC";
const xnis = "\u22FB";
const xodot = "\u2A00";
const Xopf = "\u{1D54F}";
const xopf = "\u{1D569}";
const xoplus = "\u2A01";
const xotime = "\u2A02";
const xrarr = "\u27F6";
const xrArr = "\u27F9";
const Xscr = "\u{1D4B3}";
const xscr = "\u{1D4CD}";
const xsqcup = "\u2A06";
const xuplus = "\u2A04";
const xutri = "\u25B3";
const xvee = "\u22C1";
const xwedge = "\u22C0";
const Yacute = "\xDD";
const yacute = "\xFD";
const YAcy = "\u042F";
const yacy = "\u044F";
const Ycirc = "\u0176";
const ycirc = "\u0177";
const Ycy = "\u042B";
const ycy = "\u044B";
const yen = "\xA5";
const Yfr = "\u{1D51C}";
const yfr = "\u{1D536}";
const YIcy = "\u0407";
const yicy = "\u0457";
const Yopf = "\u{1D550}";
const yopf = "\u{1D56A}";
const Yscr = "\u{1D4B4}";
const yscr = "\u{1D4CE}";
const YUcy = "\u042E";
const yucy = "\u044E";
const yuml = "\xFF";
const Yuml = "\u0178";
const Zacute = "\u0179";
const zacute = "\u017A";
const Zcaron = "\u017D";
const zcaron = "\u017E";
const Zcy = "\u0417";
const zcy = "\u0437";
const Zdot = "\u017B";
const zdot = "\u017C";
const zeetrf = "\u2128";
const ZeroWidthSpace = "\u200B";
const Zeta = "\u0396";
const zeta = "\u03B6";
const zfr = "\u{1D537}";
const Zfr = "\u2128";
const ZHcy = "\u0416";
const zhcy = "\u0436";
const zigrarr = "\u21DD";
const zopf = "\u{1D56B}";
const Zopf = "\u2124";
const Zscr = "\u{1D4B5}";
const zscr = "\u{1D4CF}";
const zwj = "\u200D";
const zwnj = "\u200C";
var require$$0$2 = {
  Aacute,
  aacute,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc,
  acirc,
  acute,
  Acy,
  acy,
  AElig,
  aelig,
  af,
  Afr,
  afr,
  Agrave,
  agrave,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp,
  AMP,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos,
  ApplyFunction,
  approx,
  approxeq,
  Aring,
  aring,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde,
  atilde,
  Auml,
  auml,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$1,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil,
  ccedil,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil,
  Cedilla,
  cemptyv,
  cent,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy,
  COPY,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute,
  eacute,
  easter,
  Ecaron,
  ecaron,
  Ecirc,
  ecirc,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave,
  egrave,
  egs,
  egsdot,
  el,
  Element: Element$1,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty: empty$1,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon: epsilon$1,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH,
  eth,
  Euml,
  euml,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12,
  frac13,
  frac14,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma: gamma$1,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge: ge$1,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt,
  GT,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute,
  iacute,
  ic,
  Icirc,
  icirc,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl,
  iff,
  ifr,
  Ifr,
  Igrave,
  igrave,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image: image$1,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "\u2208",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it: it$1,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml,
  iuml,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang: lang$1,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le: le$1,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt,
  LT,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr,
  male,
  malt,
  maltese,
  "Map": "\u2905",
  map: map$2,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro,
  midast,
  midcir,
  mid,
  middot,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap: nap$1,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne: ne$1,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde,
  ntilde,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute,
  oacute,
  oast,
  Ocirc,
  ocirc,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve,
  ograve,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf,
  ordm,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash,
  oslash,
  osol,
  Otilde,
  otilde,
  otimesas,
  Otimes,
  otimes,
  Ouml,
  ouml,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi: pi$2,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot,
  QUOT,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg,
  REG,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1,
  sup2,
  sup3,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig,
  Tab,
  target,
  Tau,
  tau: tau$1,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN,
  thorn,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie: trie$1,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute,
  uacute,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc,
  ucirc,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave,
  ugrave,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml,
  uuml,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute,
  yacute,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
var entities$1 = require$$0$2;
var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var mdurl$1 = {};
var encodeCache = {};
function getEncodeCache(exclude) {
  var i2, ch, cache2 = encodeCache[exclude];
  if (cache2) {
    return cache2;
  }
  cache2 = encodeCache[exclude] = [];
  for (i2 = 0; i2 < 128; i2++) {
    ch = String.fromCharCode(i2);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache2.push(ch);
    } else {
      cache2.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i2 = 0; i2 < exclude.length; i2++) {
    cache2[exclude.charCodeAt(i2)] = exclude[i2];
  }
  return cache2;
}
function encode$1(string2, exclude, keepEscaped) {
  var i2, l2, code3, nextCode, cache2, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache2 = getEncodeCache(exclude);
  for (i2 = 0, l2 = string2.length; i2 < l2; i2++) {
    code3 = string2.charCodeAt(i2);
    if (keepEscaped && code3 === 37 && i2 + 2 < l2) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i2 + 1, i2 + 3))) {
        result += string2.slice(i2, i2 + 3);
        i2 += 2;
        continue;
      }
    }
    if (code3 < 128) {
      result += cache2[code3];
      continue;
    }
    if (code3 >= 55296 && code3 <= 57343) {
      if (code3 >= 55296 && code3 <= 56319 && i2 + 1 < l2) {
        nextCode = string2.charCodeAt(i2 + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string2[i2] + string2[i2 + 1]);
          i2++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string2[i2]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var decodeCache = {};
function getDecodeCache(exclude) {
  var i2, ch, cache2 = decodeCache[exclude];
  if (cache2) {
    return cache2;
  }
  cache2 = decodeCache[exclude] = [];
  for (i2 = 0; i2 < 128; i2++) {
    ch = String.fromCharCode(i2);
    cache2.push(ch);
  }
  for (i2 = 0; i2 < exclude.length; i2++) {
    ch = exclude.charCodeAt(i2);
    cache2[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache2;
}
function decode$1(string2, exclude) {
  var cache2;
  if (typeof exclude !== "string") {
    exclude = decode$1.defaultChars;
  }
  cache2 = getDecodeCache(exclude);
  return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
    var i2, l2, b1, b2, b3, b4, chr, result = "";
    for (i2 = 0, l2 = seq2.length; i2 < l2; i2 += 3) {
      b1 = parseInt(seq2.slice(i2 + 1, i2 + 3), 16);
      if (b1 < 128) {
        result += cache2[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i2 + 3 < l2) {
        b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
        if ((b2 & 192) === 128) {
          chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i2 += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i2 + 6 < l2) {
        b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
        b3 = parseInt(seq2.slice(i2 + 7, i2 + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i2 += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i2 + 9 < l2) {
        b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
        b3 = parseInt(seq2.slice(i2 + 7, i2 + 9), 16);
        b4 = parseInt(seq2.slice(i2 + 10, i2 + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i2 += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
decode$1.defaultChars = ";/?:@&=+$,#";
decode$1.componentChars = "";
var decode_1 = decode$1;
var format$1 = function format2(url) {
  var result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
};
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }
  var u2 = new Url();
  u2.parse(url, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  var i2, l2, lowerProto, hec, slashes, rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  var proto2 = protocolPattern.exec(rest);
  if (proto2) {
    proto2 = proto2[0];
    lowerProto = proto2.toLowerCase();
    this.protocol = proto2;
    rest = rest.substr(proto2.length);
  }
  if (slashesDenoteHost || proto2 || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto2 && hostlessProtocol[proto2])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto2] && (slashes || proto2 && !slashedProtocol[proto2])) {
    var hostEnd = -1;
    for (i2 = 0; i2 < hostEndingChars.length; i2++) {
      hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (i2 = 0; i2 < nonHostChars.length; i2++) {
      hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part2 = hostparts[i2];
        if (!part2) {
          continue;
        }
        if (!part2.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part2.length; j2 < k2; j2++) {
            if (part2.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part2[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part2.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse = urlParse;
mdurl$1.encode = encode_1;
mdurl$1.decode = decode_1;
mdurl$1.format = format$1;
mdurl$1.parse = parse;
var uc_micro = {};
var regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var regex$2 = /[\0-\x1F\x7F-\x9F]/;
var regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
uc_micro.Any = regex$3;
uc_micro.Cc = regex$2;
uc_micro.Cf = regex$1;
uc_micro.P = regex$4;
uc_micro.Z = regex;
(function(exports2) {
  function _class2(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString2(obj) {
    return _class2(obj) === "[object String]";
  }
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function has2(object, key) {
    return _hasOwnProperty.call(object, key);
  }
  function assign2(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function arrayReplaceAt2(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  function isValidEntityCode2(c2) {
    if (c2 >= 55296 && c2 <= 57343) {
      return false;
    }
    if (c2 >= 64976 && c2 <= 65007) {
      return false;
    }
    if ((c2 & 65535) === 65535 || (c2 & 65535) === 65534) {
      return false;
    }
    if (c2 >= 0 && c2 <= 8) {
      return false;
    }
    if (c2 === 11) {
      return false;
    }
    if (c2 >= 14 && c2 <= 31) {
      return false;
    }
    if (c2 >= 127 && c2 <= 159) {
      return false;
    }
    if (c2 > 1114111) {
      return false;
    }
    return true;
  }
  function fromCodePoint2(c2) {
    if (c2 > 65535) {
      c2 -= 65536;
      var surrogate1 = 55296 + (c2 >> 10), surrogate2 = 56320 + (c2 & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c2);
  }
  var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
  var entities2 = entities$1;
  function replaceEntityPattern(match5, name) {
    var code3 = 0;
    if (has2(entities2, name)) {
      return entities2[name];
    }
    if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
      code3 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
      if (isValidEntityCode2(code3)) {
        return fromCodePoint2(code3);
      }
    }
    return match5;
  }
  function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
  }
  function unescapeAll2(str) {
    if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_ALL_RE, function(match5, escaped, entity3) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match5, entity3);
    });
  }
  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
  }
  function escapeHtml2(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }
  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE2(str) {
    return str.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  function isSpace2(code3) {
    switch (code3) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function isWhiteSpace2(code3) {
    if (code3 >= 8192 && code3 <= 8202) {
      return true;
    }
    switch (code3) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  var UNICODE_PUNCT_RE = regex$4;
  function isPunctChar2(ch) {
    return UNICODE_PUNCT_RE.test(ch);
  }
  function isMdAsciiPunct2(ch) {
    switch (ch) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function normalizeReference2(str) {
    str = str.trim().replace(/\s+/g, " ");
    if ("\u1E9E".toLowerCase() === "\u1E7E") {
      str = str.replace(//g, "\xDF");
    }
    return str.toLowerCase().toUpperCase();
  }
  exports2.lib = {};
  exports2.lib.mdurl = mdurl$1;
  exports2.lib.ucmicro = uc_micro;
  exports2.assign = assign2;
  exports2.isString = isString2;
  exports2.has = has2;
  exports2.unescapeMd = unescapeMd;
  exports2.unescapeAll = unescapeAll2;
  exports2.isValidEntityCode = isValidEntityCode2;
  exports2.fromCodePoint = fromCodePoint2;
  exports2.escapeHtml = escapeHtml2;
  exports2.arrayReplaceAt = arrayReplaceAt2;
  exports2.isSpace = isSpace2;
  exports2.isWhiteSpace = isWhiteSpace2;
  exports2.isMdAsciiPunct = isMdAsciiPunct2;
  exports2.isPunctChar = isPunctChar2;
  exports2.escapeRE = escapeRE2;
  exports2.normalizeReference = normalizeReference2;
})(utils$2);
var helpers$1 = {};
var parse_link_label = function parseLinkLabel(state, start2, disableNested) {
  var level, found, marker2, prevPos, labelEnd = -1, max2 = state.posMax, oldPos = state.pos;
  state.pos = start2 + 1;
  level = 1;
  while (state.pos < max2) {
    marker2 = state.src.charCodeAt(state.pos);
    if (marker2 === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker2 === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
};
var unescapeAll$2 = utils$2.unescapeAll;
var parse_link_destination = function parseLinkDestination(str, pos, max2) {
  var code3, level, lines = 0, start2 = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max2) {
      code3 = str.charCodeAt(pos);
      if (code3 === 10) {
        return result;
      }
      if (code3 === 60) {
        return result;
      }
      if (code3 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll$2(str.slice(start2 + 1, pos));
        result.ok = true;
        return result;
      }
      if (code3 === 92 && pos + 1 < max2) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  level = 0;
  while (pos < max2) {
    code3 = str.charCodeAt(pos);
    if (code3 === 32) {
      break;
    }
    if (code3 < 32 || code3 === 127) {
      break;
    }
    if (code3 === 92 && pos + 1 < max2) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code3 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code3 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start2 === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll$2(str.slice(start2, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};
var unescapeAll$1 = utils$2.unescapeAll;
var parse_link_title = function parseLinkTitle(str, pos, max2) {
  var code3, marker2, lines = 0, start2 = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (pos >= max2) {
    return result;
  }
  marker2 = str.charCodeAt(pos);
  if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
    return result;
  }
  pos++;
  if (marker2 === 40) {
    marker2 = 41;
  }
  while (pos < max2) {
    code3 = str.charCodeAt(pos);
    if (code3 === marker2) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll$1(str.slice(start2 + 1, pos));
      result.ok = true;
      return result;
    } else if (code3 === 40 && marker2 === 41) {
      return result;
    } else if (code3 === 10) {
      lines++;
    } else if (code3 === 92 && pos + 1 < max2) {
      pos++;
      if (str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
    pos++;
  }
  return result;
};
helpers$1.parseLinkLabel = parse_link_label;
helpers$1.parseLinkDestination = parse_link_destination;
helpers$1.parseLinkTitle = parse_link_title;
var assign$1 = utils$2.assign;
var unescapeAll = utils$2.unescapeAll;
var escapeHtml = utils$2.escapeHtml;
var default_rules = {};
default_rules.code_inline = function(tokens2, idx, options, env, slf) {
  var token2 = tokens2[idx];
  return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(tokens2[idx].content) + "</code>";
};
default_rules.code_block = function(tokens2, idx, options, env, slf) {
  var token2 = tokens2[idx];
  return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens2[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens2, idx, options, env, slf) {
  var token2 = tokens2[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i2, arr, tmpAttrs, tmpToken;
  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  if (options.highlight) {
    highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
  } else {
    highlighted = escapeHtml(token2.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    i2 = token2.attrIndex("class");
    tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
    if (i2 < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i2] = tmpAttrs[i2].slice();
      tmpAttrs[i2][1] += " " + options.langPrefix + langName;
    }
    tmpToken = {
      attrs: tmpAttrs
    };
    return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
  }
  return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
};
default_rules.image = function(tokens2, idx, options, env, slf) {
  var token2 = tokens2[idx];
  token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
  return slf.renderToken(tokens2, idx, options);
};
default_rules.hardbreak = function(tokens2, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens2, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens2, idx) {
  return escapeHtml(tokens2[idx].content);
};
default_rules.html_block = function(tokens2, idx) {
  return tokens2[idx].content;
};
default_rules.html_inline = function(tokens2, idx) {
  return tokens2[idx].content;
};
function Renderer$1() {
  this.rules = assign$1({}, default_rules);
}
Renderer$1.prototype.renderAttrs = function renderAttrs(token2) {
  var i2, l2, result;
  if (!token2.attrs) {
    return "";
  }
  result = "";
  for (i2 = 0, l2 = token2.attrs.length; i2 < l2; i2++) {
    result += " " + escapeHtml(token2.attrs[i2][0]) + '="' + escapeHtml(token2.attrs[i2][1]) + '"';
  }
  return result;
};
Renderer$1.prototype.renderToken = function renderToken(tokens2, idx, options) {
  var nextToken, result = "", needLf = false, token2 = tokens2[idx];
  if (token2.hidden) {
    return "";
  }
  if (token2.block && token2.nesting !== -1 && idx && tokens2[idx - 1].hidden) {
    result += "\n";
  }
  result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
  result += this.renderAttrs(token2);
  if (token2.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  if (token2.block) {
    needLf = true;
    if (token2.nesting === 1) {
      if (idx + 1 < tokens2.length) {
        nextToken = tokens2[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer$1.prototype.renderInline = function(tokens2, options, env) {
  var type, result = "", rules = this.rules;
  for (var i2 = 0, len2 = tokens2.length; i2 < len2; i2++) {
    type = tokens2[i2].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens2, i2, options, env, this);
    } else {
      result += this.renderToken(tokens2, i2, options);
    }
  }
  return result;
};
Renderer$1.prototype.renderInlineAsText = function(tokens2, options, env) {
  var result = "";
  for (var i2 = 0, len2 = tokens2.length; i2 < len2; i2++) {
    if (tokens2[i2].type === "text") {
      result += tokens2[i2].content;
    } else if (tokens2[i2].type === "image") {
      result += this.renderInlineAsText(tokens2[i2].children, options, env);
    } else if (tokens2[i2].type === "softbreak") {
      result += "\n";
    }
  }
  return result;
};
Renderer$1.prototype.render = function(tokens2, options, env) {
  var i2, len2, type, result = "", rules = this.rules;
  for (i2 = 0, len2 = tokens2.length; i2 < len2; i2++) {
    type = tokens2[i2].type;
    if (type === "inline") {
      result += this.renderInline(tokens2[i2].children, options, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[tokens2[i2].type](tokens2, i2, options, env, this);
    } else {
      result += this.renderToken(tokens2, i2, options, env);
    }
  }
  return result;
};
var renderer = Renderer$1;
function Ruler$3() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler$3.prototype.__find__ = function(name) {
  for (var i2 = 0; i2 < this.__rules__.length; i2++) {
    if (this.__rules__[i2].name === name) {
      return i2;
    }
  }
  return -1;
};
Ruler$3.prototype.__compile__ = function() {
  var self2 = this;
  var chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler$3.prototype.at = function(name, fn, options) {
  var index2 = this.__find__(name);
  var opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + name);
  }
  this.__rules__[index2].fn = fn;
  this.__rules__[index2].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler$3.prototype.before = function(beforeName, ruleName, fn, options) {
  var index2 = this.__find__(beforeName);
  var opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index2, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.after = function(afterName, ruleName, fn, options) {
  var index2 = this.__find__(afterName);
  var opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index2 + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.push = function(ruleName, fn, options) {
  var opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.enable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.enableOnly = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list3, ignoreInvalid);
};
Ruler$3.prototype.disable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler = Ruler$3;
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
var normalize = function normalize2(state) {
  var str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state.src = str;
};
var block = function block2(state) {
  var token2;
  if (state.inlineMode) {
    token2 = new state.Token("inline", "", 0);
    token2.content = state.src;
    token2.map = [0, 1];
    token2.children = [];
    state.tokens.push(token2);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};
var inline = function inline2(state) {
  var tokens2 = state.tokens, tok, i2, l2;
  for (i2 = 0, l2 = tokens2.length; i2 < l2; i2++) {
    tok = tokens2[i2];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};
var arrayReplaceAt = utils$2.arrayReplaceAt;
function isLinkOpen$1(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose$1(str) {
  return /^<\/a\s*>/i.test(str);
}
var linkify$1 = function linkify2(state) {
  var i2, j2, l2, tokens2, token2, currentToken, nodes, ln, text3, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
  if (!state.md.options.linkify) {
    return;
  }
  for (j2 = 0, l2 = blockTokens.length; j2 < l2; j2++) {
    if (blockTokens[j2].type !== "inline" || !state.md.linkify.pretest(blockTokens[j2].content)) {
      continue;
    }
    tokens2 = blockTokens[j2].children;
    htmlLinkLevel = 0;
    for (i2 = tokens2.length - 1; i2 >= 0; i2--) {
      currentToken = tokens2[i2];
      if (currentToken.type === "link_close") {
        i2--;
        while (tokens2[i2].level !== currentToken.level && tokens2[i2].type !== "link_open") {
          i2--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose$1(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        text3 = currentToken.content;
        links = state.md.linkify.match(text3);
        nodes = [];
        level = currentToken.level;
        lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens2[i2 - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (ln = 0; ln < links.length; ln++) {
          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          pos = links[ln].index;
          if (pos > lastPos) {
            token2 = new state.Token("text", "", 0);
            token2.content = text3.slice(lastPos, pos);
            token2.level = level;
            nodes.push(token2);
          }
          token2 = new state.Token("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.level = level++;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          token2 = new state.Token("text", "", 0);
          token2.content = urlText;
          token2.level = level;
          nodes.push(token2);
          token2 = new state.Token("link_close", "a", -1);
          token2.level = --level;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text3.length) {
          token2 = new state.Token("text", "", 0);
          token2.content = text3.slice(lastPos);
          token2.level = level;
          nodes.push(token2);
        }
        blockTokens[j2].children = tokens2 = arrayReplaceAt(tokens2, i2, nodes);
      }
    }
  }
};
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  tm: "\u2122"
};
function replaceFn(match5, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  var i2, token2, inside_autolink = 0;
  for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
    token2 = inlineTokens[i2];
    if (token2.type === "text" && !inside_autolink) {
      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  var i2, token2, inside_autolink = 0;
  for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
    token2 = inlineTokens[i2];
    if (token2.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token2.content)) {
        token2.content = token2.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
var replacements = function replace(state) {
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};
var isWhiteSpace$1 = utils$2.isWhiteSpace;
var isPunctChar$1 = utils$2.isPunctChar;
var isMdAsciiPunct$1 = utils$2.isMdAsciiPunct;
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index2, ch) {
  return str.slice(0, index2) + ch + str.slice(index2 + 1);
}
function process_inlines(tokens2, state) {
  var i2, token2, text3, t2, pos, max2, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j2, isSingle, stack2, openQuote, closeQuote;
  stack2 = [];
  for (i2 = 0; i2 < tokens2.length; i2++) {
    token2 = tokens2[i2];
    thisLevel = tokens2[i2].level;
    for (j2 = stack2.length - 1; j2 >= 0; j2--) {
      if (stack2[j2].level <= thisLevel) {
        break;
      }
    }
    stack2.length = j2 + 1;
    if (token2.type !== "text") {
      continue;
    }
    text3 = token2.content;
    pos = 0;
    max2 = text3.length;
    OUTER:
      while (pos < max2) {
        QUOTE_RE.lastIndex = pos;
        t2 = QUOTE_RE.exec(text3);
        if (!t2) {
          break;
        }
        canOpen = canClose = true;
        pos = t2.index + 1;
        isSingle = t2[0] === "'";
        lastChar = 32;
        if (t2.index - 1 >= 0) {
          lastChar = text3.charCodeAt(t2.index - 1);
        } else {
          for (j2 = i2 - 1; j2 >= 0; j2--) {
            if (tokens2[j2].type === "softbreak" || tokens2[j2].type === "hardbreak")
              break;
            if (!tokens2[j2].content)
              continue;
            lastChar = tokens2[j2].content.charCodeAt(tokens2[j2].content.length - 1);
            break;
          }
        }
        nextChar = 32;
        if (pos < max2) {
          nextChar = text3.charCodeAt(pos);
        } else {
          for (j2 = i2 + 1; j2 < tokens2.length; j2++) {
            if (tokens2[j2].type === "softbreak" || tokens2[j2].type === "hardbreak")
              break;
            if (!tokens2[j2].content)
              continue;
            nextChar = tokens2[j2].content.charCodeAt(0);
            break;
          }
        }
        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
        isLastWhiteSpace = isWhiteSpace$1(lastChar);
        isNextWhiteSpace = isWhiteSpace$1(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t2[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j2 = stack2.length - 1; j2 >= 0; j2--) {
            item = stack2[j2];
            if (stack2[j2].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack2[j2].level === thisLevel) {
              item = stack2[j2];
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token2.content = replaceAt(token2.content, t2.index, closeQuote);
              tokens2[item.token].content = replaceAt(tokens2[item.token].content, item.pos, openQuote);
              pos += closeQuote.length - 1;
              if (item.token === i2) {
                pos += openQuote.length - 1;
              }
              text3 = token2.content;
              max2 = text3.length;
              stack2.length = j2;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack2.push({
            token: i2,
            pos: t2.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
        }
      }
  }
}
var smartquotes = function smartquotes2(state) {
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
};
var text_join = function text_join2(state) {
  var j2, l2, tokens2, curr, max2, last, blockTokens = state.tokens;
  for (j2 = 0, l2 = blockTokens.length; j2 < l2; j2++) {
    if (blockTokens[j2].type !== "inline")
      continue;
    tokens2 = blockTokens[j2].children;
    max2 = tokens2.length;
    for (curr = 0; curr < max2; curr++) {
      if (tokens2[curr].type === "text_special") {
        tokens2[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max2; curr++) {
      if (tokens2[curr].type === "text" && curr + 1 < max2 && tokens2[curr + 1].type === "text") {
        tokens2[curr + 1].content = tokens2[curr].content + tokens2[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens2[last] = tokens2[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens2.length = last;
    }
  }
};
function Token$3(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token$3.prototype.attrIndex = function attrIndex(name) {
  var attrs, i2, len2;
  if (!this.attrs) {
    return -1;
  }
  attrs = this.attrs;
  for (i2 = 0, len2 = attrs.length; i2 < len2; i2++) {
    if (attrs[i2][0] === name) {
      return i2;
    }
  }
  return -1;
};
Token$3.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token$3.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name), attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token$3.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token$3.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token$1 = Token$3;
var Token$2 = token$1;
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = Token$2;
var state_core = StateCore;
var Ruler$2 = ruler;
var _rules$2 = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify$1],
  ["replacements", replacements],
  ["smartquotes", smartquotes],
  ["text_join", text_join]
];
function Core() {
  this.ruler = new Ruler$2();
  for (var i2 = 0; i2 < _rules$2.length; i2++) {
    this.ruler.push(_rules$2[i2][0], _rules$2[i2][1]);
  }
}
Core.prototype.process = function(state) {
  var i2, l2, rules;
  rules = this.ruler.getRules("");
  for (i2 = 0, l2 = rules.length; i2 < l2; i2++) {
    rules[i2](state);
  }
};
Core.prototype.State = state_core;
var parser_core = Core;
var isSpace$a = utils$2.isSpace;
function getLine(state, line2) {
  var pos = state.bMarks[line2] + state.tShift[line2], max2 = state.eMarks[line2];
  return state.src.slice(pos, max2);
}
function escapedSplit(str) {
  var result = [], pos = 0, max2 = str.length, ch, isEscaped = false, lastPos = 0, current = "";
  ch = str.charCodeAt(pos);
  while (pos < max2) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
var table = function table2(state, startLine, endLine, silent) {
  var ch, lineText, pos, i2, l2, nextLine, columns, columnCount, token2, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
  if (startLine + 2 > endLine) {
    return false;
  }
  nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace$a(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$a(ch)) {
      return false;
    }
    pos++;
  }
  lineText = getLine(state, startLine + 1);
  columns = lineText.split("|");
  aligns = [];
  for (i2 = 0; i2 < columns.length; i2++) {
    t2 = columns[i2].trim();
    if (!t2) {
      if (i2 === 0 || i2 === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  oldParentType = state.parentType;
  state.parentType = "table";
  terminatorRules = state.md.block.ruler.getRules("blockquote");
  token2 = state.push("table_open", "table", 1);
  token2.map = tableLines = [startLine, 0];
  token2 = state.push("thead_open", "thead", 1);
  token2.map = [startLine, startLine + 1];
  token2 = state.push("tr_open", "tr", 1);
  token2.map = [startLine, startLine + 1];
  for (i2 = 0; i2 < columns.length; i2++) {
    token2 = state.push("th_open", "th", 1);
    if (aligns[i2]) {
      token2.attrs = [["style", "text-align:" + aligns[i2]]];
    }
    token2 = state.push("inline", "", 0);
    token2.content = columns[i2].trim();
    token2.children = [];
    token2 = state.push("th_close", "th", -1);
  }
  token2 = state.push("tr_close", "tr", -1);
  token2 = state.push("thead_close", "thead", -1);
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    if (nextLine === startLine + 2) {
      token2 = state.push("tbody_open", "tbody", 1);
      token2.map = tbodyLines = [startLine + 2, 0];
    }
    token2 = state.push("tr_open", "tr", 1);
    token2.map = [nextLine, nextLine + 1];
    for (i2 = 0; i2 < columnCount; i2++) {
      token2 = state.push("td_open", "td", 1);
      if (aligns[i2]) {
        token2.attrs = [["style", "text-align:" + aligns[i2]]];
      }
      token2 = state.push("inline", "", 0);
      token2.content = columns[i2] ? columns[i2].trim() : "";
      token2.children = [];
      token2 = state.push("td_close", "td", -1);
    }
    token2 = state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    token2 = state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  token2 = state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};
var code = function code2(state, startLine, endLine) {
  var nextLine, last, token2;
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  last = nextLine = startLine + 1;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  token2 = state.push("code_block", "code", 0);
  token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token2.map = [startLine, state.line];
  return true;
};
var fence = function fence2(state, startLine, endLine, silent) {
  var marker2, len2, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max2) {
    return false;
  }
  marker2 = state.src.charCodeAt(pos);
  if (marker2 !== 126 && marker2 !== 96) {
    return false;
  }
  mem = pos;
  pos = state.skipChars(pos, marker2);
  len2 = pos - mem;
  if (len2 < 3) {
    return false;
  }
  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max2);
  if (marker2 === 96) {
    if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  nextLine = startLine;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max2 = state.eMarks[nextLine];
    if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker2) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker2);
    if (pos - mem < len2) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max2) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len2 = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  token2 = state.push("fence", "code", 0);
  token2.info = params;
  token2.content = state.getLines(startLine + 1, nextLine, len2, true);
  token2.markup = markup;
  token2.map = [startLine, state.line];
  return true;
};
var isSpace$9 = utils$2.isSpace;
var blockquote = function blockquote2(state, startLine, endLine, silent) {
  var adjustTab, ch, i2, initial, l2, lastLineEmpty, lines, nextLine, offset2, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos++) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  initial = offset2 = state.sCount[startLine] + 1;
  if (state.src.charCodeAt(pos) === 32) {
    pos++;
    initial++;
    offset2++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 9) {
    spaceAfterMarker = true;
    if ((state.bsCount[startLine] + offset2) % 4 === 3) {
      pos++;
      initial++;
      offset2++;
      adjustTab = false;
    } else {
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }
  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;
  while (pos < max2) {
    ch = state.src.charCodeAt(pos);
    if (isSpace$9(ch)) {
      if (ch === 9) {
        offset2 += 4 - (offset2 + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset2++;
      }
    } else {
      break;
    }
    pos++;
  }
  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
  lastLineEmpty = pos >= max2;
  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset2 - initial;
  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];
  terminatorRules = state.md.block.ruler.getRules("blockquote");
  oldParentType = state.parentType;
  state.parentType = "blockquote";
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max2 = state.eMarks[nextLine];
    if (pos >= max2) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      initial = offset2 = state.sCount[nextLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset2++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + offset2) % 4 === 3) {
          pos++;
          initial++;
          offset2++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (isSpace$9(ch)) {
          if (ch === 9) {
            offset2 += 4 - (offset2 + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset2++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max2;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset2 - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  oldIndent = state.blkIndent;
  state.blkIndent = 0;
  token2 = state.push("blockquote_open", "blockquote", 1);
  token2.markup = ">";
  token2.map = lines = [startLine, 0];
  state.md.block.tokenize(state, startLine, nextLine);
  token2 = state.push("blockquote_close", "blockquote", -1);
  token2.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (i2 = 0; i2 < oldTShift.length; i2++) {
    state.bMarks[i2 + startLine] = oldBMarks[i2];
    state.tShift[i2 + startLine] = oldTShift[i2];
    state.sCount[i2 + startLine] = oldSCount[i2];
    state.bsCount[i2 + startLine] = oldBSCount[i2];
  }
  state.blkIndent = oldIndent;
  return true;
};
var isSpace$8 = utils$2.isSpace;
var hr = function hr2(state, startLine, endLine, silent) {
  var marker2, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  marker2 = state.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
    return false;
  }
  cnt = 1;
  while (pos < max2) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker2 && !isSpace$8(ch)) {
      return false;
    }
    if (ch === marker2) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  token2 = state.push("hr", "hr", 0);
  token2.map = [startLine, state.line];
  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
  return true;
};
var isSpace$7 = utils$2.isSpace;
function skipBulletListMarker(state, startLine) {
  var marker2, pos, max2, ch;
  pos = state.bMarks[startLine] + state.tShift[startLine];
  max2 = state.eMarks[startLine];
  marker2 = state.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
    return -1;
  }
  if (pos < max2) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace$7(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  var ch, start2 = state.bMarks[startLine] + state.tShift[startLine], pos = start2, max2 = state.eMarks[startLine];
  if (pos + 1 >= max2) {
    return -1;
  }
  ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max2) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start2 >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max2) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace$7(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  var i2, l2, level = state.level + 2;
  for (i2 = idx + 2, l2 = state.tokens.length - 2; i2 < l2; i2++) {
    if (state.tokens[i2].level === level && state.tokens[i2].type === "paragraph_open") {
      state.tokens[i2 + 2].hidden = true;
      state.tokens[i2].hidden = true;
      i2 += 2;
    }
  }
}
var list = function list2(state, startLine, endLine, silent) {
  var ch, contentStart, i2, indent2, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max2, nextLine, offset2, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
    return false;
  }
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start2 = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.slice(start2, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
      return false;
  }
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  if (silent) {
    return true;
  }
  listTokIdx = state.tokens.length;
  if (isOrdered) {
    token2 = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token2.attrs = [["start", markerValue]];
    }
  } else {
    token2 = state.push("bullet_list_open", "ul", 1);
  }
  token2.map = listLines = [startLine, 0];
  token2.markup = String.fromCharCode(markerCharCode);
  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules("list");
  oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max2 = state.eMarks[nextLine];
    initial = offset2 = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
    while (pos < max2) {
      ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset2 += 4 - (offset2 + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset2++;
      } else {
        break;
      }
      pos++;
    }
    contentStart = pos;
    if (contentStart >= max2) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset2 - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    indent2 = initial + indentAfterMarker;
    token2 = state.push("list_item_open", "li", 1);
    token2.markup = String.fromCharCode(markerCharCode);
    token2.map = itemLines = [startLine, 0];
    if (isOrdered) {
      token2.info = state.src.slice(start2, posAfterMarker - 1);
    }
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent2;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset2;
    if (contentStart >= max2 && state.isEmpty(startLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;
    token2 = state.push("list_item_close", "li", -1);
    token2.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      break;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start2 = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token2 = state.push("ordered_list_close", "ol", -1);
  } else {
    token2 = state.push("bullet_list_close", "ul", -1);
  }
  token2.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
};
var normalizeReference$2 = utils$2.normalizeReference;
var isSpace$6 = utils$2.isSpace;
var reference = function reference2(state, startLine, _endLine, silent) {
  var ch, destEndPos, destEndLineNo, endLine, href, i2, l2, label, labelEnd, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine], nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  while (++pos < max2) {
    if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
      if (pos + 1 === max2) {
        return false;
      }
      if (state.src.charCodeAt(pos + 1) !== 58) {
        return false;
      }
      break;
    }
  }
  endLine = state.lineMax;
  terminatorRules = state.md.block.ruler.getRules("reference");
  oldParentType = state.parentType;
  state.parentType = "reference";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max2 = str.length;
  for (pos = 1; pos < max2; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      lines++;
    } else if (ch === 92) {
      pos++;
      if (pos < max2 && str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max2; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$6(ch))
      ;
    else {
      break;
    }
  }
  res = state.md.helpers.parseLinkDestination(str, pos, max2);
  if (!res.ok) {
    return false;
  }
  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = res.pos;
  lines += res.lines;
  destEndPos = pos;
  destEndLineNo = lines;
  start2 = pos;
  for (; pos < max2; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$6(ch))
      ;
    else {
      break;
    }
  }
  res = state.md.helpers.parseLinkTitle(str, pos, max2);
  if (pos < max2 && start2 !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = "";
    pos = destEndPos;
    lines = destEndLineNo;
  }
  while (pos < max2) {
    ch = str.charCodeAt(pos);
    if (!isSpace$6(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max2 && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max2) {
        ch = str.charCodeAt(pos);
        if (!isSpace$6(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max2 && str.charCodeAt(pos) !== 10) {
    return false;
  }
  label = normalizeReference$2(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.parentType = oldParentType;
  state.line = startLine + lines + 1;
  return true;
};
var html_blocks = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var html_re = {};
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
html_re.HTML_TAG_RE = HTML_TAG_RE$1;
html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
var block_names = html_blocks;
var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
var html_block = function html_block2(state, startLine, endLine, silent) {
  var i2, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  lineText = state.src.slice(pos, max2);
  for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
    if (HTML_SEQUENCES[i2][0].test(lineText)) {
      break;
    }
  }
  if (i2 === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i2][2];
  }
  nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i2][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max2 = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max2);
      if (HTML_SEQUENCES[i2][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  token2 = state.push("html_block", "", 0);
  token2.map = [startLine, nextLine];
  token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
};
var isSpace$5 = utils$2.isSpace;
var heading = function heading2(state, startLine, endLine, silent) {
  var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max2) {
    return false;
  }
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max2 && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max2 && !isSpace$5(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max2 = state.skipSpacesBack(max2, pos);
  tmp = state.skipCharsBack(max2, 35, pos);
  if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
    max2 = tmp;
  }
  state.line = startLine + 1;
  token2 = state.push("heading_open", "h" + String(level), 1);
  token2.markup = "########".slice(0, level);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = state.src.slice(pos, max2).trim();
  token2.map = [startLine, state.line];
  token2.children = [];
  token2 = state.push("heading_close", "h" + String(level), -1);
  token2.markup = "########".slice(0, level);
  return true;
};
var lheading = function lheading2(state, startLine, endLine) {
  var content, terminate, i2, l2, token2, pos, max2, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  oldParentType = state.parentType;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max2 = state.eMarks[nextLine];
      if (pos < max2) {
        marker2 = state.src.charCodeAt(pos);
        if (marker2 === 45 || marker2 === 61) {
          pos = state.skipChars(pos, marker2);
          pos = state.skipSpaces(pos);
          if (pos >= max2) {
            level = marker2 === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  token2 = state.push("heading_open", "h" + String(level), 1);
  token2.markup = String.fromCharCode(marker2);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state.line - 1];
  token2.children = [];
  token2 = state.push("heading_close", "h" + String(level), -1);
  token2.markup = String.fromCharCode(marker2);
  state.parentType = oldParentType;
  return true;
};
var paragraph = function paragraph2(state, startLine) {
  var content, terminate, i2, l2, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
  oldParentType = state.parentType;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  token2 = state.push("paragraph_open", "p", 1);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state.line];
  token2.children = [];
  token2 = state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
};
var Token$1 = token$1;
var isSpace$4 = utils$2.isSpace;
function StateBlock(src, md, env, tokens2) {
  var ch, s2, start2, pos, len2, indent2, offset2, indent_found;
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens2;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  this.result = "";
  s2 = this.src;
  indent_found = false;
  for (start2 = pos = indent2 = offset2 = 0, len2 = s2.length; pos < len2; pos++) {
    ch = s2.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace$4(ch)) {
        indent2++;
        if (ch === 9) {
          offset2 += 4 - offset2 % 4;
        } else {
          offset2++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len2 - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start2);
      this.eMarks.push(pos);
      this.tShift.push(indent2);
      this.sCount.push(offset2);
      this.bsCount.push(0);
      indent_found = false;
      indent2 = 0;
      offset2 = 0;
      start2 = pos + 1;
    }
  }
  this.bMarks.push(s2.length);
  this.eMarks.push(s2.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  var token2 = new Token$1(type, tag, nesting);
  token2.block = true;
  if (nesting < 0)
    this.level--;
  token2.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token2);
  return token2;
};
StateBlock.prototype.isEmpty = function isEmpty2(line2) {
  return this.bMarks[line2] + this.tShift[line2] >= this.eMarks[line2];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from2) {
  for (var max2 = this.lineMax; from2 < max2; from2++) {
    if (this.bMarks[from2] + this.tShift[from2] < this.eMarks[from2]) {
      break;
    }
  }
  return from2;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;
  for (var max2 = this.src.length; pos < max2; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace$4(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min2) {
  if (pos <= min2) {
    return pos;
  }
  while (pos > min2) {
    if (!isSpace$4(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code3) {
  for (var max2 = this.src.length; pos < max2; pos++) {
    if (this.src.charCodeAt(pos) !== code3) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code3, min2) {
  if (pos <= min2) {
    return pos;
  }
  while (pos > min2) {
    if (code3 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent2, keepLastLF) {
  var i2, lineIndent, ch, first, last, queue2, lineStart, line2 = begin;
  if (begin >= end) {
    return "";
  }
  queue2 = new Array(end - begin);
  for (i2 = 0; line2 < end; line2++, i2++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line2];
    if (line2 + 1 < end || keepLastLF) {
      last = this.eMarks[line2] + 1;
    } else {
      last = this.eMarks[line2];
    }
    while (first < last && lineIndent < indent2) {
      ch = this.src.charCodeAt(first);
      if (isSpace$4(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line2]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line2]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent2) {
      queue2[i2] = new Array(lineIndent - indent2 + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue2[i2] = this.src.slice(first, last);
    }
  }
  return queue2.join("");
};
StateBlock.prototype.Token = Token$1;
var state_block = StateBlock;
var Ruler$1 = ruler;
var _rules$1 = [
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock$1() {
  this.ruler = new Ruler$1();
  for (var i2 = 0; i2 < _rules$1.length; i2++) {
    this.ruler.push(_rules$1[i2][0], _rules$1[i2][1], { alt: (_rules$1[i2][2] || []).slice() });
  }
}
ParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {
  var ok, i2, rules = this.ruler.getRules(""), len2 = rules.length, line2 = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
  while (line2 < endLine) {
    state.line = line2 = state.skipEmptyLines(line2);
    if (line2 >= endLine) {
      break;
    }
    if (state.sCount[line2] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    for (i2 = 0; i2 < len2; i2++) {
      ok = rules[i2](state, line2, endLine, false);
      if (ok) {
        break;
      }
    }
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line2 = state.line;
    if (line2 < endLine && state.isEmpty(line2)) {
      hasEmptyLines = true;
      line2++;
      state.line = line2;
    }
  }
};
ParserBlock$1.prototype.parse = function(src, md, env, outTokens) {
  var state;
  if (!src) {
    return;
  }
  state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock$1.prototype.State = state_block;
var parser_block = ParserBlock$1;
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
var text = function text2(state, silent) {
  var pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
};
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
var linkify = function linkify3(state, silent) {
  var pos, max2, match5, proto2, link3, url, fullUrl, token2;
  if (!state.md.options.linkify)
    return false;
  if (state.linkLevel > 0)
    return false;
  pos = state.pos;
  max2 = state.posMax;
  if (pos + 3 > max2)
    return false;
  if (state.src.charCodeAt(pos) !== 58)
    return false;
  if (state.src.charCodeAt(pos + 1) !== 47)
    return false;
  if (state.src.charCodeAt(pos + 2) !== 47)
    return false;
  match5 = state.pending.match(SCHEME_RE);
  if (!match5)
    return false;
  proto2 = match5[1];
  link3 = state.md.linkify.matchAtStart(state.src.slice(pos - proto2.length));
  if (!link3)
    return false;
  url = link3.url;
  url = url.replace(/\*+$/, "");
  fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl))
    return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto2.length);
    token2 = state.push("link_open", "a", 1);
    token2.attrs = [["href", fullUrl]];
    token2.markup = "linkify";
    token2.info = "auto";
    token2 = state.push("text", "", 0);
    token2.content = state.md.normalizeLinkText(url);
    token2 = state.push("link_close", "a", -1);
    token2.markup = "linkify";
    token2.info = "auto";
  }
  state.pos += url.length - proto2.length;
  return true;
};
var isSpace$3 = utils$2.isSpace;
var newline = function newline2(state, silent) {
  var pmax, max2, ws, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  pmax = state.pending.length - 1;
  max2 = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max2 && isSpace$3(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
};
var isSpace$2 = utils$2.isSpace;
var ESCAPED = [];
for (var i$1 = 0; i$1 < 256; i$1++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
var _escape = function escape(state, silent) {
  var ch1, ch2, origStr, escapedStr, token2, pos = state.pos, max2 = state.posMax;
  if (state.src.charCodeAt(pos) !== 92)
    return false;
  pos++;
  if (pos >= max2)
    return false;
  ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max2) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace$2(ch1))
        break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max2) {
    ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  origStr = "\\" + escapedStr;
  if (!silent) {
    token2 = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token2.content = escapedStr;
    } else {
      token2.content = origStr;
    }
    token2.markup = origStr;
    token2.info = "escape";
  }
  state.pos = pos + 1;
  return true;
};
var backticks = function backtick(state, silent) {
  var start2, max2, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  start2 = pos;
  pos++;
  max2 = state.posMax;
  while (pos < max2 && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  marker2 = state.src.slice(start2, pos);
  openerLength = marker2.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {
    if (!silent)
      state.pending += marker2;
    state.pos += openerLength;
    return true;
  }
  matchStart = matchEnd = pos;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        token2 = state.push("code_inline", "code", 0);
        token2.markup = marker2;
        token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker2;
  state.pos += openerLength;
  return true;
};
var strikethrough = {};
strikethrough.tokenize = function strikethrough2(state, silent) {
  var i2, scanned, token2, len2, ch, start2 = state.pos, marker2 = state.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker2 !== 126) {
    return false;
  }
  scanned = state.scanDelims(state.pos, true);
  len2 = scanned.length;
  ch = String.fromCharCode(marker2);
  if (len2 < 2) {
    return false;
  }
  if (len2 % 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch;
    len2--;
  }
  for (i2 = 0; i2 < len2; i2 += 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch + ch;
    state.delimiters.push({
      marker: marker2,
      length: 0,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess$1(state, delimiters) {
  var i2, j2, startDelim, endDelim, token2, loneMarkers = [], max2 = delimiters.length;
  for (i2 = 0; i2 < max2; i2++) {
    startDelim = delimiters[i2];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    token2 = state.tokens[startDelim.token];
    token2.type = "s_open";
    token2.tag = "s";
    token2.nesting = 1;
    token2.markup = "~~";
    token2.content = "";
    token2 = state.tokens[endDelim.token];
    token2.type = "s_close";
    token2.tag = "s";
    token2.nesting = -1;
    token2.markup = "~~";
    token2.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    i2 = loneMarkers.pop();
    j2 = i2 + 1;
    while (j2 < state.tokens.length && state.tokens[j2].type === "s_close") {
      j2++;
    }
    j2--;
    if (i2 !== j2) {
      token2 = state.tokens[j2];
      state.tokens[j2] = state.tokens[i2];
      state.tokens[i2] = token2;
    }
  }
}
strikethrough.postProcess = function strikethrough3(state) {
  var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
  postProcess$1(state, state.delimiters);
  for (curr = 0; curr < max2; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters);
    }
  }
};
var emphasis = {};
emphasis.tokenize = function emphasis2(state, silent) {
  var i2, scanned, token2, start2 = state.pos, marker2 = state.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker2 !== 95 && marker2 !== 42) {
    return false;
  }
  scanned = state.scanDelims(state.pos, marker2 === 42);
  for (i2 = 0; i2 < scanned.length; i2++) {
    token2 = state.push("text", "", 0);
    token2.content = String.fromCharCode(marker2);
    state.delimiters.push({
      marker: marker2,
      length: scanned.length,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess(state, delimiters) {
  var i2, startDelim, endDelim, token2, ch, isStrong, max2 = delimiters.length;
  for (i2 = max2 - 1; i2 >= 0; i2--) {
    startDelim = delimiters[i2];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
    ch = String.fromCharCode(startDelim.marker);
    token2 = state.tokens[startDelim.token];
    token2.type = isStrong ? "strong_open" : "em_open";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = 1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    token2 = state.tokens[endDelim.token];
    token2.type = isStrong ? "strong_close" : "em_close";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = -1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    if (isStrong) {
      state.tokens[delimiters[i2 - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i2--;
    }
  }
}
emphasis.postProcess = function emphasis3(state) {
  var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (curr = 0; curr < max2; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};
var normalizeReference$1 = utils$2.normalizeReference;
var isSpace$1 = utils$2.isSpace;
var link = function link2(state, silent) {
  var attrs, code3, label, labelEnd, labelStart, pos, res, ref2, token2, href = "", title = "", oldPos = state.pos, max2 = state.posMax, start2 = state.pos, parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max2 && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max2; pos++) {
      code3 = state.src.charCodeAt(pos);
      if (!isSpace$1(code3) && code3 !== 10) {
        break;
      }
    }
    if (pos >= max2) {
      return false;
    }
    start2 = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start2 = pos;
      for (; pos < max2; pos++) {
        code3 = state.src.charCodeAt(pos);
        if (!isSpace$1(code3) && code3 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max2 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max2; pos++) {
          code3 = state.src.charCodeAt(pos);
          if (!isSpace$1(code3) && code3 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max2 && state.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref2 = state.env.references[normalizeReference$1(label)];
    if (!ref2) {
      state.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    token2 = state.push("link_open", "a", 1);
    token2.attrs = attrs = [["href", href]];
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    token2 = state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max2;
  return true;
};
var normalizeReference = utils$2.normalizeReference;
var isSpace = utils$2.isSpace;
var image = function image2(state, silent) {
  var attrs, code3, content, label, labelEnd, labelStart, pos, ref2, res, title, token2, tokens2, start2, href = "", oldPos = state.pos, max2 = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max2 && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max2; pos++) {
      code3 = state.src.charCodeAt(pos);
      if (!isSpace(code3) && code3 !== 10) {
        break;
      }
    }
    if (pos >= max2) {
      return false;
    }
    start2 = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start2 = pos;
    for (; pos < max2; pos++) {
      code3 = state.src.charCodeAt(pos);
      if (!isSpace(code3) && code3 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max2 && start2 !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max2; pos++) {
        code3 = state.src.charCodeAt(pos);
        if (!isSpace(code3) && code3 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max2 && state.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref2 = state.env.references[normalizeReference(label)];
    if (!ref2) {
      state.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    state.md.inline.parse(content, state.md, state.env, tokens2 = []);
    token2 = state.push("image", "img", 0);
    token2.attrs = attrs = [["src", href], ["alt", ""]];
    token2.children = tokens2;
    token2.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max2;
  return true;
};
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
var autolink = function autolink2(state, silent) {
  var url, fullUrl, token2, ch, start2, max2, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  start2 = state.pos;
  max2 = state.posMax;
  for (; ; ) {
    if (++pos >= max2)
      return false;
    ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  url = state.src.slice(start2 + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state.push("text", "", 0);
      token2.content = state.md.normalizeLinkText(url);
      token2 = state.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state.push("text", "", 0);
      token2.content = state.md.normalizeLinkText(url);
      token2 = state.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
};
var HTML_TAG_RE = html_re.HTML_TAG_RE;
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  var lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
var html_inline = function html_inline2(state, silent) {
  var ch, match5, max2, token2, pos = state.pos;
  if (!state.md.options.html) {
    return false;
  }
  max2 = state.posMax;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {
    return false;
  }
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  match5 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match5) {
    return false;
  }
  if (!silent) {
    token2 = state.push("html_inline", "", 0);
    token2.content = state.src.slice(pos, pos + match5[0].length);
    if (isLinkOpen(token2.content))
      state.linkLevel++;
    if (isLinkClose(token2.content))
      state.linkLevel--;
  }
  state.pos += match5[0].length;
  return true;
};
var entities = entities$1;
var has = utils$2.has;
var isValidEntityCode = utils$2.isValidEntityCode;
var fromCodePoint = utils$2.fromCodePoint;
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
var entity = function entity2(state, silent) {
  var ch, code3, match5, token2, pos = state.pos, max2 = state.posMax;
  if (state.src.charCodeAt(pos) !== 38)
    return false;
  if (pos + 1 >= max2)
    return false;
  ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    match5 = state.src.slice(pos).match(DIGITAL_RE);
    if (match5) {
      if (!silent) {
        code3 = match5[1][0].toLowerCase() === "x" ? parseInt(match5[1].slice(1), 16) : parseInt(match5[1], 10);
        token2 = state.push("text_special", "", 0);
        token2.content = isValidEntityCode(code3) ? fromCodePoint(code3) : fromCodePoint(65533);
        token2.markup = match5[0];
        token2.info = "entity";
      }
      state.pos += match5[0].length;
      return true;
    }
  } else {
    match5 = state.src.slice(pos).match(NAMED_RE);
    if (match5) {
      if (has(entities, match5[1])) {
        if (!silent) {
          token2 = state.push("text_special", "", 0);
          token2.content = entities[match5[1]];
          token2.markup = match5[0];
          token2.info = "entity";
        }
        state.pos += match5[0].length;
        return true;
      }
    }
  }
  return false;
};
function processDelimiters(state, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max2 = delimiters.length;
  if (!max2)
    return;
  var headerIdx = 0;
  var lastTokenIdx = -2;
  var jumps = [];
  for (closerIdx = 0; closerIdx < max2; closerIdx++) {
    closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    openerIdx = headerIdx - jumps[headerIdx] - 1;
    newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
var balance_pairs = function link_pairs(state) {
  var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
  processDelimiters(state, state.delimiters);
  for (curr = 0; curr < max2; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};
var fragments_join = function fragments_join2(state) {
  var curr, last, level = 0, tokens2 = state.tokens, max2 = state.tokens.length;
  for (curr = last = 0; curr < max2; curr++) {
    if (tokens2[curr].nesting < 0)
      level--;
    tokens2[curr].level = level;
    if (tokens2[curr].nesting > 0)
      level++;
    if (tokens2[curr].type === "text" && curr + 1 < max2 && tokens2[curr + 1].type === "text") {
      tokens2[curr + 1].content = tokens2[curr].content + tokens2[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens2[last] = tokens2[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens2.length = last;
  }
};
var Token = token$1;
var isWhiteSpace = utils$2.isWhiteSpace;
var isPunctChar = utils$2.isPunctChar;
var isMdAsciiPunct = utils$2.isMdAsciiPunct;
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  var token2 = new Token("text", "", 0);
  token2.content = this.pending;
  token2.level = this.pendingLevel;
  this.tokens.push(token2);
  this.pending = "";
  return token2;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  var token2 = new Token(type, tag, nesting);
  var token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token2.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token2);
  this.tokens_meta.push(token_meta);
  return token2;
};
StateInline.prototype.scanDelims = function(start2, canSplitWord) {
  var pos = start2, lastChar, nextChar, count2, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max2 = this.posMax, marker2 = this.src.charCodeAt(start2);
  lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
  while (pos < max2 && this.src.charCodeAt(pos) === marker2) {
    pos++;
  }
  count2 = pos - start2;
  nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;
  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);
  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }
  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }
  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }
  return {
    can_open,
    can_close,
    length: count2
  };
};
StateInline.prototype.Token = Token;
var state_inline = StateInline;
var Ruler = ruler;
var _rules = [
  ["text", text],
  ["linkify", linkify],
  ["newline", newline],
  ["escape", _escape],
  ["backticks", backticks],
  ["strikethrough", strikethrough.tokenize],
  ["emphasis", emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules2 = [
  ["balance_pairs", balance_pairs],
  ["strikethrough", strikethrough.postProcess],
  ["emphasis", emphasis.postProcess],
  ["fragments_join", fragments_join]
];
function ParserInline$1() {
  var i2;
  this.ruler = new Ruler();
  for (i2 = 0; i2 < _rules.length; i2++) {
    this.ruler.push(_rules[i2][0], _rules[i2][1]);
  }
  this.ruler2 = new Ruler();
  for (i2 = 0; i2 < _rules2.length; i2++) {
    this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
  }
}
ParserInline$1.prototype.skipToken = function(state) {
  var ok, i2, pos = state.pos, rules = this.ruler.getRules(""), len2 = rules.length, maxNesting = state.md.options.maxNesting, cache2 = state.cache;
  if (typeof cache2[pos] !== "undefined") {
    state.pos = cache2[pos];
    return;
  }
  if (state.level < maxNesting) {
    for (i2 = 0; i2 < len2; i2++) {
      state.level++;
      ok = rules[i2](state, true);
      state.level--;
      if (ok) {
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache2[pos] = state.pos;
};
ParserInline$1.prototype.tokenize = function(state) {
  var ok, i2, rules = this.ruler.getRules(""), len2 = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    if (state.level < maxNesting) {
      for (i2 = 0; i2 < len2; i2++) {
        ok = rules[i2](state, false);
        if (ok) {
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline$1.prototype.parse = function(str, md, env, outTokens) {
  var i2, rules, len2;
  var state = new this.State(str, md, env, outTokens);
  this.tokenize(state);
  rules = this.ruler2.getRules("");
  len2 = rules.length;
  for (i2 = 0; i2 < len2; i2++) {
    rules[i2](state);
  }
};
ParserInline$1.prototype.State = state_inline;
var parser_inline = ParserInline$1;
var re$1 = function(opts) {
  var re2 = {};
  opts = opts || {};
  re2.src_Any = regex$3.source;
  re2.src_Cc = regex$2.source;
  re2.src_Z = regex.source;
  re2.src_P = regex$4.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  var text_separators = "[><\uFF5C]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
};
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString$1(obj) {
  return _class(obj) === "[object String]";
}
function isObject$2(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction$1(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k2) {
    return acc || defaultOptions.hasOwnProperty(k2);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text3[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text3[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re2) {
  return function(text3, pos) {
    var tail = text3.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match5, self2) {
    self2.normalize(match5);
  };
}
function compile(self2) {
  var re2 = self2.re = re$1(self2.__opts__);
  var tlds3 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds3.push(tlds_2ch_src_re);
  }
  tlds3.push(re2.src_xn);
  re2.src_tlds = tlds3.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re2.src_tlds);
  }
  re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
  re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
  re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
  re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
  var aliases2 = [];
  self2.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name) {
    var val = self2.__schemas__[name];
    if (val === null) {
      return;
    }
    var compiled = { validate: null, link: null };
    self2.__compiled__[name] = compiled;
    if (isObject$2(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction$1(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction$1(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString$1(val)) {
      aliases2.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases2.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  var slist = Object.keys(self2.__compiled__).filter(function(name) {
    return name.length > 0 && self2.__compiled__[name];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
  resetScanCache(self2);
}
function Match(self2, shift2) {
  var start2 = self2.__index__, end = self2.__last_index__, text3 = self2.__text_cache__.slice(start2, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start2 + shift2;
  this.lastIndex = end + shift2;
  this.raw = text3;
  this.text = text3;
  this.url = text3;
}
function createMatch(self2, shift2) {
  var match5 = new Match(self2, shift2);
  self2.__compiled__[match5.schema].normalize(match5, self2);
  return match5;
}
function LinkifyIt$1(schemas2, options) {
  if (!(this instanceof LinkifyIt$1)) {
    return new LinkifyIt$1(schemas2, options);
  }
  if (!options) {
    if (isOptionsObj(schemas2)) {
      options = schemas2;
      schemas2 = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign({}, defaultSchemas, schemas2);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt$1.prototype.add = function add2(schema2, definition) {
  this.__schemas__[schema2] = definition;
  compile(this);
  return this;
};
LinkifyIt$1.prototype.set = function set2(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};
LinkifyIt$1.prototype.test = function test(text3) {
  this.__text_cache__ = text3;
  this.__index__ = -1;
  if (!text3.length) {
    return false;
  }
  var m2, ml, me2, len2, shift2, next, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text3)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m2 = re2.exec(text3)) !== null) {
      len2 = this.testSchemaAt(text3, m2[2], re2.lastIndex);
      if (len2) {
        this.__schema__ = m2[2];
        this.__index__ = m2.index + m2[1].length;
        this.__last_index__ = m2.index + m2[0].length + len2;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text3.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift2 = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift2 < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift2;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text3.indexOf("@");
    if (at_pos >= 0) {
      if ((me2 = text3.match(this.re.email_fuzzy)) !== null) {
        shift2 = me2.index + me2[1].length;
        next = me2.index + me2[0].length;
        if (this.__index__ < 0 || shift2 < this.__index__ || shift2 === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift2;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt$1.prototype.pretest = function pretest(text3) {
  return this.re.pretest.test(text3);
};
LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text3, schema2, pos) {
  if (!this.__compiled__[schema2.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema2.toLowerCase()].validate(text3, pos, this);
};
LinkifyIt$1.prototype.match = function match(text3) {
  var shift2 = 0, result = [];
  if (this.__index__ >= 0 && this.__text_cache__ === text3) {
    result.push(createMatch(this, shift2));
    shift2 = this.__last_index__;
  }
  var tail = shift2 ? text3.slice(shift2) : text3;
  while (this.test(tail)) {
    result.push(createMatch(this, shift2));
    tail = tail.slice(this.__last_index__);
    shift2 += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt$1.prototype.matchAtStart = function matchAtStart(text3) {
  this.__text_cache__ = text3;
  this.__index__ = -1;
  if (!text3.length)
    return null;
  var m2 = this.re.schema_at_start.exec(text3);
  if (!m2)
    return null;
  var len2 = this.testSchemaAt(text3, m2[2], m2[0].length);
  if (!len2)
    return null;
  this.__schema__ = m2[2];
  this.__index__ = m2.index + m2[1].length;
  this.__last_index__ = m2.index + m2[0].length + len2;
  return createMatch(this, 0);
};
LinkifyIt$1.prototype.tlds = function tlds2(list3, keepOld) {
  list3 = Array.isArray(list3) ? list3 : [list3];
  if (!keepOld) {
    this.__tlds__ = list3.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list3).sort().filter(function(el2, idx, arr) {
    return el2 !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt$1.prototype.normalize = function normalize3(match5) {
  if (!match5.schema) {
    match5.url = "http://" + match5.url;
  }
  if (match5.schema === "mailto:" && !/^mailto:/i.test(match5.url)) {
    match5.url = "mailto:" + match5.url;
  }
};
LinkifyIt$1.prototype.onCompile = function onCompile() {
};
var linkifyIt = LinkifyIt$1;
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map$1(array2, fn) {
  const result = [];
  let length = array2.length;
  while (length--) {
    result[length] = fn(array2[length]);
  }
  return result;
}
function mapDomain(string2, fn) {
  const parts = string2.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string2 = parts[1];
  }
  string2 = string2.replace(regexSeparators, ".");
  const labels = string2.split(".");
  const encoded = map$1(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string2) {
  const output = [];
  let counter2 = 0;
  const length = string2.length;
  while (counter2 < length) {
    const value = string2.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length) {
      const extra = string2.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const ucs2encode = (array2) => String.fromCodePoint(...array2);
const basicToDigit = function(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta2, numPoints, firstTime) {
  let k2 = 0;
  delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
  delta2 += floor(delta2 / numPoints);
  for (; delta2 > baseMinusTMin * tMax >> 1; k2 += base) {
    delta2 = floor(delta2 / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
};
const decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i2 = 0;
  let n2 = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j2 = 0; j2 < basic; ++j2) {
    if (input.charCodeAt(j2) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j2));
  }
  for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
    let oldi = i2;
    for (let w2 = 1, k2 = base; ; k2 += base) {
      if (index2 >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index2++));
      if (digit >= base || digit > floor((maxInt - i2) / w2)) {
        error("overflow");
      }
      i2 += digit * w2;
      const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w2 > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w2 *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i2 - oldi, out, oldi == 0);
    if (floor(i2 / out) > maxInt - n2) {
      error("overflow");
    }
    n2 += floor(i2 / out);
    i2 %= out;
    output.splice(i2++, 0, n2);
  }
  return String.fromCodePoint(...output);
};
const encode = function(input) {
  const output = [];
  input = ucs2decode(input);
  let inputLength = input.length;
  let n2 = initialN;
  let delta2 = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  let basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m2 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta2) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta2 += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (const currentValue of input) {
      if (currentValue < n2 && ++delta2 > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        let q2 = delta2;
        for (let k2 = base; ; k2 += base) {
          const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q2 < t2) {
            break;
          }
          const qMinusT = q2 - t2;
          const baseMinusT = base - t2;
          output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
        delta2 = 0;
        ++handledCPCount;
      }
    }
    ++delta2;
    ++n2;
  }
  return output.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string2) {
    return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string2) {
    return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
  });
};
const punycode$1 = {
  "version": "2.1.0",
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ucs2decode,
  ucs2encode,
  decode,
  encode,
  toASCII,
  toUnicode,
  "default": punycode$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
var _default$1 = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var zero$1 = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
var commonmark = {
  options: {
    html: true,
    xhtmlOut: true,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
var utils$1 = utils$2;
var helpers = helpers$1;
var Renderer = renderer;
var ParserCore = parser_core;
var ParserBlock = parser_block;
var ParserInline = parser_inline;
var LinkifyIt = linkifyIt;
var mdurl = mdurl$1;
var punycode = require$$8;
var config = {
  default: _default$1,
  zero: zero$1,
  commonmark
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  var str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.encode(mdurl.format(parsed));
}
function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!utils$1.isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new ParserCore();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils$1;
  this.helpers = utils$1.assign({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  utils$1.assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  var self2 = this, presetName;
  if (utils$1.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name) {
      if (presets.components[name].rules) {
        self2[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self2[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list3, true));
  var missed = list3.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list3, true));
  var missed = list3.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin2) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin2.apply(plugin2, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  var state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  var state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib$1 = MarkdownIt;
var markdownIt = lib$1;
function externalLinksPlugin(md, options) {
  options = options || {};
  let externalClassName = typeof options.externalClassName === "string" || options.externalClassName === null ? options.externalClassName : "external-link";
  let internalClassName = typeof options.internalClassName === "string" || options.internalClassName === null ? options.internalClassName : null;
  let internalDomains = Array.isArray(options.internalDomains) ? options.internalDomains.map((domain) => domain.toLowerCase()) : [];
  let externalTarget = options.externalTarget || "_self";
  let internalTarget = options.internalTarget || "_self";
  let externalRel = options.externalRel || null;
  let internalRel = options.internalRel || null;
  if (externalClassName === null && internalClassName === null && externalTarget === "_self" && internalTarget === "_self" && externalRel === null && internalRel === null) {
    return;
  }
  function externalLinks(state) {
    function applyFilterToTokenHierarchy(token2) {
      if (token2.children) {
        token2.children.map(applyFilterToTokenHierarchy);
      }
      if (token2.type === "link_open") {
        let href = token2.attrGet("href");
        let internal = isInternalLink(href);
        let newClasses = internal ? internalClassName : externalClassName;
        if (newClasses) {
          let existingClasses = token2.attrGet("class") || "";
          if (existingClasses !== "") {
            newClasses = existingClasses + " " + newClasses;
          }
          token2.attrSet("class", newClasses);
        }
        let target2 = internal ? internalTarget : externalTarget;
        if (target2 !== "_self") {
          token2.attrSet("target", target2);
        }
        let rel = internal ? internalRel : externalRel;
        if (rel) {
          let existingRel = token2.attrGet("rel") || "";
          if (existingRel !== "") {
            rel = existingRel + " " + rel;
          }
          token2.attrSet("rel", rel);
        }
      }
    }
    state.tokens.map(applyFilterToTokenHierarchy);
  }
  function isInternalLink(href) {
    let domain = getDomain(href);
    return domain === null || internalDomains.indexOf(domain) !== -1;
  }
  function getDomain(href) {
    let domain = href.split("//")[1];
    if (domain) {
      domain = domain.split("/")[0].toLowerCase();
      return domain || null;
    }
    return null;
  }
  md.core.ruler.push("external_links", externalLinks);
}
var lib = externalLinksPlugin;
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module2, exports2) {
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN2 = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary2 = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal2 = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag2] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array2, setter, iteratee, accumulator) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        var value = array2[index2];
        setter(accumulator, value, iteratee(value), array2);
      }
      return accumulator;
    }
    function arrayEach(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEachRight(array2, iteratee) {
      var length = array2 == null ? 0 : array2.length;
      while (length--) {
        if (iteratee(array2[length], length, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEvery(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (!predicate(array2[index2], index2, array2)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      return !!length && baseIndexOf(array2, value, 0) > -1;
    }
    function arrayIncludesWith(array2, value, comparator) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (comparator(value, array2[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    function arrayPush(array2, values) {
      var index2 = -1, length = values.length, offset2 = array2.length;
      while (++index2 < length) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array2[index2], index2, array2);
      }
      return accumulator;
    }
    function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
      var length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array2[length], length, array2);
      }
      return accumulator;
    }
    function arraySome(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string2) {
      return string2.split("");
    }
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array2, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array2.length;
      while (++index2 < length) {
        if (comparator(array2[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array2, iteratee) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseSum(array2, iteratee) / length : NAN2;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array2, comparer) {
      var length = array2.length;
      array2.sort(comparer);
      while (length--) {
        array2[length] = array2[length].value;
      }
      return array2;
    }
    function baseSum(array2, iteratee) {
      var result, index2 = -1, length = array2.length;
      while (++index2 < length) {
        var current = iteratee(array2[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array2, placeholder) {
      var length = array2.length, result = 0;
      while (length--) {
        if (array2[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes2);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    function iteratorToArray(iterator) {
      var data2, result = [];
      while (!(data2 = iterator.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array2, placeholder) {
      var index2 = -1, length = array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array2[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set3) {
      var index2 = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set3) {
      var index2 = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array2, value, fromIndex) {
      var index2 = fromIndex - 1, length = array2.length;
      while (++index2 < length) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array2, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string2) {
      return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string2) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string2)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto2 = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter2 = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto2.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root2._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto2) {
          if (!isObject2(proto2)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto2);
          }
          object.prototype = proto2;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array2, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array2[index2];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$1;
      }
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== undefined$1 : hasOwnProperty2.call(data2, key);
      }
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        return index2 < 0 ? undefined$1 : data2[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size3 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result2 = data2["delete"](key);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs2 = data2.__data__;
          if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
            pairs2.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs2);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array2) {
        var length = array2.length;
        return length ? array2[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array2, n2) {
        return shuffleSelf(copyArray(array2), baseClamp(n2, 0, array2.length));
      }
      function arrayShuffle(array2) {
        return shuffleSelf(copyArray(array2));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower2, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower2 !== undefined$1) {
            number = number >= lower2 ? number : lower2;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack2) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack());
        var stacked = stack2.get(value);
        if (stacked) {
          return stacked;
        }
        stack2.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array2, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array2[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed2, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array2, iteratee2, comparator) {
        var index2 = -1, length = array2.length;
        while (++index2 < length) {
          var value = array2[index2], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array2, value, start2, end) {
        var length = array2.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start2 > end ? 0 : toLength(end);
        while (start2 < end) {
          array2[start2++] = value;
        }
        return array2;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array2, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array2.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array2[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path2) {
        path2 = castPath(path2, object);
        var index2 = 0, length = path2.length;
        while (object != null && index2 < length) {
          object = object[toKey(path2[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag2;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start2, end) {
        return number >= nativeMin2(start2, end) && number < nativeMax2(start2, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array2 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array2 = arrayMap(array2, baseUnary(iteratee2));
          }
          maxLength = nativeMin2(array2.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined$1;
        }
        array2 = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path2, args) {
        path2 = castPath(path2, object);
        object = parent(object, path2);
        var func = object == null ? object : object[toKey(last(path2))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag2(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack2);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag2(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path2, srcValue) {
        if (isKey(path2) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path2), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path2);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack2) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array2, n2) {
        var length = array2.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array2[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path2) {
          return hasIn(object, path2);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path2 = paths[index2], value = baseGet(object, path2);
          if (predicate(value, path2)) {
            baseSet(result2, castPath(path2, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path2) {
        return function(object) {
          return baseGet(object, path2);
        };
      }
      function basePullAll(array2, values2, iteratee2, comparator) {
        var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array2;
        if (array2 === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array2, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf3(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array2) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array2, fromIndex, 1);
          }
        }
        return array2;
      }
      function basePullAt(array2, indexes) {
        var length = array2 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array2, index2, 1);
            } else {
              baseUnset(array2, index2);
            }
          }
        }
        return array2;
      }
      function baseRandom(lower2, upper) {
        return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
      }
      function baseRange(start2, end, step, fromRight) {
        var index2 = -1, length = nativeMax2(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string2, n2) {
        var result2 = "";
        if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string2;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string2 += string2;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array2 = values(collection);
        return shuffleSelf(array2, baseClamp(n2, 0, array2.length));
      }
      function baseSet(object, path2, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path2 = castPath(path2, object);
        var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path2[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty ? identity2 : function(func, string2) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant2(string2),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array2, start2, end) {
        var index2 = -1, length = array2.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start2 > end ? 0 : end - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array2[index2 + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array2, value, retHighest) {
        var low = 0, high = array2 == null ? low : array2.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid2 = low + high >>> 1, computed2 = array2[mid2];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid2 + 1;
            } else {
              high = mid2;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array2, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
        var low = 0, high = array2 == null ? 0 : array2.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid2 = nativeFloor((low + high) / 2), computed2 = iteratee2(array2[mid2]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid2 + 1;
          } else {
            high = mid2;
          }
        }
        return nativeMin2(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array2, iteratee2) {
        var index2 = -1, length = array2.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        return +value;
      }
      function baseToString2(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString2) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function baseUniq(array2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set4 = iteratee2 ? null : createSet(array2);
          if (set4) {
            return setToArray(set4);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes2(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path2) {
        path2 = castPath(path2, object);
        object = parent(object, path2);
        return object == null || delete object[toKey(last(path2))];
      }
      function baseUpdate(object, path2, updater, customizer) {
        return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
      }
      function baseWhile(array2, predicate, isDrop, fromRight) {
        var length = array2.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array2[index2], index2, array2)) {
        }
        return isDrop ? baseSlice(array2, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array2, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array2 = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array2, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array2, start2, end) {
        var length = array2.length;
        end = end === undefined$1 ? length : end;
        return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root2.clearTimeout(id2);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order2 = orders[index2];
            return result2 * (order2 == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array2) {
        var index2 = -1, length = source.length;
        array2 || (array2 = Array2(length));
        while (++index2 < length) {
          array2[index2] = source[index2];
        }
        return array2;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString2(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString2(value);
              other = baseToString2(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
            end = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end === undefined$1) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start2 < end ? 1 : -1 : toFinite(step);
          return baseRange(start2, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin2(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data2 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack2.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
          stack2["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array2);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack2.set(array2, other);
        stack2.set(other, array2);
        while (++index2 < arrLength) {
          var arrValue = array2[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = false;
            break;
          }
        }
        stack2["delete"](array2);
        stack2["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack2.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result2;
          case symbolTag2:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
        while (length--) {
          var data2 = array2[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data2 = map3.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue2(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
        getTag2 = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data2 = transforms[index2], size3 = data2.size;
          switch (data2.type) {
            case "drop":
              start2 += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin2(end, start2 + size3);
              break;
            case "takeRight":
              start2 = nativeMax2(start2, end - size3);
              break;
          }
        }
        return { "start": start2, "end": end };
      }
      function getWrapDetails(source) {
        var match5 = source.match(reWrapDetails);
        return match5 ? match5[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path2, hasFunc) {
        path2 = castPath(path2, object);
        var index2 = -1, length = path2.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path2[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array2) {
        var length = array2.length, result2 = new array2.constructor(length);
        if (length && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
          result2.index = array2.index;
          result2.input = array2.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag2:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag2:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto2;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data2, source) {
        var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source[8] : nativeMin2(data2[8], source[8]);
        }
        if (data2[9] == null) {
          data2[9] = source[9];
        }
        data2[0] = source[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start2, transform3) {
        start2 = nativeMax2(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax2(args.length - start2, 0), array2 = Array2(length);
          while (++index2 < length) {
            array2[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform3(array2);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path2) {
        return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
      }
      function reorder(array2, indexes) {
        var arrLength = array2.length, length = nativeMin2(indexes.length, arrLength), oldArray = copyArray(array2);
        while (length--) {
          var index2 = indexes[length];
          array2[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array2;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference3, bitmask) {
        var source = reference3 + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count2 = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count2 >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count2 = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array2, size3) {
        var index2 = -1, length = array2.length, lastIndex = length - 1;
        size3 = size3 === undefined$1 ? length : size3;
        while (++index2 < size3) {
          var rand = baseRandom(index2, lastIndex), value = array2[rand];
          array2[rand] = array2[index2];
          array2[index2] = value;
        }
        array2.length = size3;
        return array2;
      }
      var stringToPath = memoizeCapped(function(string2) {
        var result2 = [];
        if (string2.charCodeAt(0) === 46) {
          result2.push("");
        }
        string2.replace(rePropName, function(match5, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match5);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array2, size3, guard) {
        if (guard ? isIterateeCall(array2, size3, guard) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax2(toInteger(size3), 0);
        }
        var length = array2 == null ? 0 : array2.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array2, index2, index2 += size3);
        }
        return result2;
      }
      function compact(array2) {
        var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array2[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array2 = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array2, values2) {
        return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array2, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array2, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array2, n2, guard) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array2, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array2, n2, guard) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
      }
      function fill(array2, value, start2, end) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
          start2 = 0;
          end = length;
        }
        return baseFill(array2, value, start2, end);
      }
      function findIndex(array2, predicate, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length + index2, 0);
        }
        return baseFindIndex(array2, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array2, predicate, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
        }
        return baseFindIndex(array2, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, 1) : [];
      }
      function flattenDeep(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, INFINITY2) : [];
      }
      function flattenDepth(array2, depth) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array2, depth);
      }
      function fromPairs(pairs2) {
        var index2 = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs2[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array2) {
        return array2 && array2.length ? array2[0] : undefined$1;
      }
      function indexOf2(array2, value, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length + index2, 0);
        }
        return baseIndexOf(array2, value, index2);
      }
      function initial(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSlice(array2, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join2(array2, separator2) {
        return array2 == null ? "" : nativeJoin.call(array2, separator2);
      }
      function last(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? array2[length - 1] : undefined$1;
      }
      function lastIndexOf(array2, value, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array2, value, index2) : baseFindIndex(array2, baseIsNaN, index2, true);
      }
      function nth(array2, n2) {
        return array2 && array2.length ? baseNth(array2, toInteger(n2)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array2, values2) {
        return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
      }
      function pullAllBy(array2, values2, iteratee2) {
        return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
      }
      function pullAllWith(array2, values2, comparator) {
        return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined$1, comparator) : array2;
      }
      var pullAt = flatRest(function(array2, indexes) {
        var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
        basePullAt(array2, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array2, predicate) {
        var result2 = [];
        if (!(array2 && array2.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array2.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array2[index2];
          if (predicate(value, index2, array2)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array2, indexes);
        return result2;
      }
      function reverse(array2) {
        return array2 == null ? array2 : nativeReverse.call(array2);
      }
      function slice(array2, start2, end) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array2, start2, end)) {
          start2 = 0;
          end = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array2, start2, end);
      }
      function sortedIndex(array2, value) {
        return baseSortedIndex(array2, value);
      }
      function sortedIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        if (length) {
          var index2 = baseSortedIndex(array2, value);
          if (index2 < length && eq(array2[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array2, value) {
        return baseSortedIndex(array2, value, true);
      }
      function sortedLastIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        if (length) {
          var index2 = baseSortedIndex(array2, value, true) - 1;
          if (eq(array2[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array2) {
        return array2 && array2.length ? baseSortedUniq(array2) : [];
      }
      function sortedUniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSlice(array2, 1, length) : [];
      }
      function take(array2, n2, guard) {
        if (!(array2 && array2.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array2, n2, guard) {
        var length = array2 == null ? 0 : array2.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array2, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array2) {
        return array2 && array2.length ? baseUniq(array2) : [];
      }
      function uniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array2, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array2 && array2.length ? baseUniq(array2, undefined$1, comparator) : [];
      }
      function unzip(array2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var length = 0;
        array2 = arrayFilter(array2, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax2(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array2, baseProperty(index2));
        });
      }
      function unzipWith(array2, iteratee2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var result2 = unzip(array2);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array2, values2) {
        return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array2) {
          if (length && !array2.length) {
            array2.push(undefined$1);
          }
          return array2;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY2);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy2 = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax2(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path2, args) {
        var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some2(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey2 = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax2(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin2(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 == null ? 0 : nativeMax2(toInteger(start2), 0);
        return baseRest(function(args) {
          var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array2) {
            arrayPush(otherArgs, array2);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap2(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike2(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag(value) == boolTag2;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty3(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag2(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto2 = getPrototype(value);
        if (proto2 === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag2;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag2(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag2(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY2 || value === -INFINITY2) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary2.test(value);
        return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString2(value);
      }
      var assign2 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path2, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path2);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has2(object, path2) {
        return object != null && hasPath(object, path2, baseHas);
      }
      function hasIn(object, path2) {
        return object != null && hasPath(object, path2, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant2(identity2));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path2) {
          path2 = castPath(path2, object);
          isDeep || (isDeep = path2.length > 1);
          return path2;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy2(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy2(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop2) {
          return [prop2];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path2) {
          return predicate(value, path2[0]);
        });
      }
      function result(object, path2, defaultValue) {
        path2 = castPath(path2, object);
        var index2 = -1, length = path2.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path2[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set3(object, path2, value) {
        return object == null ? object : baseSet(object, path2, value);
      }
      function setWith(object, path2, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path2, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path2) {
        return object == null ? true : baseUnset(object, path2);
      }
      function update3(object, path2, updater) {
        return object == null ? object : baseUpdate(object, path2, castFunction(updater));
      }
      function updateWith(object, path2, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number, lower2, upper) {
        if (upper === undefined$1) {
          upper = lower2;
          lower2 = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower2 !== undefined$1) {
          lower2 = toNumber2(lower2);
          lower2 = lower2 === lower2 ? lower2 : 0;
        }
        return baseClamp(toNumber2(number), lower2, upper);
      }
      function inRange(number, start2, end) {
        start2 = toFinite(start2);
        if (end === undefined$1) {
          end = start2;
          start2 = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber2(number);
        return baseInRange(number, start2, end);
      }
      function random(lower2, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower2 == "boolean") {
            floating = lower2;
            lower2 = undefined$1;
          }
        }
        if (lower2 === undefined$1 && upper === undefined$1) {
          lower2 = 0;
          upper = 1;
        } else {
          lower2 = toFinite(lower2);
          if (upper === undefined$1) {
            upper = lower2;
            lower2 = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower2 > upper) {
          var temp = lower2;
          lower2 = upper;
          upper = temp;
        }
        if (floating || lower2 % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin2(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower2, upper);
      }
      var camelCase = createCompounder(function(result2, word2, index2) {
        word2 = word2.toLowerCase();
        return result2 + (index2 ? capitalize2(word2) : word2);
      });
      function capitalize2(string2) {
        return upperFirst(toString2(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString2(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string2, target2, position) {
        string2 = toString2(string2);
        target2 = baseToString2(target2);
        var length = string2.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target2.length;
        return position >= 0 && string2.slice(position, end) == target2;
      }
      function escape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
      }
      function escapeRegExp(string2) {
        string2 = toString2(string2);
        return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
      }
      var kebabCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? "-" : "") + word2.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? " " : "") + word2.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string2, length, chars) {
        string2 = toString2(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        if (!length || strLength >= length) {
          return string2;
        }
        var mid2 = (length - strLength) / 2;
        return createPadding(nativeFloor(mid2), chars) + string2 + createPadding(nativeCeil(mid2), chars);
      }
      function padEnd(string2, length, chars) {
        string2 = toString2(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
      }
      function padStart(string2, length, chars) {
        string2 = toString2(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
      }
      function parseInt2(string2, radix2, guard) {
        if (guard || radix2 == null) {
          radix2 = 0;
        } else if (radix2) {
          radix2 = +radix2;
        }
        return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix2 || 0);
      }
      function repeat(string2, n2, guard) {
        if (guard ? isIterateeCall(string2, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString2(string2), n2);
      }
      function replace2() {
        var args = arguments, string2 = toString2(args[0]);
        return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? "_" : "") + word2.toLowerCase();
      });
      function split(string2, separator2, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string2, separator2, limit)) {
          separator2 = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string2 = toString2(string2);
        if (string2 && (typeof separator2 == "string" || separator2 != null && !isRegExp2(separator2))) {
          separator2 = baseToString2(separator2);
          if (!separator2 && hasUnicode(string2)) {
            return castSlice(stringToArray(string2), 0, limit);
          }
        }
        return string2.split(separator2, limit);
      }
      var startCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word2);
      });
      function startsWith(string2, target2, position) {
        string2 = toString2(string2);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
        target2 = baseToString2(target2);
        return string2.slice(position, position + target2.length) == target2;
      }
      function template(string2, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string2, options, guard)) {
          options = undefined$1;
        }
        string2 = toString2(string2);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate2 = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string2.replace(reDelimiters, function(match5, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string2.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset2 + match5.length;
          return match5;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return baseTrim(string2);
        }
        if (!string2 || !(chars = baseToString2(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end).join("");
      }
      function trimEnd(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return string2.slice(0, trimmedEndIndex(string2) + 1);
        }
        if (!string2 || !(chars = baseToString2(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return string2.replace(reTrimStart, "");
        }
        if (!string2 || !(chars = baseToString2(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string2, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator2 = "separator" in options ? options.separator : separator2;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString2(options.omission) : omission;
        }
        string2 = toString2(string2);
        var strLength = string2.length;
        if (hasUnicode(string2)) {
          var strSymbols = stringToArray(string2);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string2;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
        if (separator2 === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp2(separator2)) {
          if (string2.slice(end).search(separator2)) {
            var match5, substring = result2;
            if (!separator2.global) {
              separator2 = RegExp2(separator2.source, toString2(reFlags.exec(separator2)) + "g");
            }
            separator2.lastIndex = 0;
            while (match5 = separator2.exec(substring)) {
              var newEnd = match5.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string2.indexOf(baseToString2(separator2), end) != end) {
          var index2 = result2.lastIndexOf(separator2);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
      }
      var upperCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? " " : "") + word2.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard) {
        string2 = toString2(string2);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs2) {
        var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
        pairs2 = !length ? [] : arrayMap(pairs2, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs2[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant2(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches2(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path2, srcValue) {
        return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path2, args) {
        return function(object) {
          return baseInvoke(object, path2, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path2) {
          return baseInvoke(object, path2, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
      }
      function propertyOf(object) {
        return function(path2) {
          return object == null ? undefined$1 : baseGet(object, path2);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times2(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin2(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id2 = ++idCounter2;
        return toString2(prefix) + id2;
      }
      var add3 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide2 = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor2 = createRound("floor");
      function max2(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined$1;
      }
      function maxBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array2) {
        return baseMean(array2, identity2);
      }
      function meanBy(array2, iteratee2) {
        return baseMean(array2, getIteratee(iteratee2, 2));
      }
      function min2(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : undefined$1;
      }
      function minBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract2 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum2(array2) {
        return array2 && array2.length ? baseSum(array2, identity2) : 0;
      }
      function sumBy(array2, iteratee2) {
        return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey2;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant2;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy2;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy2;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove2;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set3;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update3;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap2;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add3;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide2;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor2;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty3;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join2;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace2;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some2;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract2;
      lodash2.sum = sum2;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times2;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax2(toInteger(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin2(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin2(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
        if (typeof path2 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path2, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root2._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var _$2 = lodash.exports;
//! moment.js
//! version : 2.29.3
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject$1(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a2, b2) {
  return Object.prototype.hasOwnProperty.call(a2, b2);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k2;
    for (k2 in obj) {
      if (hasOwnProp(obj, k2)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i2, arrLen = arr.length;
  for (i2 = 0; i2 < arrLen; ++i2) {
    res.push(fn(arr[i2], i2));
  }
  return res;
}
function extend$2(a2, b2) {
  for (var i2 in b2) {
    if (hasOwnProp(b2, i2)) {
      a2[i2] = b2[i2];
    }
  }
  if (hasOwnProp(b2, "toString")) {
    a2.toString = b2.toString;
  }
  if (hasOwnProp(b2, "valueOf")) {
    a2.valueOf = b2.valueOf;
  }
  return a2;
}
function createUTC(input, format3, locale2, strict) {
  return createLocalOrUTC(input, format3, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len2 = t2.length >>> 0, i2;
    for (i2 = 0; i2 < len2; i2++) {
      if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m2) {
  if (m2._isValid == null) {
    var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i2) {
      return i2 != null;
    }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m2)) {
      m2._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m2._isValid;
}
function createInvalid(flags) {
  var m2 = createUTC(NaN);
  if (flags != null) {
    extend$2(getParsingFlags(m2), flags);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i2, prop2, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i2 = 0; i2 < momentPropertiesLen; i2++) {
      prop2 = momentProperties[i2];
      val = from2[prop2];
      if (!isUndefined(val)) {
        to2[prop2] = val;
      }
    }
  }
  return to2;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend$2(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i2, key, argLen = arguments.length;
      for (i2 = 0; i2 < argLen; i2++) {
        arg = "";
        if (typeof arguments[i2] === "object") {
          arg += "\n[" + i2 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i2];
        }
        args.push(arg);
      }
      warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set$2(config2) {
  var prop2, i2;
  for (i2 in config2) {
    if (hasOwnProp(config2, i2)) {
      prop2 = config2[i2];
      if (isFunction(prop2)) {
        this[i2] = prop2;
      } else {
        this["_" + i2] = prop2;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend$2({}, parentConfig), prop2;
  for (prop2 in childConfig) {
    if (hasOwnProp(childConfig, prop2)) {
      if (isObject$1(parentConfig[prop2]) && isObject$1(childConfig[prop2])) {
        res[prop2] = {};
        extend$2(res[prop2], parentConfig[prop2]);
        extend$2(res[prop2], childConfig[prop2]);
      } else if (childConfig[prop2] != null) {
        res[prop2] = childConfig[prop2];
      } else {
        delete res[prop2];
      }
    }
  }
  for (prop2 in parentConfig) {
    if (hasOwnProp(parentConfig, prop2) && !hasOwnProp(childConfig, prop2) && isObject$1(parentConfig[prop2])) {
      res[prop2] = extend$2({}, res[prop2]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i2, res = [];
    for (i2 in obj) {
      if (hasOwnProp(obj, i2)) {
        res.push(i2);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(func.apply(this, arguments), token2);
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format3) {
  var array2 = format3.match(formattingTokens), i2, length;
  for (i2 = 0, length = array2.length; i2 < length; i2++) {
    if (formatTokenFunctions[array2[i2]]) {
      array2[i2] = formatTokenFunctions[array2[i2]];
    } else {
      array2[i2] = removeFormattingTokens(array2[i2]);
    }
  }
  return function(mom) {
    var output = "", i3;
    for (i3 = 0; i3 < length; i3++) {
      output += isFunction(array2[i3]) ? array2[i3].call(mom, format3) : array2[i3];
    }
    return output;
  };
}
function formatMoment(m2, format3) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format3 = expandFormat(format3, m2.localeData());
  formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
  return formatFunctions[format3](m2);
}
function expandFormat(format3, locale2) {
  var i2 = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i2 >= 0 && localFormattingTokens.test(format3)) {
    format3 = format3.replace(localFormattingTokens, replaceLongDateFormatTokens);
    localFormattingTokens.lastIndex = 0;
    i2 -= 1;
  }
  return format3;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format3 || !formatUpper) {
    return format3;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal$1(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string2, isFuture) {
  var output = this._relativeTime[string2];
  return isFunction(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format3) ? format3(output) : format3.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop2;
  for (prop2 in inputObject) {
    if (hasOwnProp(inputObject, prop2)) {
      normalizedProp = normalizeUnits(prop2);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop2];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u2;
  for (u2 in unitsObj) {
    if (hasOwnProp(unitsObj, u2)) {
      units.push({ unit: u2, priority: priorities[u2] });
    }
  }
  units.sort(function(a2, b2) {
    return a2.priority - b2.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get$2(this, unit);
    }
  };
}
function get$2(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
    for (i2 = 0; i2 < prioritizedLen; i2++) {
      this[prioritized[i2].unit](units[prioritized[i2].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex2, strictRegex) {
  regexes[token2] = isFunction(regex2) ? regex2 : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex2;
  };
}
function getParseRegexForToken(token2, config2) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config2._strict, config2._locale);
}
function unescapeFormat(s2) {
  return regexEscape(s2.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
    return p1 || p2 || p3 || p4;
  }));
}
function regexEscape(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i2, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array2) {
      array2[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    tokens[token2[i2]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array2, config2, token3) {
    config2._w = config2._w || {};
    callback(input, config2._w, config2, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config2) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config2._a, config2, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n2, x2) {
  return (n2 % x2 + x2) % x2;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o2) {
    var i2;
    for (i2 = 0; i2 < this.length; ++i2) {
      if (this[i2] === o2) {
        return i2;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format3) {
  return this.localeData().monthsShort(this, format3);
});
addFormatToken("MMMM", 0, 0, function(format3) {
  return this.localeData().months(this, format3);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array2) {
  array2[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array2, config2, token2) {
  var month = config2._locale.monthsParse(input, token2, config2._strict);
  if (month != null) {
    array2[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m2, format3) {
  if (!m2) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format3) {
  if (!m2) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format3, strict) {
  var i2, ii2, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i2 = 0; i2 < 12; ++i2) {
      mom = createUTC([2e3, i2]);
      this._shortMonthsParse[i2] = this.monthsShort(mom, "").toLocaleLowerCase();
      this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format3 === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format3 === "MMM") {
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._longMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeMonthsParse(monthName, format3, strict) {
  var i2, mom, regex2;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format3, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    if (strict && !this._longMonthsParse[i2]) {
      this._longMonthsParse[i2] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
      this._shortMonthsParse[i2] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
    }
    if (!strict && !this._monthsParse[i2]) {
      regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i2] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format3 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (strict && format3 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (!strict && this._monthsParse[i2].test(monthName)) {
      return i2;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get$2(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i2 = 0; i2 < 12; i2++) {
    shortPieces[i2] = regexEscape(shortPieces[i2]);
    longPieces[i2] = regexEscape(longPieces[i2]);
  }
  for (i2 = 0; i2 < 24; i2++) {
    mixedPieces[i2] = regexEscape(mixedPieces[i2]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
}
addFormatToken("Y", 0, 0, function() {
  var y2 = this.year();
  return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array2) {
  array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array2) {
  array2[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array2) {
  array2[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y2, m2, d2, h2, M2, s2, ms2) {
  var date;
  if (y2 < 100 && y2 >= 0) {
    date = new Date(y2 + 400, m2, d2, h2, M2, s2, ms2);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y2);
    }
  } else {
    date = new Date(y2, m2, d2, h2, M2, s2, ms2);
  }
  return date;
}
function createUTCDate(y2) {
  var date, args;
  if (y2 < 100 && y2 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y2 + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y2);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config2, token2) {
  week[token2.substr(0, 1)] = toInt(input);
});
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  doy: 6
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format3) {
  return this.localeData().weekdaysMin(this, format3);
});
addFormatToken("ddd", 0, 0, function(format3) {
  return this.localeData().weekdaysShort(this, format3);
});
addFormatToken("dddd", 0, 0, function(format3) {
  return this.localeData().weekdays(this, format3);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
  var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format3) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format3, strict) {
  var i2, ii2, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i2 = 0; i2 < 7; ++i2) {
      mom = createUTC([2e3, 1]).day(i2);
      this._minWeekdaysParse[i2] = this.weekdaysMin(mom, "").toLocaleLowerCase();
      this._shortWeekdaysParse[i2] = this.weekdaysShort(mom, "").toLocaleLowerCase();
      this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format3 === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format3 === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format3 === "dddd") {
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format3 === "ddd") {
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf.call(this._minWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format3, strict) {
  var i2, mom, regex2;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format3, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    if (strict && !this._fullWeekdaysParse[i2]) {
      this._fullWeekdaysParse[i2] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
      this._shortWeekdaysParse[i2] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
      this._minWeekdaysParse[i2] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
    }
    if (!this._weekdaysParse[i2]) {
      regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i2] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format3 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format3 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
      return i2;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array2, config2) {
  var kInput = toInt(input);
  array2[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array2, config2) {
  config2._isPm = config2._locale.isPM(input);
  config2._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array2, config2) {
  array2[HOUR] = toInt(input);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input, array2, config2) {
  var pos = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos));
  array2[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input, array2, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos1));
  array2[MINUTE] = toInt(input.substr(pos1, 2));
  array2[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input, array2, config2) {
  var pos = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos));
  array2[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array2, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos1));
  array2[MINUTE] = toInt(input.substr(pos1, 2));
  array2[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i2, minl = Math.min(arr1.length, arr2.length);
  for (i2 = 0; i2 < minl; i2 += 1) {
    if (arr1[i2] !== arr2[i2]) {
      return i2;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i2 = 0, j2, next, locale2, split;
  while (i2 < names.length) {
    split = normalizeLocale(names[i2]).split("-");
    j2 = split.length;
    next = normalizeLocale(names[i2 + 1]);
    next = next ? next.split("-") : null;
    while (j2 > 0) {
      locale2 = loadLocale(split.slice(0, j2).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
        break;
      }
      j2--;
    }
    i2++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e2) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data2;
  if (key) {
    if (isUndefined(values)) {
      data2 = getLocale(key);
    } else {
      data2 = defineLocale(key, values);
    }
    if (data2) {
      globalLocale = data2;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("Locale " + key + " not found. Did you forget to load it?");
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config2) {
  if (config2 !== null) {
    var locale2, parentConfig = baseConfig;
    config2.abbr = name;
    if (locales[name] != null) {
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
      parentConfig = locales[name]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale2 = loadLocale(config2.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x2) {
        defineLocale(x2.name, x2.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config2) {
  if (config2 != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config2));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name;
      }
      locale2 = new Locale(config2);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m2) {
  var overflow, a2 = m2._a;
  if (a2 && getParsingFlags(m2).overflow === -2) {
    overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i2, l2, string2 = config2._i, match5 = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match5) {
    getParsingFlags(config2).iso = true;
    for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
      if (isoDates[i2][1].exec(match5[1])) {
        dateFormat = isoDates[i2][0];
        allowTime = isoDates[i2][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
        if (isoTimes[i2][1].exec(match5[3])) {
          timeFormat = (match5[2] || " ") + isoTimes[i2][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
    return h2 * 60 + m2;
  }
}
function configFromRFC2822(config2) {
  var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(match5[4], match5[3], match5[2], match5[5], match5[6], match5[7]);
    if (!checkWeekday(match5[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match5[8], match5[9], match5[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config2) {
  config2._d = new Date(config2._i + (config2._useUTC ? " UTC" : ""));
});
function defaults(a2, b2, c2) {
  if (a2 != null) {
    return a2;
  }
  if (b2 != null) {
    return b2;
  }
  return c2;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date.getUTCMonth();
    config2._a[DATE] = date.getUTCDate();
  }
  for (i2 = 0; i2 < 3 && config2._a[i2] == null; ++i2) {
    config2._a[i2] = input[i2] = currentDate[i2];
  }
  for (; i2 < 7; i2++) {
    config2._a[i2] = input[i2] = config2._a[i2] == null ? i2 === 2 ? 1 : 0 : config2._a[i2];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(null, input);
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w2 = config2._w;
  if (w2.GG != null || w2.W != null || w2.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(w2.GG, config2._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
    week = defaults(w2.W, 1);
    weekday = defaults(w2.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w2.gg, config2._a[YEAR], curWeek.year);
    week = defaults(w2.w, curWeek.week);
    if (w2.d != null) {
      weekday = w2.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w2.e != null) {
      weekday = w2.e + dow;
      if (w2.e < 0 || w2.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string2 = "" + config2._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    token2 = tokens2[i2];
    parsedInput = (string2.match(getParseRegexForToken(token2, config2)) || [])[0];
    if (parsedInput) {
      skipped = string2.substr(0, string2.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string2 = string2.slice(string2.indexOf(parsedInput) + parsedInput.length);
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string2.length > 0) {
    getParsingFlags(config2).unusedInput.push(string2);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(config2._locale, config2._a[HOUR], config2._meridiem);
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale2, hour2, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour2;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour2, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour2 < 12) {
      hour2 += 12;
    }
    if (!isPm && hour2 === 12) {
      hour2 = 0;
    }
    return hour2;
  } else {
    return hour2;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = new Date(NaN);
    return;
  }
  for (i2 = 0; i2 < configfLen; i2++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i2];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend$2(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i2 = normalizeObjectUnits(config2._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
  config2._a = map([i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond], function(obj) {
    return obj && parseInt(obj, 10);
  });
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input = config2._i, format3 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input === null || format3 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config2._i = input = config2._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config2._d = input;
  } else if (isArray(format3)) {
    configFromStringAndArray(config2);
  } else if (format3) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input = config2._i;
  if (isUndefined(input)) {
    config2._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config2._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config2);
  } else if (isArray(input)) {
    config2._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject$1(input)) {
    configFromObject(config2);
  } else if (isNumber(input)) {
    config2._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
  var c2 = {};
  if (format3 === true || format3 === false) {
    strict = format3;
    format3 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$1(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale2;
  c2._i = input;
  c2._f = format3;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input, format3, locale2, strict) {
  return createLocalOrUTC(input, format3, locale2, strict, false);
}
var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other < this ? this : other;
  } else {
    return createInvalid();
  }
}), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
  var other = createLocal.apply(null, arguments);
  if (this.isValid() && other.isValid()) {
    return other > this ? this : other;
  } else {
    return createInvalid();
  }
});
function pickBy(fn, moments) {
  var res, i2;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i2 = 1; i2 < moments.length; ++i2) {
    if (!moments[i2].isValid() || moments[i2][fn](res)) {
      res = moments[i2];
    }
  }
  return res;
}
function min$2() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max$2() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now$4 = function() {
  return Date.now ? Date.now() : +new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i2, orderLen = ordering.length;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i2 = 0; i2 < orderLen; ++i2) {
    if (m2[ordering[i2]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len2 = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
  for (i2 = 0; i2 < len2; i2++) {
    if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator2) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator2 + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array2, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher2, string2) {
  var matches2 = (string2 || "").match(matcher2), chunk, parts, minutes2;
  if (matches2 === null) {
    return null;
  }
  chunk = matches2[matches2.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match5 = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match5 = aspNetRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
    };
  } else if (match5 = isoRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base2, other) {
  var res = {};
  res.months = other.month() - base2.month() + (other.year() - base2.year()) * 12;
  if (base2.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base2.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base2, other) {
  var res;
  if (!(base2.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base2);
  if (base2.isBefore(other)) {
    res = positiveMomentsDifference(base2, other);
  } else {
    res = positiveMomentsDifference(other, base2);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period2) {
    var dur, tmp;
    if (period2 !== null && !isNaN(+period2)) {
      deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
      tmp = val;
      val = period2;
      period2 = tmp;
    }
    dur = createDuration(val, period2);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get$2(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1$1(mom, "Date", get$2(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add$4 = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i2, property, propertyLen = properties.length;
  for (i2 = 0; i2 < propertyLen; i2 += 1) {
    property = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i2, property;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format3]) ? formats[format3].call(this, now2) : formats[format3]);
  return this.format(output || this.localeData().calendar(format3, this, createLocal(now2)));
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a2, b2) {
  if (a2.date() < b2.date()) {
    return -monthDiff(b2, a2);
  }
  var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b2 - anchor < 0) {
    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b2 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b2 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(m2, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(m2, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
  if (key === void 0) {
    return this.localeData();
  } else {
    return this.locale(key);
  }
});
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return new Date(y2, m2, d2).valueOf();
  }
}
function utcStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y2, m2, d2);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
      break;
    case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend$2({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array2, config2, token2) {
  var era = config2._locale.erasParse(input, token2, config2._strict);
  if (era) {
    getParsingFlags(config2).era = era;
  } else {
    getParsingFlags(config2).invalidEra = input;
  }
});
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array2, config2, token2) {
  var match5;
  if (config2._locale._eraYearOrdinalRegex) {
    match5 = input.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array2[YEAR] = config2._locale.eraYearOrdinalParse(input, match5);
  } else {
    array2[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m2, format3) {
  var i2, l2, date, eras = this._eras || getLocale("en")._eras;
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    switch (typeof eras[i2].since) {
      case "string":
        date = hooks(eras[i2].since).startOf("day");
        eras[i2].since = date.valueOf();
        break;
    }
    switch (typeof eras[i2].until) {
      case "undefined":
        eras[i2].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i2].until).startOf("day").valueOf();
        eras[i2].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format3, strict) {
  var i2, l2, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    name = eras[i2].name.toUpperCase();
    abbr = eras[i2].abbr.toUpperCase();
    narrow = eras[i2].narrow.toUpperCase();
    if (strict) {
      switch (format3) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i2];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i2];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i2];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i2];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].name;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].narrow;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].abbr;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i2, l2, dir, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
      return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    namePieces.push(regexEscape(eras[i2].name));
    abbrPieces.push(regexEscape(eras[i2].abbr));
    narrowPieces.push(regexEscape(eras[i2].narrow));
    mixedPieces.push(regexEscape(eras[i2].name));
    mixedPieces.push(regexEscape(eras[i2].abbr));
    mixedPieces.push(regexEscape(eras[i2].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config2, token2) {
  week[token2.substr(0, 2)] = toInt(input);
});
addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array2) {
  array2[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array2) {
  array2[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array2, config2) {
  config2._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array2) {
  array2[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add$4;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string2) {
  return string2;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal$1;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set$2;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1$1(format3, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format3);
}
function listMonthsImpl(format3, index2, field) {
  if (isNumber(format3)) {
    index2 = format3;
    format3 = void 0;
  }
  format3 = format3 || "";
  if (index2 != null) {
    return get$1$1(format3, index2, field, "month");
  }
  var i2, out = [];
  for (i2 = 0; i2 < 12; i2++) {
    out[i2] = get$1$1(format3, i2, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format3, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format3)) {
      index2 = format3;
      format3 = void 0;
    }
    format3 = format3 || "";
  } else {
    format3 = localeSorted;
    index2 = format3;
    localeSorted = false;
    if (isNumber(format3)) {
      index2 = format3;
      format3 = void 0;
    }
    format3 = format3 || "";
  }
  var locale2 = getLocale(), shift2 = localeSorted ? locale2._week.dow : 0, i2, out = [];
  if (index2 != null) {
    return get$1$1(format3, (index2 + shift2) % 7, field, "day");
  }
  for (i2 = 0; i2 < 7; i2++) {
    out[i2] = get$1$1(format3, (i2 + shift2) % 7, field, "day");
  }
  return out;
}
function listMonths(format3, index2) {
  return listMonthsImpl(format3, index2, "months");
}
function listMonthsShort(format3, index2) {
  return listMonthsImpl(format3, index2, "monthsShort");
}
function listWeekdays(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
var mathAbs = Math.abs;
function abs$2() {
  var data2 = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data2.milliseconds = mathAbs(data2.milliseconds);
  data2.seconds = mathAbs(data2.seconds);
  data2.minutes = mathAbs(data2.minutes);
  data2.hours = mathAbs(data2.hours);
  data2.months = mathAbs(data2.months);
  data2.years = mathAbs(data2.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data2 = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data2.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data2.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data2.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data2.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data2.days = days2;
  data2.months = months2;
  data2.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1() {
  return createDuration(this);
}
function get$2$1(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  s: 45,
  m: 45,
  h: 22,
  d: 26,
  w: null,
  M: 11
};
function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a2[2] = withoutSuffix;
  a2[3] = +posNegDuration > 0;
  a2[4] = locale2;
  return substituteTimeAgo.apply(null, a2);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1$1 = Math.abs;
function sign(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1$1(this._milliseconds) / 1e3, days2 = abs$1$1(this._days), months2 = abs$1$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs$2;
proto$2.add = add$1$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2$1;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array2, config2) {
  config2._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array2, config2) {
  config2._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.29.3";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min$2;
hooks.max = max$2;
hooks.now = now$4;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm",
  TIME_SECONDS: "HH:mm:ss",
  TIME_MS: "HH:mm:ss.SSS",
  WEEK: "GGGG-[W]WW",
  MONTH: "YYYY-MM"
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d2 });
    }, reject);
  }
}
const isPlatformWeb = () => {
  return typeof window !== "undefined";
};
isPlatformWeb() ? [] : ({}.TEST_GUN_PEERS || "").split(",").map((peer) => peer.trim()).filter((peer) => !!peer);
function isInRange(key, range2) {
  if (isValueRangeEmpty(range2)) {
    return false;
  }
  let { start: start2, end, startClosed, endClosed } = range2;
  let keyValue = key.valueOf();
  if (typeof start2 !== "undefined") {
    let startValue = start2.valueOf();
    if (keyValue < startValue)
      return false;
    if (!startClosed && keyValue === startValue)
      return false;
  }
  if (typeof end !== "undefined") {
    let endValue = end.valueOf();
    if (keyValue > endValue)
      return false;
    if (!endClosed && keyValue === endValue)
      return false;
  }
  return true;
}
function filteredIndexRange(keys2, range2) {
  if (isValueRangeEmpty(range2)) {
    return [0, 0];
  }
  let len2 = keys2.length;
  if (len2 === 0) {
    return [0, 0];
  }
  if (len2 === 1) {
    if (isInRange(keys2[0], range2)) {
      return [0, 1];
    } else {
      return [0, 0];
    }
  }
  let { start: start2, end, startClosed = true, endClosed = false } = range2;
  let iStart = 0;
  if (typeof start2 !== "undefined") {
    iStart = _$2.sortedIndex(keys2, start2);
    let key = keys2[iStart];
    if (key <= start2 && !startClosed) {
      iStart += 1;
    }
  }
  let iEnd = len2 - 1;
  if (typeof end !== "undefined") {
    iEnd = _$2.sortedIndex(keys2, end);
    let key = keys2[iEnd];
    if (key >= end && !endClosed) {
      iEnd -= 1;
    }
    iEnd = Math.min(iEnd, len2 - 1);
  }
  if (iStart > iEnd) {
    return [0, 0];
  }
  return [iStart, iEnd + 1];
}
const isValueRangeEmpty = (range2) => {
  let { start: start2, end, startClosed, endClosed } = range2;
  if (typeof start2 !== "undefined" && typeof end !== "undefined") {
    if (start2 == end && !(startClosed && endClosed)) {
      return true;
    } else if (start2 > end) {
      return true;
    }
  }
  return false;
};
function rangeWithFilter(filter2) {
  let { gt: gt2, gte, lt: lt2, lte } = filter2 || {};
  let range2 = {
    start: void 0,
    end: void 0,
    startClosed: false,
    endClosed: false
  };
  if (typeof gte !== "undefined") {
    range2.start = gte;
    range2.startClosed = true;
  } else if (typeof gt2 !== "undefined") {
    range2.start = gt2;
  }
  if (typeof lte !== "undefined") {
    range2.end = lte;
    range2.endClosed = true;
  } else if (typeof lt2 !== "undefined") {
    range2.end = lt2;
  }
  return range2;
}
function filterWithRange(range2) {
  let { start: start2, end, startClosed, endClosed } = range2;
  let filter2 = {};
  if (startClosed) {
    filter2.gte = start2;
  } else {
    filter2.gt = start2;
  }
  if (endClosed) {
    filter2.lte = end;
  } else {
    filter2.lt = end;
  }
  return filter2;
}
function mapValueRange(range2, map2) {
  return {
    start: typeof range2.start !== "undefined" ? map2(range2.start) : void 0,
    end: typeof range2.end !== "undefined" ? map2(range2.end) : void 0,
    startClosed: range2.startClosed,
    endClosed: range2.endClosed
  };
}
function subscribe(ref2, callback, opt) {
  let internalSub;
  let didUnsub = false;
  let externalSub = {
    off: () => {
      if (didUnsub) {
        return;
      }
      didUnsub = true;
      internalSub === null || internalSub === void 0 ? void 0 : internalSub.off();
      internalSub = void 0;
    }
  };
  ref2.on((data2, key, at2, sub2) => {
    if (didUnsub) {
      sub2.off();
      return;
    }
    internalSub = sub2;
    try {
      callback(data2, key, at2, Object.assign(Object.assign({}, sub2), externalSub));
    } catch (error2) {
      externalSub.off();
      throw error2;
    }
  }, opt);
  return externalSub;
}
const ASC_ORDER = 1;
function iterateRecord(ref2, opts = {}) {
  if (!ref2) {
    throw new Error("Invalid Gun node reference");
  }
  return _iterateSortedRecord(ref2, opts);
}
function _iterateSortedRecord(ref2, opts) {
  var _a2;
  return __asyncGenerator(this, arguments, function* _iterateSortedRecord_1() {
    let order2 = opts.order || ASC_ORDER;
    let range2 = rangeWithFilter(opts);
    if (isValueRangeEmpty(range2)) {
      return yield __await(void 0);
    }
    let obj = yield __await(ref2.then());
    if (typeof obj === "undefined" || obj === null) {
      return yield __await(void 0);
    }
    if (typeof obj !== "object") {
      throw new Error(`Cannot iterate keys of non-object record "${obj}" at key "${(_a2 = ref2._) === null || _a2 === void 0 ? void 0 : _a2.get}"`);
    }
    obj = _$2.omit(obj, "_");
    let keys2 = Object.keys(obj).sort();
    let [iStart, iEnd] = filteredIndexRange(keys2, range2);
    if (iStart >= iEnd) {
      return yield __await(void 0);
    }
    let key;
    if (order2 >= 0) {
      for (let i2 = iStart; i2 < iEnd; i2++) {
        key = keys2[i2];
        yield yield __await([obj[key], key]);
      }
    } else {
      for (let i2 = iEnd - 1; i2 >= iStart; i2--) {
        key = keys2[i2];
        yield yield __await([obj[key], key]);
      }
    }
  });
}
function iterateRefs(ref2, opts) {
  return __asyncGenerator(this, arguments, function* iterateRefs_1() {
    var e_2, _a2;
    let innerRef;
    try {
      for (var _b = __asyncValues(iterateRecord(ref2, opts)), _c; _c = yield __await(_b.next()), !_c.done; ) {
        let [val, key] = _c.value;
        innerRef = ref2.get(key);
        yield yield __await([innerRef, key]);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          yield __await(_a2.call(_b));
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  });
}
const ALL_DATE_UNITS = [
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
const DATE_UNIT_SET = new Set(ALL_DATE_UNITS);
const ZERO_DATE = hooks.utc().startOf("year").set("year", 1);
class DateTree {
  constructor(root2, resolution) {
    if (!DateTree.isResolution(resolution)) {
      throw new Error("Invalid graph date resolution: " + resolution);
    }
    this.root = root2;
    this.resolution = resolution;
  }
  nextDate(date) {
    let m2 = DateTree.parseDate(date);
    let floor2 = m2.startOf(this.resolution);
    let next = floor2.add(1, this.resolution);
    return next;
  }
  previousDate(date) {
    let m2 = DateTree.parseDate(date);
    let floor2 = m2.startOf(this.resolution);
    if (floor2.isSame(m2)) {
      floor2 = floor2.subtract(1, this.resolution);
    }
    return floor2;
  }
  on(cb, opts = {}) {
    let range2 = mapValueRange(rangeWithFilter(opts), (x2) => DateTree.parseDate(x2, this.resolution));
    let { start: start2, end } = range2;
    if (!start2 && !end) {
      return this._onAny(cb);
    }
    let startComps = start2 && DateTree.getDateComponents(start2, this.resolution) || {};
    let endComps = end && DateTree.getDateComponents(end, this.resolution) || {};
    let commonUnit = DateTree.largestCommonUnit(startComps, endComps);
    let commonComps = commonUnit ? DateTree.downsampleDateComponents(startComps, commonUnit) : {};
    let mapTable = {};
    let subTable = {};
    let didUnsub = false;
    let commonSub = {
      off: () => {
        if (didUnsub) {
          return;
        }
        didUnsub = true;
        for (let sub2 of Object.values(subTable)) {
          sub2.off();
        }
        subTable = {};
      }
    };
    const beginSub = (comps, unit) => {
      if (didUnsub) {
        return;
      }
      let compKey = DateTree.dateComponentsToString(comps, unit);
      if (compKey in mapTable) {
        return;
      }
      let innerRef = this._getRef(comps);
      let innerUnit = unit ? DateTree.getSmallerUnit(unit) : "year";
      let innerRange = DateTree.getDateComponentKeyRange(comps, {
        start: startComps,
        end: endComps
      }, innerUnit);
      let { start: innerStart, end: innerEnd } = innerRange;
      if (typeof innerStart !== "undefined" || typeof innerEnd !== "undefined") {
        let lexRange = {};
        if (typeof innerStart !== "undefined") {
          lexRange[">"] = innerStart;
        }
        if (typeof innerEnd !== "undefined") {
          lexRange["<"] = innerEnd;
        }
        innerRef = innerRef.get({ ".": lexRange });
      }
      let map2 = innerRef.map();
      mapTable[compKey] = map2;
      subTable[compKey] = subscribe(map2, (data2, key, at2, innerSub) => {
        let value = DateTree.decodeDateComponent(key);
        let innerComps = Object.assign(Object.assign({}, comps), { [innerUnit]: value });
        if (innerUnit === this.resolution) {
          let date = DateTree.getDateWithComponents(innerComps);
          if (isInRange(date, range2)) {
            cb(data2, date, at2, commonSub);
          }
        } else {
          beginSub(innerComps, innerUnit);
        }
      });
    };
    beginSub(commonComps, commonUnit);
    return commonSub;
  }
  _onAny(cb) {
    let units = this._allUnits();
    let ref2 = this.root.map();
    for (let i2 = 0; i2 < units.length - 1; i2++) {
      ref2 = ref2.map();
    }
    return ref2.on((data2, key, at2, event) => {
      let date = this.getDate(at2);
      cb(data2, date, at2, event);
    });
  }
  changesAbout(date, callback) {
    let m2 = DateTree.parseDate(date);
    let comps = DateTree.getDateComponents(m2, this.resolution);
    let units = Object.keys(comps);
    let refs = this._getRefChain(comps);
    let refTable = _$2.zipObject(units, refs);
    let subTable = {};
    let didUnsub = false;
    let commonSub = {
      off: () => {
        if (didUnsub) {
          return;
        }
        didUnsub = true;
        for (let sub2 of Object.values(subTable)) {
          sub2.off();
        }
        subTable = {};
      }
    };
    _$2.forIn(refTable, (ref2, unit) => {
      subTable[unit] = subscribe(ref2, (changes, outerKey, at2, sub2) => {
        _$2.forIn(changes, (val, key) => {
          if (key === "_") {
            return;
          }
          let changedUnit = unit;
          let changeComps = DateTree.downsampleDateComponents(comps, changedUnit);
          let compVal = DateTree.decodeDateComponent(key);
          if (compVal !== changeComps[changedUnit]) {
            changeComps[changedUnit] = compVal;
          } else {
            return;
          }
          try {
            callback(changeComps, commonSub);
          } catch (error2) {
            console.error(`Uncaught error in DateTree: ${error2}`);
          }
        });
      }, { change: true });
    });
    return commonSub;
  }
  getDate(ref2) {
    var _a2, _b, _c, _d, _e, _f2;
    let currentRef = ref2;
    let units = this._allUnits();
    let keys2 = [];
    let ok = true;
    const getKey = (ref3) => {
      var _a3, _b2, _c2, _d2;
      return ((_a3 = ref3._) === null || _a3 === void 0 ? void 0 : _a3.get) || ref3.get || ((_b2 = ref3.$) === null || _b2 === void 0 ? void 0 : _b2.get) || ((_d2 = (_c2 = ref3.$) === null || _c2 === void 0 ? void 0 : _c2._) === null || _d2 === void 0 ? void 0 : _d2.get);
    };
    const rootKey = getKey(this.root);
    while (currentRef && keys2.length < units.length) {
      let key = getKey(currentRef);
      if (!key || key === rootKey) {
        ok = false;
        break;
      }
      keys2.unshift(key);
      if (typeof currentRef.back === "function") {
        currentRef = currentRef.back();
      } else if (typeof ((_b = (_a2 = currentRef.$) === null || _a2 === void 0 ? void 0 : _a2._) === null || _b === void 0 ? void 0 : _b.back) === "object") {
        currentRef = (_d = (_c = currentRef.$) === null || _c === void 0 ? void 0 : _c._) === null || _d === void 0 ? void 0 : _d.back;
      } else if (typeof ((_e = currentRef.$) === null || _e === void 0 ? void 0 : _e.back) === "function") {
        currentRef = (_f2 = currentRef.$) === null || _f2 === void 0 ? void 0 : _f2.back();
      } else {
        ok = false;
        break;
      }
    }
    if (getKey(currentRef) !== rootKey) {
      ok = false;
    }
    if (!ok) {
      throw new Error("Invalid Gun node reference. Expected a leaf on the date tree.");
    }
    let values = keys2.map((k2) => DateTree.decodeDateComponent(k2));
    let comps = _$2.zipObject(units, values);
    return DateTree.getDateWithComponents(comps);
  }
  get(date) {
    let comps = DateTree.getDateComponents(DateTree.parseDate(date), this.resolution);
    let chain = this._getRefChain(comps);
    return chain[chain.length - 1];
  }
  _getRefChain(comps) {
    let ref2 = this.root;
    let refs = [ref2];
    _$2.forIn(comps, (val, unit) => {
      let key = DateTree.encodeDateComponent(val, unit);
      ref2 = ref2.get(key);
      refs.push(ref2);
    });
    return refs;
  }
  _getRef(comps) {
    let chain = this._getRefChain(comps);
    return chain[chain.length - 1];
  }
  latest() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.previous();
    });
  }
  earliest() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.next();
    });
  }
  next(date) {
    var e_1, _a2;
    return __awaiter(this, void 0, void 0, function* () {
      let it2 = this.iterate({
        gt: date && DateTree.parseDate(date, this.resolution) || void 0,
        order: 1
      });
      try {
        for (var it_1 = __asyncValues(it2), it_1_1; it_1_1 = yield it_1.next(), !it_1_1.done; ) {
          let [ref2, refDate] = it_1_1.value;
          if (date) {
            if (refDate.isSame(date)) {
              continue;
            } else if (refDate.isBefore(date)) {
              throw new Error(`Unexpected date ${refDate} after ${date}`);
            }
          }
          return [ref2, refDate];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (it_1_1 && !it_1_1.done && (_a2 = it_1.return))
            yield _a2.call(it_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return [void 0, void 0];
    });
  }
  previous(date) {
    var e_2, _a2;
    return __awaiter(this, void 0, void 0, function* () {
      let it2 = this.iterate({
        lt: date && DateTree.parseDate(date, this.resolution) || void 0,
        order: -1
      });
      try {
        for (var it_2 = __asyncValues(it2), it_2_1; it_2_1 = yield it_2.next(), !it_2_1.done; ) {
          let [ref2, refDate] = it_2_1.value;
          if (date) {
            if (refDate.isSame(date)) {
              continue;
            } else if (refDate.isAfter(date)) {
              throw new Error(`Unexpected date ${refDate} before ${date}`);
            }
          }
          return [ref2, refDate];
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (it_2_1 && !it_2_1.done && (_a2 = it_2.return))
            yield _a2.call(it_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return [void 0, void 0];
    });
  }
  iterate(opts = {}) {
    return __asyncGenerator(this, arguments, function* iterate_1() {
      var e_3, _a2;
      let range2 = mapValueRange(rangeWithFilter(opts), (x2) => DateTree.parseDate(x2, this.resolution));
      let { start: start2, end } = range2;
      let { order: order2 } = opts;
      let ref2 = this.root;
      let startComps = start2 && DateTree.getDateComponents(start2, this.resolution) || {};
      let endComps = end && DateTree.getDateComponents(end, this.resolution) || {};
      let comps = {};
      let units = this._allUnits();
      let unitIndex = 0;
      let unitsLen = units.length;
      let it2;
      let itStack = [];
      while (unitIndex >= 0) {
        let goUp = false;
        let unit = units[unitIndex];
        let atLeaf = unitIndex === unitsLen - 1;
        if (ref2) {
          let range3 = DateTree.getDateComponentKeyRange(comps, {
            start: startComps,
            end: endComps
          }, unit);
          let filter2 = filterWithRange(range3);
          it2 = this._iterateRef(ref2, Object.assign(Object.assign({}, filter2), { order: order2 }));
          itStack.unshift(it2);
          ref2 = void 0;
        }
        if (it2 && atLeaf) {
          try {
            for (var it_3 = (e_3 = void 0, __asyncValues(it2)), it_3_1; it_3_1 = yield __await(it_3.next()), !it_3_1.done; ) {
              let [innerRef, compVal] = it_3_1.value;
              comps[unit] = compVal;
              let date = DateTree.getDateWithComponents(comps, this.resolution);
              if (isInRange(date, range2)) {
                yield yield __await([innerRef, date]);
              }
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (it_3_1 && !it_3_1.done && (_a2 = it_3.return))
                yield __await(_a2.call(it_3));
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          goUp = true;
        }
        if (!goUp) {
          let next = yield __await(itStack[0].next());
          if (next.done) {
            goUp = true;
          } else {
            ref2 = next.value[0];
            comps[unit] = next.value[1];
            unitIndex += 1;
          }
        }
        if (goUp) {
          itStack.shift();
          unitIndex -= 1;
          if (unit in comps) {
            delete comps[unit];
          }
          continue;
        }
      }
    });
  }
  _iterateRef(ref2, opts) {
    return __asyncGenerator(this, arguments, function* _iterateRef_1() {
      var e_4, _a2;
      try {
        for (var _b = __asyncValues(iterateRefs(ref2, opts)), _c; _c = yield __await(_b.next()), !_c.done; ) {
          let [innerRef, key] = _c.value;
          let val = DateTree.decodeDateComponent(key);
          yield yield __await([innerRef, val]);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            yield __await(_a2.call(_b));
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    });
  }
  _allUnits() {
    let units = [];
    for (let res of ALL_DATE_UNITS) {
      units.push(res);
      if (res === this.resolution) {
        break;
      }
    }
    return units;
  }
  static lowerUnit(unit) {
    let i2 = ALL_DATE_UNITS.indexOf(unit);
    if (i2 < 0) {
      return void 0;
    }
    return ALL_DATE_UNITS[i2 - 1];
  }
  static getDateWithComponents(comps, resolution) {
    let c2 = comps;
    let m2 = ZERO_DATE.clone();
    for (let res of ALL_DATE_UNITS) {
      if (res in comps) {
        let val = nativeDateValue(c2[res], res);
        m2.set(nativeDateUnit(res), val);
      } else {
        break;
      }
      if (res === resolution) {
        break;
      }
    }
    return m2;
  }
  static getDateComponents(date, resolution) {
    let m2 = this.parseDate(date);
    if (!this.isResolution(resolution)) {
      throw new Error("Invalid graph date resolution: " + resolution);
    }
    let comps = {};
    for (let res of ALL_DATE_UNITS) {
      comps[res] = this.getDateComponent(m2, res);
      if (res === resolution) {
        break;
      }
    }
    return comps;
  }
  static getDateComponent(date, unit) {
    let m2 = this.parseDate(date);
    let val = m2.get(nativeDateUnit(unit));
    return graphDateValue(val, unit);
  }
  static largestCommonUnit(comp1, comp2) {
    let commonUnit;
    for (let unit of ALL_DATE_UNITS) {
      if (comp1[unit] === comp2[unit]) {
        commonUnit = unit;
      } else {
        break;
      }
    }
    return commonUnit;
  }
  static encodeDateComponent(value, unit) {
    if (typeof value === "undefined") {
      return void 0;
    }
    let key = value.toString();
    let padLen = DATE_COMP_PADS[unit];
    return key.padStart(padLen, "0");
  }
  static decodeDateComponent(key) {
    return Math.round(parseFloat(key));
  }
  static downsampleDateComponents(components, resolution) {
    let newComponents = {};
    for (let res of ALL_DATE_UNITS) {
      newComponents[res] = components[res];
      if (res === resolution) {
        break;
      }
    }
    return newComponents;
  }
  static getDateComponentKeyRange(comps, compRange, unit) {
    let [startVal, endVal] = DateTree.getDateComponentRange(comps, compRange.start, compRange.end, unit);
    return {
      start: DateTree.encodeDateComponent(startVal, unit),
      end: DateTree.encodeDateComponent(endVal, unit),
      startClosed: true,
      endClosed: true
    };
  }
  static getDateComponentRange(comps, startComps, endComps, unit) {
    let startVal = startComps[unit];
    let endVal = endComps[unit];
    if (typeof startVal === "undefined" && typeof endVal === "undefined") {
      return [startVal, endVal];
    }
    let upUnit = this.getBiggerUnit(unit);
    if (!upUnit) {
      return [startVal, endVal];
    }
    let upComps = this.downsampleDateComponents(comps, upUnit);
    if (typeof startVal !== "undefined") {
      let upStartComps = this.downsampleDateComponents(startComps, upUnit);
      if (!_$2.isEqual(upStartComps, upComps)) {
        startVal = void 0;
      }
    }
    if (typeof endVal !== "undefined") {
      let upEndComps = DateTree.downsampleDateComponents(endComps, upUnit);
      if (!_$2.isEqual(upEndComps, upComps)) {
        endVal = void 0;
      }
    }
    return [startVal, endVal];
  }
  static getBiggerUnit(unit) {
    let i2 = ALL_DATE_UNITS.indexOf(unit);
    if (i2 < 0)
      return void 0;
    return ALL_DATE_UNITS[i2 - 1];
  }
  static getSmallerUnit(unit) {
    let i2 = ALL_DATE_UNITS.indexOf(unit);
    if (i2 === ALL_DATE_UNITS.length - 1)
      return void 0;
    return ALL_DATE_UNITS[i2 + 1];
  }
  static dateComponentsToString(comp2, resolution) {
    let str = "";
    for (let unit of ALL_DATE_UNITS) {
      if (!(resolution || unit in comp2)) {
        break;
      }
      let val = this.encodeDateComponent(comp2[unit], unit);
      switch (unit) {
        case "year":
          break;
        case "month":
        case "day":
          str += "-";
          break;
        case "hour":
          str += "T";
          break;
        case "minute":
        case "second":
          str += ":";
          break;
        case "millisecond":
          str += ".";
          break;
      }
      str += val;
      if (unit === "millisecond") {
        str += "Z";
      }
      if (unit === resolution) {
        break;
      }
    }
    return str;
  }
  static isResolution(resolution) {
    if (typeof resolution !== "string")
      return false;
    return DATE_UNIT_SET.has(resolution);
  }
  static parseDate(date, resolution) {
    if (!date || typeof date === "number" && (isNaN(date) || !isFinite(date))) {
      throw new Error("Invalid date");
    }
    let m2 = hooks(date).utc();
    if (resolution) {
      m2 = m2.startOf(resolution);
    }
    return m2;
  }
}
const nativeDateUnit = (res) => {
  if (res === "day") {
    return "date";
  }
  return res;
};
const graphDateValue = (value, res) => {
  if (res === "month") {
    value += 1;
  }
  return value;
};
const nativeDateValue = (value, res) => {
  if (res === "month") {
    value -= 1;
  }
  return value;
};
(() => {
  let maxDate = hooks.utc().startOf("year");
  let units = ALL_DATE_UNITS.slice(1);
  return _$2.zipObject(units, units.map((r2) => graphDateValue(maxDate.get(nativeDateUnit(r2)), r2)));
})();
const MAX_DATE_COMPONENTS = (() => {
  let maxDate = hooks.utc().endOf("year");
  let units = ALL_DATE_UNITS.slice(1);
  return _$2.zipObject(units, units.map((r2) => graphDateValue(maxDate.get(nativeDateUnit(r2)), r2) + 1));
})();
const DATE_COMP_PADS = (() => {
  let pads = {
    year: 4
  };
  for (let unit of ALL_DATE_UNITS) {
    if (unit !== "year") {
      let max2 = MAX_DATE_COMPONENTS[unit] - 1;
      pads[unit] = max2.toString().length;
    }
  }
  return pads;
})();
var classesmjs = { "trie": "ABAOAAAAAAAQmQAAAYAIf/ftmwuoFUUYx+d4z7nnHO+rUiF8gFHRBQ00CyQpJEtMUiwSSjLkViBlIqUhXnuoEXXpaWVkJFFWpj3EQCN6UdiVIKw0C4QSxbDkhkSKlUL/ZXe709yZ2XnvUfeDHzM7M/t937xn9+yZ3kTIDWAO6ALLwEoqzTbsAavBk2CNQvl14A1J/kawBXwIPgdfge/Aj2AfVe4g6AN/gL8BKRNSA1XQAYaCkeBF8ApYX47vTdkDLkDa2+BdsBV8Ar4EvWAn+AH8DPaBQ6CPuj4KTiblKxVC2irx/cMQvoNwVCW2cyHCOq4vrvTrn4D4pOR6CsJrwFjKfnTfDKSNq8Xx2YjfUun3fR7i85PrBQjvTeLdCFeBHjCUKr8a8bXgVbCx8v92uLHWz9yE28CSBLqsjDcVy7lmSyXmr3JMlPYBrj9L6jmf6ffxSN/OtMHXFbH+3UneXoQHkvgjYEii9zDSfgfHwAlQbiaktTnOG5KEw5sH6h2NtE5Oeko0r8ZJ8lVZCD8XR+MMumZS6VEdnkjq8zjVz88ivlaj319G2fVU+TT+FsL3JHq2SfI+Rt520At2gt0Ue5nr/eBXcAQcB/+AprpeG7Volqc5J7l3uIGOiUz/7uKMAdv+j7iSsjPVckyNtmirgoKCgoKCgoKCgoKCggIVZjTH79LS64WS9zYps3HPXOqZt7dKyGU1Qu5A2t1J+hKEy8HsWvw+cAXiVyD+WJL/FMIXwEvJ9WsIjyHclPEs/T7yH4CeB8FDYAVYCVaBh2tFXpFX5BV5RZ7rvLvAPeC+Wv57VkFBwenLNge/0clY09T/uzpLFyeNPh8vL/vxSYcNbTGHwDQFOtsJmdg+MH0pk7YB14dAZwch8zritOcQ7gDkLEJGgllgcgshi8D+OiHnDSbk+VLMzVScZVOLOI+mm9KxGfHDuG9MK54twOvgYKuanoKCgoKC048j2BcI9oUDOCccx35YKsffeUTfCV2C+OXJHj0I4W9IuxrPLEea4/yj4CpqDz/JOWtEuirV/u/I2hAfVuXvxSOQfj6VNwbxCYKyERORN5nKn1bt/+4pYhaVF33/dZNE11xJXsRU6J3JnFduxz0LwOLoXuR1JzrmGJxrVlL2exB/mvFnDa67Er3rMnylWa9R1ierGuCsx7IDbXN9QHs9aINvYHMPp09+apB+0iX6XreHYhlDj4RnygPLn2nYtP2nGc92Q5g51+v5WdCEnfBpl8Cv8Qq/n6jwrWa993LKd3hevzYm839zA6wDW+HDddjnP6J8+cKBX9Gc/6Uah30I/wQnGqC+qpTRJq0Z72xN++/sU+BdMFu3c08Bn02gv9/mcVE9/n48KjsW8UvBpHqc1wmmID49+g65nq2LZbRiue/BnAz9t9b59aHrOoK67kr03ZnctygJlyK8n7I1Kvo9A9ePGtSPtW/S/j6J2vXaptJ/lOO/7mTSRMUHKd6jQiH5SdH+7saxz/HfzvGZTTOVyhmOSwllp9Ek7z407Xc6FMVPdykJUBXdNm/kPacR15dQY1BWh1JGGVYHr6wPof3KSxpprDSynAnt4KpuvDlVUtTvmqqgDlUK9ppeM1TraSqsXdZ3Oj0Vnf2NJ7b305K2n2zfFbW/q/2lyoEwcdoPuo+rVJj33JWNYd784YnoPGQ7d3R9LmXc50No+z7OaeVEdxtx9/7H9bslV8/VqYR+H+bCBm/dp4W31qZjRoaL/ahR3zfy1hbR/q9aLpTI7LLrWV5Cj0lC5Pu+6BxAl6f3Ntm9Ov7ltf+x9Qltm/VB1Iasj3R5HVuqZUP2R4WJ5zVfZPODV5bnN1vWZTva6hfNd1o3e371MQ58jy/b9cilH7Q/Pua36Xqbh4jW2qznYVXdOvbzeObi7adpuuxMk6Uzz/6MhD0X8M4IvP51XT/2zJKnsP2p449ov+GdEejyvHcRrsc62+ema23WudOVqPprYjfvfSaEPXaM8ey5nG8qfcRD5Wxja8/GP1fYimq7sfXVWbNtRfXs7aM9THVEovrO0kZ8tH2otUtlzNFjTbaXqb6/0K2bzzaQ1ZGXzgqv/iI9IfvS51marq/K2kyHJOMe1XZUGVMi3SElq56i+tLpeYmPvS+vfqCFN5Z4c97nvGVt8Pqe55+uqKzbKnPRx97OXqui+5wj85vOUz0rhEBky0ZcjmeR3ya/N7r+jTJLfLUBL810jOqOYxfCWwN9+yBaj0KJy/lqYtvULx+iuwa73sNpvSJ7KvZDjp/UnqyNRNcmdlTK5H1m9KGPN/Zl7WjSxqrjy/TZSvSszL6HDz1+eZKnDyFs66ypoj1eRa9v0TlTqOpyKfQYz1tEa3Qee23qj0vRfVdi+zwp2ut03rnq+OxDaN/ZNV90rdpuOj6zelXbIeR4TcXm/QE9PnyKK/2yMylbH9EcyOO5hieyuqQieh7Lqw6ubZqOXZMxKxobsjGk6r/qPuZaTPaYkH2YCtuHdHlWV2hRabcQ80zVhs7abiMq73Vt54+qqPYRz8esevheV1XGE9uehFNGJrzfElh9tutnlrDj0KVOX/PQ53xn290EHd9tfFQVH+8ZdUW0/rD5Iddw33ZC7kMiu65xZUulDjr19SUi3122oQufXPmmOy+z7PqQ0O3pWtoDwquTqGxzIFyJr33N9Z4fQkL6YXM2ckGtAaClnjODPdPKoCsu68qK77qrwEoLGdhmPgltLxWf3xz51s3DREdIUbUZ0i9XtnTONLJ7Q/hqKrpjRrVs3vWihddXsn7UPc+a3OML0zaxtWfSXoTIfTbN45U1WUtltmT+i+qqY9u0X21E156NX3ndK9Np0095+6KiUyXNh5jOA54eV21ju36yemz8yPLJ1Vrgep8JtU/Zim4b88qp2vFFHjZ9rW8mvtvq9u2rrZ5Q9m3t+BpbJnk+x/e/", "classes": { "Other": 0, "Prepend": 1, "CR": 2, "LF": 3, "Control": 4, "Extend": 5, "Regional_Indicator": 6, "SpacingMark": 7, "L": 8, "V": 9, "T": 10, "LV": 11, "LVT": 12, "ZWJ": 13, "ExtPict": 14 } };
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree();
  this.dtree = new Tree();
}
var sltree = new Tree();
var sdtree = new Tree();
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
var clcidx = new Uint8Array([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);
function tinf_build_bits_base(bits2, base2, delta2, first) {
  var i2, sum2;
  for (i2 = 0; i2 < delta2; ++i2)
    bits2[i2] = 0;
  for (i2 = 0; i2 < 30 - delta2; ++i2)
    bits2[i2 + delta2] = i2 / delta2 | 0;
  for (sum2 = first, i2 = 0; i2 < 30; ++i2) {
    base2[i2] = sum2;
    sum2 += 1 << bits2[i2];
  }
}
function tinf_build_fixed_trees(lt2, dt) {
  var i2;
  for (i2 = 0; i2 < 7; ++i2)
    lt2.table[i2] = 0;
  lt2.table[7] = 24;
  lt2.table[8] = 152;
  lt2.table[9] = 112;
  for (i2 = 0; i2 < 24; ++i2)
    lt2.trans[i2] = 256 + i2;
  for (i2 = 0; i2 < 144; ++i2)
    lt2.trans[24 + i2] = i2;
  for (i2 = 0; i2 < 8; ++i2)
    lt2.trans[24 + 144 + i2] = 280 + i2;
  for (i2 = 0; i2 < 112; ++i2)
    lt2.trans[24 + 144 + 8 + i2] = 144 + i2;
  for (i2 = 0; i2 < 5; ++i2)
    dt.table[i2] = 0;
  dt.table[5] = 32;
  for (i2 = 0; i2 < 32; ++i2)
    dt.trans[i2] = i2;
}
var offs = new Uint16Array(16);
function tinf_build_tree(t2, lengths2, off, num2) {
  var i2, sum2;
  for (i2 = 0; i2 < 16; ++i2)
    t2.table[i2] = 0;
  for (i2 = 0; i2 < num2; ++i2)
    t2.table[lengths2[off + i2]]++;
  t2.table[0] = 0;
  for (sum2 = 0, i2 = 0; i2 < 16; ++i2) {
    offs[i2] = sum2;
    sum2 += t2.table[i2];
  }
  for (i2 = 0; i2 < num2; ++i2) {
    if (lengths2[off + i2])
      t2.trans[offs[lengths2[off + i2]]++] = i2;
  }
}
function tinf_getbit(d2) {
  if (!d2.bitcount--) {
    d2.tag = d2.source[d2.sourceIndex++];
    d2.bitcount = 7;
  }
  var bit = d2.tag & 1;
  d2.tag >>>= 1;
  return bit;
}
function tinf_read_bits(d2, num2, base2) {
  if (!num2)
    return base2;
  while (d2.bitcount < 24) {
    d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
    d2.bitcount += 8;
  }
  var val = d2.tag & 65535 >>> 16 - num2;
  d2.tag >>>= num2;
  d2.bitcount -= num2;
  return val + base2;
}
function tinf_decode_symbol(d2, t2) {
  while (d2.bitcount < 24) {
    d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
    d2.bitcount += 8;
  }
  var sum2 = 0, cur = 0, len2 = 0;
  var tag = d2.tag;
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len2;
    sum2 += t2.table[len2];
    cur -= t2.table[len2];
  } while (cur >= 0);
  d2.tag = tag;
  d2.bitcount -= len2;
  return t2.trans[sum2 + cur];
}
function tinf_decode_trees(d2, lt2, dt) {
  var hlit, hdist, hclen;
  var i2, num2, length;
  hlit = tinf_read_bits(d2, 5, 257);
  hdist = tinf_read_bits(d2, 5, 1);
  hclen = tinf_read_bits(d2, 4, 4);
  for (i2 = 0; i2 < 19; ++i2)
    lengths[i2] = 0;
  for (i2 = 0; i2 < hclen; ++i2) {
    var clen = tinf_read_bits(d2, 3, 0);
    lengths[clcidx[i2]] = clen;
  }
  tinf_build_tree(code_tree, lengths, 0, 19);
  for (num2 = 0; num2 < hlit + hdist; ) {
    var sym = tinf_decode_symbol(d2, code_tree);
    switch (sym) {
      case 16:
        var prev = lengths[num2 - 1];
        for (length = tinf_read_bits(d2, 2, 3); length; --length) {
          lengths[num2++] = prev;
        }
        break;
      case 17:
        for (length = tinf_read_bits(d2, 3, 3); length; --length) {
          lengths[num2++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits(d2, 7, 11); length; --length) {
          lengths[num2++] = 0;
        }
        break;
      default:
        lengths[num2++] = sym;
        break;
    }
  }
  tinf_build_tree(lt2, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}
function tinf_inflate_block_data(d2, lt2, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d2, lt2);
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d2.dest[d2.destLen++] = sym;
    } else {
      var length, dist2, offs2;
      var i2;
      sym -= 257;
      length = tinf_read_bits(d2, length_bits[sym], length_base[sym]);
      dist2 = tinf_decode_symbol(d2, dt);
      offs2 = d2.destLen - tinf_read_bits(d2, dist_bits[dist2], dist_base[dist2]);
      for (i2 = offs2; i2 < offs2 + length; ++i2) {
        d2.dest[d2.destLen++] = d2.dest[i2];
      }
    }
  }
}
function tinf_inflate_uncompressed_block(d2) {
  var length, invlength;
  var i2;
  while (d2.bitcount > 8) {
    d2.sourceIndex--;
    d2.bitcount -= 8;
  }
  length = d2.source[d2.sourceIndex + 1];
  length = 256 * length + d2.source[d2.sourceIndex];
  invlength = d2.source[d2.sourceIndex + 3];
  invlength = 256 * invlength + d2.source[d2.sourceIndex + 2];
  if (length !== (~invlength & 65535))
    return TINF_DATA_ERROR;
  d2.sourceIndex += 4;
  for (i2 = length; i2; --i2)
    d2.dest[d2.destLen++] = d2.source[d2.sourceIndex++];
  d2.bitcount = 0;
  return TINF_OK;
}
function tinf_uncompress(source, dest) {
  var d2 = new Data(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit(d2);
    btype = tinf_read_bits(d2, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block(d2);
        break;
      case 1:
        res = tinf_inflate_block_data(d2, sltree, sdtree);
        break;
      case 2:
        tinf_decode_trees(d2, d2.ltree, d2.dtree);
        res = tinf_inflate_block_data(d2, d2.ltree, d2.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK)
      throw new Error("Data error");
  } while (!bfinal);
  if (d2.destLen < d2.dest.length) {
    if (typeof d2.dest.slice === "function")
      return d2.dest.slice(0, d2.destLen);
    else
      return d2.dest.subarray(0, d2.destLen);
  }
  return d2.dest;
}
tinf_build_fixed_trees(sltree, sdtree);
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
length_bits[28] = 0;
length_base[28] = 258;
const isBigEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
const swap = (b2, n2, m2) => {
  let i2 = b2[n2];
  b2[n2] = b2[m2];
  b2[m2] = i2;
};
const swap32 = (array2) => {
  const len2 = array2.length;
  for (let i2 = 0; i2 < len2; i2 += 4) {
    swap(array2, i2, i2 + 3);
    swap(array2, i2 + 1, i2 + 2);
  }
};
const swap32LE$1 = (array2) => {
  if (isBigEndian) {
    swap32(array2);
  }
};
const exports$2 = {
  swap32LE: swap32LE$1
};
const swap32LE = exports$2.swap32LE;
const SHIFT_1 = 6 + 5;
const SHIFT_2 = 5;
const SHIFT_1_2 = SHIFT_1 - SHIFT_2;
const OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
const INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
const INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
const INDEX_SHIFT = 2;
const DATA_BLOCK_LENGTH = 1 << SHIFT_2;
const DATA_MASK = DATA_BLOCK_LENGTH - 1;
const LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
const LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
const INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
const UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
const UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
const INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
const DATA_GRANULARITY = 1 << INDEX_SHIFT;
class UnicodeTrie {
  constructor(data2) {
    const isBuffer = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
    if (isBuffer || data2 instanceof Uint8Array) {
      let uncompressedLength;
      if (isBuffer) {
        this.highStart = data2.readUInt32LE(0);
        this.errorValue = data2.readUInt32LE(4);
        uncompressedLength = data2.readUInt32LE(8);
        data2 = data2.slice(12);
      } else {
        const view = new DataView(data2.buffer);
        this.highStart = view.getUint32(0, true);
        this.errorValue = view.getUint32(4, true);
        uncompressedLength = view.getUint32(8, true);
        data2 = data2.subarray(12);
      }
      data2 = tinf_uncompress(data2, new Uint8Array(uncompressedLength));
      data2 = tinf_uncompress(data2, new Uint8Array(uncompressedLength));
      swap32LE(data2);
      this.data = new Uint32Array(data2.buffer);
    } else {
      ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
    }
  }
  get(codePoint) {
    let index2;
    if (codePoint < 0 || codePoint > 1114111) {
      return this.errorValue;
    }
    if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
      index2 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index2];
    }
    if (codePoint <= 65535) {
      index2 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index2];
    }
    if (codePoint < this.highStart) {
      index2 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
      index2 = this.data[index2 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
      index2 = (index2 << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index2];
    }
    return this.data[this.data.length - DATA_GRANULARITY];
  }
}
const trie = classesmjs.trie;
const { Other, Prepend, CR, LF, Control, Extend, Regional_Indicator, SpacingMark, L: L$2, V: V$2, T: T$2, LV, LVT, ZWJ, ExtPict } = classesmjs.classes;
let data = null;
if (globalThis["window"]) {
  const bin = window.atob(trie);
  data = new Uint8Array(bin.length);
  for (let i2 = 0; i2 < bin.length; i2++)
    data[i2] = bin.charCodeAt(i2);
} else {
  data = Buffer.from(trie, "base64");
}
const classTrie = new UnicodeTrie(data);
const codePointAt = function(str, idx) {
  const code3 = str.charCodeAt(idx);
  if (55296 <= code3 && code3 <= 56319) {
    const hi = code3;
    const low = str.charCodeAt(idx + 1);
    if (56320 <= low && low <= 57343) {
      return (hi - 55296) * 1024 + (low - 56320) + 65536;
    }
    return hi;
  }
  if (56320 <= code3 && code3 <= 57343) {
    const hi = str.charCodeAt(idx - 1);
    const low = code3;
    if (55296 <= hi && hi <= 56319) {
      return (hi - 55296) * 1024 + (low - 56320) + 65536;
    }
    return low;
  }
  return code3;
};
const isSurrogate = function(str, pos) {
  let ref2, ref1;
  return 55296 <= (ref2 = str.charCodeAt(pos)) && ref2 <= 56319 && (56320 <= (ref1 = str.charCodeAt(pos + 1)) && ref1 <= 57343);
};
const BreakType = {
  NotBreak: 0,
  BreakStart: 1,
  Break: 2,
  BreakLastRegional: 3,
  BreakPenultimateRegional: 4
};
const shouldBreak = function(reverse, start2, mid2, end) {
  const all = [start2].concat(mid2).concat([end]);
  const previous = reverse ? start2 : all[all.length - 2];
  const next = reverse ? all[1] : end;
  let rIIndex = all.lastIndexOf(Regional_Indicator);
  if (rIIndex > 0 && all.slice(1, rIIndex).every((c2) => c2 === Regional_Indicator) && (previous !== Prepend && previous !== Regional_Indicator)) {
    if (all.filter((c2) => c2 === Regional_Indicator).length % 2 === 1) {
      return BreakType.BreakLastRegional;
    } else {
      return BreakType.BreakPenultimateRegional;
    }
  }
  if (previous === CR && next === LF) {
    return BreakType.NotBreak;
  }
  if (previous === Control || previous === CR || previous === LF) {
    if (next !== Extend && mid2.every((c2) => c2 === Extend)) {
      return BreakType.Break;
    } else {
      return BreakType.BreakStart;
    }
  }
  if (next === Control || next === CR || next === LF) {
    return BreakType.BreakStart;
  }
  if (previous === L$2 && (next === L$2 || next === V$2 || next === LV || next === LVT)) {
    return BreakType.NotBreak;
  }
  if ((previous === LV || previous === V$2) && (next === V$2 || next === T$2)) {
    return BreakType.NotBreak;
  }
  if ((previous === LVT || previous === T$2) && next === T$2) {
    return BreakType.NotBreak;
  }
  if (reverse) {
    if (next === Extend) {
      return BreakType.NotBreak;
    }
    if (next === ZWJ) {
      if (previous == Other && mid2.length > 0 && mid2[0] == ZWJ) {
        return end != ExtPict ? BreakType.BreakStart : BreakType.Break;
      }
      return BreakType.NotBreak;
    }
  } else {
    if (next === Extend || next === ZWJ) {
      return BreakType.NotBreak;
    }
  }
  if (next === SpacingMark) {
    return BreakType.NotBreak;
  }
  if (previous === Prepend) {
    return BreakType.NotBreak;
  }
  if (reverse) {
    if (previous == ZWJ && next == ExtPict && (start2 == ZWJ || start2 == Other)) {
      return BreakType.NotBreak;
    }
  } else {
    if (start2 == ExtPict && previous == ZWJ && next == ExtPict) {
      return BreakType.NotBreak;
    }
  }
  if (!reverse && mid2.indexOf(Regional_Indicator) >= 0) {
    return BreakType.Break;
  }
  if (previous === Regional_Indicator && next === Regional_Indicator) {
    return BreakType.NotBreak;
  }
  return BreakType.BreakStart;
};
const getUnicodeByteOffset = function(str, start2, unicodeOffset) {
  while (unicodeOffset--) {
    start2 += isSurrogate(str, start2) ? 2 : 1;
  }
  return start2;
};
const exports$1 = {};
exports$1.nextBreak = function(string2, index2 = 0) {
  if (index2 < 0) {
    return 0;
  }
  if (index2 >= string2.length - 1) {
    return string2.length;
  }
  const prev = classTrie.get(string2.codePointAt(index2));
  const mid2 = [];
  let i2, j2, ref1;
  for (i2 = j2 = index2 + 1, ref1 = string2.length; j2 < ref1; i2 = j2 += 1) {
    if (isSurrogate(string2, i2 - 1)) {
      continue;
    }
    const next = classTrie.get(string2.codePointAt(i2));
    if (shouldBreak(false, prev, mid2, next)) {
      return i2;
    }
    mid2.push(next);
  }
  return string2.length;
};
exports$1.previousBreak = function(string2, index2 = string2.length) {
  if (index2 > string2.length) {
    return string2.length;
  }
  if (index2 <= 1) {
    return 0;
  }
  index2--;
  let mid2 = [];
  let next = classTrie.get(codePointAt(string2, index2));
  let i2, j2;
  for (i2 = j2 = index2 - 1; j2 >= -1; i2 = j2 += -1) {
    if (isSurrogate(string2, i2)) {
      continue;
    }
    let prev = classTrie.get(codePointAt(string2, i2));
    switch (shouldBreak(true, prev, mid2, next)) {
      case BreakType.Break:
        return i2 + mid2.length + 1;
      case BreakType.BreakStart:
        return i2 + 1;
      case BreakType.BreakLastRegional:
        const offset2 = getUnicodeByteOffset(string2, i2, mid2.concat(next).lastIndexOf(Regional_Indicator) + 1);
        return offset2;
      case BreakType.BreakPenultimateRegional:
        return getUnicodeByteOffset(string2, i2, mid2.concat(next).lastIndexOf(Regional_Indicator));
    }
    mid2.unshift(prev);
  }
};
exports$1.break = function(str) {
  const res = [];
  let index2 = 0;
  let brk;
  while ((brk = exports$1.nextBreak(str, index2)) < str.length) {
    res.push(str.slice(index2, brk));
    index2 = brk;
  }
  if (index2 < str.length) {
    res.push(str.slice(index2));
  }
  return res;
};
exports$1.countBreaks = function(str) {
  let count2 = 0;
  let index2 = 0;
  let brk;
  while ((brk = exports$1.nextBreak(str, index2)) < str.length) {
    index2 = brk;
    count2++;
  }
  if (index2 < str.length) {
    count2++;
  }
  return count2;
};
var GB = exports$1;
var base32$1 = { exports: {} };
var __viteBrowserExternal_crypto = new Proxy({}, {
  get() {
    throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});
var __viteBrowserExternal_crypto$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal_crypto
}, Symbol.toStringTag, { value: "Module" }));
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_crypto$1);
var __viteBrowserExternal_fs = new Proxy({}, {
  get() {
    throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});
var __viteBrowserExternal_fs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal_fs
}, Symbol.toStringTag, { value: "Module" }));
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_fs$1);
(function(module2) {
  (function() {
    var alphabet = "0123456789abcdefghjkmnpqrtuvwxyz";
    var alias = { o: 0, i: 1, l: 1, s: 5 };
    var lookup2 = function() {
      var table3 = {};
      for (var i2 = 0; i2 < alphabet.length; i2++) {
        table3[alphabet[i2]] = i2;
      }
      for (var key in alias) {
        if (!alias.hasOwnProperty(key))
          continue;
        table3[key] = table3["" + alias[key]];
      }
      lookup2 = function() {
        return table3;
      };
      return table3;
    };
    function Encoder() {
      var skip = 0;
      var bits2 = 0;
      this.output = "";
      this.readByte = function(byte) {
        if (typeof byte == "string")
          byte = byte.charCodeAt(0);
        if (skip < 0) {
          bits2 |= byte >> -skip;
        } else {
          bits2 = byte << skip & 248;
        }
        if (skip > 3) {
          skip -= 8;
          return 1;
        }
        if (skip < 4) {
          this.output += alphabet[bits2 >> 3];
          skip += 5;
        }
        return 0;
      };
      this.finish = function(check2) {
        var output = this.output + (skip < 0 ? alphabet[bits2 >> 3] : "") + (check2 ? "$" : "");
        this.output = "";
        return output;
      };
    }
    Encoder.prototype.update = function(input, flush) {
      for (var i2 = 0; i2 < input.length; ) {
        i2 += this.readByte(input[i2]);
      }
      var output = this.output;
      this.output = "";
      if (flush) {
        output += this.finish();
      }
      return output;
    };
    function Decoder() {
      var skip = 0;
      var byte = 0;
      this.output = "";
      this.readChar = function(char) {
        if (typeof char != "string") {
          if (typeof char == "number") {
            char = String.fromCharCode(char);
          }
        }
        char = char.toLowerCase();
        var val = lookup2()[char];
        if (typeof val == "undefined") {
          return;
        }
        val <<= 3;
        byte |= val >>> skip;
        skip += 5;
        if (skip >= 8) {
          this.output += String.fromCharCode(byte);
          skip -= 8;
          if (skip > 0)
            byte = val << 5 - skip & 255;
          else
            byte = 0;
        }
      };
      this.finish = function(check2) {
        var output = this.output + (skip < 0 ? alphabet[bits >> 3] : "") + (check2 ? "$" : "");
        this.output = "";
        return output;
      };
    }
    Decoder.prototype.update = function(input, flush) {
      for (var i2 = 0; i2 < input.length; i2++) {
        this.readChar(input[i2]);
      }
      var output = this.output;
      this.output = "";
      if (flush) {
        output += this.finish();
      }
      return output;
    };
    function encode2(input) {
      var encoder = new Encoder();
      var output = encoder.update(input, true);
      return output;
    }
    function decode2(input) {
      var decoder = new Decoder();
      var output = decoder.update(input, true);
      return output;
    }
    var crypto, fs;
    function sha1(input, cb) {
      if (typeof crypto == "undefined")
        crypto = require$$0$1;
      var hash2 = crypto.createHash("sha1");
      hash2.digest = function(digest) {
        return function() {
          return encode2(digest.call(this, "binary"));
        };
      }(hash2.digest);
      if (cb) {
        if (typeof input == "string" || Buffer.isBuffer(input)) {
          try {
            return cb(null, sha1(input));
          } catch (err) {
            return cb(err, null);
          }
        }
        if (!typeof input.on == "function")
          return cb({ message: "Not a stream!" });
        input.on("data", function(chunk) {
          hash2.update(chunk);
        });
        input.on("end", function() {
          cb(null, hash2.digest());
        });
        return;
      }
      if (input) {
        return hash2.update(input).digest();
      }
      return hash2;
    }
    sha1.file = function(filename, cb) {
      if (filename == "-") {
        process.stdin.resume();
        return sha1(process.stdin, cb);
      }
      if (typeof fs == "undefined")
        fs = require$$1;
      return fs.stat(filename, function(err, stats) {
        if (err)
          return cb(err, null);
        if (stats.isDirectory())
          return cb({ dir: true, message: "Is a directory" });
        return sha1(require$$1.createReadStream(filename), cb);
      });
    };
    var base322 = {
      Decoder,
      Encoder,
      encode: encode2,
      decode: decode2,
      sha1
    };
    if (typeof window !== "undefined") {
      window.base32 = base322;
    }
    if (module2.exports) {
      module2.exports = base322;
    }
  })();
})(base32$1);
var base32 = base32$1.exports;
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function distanceOf(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function growBox(box, size2) {
  return {
    x: box.x - size2,
    y: box.y - size2,
    w: box.w + 2 * size2,
    h: box.h + 2 * size2
  };
}
function isPointInBox(point, box) {
  return point.x > box.x && point.x < box.x + box.w && point.y > box.y && point.y < box.y + box.h;
}
function controlPointOf(target2, another, sideOfTarget) {
  var margin = 30;
  switch (sideOfTarget) {
    case "top": {
      return {
        x: target2.x,
        y: Math.min(target2.y - (target2.y - another.y) / 2, target2.y - margin)
      };
    }
    case "bottom": {
      return {
        x: target2.x,
        y: Math.max(target2.y - (target2.y - another.y) / 2, target2.y + margin)
      };
    }
    case "left": {
      return {
        x: Math.min(target2.x - (target2.x - another.x) / 2, target2.x - margin),
        y: target2.y
      };
    }
    case "right": {
      return {
        x: Math.max(target2.x - (target2.x - another.x) / 2, target2.x + margin),
        y: target2.y
      };
    }
  }
}
function angleOf(enteringSide) {
  switch (enteringSide) {
    case "left":
      return 0;
    case "top":
      return 90;
    case "right":
      return 180;
    case "bottom":
      return 270;
  }
}
function getBoxToBoxArrow(x0, y0, w0, h0, x1, y1, w1, h1, userOptions) {
  var options = _extends({
    padStart: 0,
    padEnd: 0
  }, userOptions);
  var startBox = {
    x: x0,
    y: y0,
    w: w0,
    h: h0
  };
  var startAtTop = {
    x: x0 + w0 / 2,
    y: y0 - 2 * options.padStart
  };
  var startAtBottom = {
    x: x0 + w0 / 2,
    y: y0 + h0 + 2 * options.padStart
  };
  var startAtLeft = {
    x: x0 - 2 * options.padStart,
    y: y0 + h0 / 2
  };
  var startAtRight = {
    x: x0 + w0 + 2 * options.padStart,
    y: y0 + h0 / 2
  };
  var endBox = {
    x: x1,
    y: y1,
    w: w1,
    h: h1
  };
  var endAtTop = {
    x: x1 + w1 / 2,
    y: y1 - 2 * options.padEnd
  };
  var endAtBottom = {
    x: x1 + w1 / 2,
    y: y1 + h1 + 2 * options.padEnd
  };
  var endAtLeft = {
    x: x1 - 2 * options.padEnd,
    y: y1 + h1 / 2
  };
  var endAtRight = {
    x: x1 + w1 + 2 * options.padEnd,
    y: y1 + h1 / 2
  };
  var sides = ["top", "right", "bottom", "left"];
  var startPoints = [startAtTop, startAtRight, startAtBottom, startAtLeft];
  var endPoints = [endAtTop, endAtRight, endAtBottom, endAtLeft];
  var shortestDistance = 1 / 0;
  var bestStartPoint = startAtTop;
  var bestEndPoint = endAtTop;
  var bestStartSide = "top";
  var bestEndSide = "top";
  var keepOutZone = 15;
  for (var startSideId = 0; startSideId < sides.length; startSideId++) {
    var startPoint = startPoints[startSideId];
    if (isPointInBox(startPoint, growBox(endBox, keepOutZone)))
      continue;
    for (var endSideId = 0; endSideId < sides.length; endSideId++) {
      var endPoint = endPoints[endSideId];
      if (isPointInBox(endPoint, growBox(startBox, keepOutZone)))
        continue;
      var d2 = distanceOf(startPoint, endPoint);
      if (d2 < shortestDistance) {
        shortestDistance = d2;
        bestStartPoint = startPoint;
        bestEndPoint = endPoint;
        bestStartSide = sides[startSideId];
        bestEndSide = sides[endSideId];
      }
    }
  }
  var controlPointForStartPoint = controlPointOf(bestStartPoint, bestEndPoint, bestStartSide);
  var controlPointForEndPoint = controlPointOf(bestEndPoint, bestStartPoint, bestEndSide);
  return [bestStartPoint.x, bestStartPoint.y, controlPointForStartPoint.x, controlPointForStartPoint.y, controlPointForEndPoint.x, controlPointForEndPoint.y, bestEndPoint.x, bestEndPoint.y, angleOf(bestEndSide), angleOf(bestStartSide)];
}
function getArrow(x0, y0, x1, y1, userOptions) {
  return getBoxToBoxArrow(x0, y0, 0, 0, x1, y1, 0, 0, userOptions);
}
function W$1(e2, t2, s2, h2 = (b2) => b2) {
  return e2 * h2(0.5 - t2 * (0.5 - s2));
}
function re(e2) {
  return [-e2[0], -e2[1]];
}
function l$1(e2, t2) {
  return [e2[0] + t2[0], e2[1] + t2[1]];
}
function a$2(e2, t2) {
  return [e2[0] - t2[0], e2[1] - t2[1]];
}
function f$1(e2, t2) {
  return [e2[0] * t2, e2[1] * t2];
}
function le(e2, t2) {
  return [e2[0] / t2, e2[1] / t2];
}
function L$1(e2) {
  return [e2[1], -e2[0]];
}
function ne(e2, t2) {
  return e2[0] * t2[0] + e2[1] * t2[1];
}
function oe(e2, t2) {
  return e2[0] === t2[0] && e2[1] === t2[1];
}
function fe(e2) {
  return Math.hypot(e2[0], e2[1]);
}
function be(e2) {
  return e2[0] * e2[0] + e2[1] * e2[1];
}
function Y$1(e2, t2) {
  return be(a$2(e2, t2));
}
function G$1(e2) {
  return le(e2, fe(e2));
}
function ue(e2, t2) {
  return Math.hypot(e2[1] - t2[1], e2[0] - t2[0]);
}
function T$1(e2, t2, s2) {
  let h2 = Math.sin(s2), b2 = Math.cos(s2), v2 = e2[0] - t2[0], n2 = e2[1] - t2[1], g2 = v2 * b2 - n2 * h2, E2 = v2 * h2 + n2 * b2;
  return [g2 + t2[0], E2 + t2[1]];
}
function V$1(e2, t2, s2) {
  return l$1(e2, f$1(a$2(t2, e2), s2));
}
function Z$1(e2, t2, s2) {
  return l$1(e2, f$1(t2, s2));
}
var { min: _$1, PI: ge } = Math, se = 0.275, j$1 = ge + 1e-4;
function ie(e2, t2 = {}) {
  let { size: s2 = 16, smoothing: h2 = 0.5, thinning: b2 = 0.5, simulatePressure: v2 = true, easing: n2 = (r2) => r2, start: g2 = {}, end: E2 = {}, last: z2 = false } = t2, { cap: d2 = true, taper: x2 = 0, easing: q2 = (r2) => r2 * (2 - r2) } = g2, { cap: m2 = true, taper: c2 = 0, easing: M2 = (r2) => --r2 * r2 * r2 + 1 } = E2;
  if (e2.length === 0 || s2 <= 0)
    return [];
  let H2 = e2[e2.length - 1].runningLength, $2 = Math.pow(s2 * h2, 2), D2 = [], R2 = [], N2 = e2.slice(0, 10).reduce((r2, i2) => {
    let o2 = i2.pressure;
    if (v2) {
      let u2 = _$1(1, i2.distance / s2), J2 = _$1(1, 1 - u2);
      o2 = _$1(1, r2 + (J2 - r2) * (u2 * se));
    }
    return (r2 + o2) / 2;
  }, e2[0].pressure), p2 = W$1(s2, b2, e2[e2.length - 1].pressure, n2), U2, B2 = e2[0].vector, I2 = e2[0].point, C2 = I2, y2 = I2, O2 = C2;
  for (let r2 = 0; r2 < e2.length; r2++) {
    let { pressure: i2 } = e2[r2], { point: o2, vector: u2, distance: J2, runningLength: K2 } = e2[r2];
    if (r2 < e2.length - 1 && H2 - K2 < 3)
      continue;
    if (b2) {
      if (v2) {
        let P2 = _$1(1, J2 / s2), Q2 = _$1(1, 1 - P2);
        i2 = _$1(1, N2 + (Q2 - N2) * (P2 * se));
      }
      p2 = W$1(s2, b2, i2, n2);
    } else
      p2 = s2 / 2;
    U2 === void 0 && (U2 = p2);
    let pe = K2 < x2 ? q2(K2 / x2) : 1, ae = H2 - K2 < c2 ? M2((H2 - K2) / c2) : 1;
    if (p2 = Math.max(0.01, p2 * Math.min(pe, ae)), r2 === e2.length - 1) {
      let P2 = f$1(L$1(u2), p2);
      D2.push(a$2(o2, P2)), R2.push(l$1(o2, P2));
      continue;
    }
    let A2 = e2[r2 + 1].vector, ee2 = ne(u2, A2);
    if (ee2 < 0) {
      let P2 = f$1(L$1(B2), p2);
      for (let Q2 = 1 / 13, w2 = 0; w2 <= 1; w2 += Q2)
        y2 = T$1(a$2(o2, P2), o2, j$1 * w2), D2.push(y2), O2 = T$1(l$1(o2, P2), o2, j$1 * -w2), R2.push(O2);
      I2 = y2, C2 = O2;
      continue;
    }
    let te = f$1(L$1(V$1(A2, u2, ee2)), p2);
    y2 = a$2(o2, te), (r2 <= 1 || Y$1(I2, y2) > $2) && (D2.push(y2), I2 = y2), O2 = l$1(o2, te), (r2 <= 1 || Y$1(C2, O2) > $2) && (R2.push(O2), C2 = O2), N2 = i2, B2 = u2;
  }
  let S2 = e2[0].point.slice(0, 2), k2 = e2.length > 1 ? e2[e2.length - 1].point.slice(0, 2) : l$1(e2[0].point, [1, 1]), X2 = [], F2 = [];
  if (e2.length === 1) {
    if (!(x2 || c2) || z2) {
      let r2 = Z$1(S2, G$1(L$1(a$2(S2, k2))), -(U2 || p2)), i2 = [];
      for (let o2 = 1 / 13, u2 = o2; u2 <= 1; u2 += o2)
        i2.push(T$1(r2, S2, j$1 * 2 * u2));
      return i2;
    }
  } else {
    if (!(x2 || c2 && e2.length === 1))
      if (d2)
        for (let i2 = 1 / 13, o2 = i2; o2 <= 1; o2 += i2) {
          let u2 = T$1(R2[0], S2, j$1 * o2);
          X2.push(u2);
        }
      else {
        let i2 = a$2(D2[0], R2[0]), o2 = f$1(i2, 0.5), u2 = f$1(i2, 0.51);
        X2.push(a$2(S2, o2), a$2(S2, u2), l$1(S2, u2), l$1(S2, o2));
      }
    let r2 = L$1(re(e2[e2.length - 1].vector));
    if (c2 || x2 && e2.length === 1)
      F2.push(k2);
    else if (m2) {
      let i2 = Z$1(k2, r2, p2);
      for (let o2 = 1 / 29, u2 = o2; u2 < 1; u2 += o2)
        F2.push(T$1(i2, k2, j$1 * 3 * u2));
    } else
      F2.push(l$1(k2, f$1(r2, p2)), l$1(k2, f$1(r2, p2 * 0.99)), a$2(k2, f$1(r2, p2 * 0.99)), a$2(k2, f$1(r2, p2)));
  }
  return D2.concat(F2, R2.reverse(), X2);
}
function ce(e2, t2 = {}) {
  var q2;
  let { streamline: s2 = 0.5, size: h2 = 16, last: b2 = false } = t2;
  if (e2.length === 0)
    return [];
  let v2 = 0.15 + (1 - s2) * 0.85, n2 = Array.isArray(e2[0]) ? e2 : e2.map(({ x: m2, y: c2, pressure: M2 = 0.5 }) => [m2, c2, M2]);
  if (n2.length === 2) {
    let m2 = n2[1];
    n2 = n2.slice(0, -1);
    for (let c2 = 1; c2 < 5; c2++)
      n2.push(V$1(n2[0], m2, c2 / 4));
  }
  n2.length === 1 && (n2 = [...n2, [...l$1(n2[0], [1, 1]), ...n2[0].slice(2)]]);
  let g2 = [{ point: [n2[0][0], n2[0][1]], pressure: n2[0][2] >= 0 ? n2[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], E2 = false, z2 = 0, d2 = g2[0], x2 = n2.length - 1;
  for (let m2 = 1; m2 < n2.length; m2++) {
    let c2 = b2 && m2 === x2 ? n2[m2].slice(0, 2) : V$1(d2.point, n2[m2], v2);
    if (oe(d2.point, c2))
      continue;
    let M2 = ue(c2, d2.point);
    if (z2 += M2, m2 < x2 && !E2) {
      if (z2 < h2)
        continue;
      E2 = true;
    }
    d2 = { point: c2, pressure: n2[m2][2] >= 0 ? n2[m2][2] : 0.5, vector: G$1(a$2(d2.point, c2)), distance: M2, runningLength: z2 }, g2.push(d2);
  }
  return g2[0].vector = ((q2 = g2[1]) == null ? void 0 : q2.vector) || [0, 0], g2;
}
function me(e2, t2 = {}) {
  return ie(ce(e2, t2), t2);
}
var Te = me;
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop2))
      __defNormalProp(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop2))
        __defNormalProp(a2, prop2, b2[prop2]);
    }
  return a2;
};
var createNanoEvents = () => ({
  events: {},
  emit(event, ...args) {
    (this.events[event] || []).forEach((i2) => i2(...args));
  },
  on(event, cb) {
    (this.events[event] = this.events[event] || []).push(cb);
    return () => this.events[event] = (this.events[event] || []).filter((i2) => i2 !== cb);
  }
});
function numSort(a2, b2) {
  return a2 - b2;
}
function getSymbol(a2) {
  if (a2 < 0)
    return -1;
  return 1;
}
function splitNum(a2) {
  return [Math.abs(a2), getSymbol(a2)];
}
function guid() {
  const S4 = () => ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
  return `${S4() + S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;
}
var DECIMAL = 2;
var D$1 = DECIMAL;
var BaseModel = class {
  constructor(drauu) {
    this.drauu = drauu;
    this.event = void 0;
    this.point = void 0;
    this.start = void 0;
    this.el = null;
  }
  onSelected(el2) {
  }
  onUnselected() {
  }
  onStart(point) {
    return void 0;
  }
  onMove(point) {
    return false;
  }
  onEnd(point) {
    return void 0;
  }
  get brush() {
    return this.drauu.brush;
  }
  get shiftPressed() {
    return this.drauu.shiftPressed;
  }
  get altPressed() {
    return this.drauu.altPressed;
  }
  get svgElement() {
    return this.drauu.el;
  }
  getMousePosition(event) {
    var _a2, _b;
    const el2 = this.drauu.el;
    const scale = (_a2 = this.drauu.options.coordinateScale) != null ? _a2 : 1;
    if (this.drauu.options.coordinateTransform === false) {
      const rect2 = this.drauu.el.getBoundingClientRect();
      return {
        x: (event.pageX - rect2.left) * scale,
        y: (event.pageY - rect2.top) * scale,
        pressure: event.pressure
      };
    } else {
      const point = this.drauu.svgPoint;
      point.x = event.clientX;
      point.y = event.clientY;
      const loc = point.matrixTransform((_b = el2.getScreenCTM()) == null ? void 0 : _b.inverse());
      return {
        x: loc.x * scale,
        y: loc.y * scale,
        pressure: event.pressure
      };
    }
  }
  createElement(name, overrides) {
    var _a2;
    const el2 = document.createElementNS("http://www.w3.org/2000/svg", name);
    const brush = overrides ? __spreadValues(__spreadValues({}, this.brush), overrides) : this.brush;
    el2.setAttribute("fill", (_a2 = brush.fill) != null ? _a2 : "transparent");
    el2.setAttribute("stroke", brush.color);
    el2.setAttribute("stroke-width", brush.size.toString());
    el2.setAttribute("stroke-linecap", "round");
    if (brush.dasharray)
      el2.setAttribute("stroke-dasharray", brush.dasharray);
    return el2;
  }
  attr(name, value) {
    this.el.setAttribute(name, typeof value === "string" ? value : value.toFixed(D$1));
  }
  _setEvent(event) {
    this.event = event;
    this.point = this.getMousePosition(event);
  }
  _eventDown(event) {
    this._setEvent(event);
    this.start = this.point;
    return this.onStart(this.point);
  }
  _eventMove(event) {
    this._setEvent(event);
    return this.onMove(this.point);
  }
  _eventUp(event) {
    this._setEvent(event);
    return this.onEnd(this.point);
  }
};
var StylusModel = class extends BaseModel {
  constructor() {
    super(...arguments);
    this.points = [];
  }
  onStart(point) {
    this.el = document.createElementNS("http://www.w3.org/2000/svg", "path");
    this.points = [point];
    this.attr("fill", this.brush.color);
    this.attr("d", this.getSvgData(this.points));
    return this.el;
  }
  onMove(point) {
    if (!this.el)
      this.onStart(point);
    if (this.points[this.points.length - 1] !== point)
      this.points.push(point);
    this.attr("d", this.getSvgData(this.points));
    return true;
  }
  onEnd() {
    const path2 = this.el;
    this.el = null;
    if (!path2)
      return false;
    return true;
  }
  getSvgData(points) {
    const stroke = Te(points, __spreadValues({
      size: this.brush.size * 2,
      thinning: 0.9,
      simulatePressure: false,
      start: {
        taper: 5
      },
      end: {
        taper: 5
      }
    }, this.brush.stylusOptions));
    if (!stroke.length)
      return "";
    const d2 = stroke.reduce((acc, [x0, y0], i2, arr) => {
      const [x1, y1] = arr[(i2 + 1) % arr.length];
      acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2);
      return acc;
    }, ["M", ...stroke[0], "Q"]);
    d2.push("Z");
    return d2.map((i2) => typeof i2 === "number" ? i2.toFixed(2) : i2).join(" ");
  }
};
var EllipseModel = class extends BaseModel {
  onStart(point) {
    this.el = this.createElement("ellipse");
    this.attr("cx", point.x);
    this.attr("cy", point.y);
    return this.el;
  }
  onMove(point) {
    if (!this.el || !this.start)
      return false;
    let [dx, sx] = splitNum(point.x - this.start.x);
    let [dy, sy] = splitNum(point.y - this.start.y);
    if (this.shiftPressed) {
      const d2 = Math.min(dx, dy);
      dx = d2;
      dy = d2;
    }
    if (this.altPressed) {
      this.attr("cx", this.start.x);
      this.attr("cy", this.start.y);
      this.attr("rx", dx);
      this.attr("ry", dy);
    } else {
      const [x1, x2] = [this.start.x, this.start.x + dx * sx].sort(numSort);
      const [y1, y2] = [this.start.y, this.start.y + dy * sy].sort(numSort);
      this.attr("cx", (x1 + x2) / 2);
      this.attr("cy", (y1 + y2) / 2);
      this.attr("rx", (x2 - x1) / 2);
      this.attr("ry", (y2 - y1) / 2);
    }
    return true;
  }
  onEnd() {
    const path2 = this.el;
    this.el = null;
    if (!path2)
      return false;
    if (!path2.getTotalLength())
      return false;
    return true;
  }
};
function createArrowHead(id2, fill) {
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  const marker2 = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  const head = document.createElementNS("http://www.w3.org/2000/svg", "path");
  head.setAttribute("fill", fill);
  marker2.setAttribute("id", id2);
  marker2.setAttribute("viewBox", "0 -5 10 10");
  marker2.setAttribute("refX", "5");
  marker2.setAttribute("refY", "0");
  marker2.setAttribute("markerWidth", "4");
  marker2.setAttribute("markerHeight", "4");
  marker2.setAttribute("orient", "auto");
  head.setAttribute("d", "M0,-5L10,0L0,5");
  marker2.appendChild(head);
  defs.appendChild(marker2);
  return defs;
}
var LineModel = class extends BaseModel {
  onStart(point) {
    this.el = this.createElement("line", { fill: "transparent" });
    this.attr("x1", point.x);
    this.attr("y1", point.y);
    this.attr("x2", point.x);
    this.attr("y2", point.y);
    if (this.brush.arrowEnd) {
      const id2 = guid();
      const g2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g2.append(createArrowHead(id2, this.brush.color));
      g2.append(this.el);
      this.attr("marker-end", `url(#${id2})`);
      return g2;
    }
    return this.el;
  }
  onMove(point) {
    if (!this.el)
      return false;
    let { x: x2, y: y2 } = point;
    if (this.shiftPressed) {
      const dx = point.x - this.start.x;
      const dy = point.y - this.start.y;
      if (dy !== 0) {
        let slope = dx / dy;
        slope = Math.round(slope);
        if (Math.abs(slope) <= 1) {
          x2 = this.start.x + dy * slope;
          y2 = this.start.y + dy;
        } else {
          x2 = this.start.x + dx;
          y2 = this.start.y;
        }
      }
    }
    if (this.altPressed) {
      this.attr("x1", this.start.x * 2 - x2);
      this.attr("y1", this.start.y * 2 - y2);
      this.attr("x2", x2);
      this.attr("y2", y2);
    } else {
      this.attr("x1", this.start.x);
      this.attr("y1", this.start.y);
      this.attr("x2", x2);
      this.attr("y2", y2);
    }
    return true;
  }
  onEnd() {
    const path2 = this.el;
    this.el = null;
    if (!path2)
      return false;
    if (path2.getTotalLength() < 5)
      return false;
    return true;
  }
};
var RectModel = class extends BaseModel {
  onStart(point) {
    this.el = this.createElement("rect");
    if (this.brush.cornerRadius) {
      this.attr("rx", this.brush.cornerRadius);
      this.attr("ry", this.brush.cornerRadius);
    }
    this.attr("x", point.x);
    this.attr("y", point.y);
    return this.el;
  }
  onMove(point) {
    if (!this.el || !this.start)
      return false;
    let [dx, sx] = splitNum(point.x - this.start.x);
    let [dy, sy] = splitNum(point.y - this.start.y);
    if (this.shiftPressed) {
      const d2 = Math.min(dx, dy);
      dx = d2;
      dy = d2;
    }
    if (this.altPressed) {
      this.attr("x", this.start.x - dx);
      this.attr("y", this.start.y - dy);
      this.attr("width", dx * 2);
      this.attr("height", dy * 2);
    } else {
      const [x1, x2] = [this.start.x, this.start.x + dx * sx].sort(numSort);
      const [y1, y2] = [this.start.y, this.start.y + dy * sy].sort(numSort);
      this.attr("x", x1);
      this.attr("y", y1);
      this.attr("width", x2 - x1);
      this.attr("height", y2 - y1);
    }
    return true;
  }
  onEnd() {
    const path2 = this.el;
    this.el = null;
    if (!path2)
      return false;
    if (!path2.getTotalLength())
      return false;
    return true;
  }
};
function getSqDist(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return dx * dx + dy * dy;
}
function getSqSegDist(p2, p1, p22) {
  let x2 = p1.x;
  let y2 = p1.y;
  let dx = p22.x - x2;
  let dy = p22.y - y2;
  if (dx !== 0 || dy !== 0) {
    const t2 = ((p2.x - x2) * dx + (p2.y - y2) * dy) / (dx * dx + dy * dy);
    if (t2 > 1) {
      x2 = p22.x;
      y2 = p22.y;
    } else if (t2 > 0) {
      x2 += dx * t2;
      y2 += dy * t2;
    }
  }
  dx = p2.x - x2;
  dy = p2.y - y2;
  return dx * dx + dy * dy;
}
function simplifyRadialDist(points, sqTolerance) {
  let prevPoint = points[0];
  const newPoints = [prevPoint];
  let point;
  for (let i2 = 1, len2 = points.length; i2 < len2; i2++) {
    point = points[i2];
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  }
  if (prevPoint !== point && point)
    newPoints.push(point);
  return newPoints;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
  let maxSqDist = sqTolerance;
  let index2 = 0;
  for (let i2 = first + 1; i2 < last; i2++) {
    const sqDist = getSqSegDist(points[i2], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index2 = i2;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index2 - first > 1)
      simplifyDPStep(points, first, index2, sqTolerance, simplified);
    simplified.push(points[index2]);
    if (last - index2 > 1)
      simplifyDPStep(points, index2, last, sqTolerance, simplified);
  }
}
function simplifyDouglasPeucker(points, sqTolerance) {
  const last = points.length - 1;
  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);
  return simplified;
}
function simplify(points, tolerance, highestQuality = false) {
  if (points.length <= 2)
    return points;
  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  points = simplifyDouglasPeucker(points, sqTolerance);
  return points;
}
var DrawModel = class extends BaseModel {
  constructor() {
    super(...arguments);
    this.points = [];
    this.count = 0;
  }
  onStart(point) {
    this.el = this.createElement("path", { fill: "transparent" });
    this.points = [point];
    if (this.brush.arrowEnd) {
      this.arrowId = guid();
      const head = createArrowHead(this.arrowId, this.brush.color);
      this.el.appendChild(head);
    }
    return this.el;
  }
  onMove(point) {
    if (!this.el)
      this.onStart(point);
    if (this.points[this.points.length - 1] !== point) {
      this.points.push(point);
      this.count += 1;
    }
    if (this.count > 5) {
      this.points = simplify(this.points, 1, true);
      this.count = 0;
    }
    this.attr("d", toSvgData(this.points));
    return true;
  }
  onEnd() {
    const path2 = this.el;
    this.el = null;
    if (!path2)
      return false;
    path2.setAttribute("d", toSvgData(simplify(this.points, 1, true)));
    if (!path2.getTotalLength())
      return false;
    return true;
  }
};
function line(a2, b2) {
  const lengthX = b2.x - a2.x;
  const lengthY = b2.y - a2.y;
  return {
    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),
    angle: Math.atan2(lengthY, lengthX)
  };
}
function controlPoint(current, previous, next, reverse) {
  const p2 = previous || current;
  const n2 = next || current;
  const smoothing = 0.2;
  const o2 = line(p2, n2);
  const angle2 = o2.angle + (reverse ? Math.PI : 0);
  const length = o2.length * smoothing;
  const x2 = current.x + Math.cos(angle2) * length;
  const y2 = current.y + Math.sin(angle2) * length;
  return { x: x2, y: y2 };
}
function bezierCommand(point, i2, points) {
  const cps = controlPoint(points[i2 - 1], points[i2 - 2], point);
  const cpe = controlPoint(point, points[i2 - 1], points[i2 + 1], true);
  return `C ${cps.x.toFixed(D$1)},${cps.y.toFixed(D$1)} ${cpe.x.toFixed(D$1)},${cpe.y.toFixed(D$1)} ${point.x.toFixed(D$1)},${point.y.toFixed(D$1)}`;
}
function toSvgData(points) {
  return points.reduce((acc, point, i2, a2) => i2 === 0 ? `M ${point.x.toFixed(D$1)},${point.y.toFixed(D$1)}` : `${acc} ${bezierCommand(point, i2, a2)}`, "");
}
var EraserModel = class extends BaseModel {
  constructor() {
    super(...arguments);
    this.pathSubFactor = 20;
    this.pathFragments = [];
  }
  onSelected(el2) {
    const calculatePathFragments = (children2, element) => {
      if (children2 && children2.length) {
        for (let i2 = 0; i2 < children2.length; i2++) {
          const ele = children2[i2];
          if (ele.getTotalLength) {
            const pathLength = ele.getTotalLength();
            for (let j2 = 0; j2 < this.pathSubFactor; j2++) {
              const pos1 = ele.getPointAtLength(pathLength * j2 / this.pathSubFactor);
              const pos2 = ele.getPointAtLength(pathLength * (j2 + 1) / this.pathSubFactor);
              this.pathFragments.push({
                x1: pos1.x,
                x2: pos2.x,
                y1: pos1.y,
                y2: pos2.y,
                segment: j2,
                element: element || ele
              });
            }
          } else {
            if (ele.children)
              calculatePathFragments(ele.children, ele);
          }
        }
      }
    };
    if (el2)
      calculatePathFragments(el2.children);
  }
  onUnselected() {
    this.pathFragments = [];
  }
  onStart(point) {
    this.svgPointPrevious = this.svgElement.createSVGPoint();
    this.svgPointPrevious.x = point.x;
    this.svgPointPrevious.y = point.y;
    return void 0;
  }
  onMove(point) {
    this.svgPointCurrent = this.svgElement.createSVGPoint();
    this.svgPointCurrent.x = point.x;
    this.svgPointCurrent.y = point.y;
    const erased = this.checkAndEraseElement();
    this.svgPointPrevious = this.svgPointCurrent;
    return erased;
  }
  onEnd() {
    this.svgPointPrevious = void 0;
    this.svgPointCurrent = void 0;
    return true;
  }
  checkAndEraseElement() {
    const erased = [];
    if (this.pathFragments.length) {
      for (let i2 = 0; i2 < this.pathFragments.length; i2++) {
        const segment = this.pathFragments[i2];
        const line2 = {
          x1: this.svgPointPrevious.x,
          x2: this.svgPointCurrent.x,
          y1: this.svgPointPrevious.y,
          y2: this.svgPointCurrent.y
        };
        if (this.lineLineIntersect(segment, line2)) {
          segment.element.remove();
          erased.push(i2);
        }
      }
    }
    if (erased.length)
      this.pathFragments = this.pathFragments.filter((v2, i2) => !erased.includes(i2));
    return erased.length > 0;
  }
  lineLineIntersect(line1, line2) {
    const x1 = line1.x1;
    const x2 = line1.x2;
    const x3 = line2.x1;
    const x4 = line2.x2;
    const y1 = line1.y1;
    const y2 = line1.y2;
    const y3 = line2.y1;
    const y4 = line2.y2;
    const pt_denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    const pt_x_num = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
    const pt_y_num = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
    const btwn = (a2, b1, b2) => {
      if (a2 >= b1 && a2 <= b2)
        return true;
      return a2 >= b2 && a2 <= b1;
    };
    if (pt_denom === 0) {
      return false;
    } else {
      const pt = {
        x: pt_x_num / pt_denom,
        y: pt_y_num / pt_denom
      };
      return btwn(pt.x, x1, x2) && btwn(pt.y, y1, y2) && btwn(pt.x, x3, x4) && btwn(pt.y, y3, y4);
    }
  }
};
function createModels(drauu) {
  return {
    draw: new DrawModel(drauu),
    stylus: new StylusModel(drauu),
    line: new LineModel(drauu),
    rectangle: new RectModel(drauu),
    ellipse: new EllipseModel(drauu),
    eraseLine: new EraserModel(drauu)
  };
}
var Drauu = class {
  constructor(options = {}) {
    this.options = options;
    this.el = null;
    this.svgPoint = null;
    this.eventEl = null;
    this.shiftPressed = false;
    this.altPressed = false;
    this.drawing = false;
    this._emitter = createNanoEvents();
    this._models = createModels(this);
    this._undoStack = [];
    this._disposables = [];
    if (!this.options.brush)
      this.options.brush = { color: "black", size: 3, mode: "stylus" };
    if (options.el)
      this.mount(options.el, options.eventTarget);
  }
  get model() {
    return this._models[this.mode];
  }
  get mounted() {
    return !!this.el;
  }
  get mode() {
    return this.options.brush.mode || "stylus";
  }
  set mode(v2) {
    const unselected = this._models[this.mode];
    unselected.onUnselected();
    this.options.brush.mode = v2;
    this.model.onSelected(this.el);
  }
  get brush() {
    return this.options.brush;
  }
  set brush(v2) {
    this.options.brush = v2;
  }
  resolveSelector(selector2) {
    if (typeof selector2 === "string")
      return document.querySelector(selector2);
    else
      return selector2 || null;
  }
  mount(el2, eventEl) {
    if (this.el)
      throw new Error("[drauu] already mounted, unmount previous target first");
    this.el = this.resolveSelector(el2);
    if (!this.el)
      throw new Error("[drauu] target element not found");
    if (this.el.tagName.toLocaleLowerCase() !== "svg")
      throw new Error("[drauu] can only mount to a SVG element");
    if (!this.el.createSVGPoint)
      throw new Error("[drauu] SVG element must be create by document.createElementNS('http://www.w3.org/2000/svg', 'svg')");
    this.svgPoint = this.el.createSVGPoint();
    const target2 = this.resolveSelector(eventEl) || this.el;
    const start2 = this.eventStart.bind(this);
    const move = this.eventMove.bind(this);
    const end = this.eventEnd.bind(this);
    const keyboard = this.eventKeyboard.bind(this);
    target2.addEventListener("pointerdown", start2, { passive: false });
    window.addEventListener("pointermove", move, { passive: false });
    window.addEventListener("pointerup", end, { passive: false });
    window.addEventListener("pointercancel", end, { passive: false });
    window.addEventListener("keydown", keyboard, false);
    window.addEventListener("keyup", keyboard, false);
    this._disposables.push(() => {
      target2.removeEventListener("pointerdown", start2);
      window.removeEventListener("pointermove", move);
      window.removeEventListener("pointerup", end);
      window.removeEventListener("pointercancel", end);
      window.removeEventListener("keydown", keyboard, false);
      window.removeEventListener("keyup", keyboard, false);
    });
    this._emitter.emit("mounted");
  }
  unmount() {
    this._disposables.forEach((fn) => fn());
    this._disposables.length = 0;
    this.el = null;
    this._emitter.emit("unmounted");
  }
  on(type, fn) {
    return this._emitter.on(type, fn);
  }
  undo() {
    const el2 = this.el;
    if (!el2.lastElementChild)
      return false;
    this._undoStack.push(el2.lastElementChild.cloneNode(true));
    el2.lastElementChild.remove();
    this._emitter.emit("changed");
    return true;
  }
  redo() {
    if (!this._undoStack.length)
      return false;
    this.el.appendChild(this._undoStack.pop());
    this._emitter.emit("changed");
    return true;
  }
  canRedo() {
    return !!this._undoStack.length;
  }
  canUndo() {
    var _a2;
    return !!((_a2 = this.el) == null ? void 0 : _a2.lastElementChild);
  }
  eventMove(event) {
    if (!this.acceptsInput(event) || !this.drawing)
      return;
    if (this.model._eventMove(event)) {
      event.stopPropagation();
      event.preventDefault();
      this._emitter.emit("changed");
    }
  }
  eventStart(event) {
    if (!this.acceptsInput(event))
      return;
    event.stopPropagation();
    event.preventDefault();
    if (this._currentNode)
      this.cancel();
    this.drawing = true;
    this._emitter.emit("start");
    this._currentNode = this.model._eventDown(event);
    if (this._currentNode && this.mode !== "eraseLine")
      this.el.appendChild(this._currentNode);
    this._emitter.emit("changed");
  }
  eventEnd(event) {
    if (!this.acceptsInput(event) || !this.drawing)
      return;
    const result = this.model._eventUp(event);
    if (!result) {
      this.cancel();
    } else {
      if (result instanceof Element && result !== this._currentNode)
        this._currentNode = result;
      this.commit();
    }
    this.drawing = false;
    this._emitter.emit("end");
    this._emitter.emit("changed");
  }
  acceptsInput(event) {
    return !this.options.acceptsInputTypes || this.options.acceptsInputTypes.includes(event.pointerType);
  }
  eventKeyboard(event) {
    if (this.shiftPressed === event.shiftKey && this.altPressed === event.altKey)
      return;
    this.shiftPressed = event.shiftKey;
    this.altPressed = event.altKey;
    if (this.model.point) {
      if (this.model.onMove(this.model.point))
        this._emitter.emit("changed");
    }
  }
  commit() {
    this._undoStack.length = 0;
    const node = this._currentNode;
    this._currentNode = void 0;
    this._emitter.emit("committed", node);
  }
  clear() {
    this._undoStack.length = 0;
    this.cancel();
    this.el.innerHTML = "";
    this._emitter.emit("changed");
  }
  cancel() {
    if (this._currentNode) {
      this.el.removeChild(this._currentNode);
      this._currentNode = void 0;
      this._emitter.emit("canceled");
    }
  }
  dump() {
    return this.el.innerHTML;
  }
  load(svg2) {
    this.clear();
    this.el.innerHTML = svg2;
  }
};
function createDrauu(options) {
  return new Drauu(options);
}
(() => {
  if (!needPoly()) {
    return;
  }
  const proto2 = CanvasRenderingContext2D.prototype;
  const original = proto2.drawImage;
  if (!original) {
    console.error("This script requires a basic implementation of drawImage");
    return;
  }
  proto2.drawImage = function drawImage2(source, x2, y2) {
    const will_crop = arguments.length === 9;
    if (!will_crop) {
      return original.apply(this, [...arguments]);
    }
    const safe_rect = getSafeRect(...arguments);
    if (isEmptyRect(safe_rect)) {
      return;
    }
    return original.apply(this, safe_rect);
  };
  function needPoly() {
    const ctx = document.createElement("canvas").getContext("2d");
    ctx.fillRect(0, 0, 40, 40);
    ctx.drawImage(ctx.canvas, -40, -40, 80, 80, 50, 50, 20, 20);
    const img = ctx.getImageData(50, 50, 30, 30);
    const data2 = new Uint32Array(img.data.buffer);
    const colorAt = (x2, y2) => data2[y2 * img.width + x2];
    const transparents = [
      [9, 9],
      [20, 9],
      [9, 20],
      [20, 20]
    ];
    const blacks = [
      [10, 10],
      [19, 10],
      [10, 19],
      [19, 19]
    ];
    return transparents.some(([x2, y2]) => colorAt(x2, y2) !== 0) || blacks.some(([x2, y2]) => colorAt(x2, y2) === 0);
  }
  function getSafeRect(image3, sx, sy, sw, sh, dx, dy, dw, dh) {
    const { width, height } = getSourceDimensions(image3);
    if (sw < 0) {
      sx += sw;
      sw = Math.abs(sw);
    }
    if (sh < 0) {
      sy += sh;
      sh = Math.abs(sh);
    }
    if (dw < 0) {
      dx += dw;
      dw = Math.abs(dw);
    }
    if (dh < 0) {
      dy += dh;
      dh = Math.abs(dh);
    }
    const x1 = Math.max(sx, 0);
    const x2 = Math.min(sx + sw, width);
    const y1 = Math.max(sy, 0);
    const y2 = Math.min(sy + sh, height);
    const w_ratio = dw / sw;
    const h_ratio = dh / sh;
    return [
      image3,
      x1,
      y1,
      x2 - x1,
      y2 - y1,
      sx < 0 ? dx - sx * w_ratio : dx,
      sy < 0 ? dy - sy * h_ratio : dy,
      (x2 - x1) * w_ratio,
      (y2 - y1) * h_ratio
    ];
  }
  function isEmptyRect(args) {
    return [3, 4, 7, 8].some((index2) => !args[index2]);
  }
  function getSourceDimensions(source) {
    const sourceIs = (type) => {
      const constructor = globalThis[type];
      return constructor && source instanceof constructor;
    };
    if (sourceIs("HTMLImageElement")) {
      return { width: source.naturalWidth, height: source.naturalHeight };
    } else if (sourceIs("HTMLVideoElement")) {
      return { width: source.videoWidth, height: source.videoHeight };
    } else if (sourceIs("SVGImageElement")) {
      throw new TypeError("SVGImageElement isn't yet supported as source image.", "UnsupportedError");
    } else if (sourceIs("HTMLCanvasElement") || sourceIs("ImageBitmap")) {
      return source;
    }
  }
})();
function mountClass(elClass = "gun-avatar") {
  document.addEventListener("DOMContentLoaded", () => {
    let avatars = document.getElementsByClassName(elClass);
    for (let img of avatars) {
      if (img.dataset.round != "false") {
        img.style.borderRadius = "100%";
      }
      img.src = gunAvatar({
        pub: img.dataset.pub,
        size: img.dataset.size,
        dark: img.dataset.dark,
        draw: img.dataset.draw,
        reflect: img.dataset.reflect != "false"
      });
    }
  });
}
function mountElement(elName = "gun-avatar") {
  let initiated = false;
  if (!document || initiated)
    return;
  class Avatar extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
      this.img = document.createElement("img");
      this.shadowRoot.append(this.img);
    }
    render() {
      this.pub = this.hasAttribute("pub") ? this.getAttribute("pub") : "1234123455Ute2tFhdjDQgzR-1234lfSlZxgEZKuquI.2F-j1234434U1234Asj-5lxnECG5TDyuPD8gEiuI123";
      this.size = this.hasAttribute("size") ? this.getAttribute("size") : 400;
      this.draw = this.hasAttribute("draw") ? this.getAttribute("draw") : "circles";
      this.reflect = this.hasAttribute("reflect") ? this.getAttribute("reflect") != "false" : true;
      this.round = this.hasAttribute("round") || this.getAttribute("round") == "" ? true : false;
      if (this.round) {
        this.img.style.borderRadius = "100%";
      } else {
        this.img.style.borderRadius = "0%";
      }
      this.dark = this.hasAttribute("dark") || this.getAttribute("dark") == "" ? true : false;
      this.img.src = gunAvatar({
        pub: this.pub,
        size: this.size,
        dark: this.dark,
        draw: this.draw,
        reflect: this.reflect
      });
    }
    connectedCallback() {
      this.render();
    }
    static get observedAttributes() {
      return ["pub", "round", "size", "dark", "draw", "reflect"];
    }
    attributeChangedCallback(name, oldValue, newValue) {
      this.render();
    }
  }
  customElements.define(elName, Avatar);
  initiated = true;
}
const cache = {};
function gunAvatar({
  pub,
  size: size2 = 800,
  dark = false,
  draw = "circles",
  reflect = true
} = {}) {
  var _a2, _b;
  if (!pub)
    return;
  if ((_b = (_a2 = cache == null ? void 0 : cache[draw]) == null ? void 0 : _a2[size2]) == null ? void 0 : _b[pub])
    return cache[dark ? "dark" : "light"][draw][size2][pub];
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = size2;
  const ctx = canvas.getContext("2d");
  const split = pub.split(".");
  const decoded = split.map((single) => decodeUrlSafeBase64(single));
  drawGradient(ctx, decoded[0][42], decoded[1][42], size2, dark);
  if (draw == "circles") {
    drawCircles(decoded[0], ctx, size2, 0.42 * size2);
    ctx.globalCompositeOperation = "multiply";
    drawCircles(decoded[1], ctx, size2, 0.125 * size2);
  }
  if (draw == "squares") {
    ctx.filter = "blur(20px)";
    drawSquares(decoded[0], ctx, size2);
    ctx.filter = "blur(0px)";
    ctx.globalCompositeOperation = "color-burn";
    drawSquares(decoded[1], ctx, size2);
  }
  if (reflect) {
    ctx.globalCompositeOperation = "source-over";
    ctx.scale(-1, 1);
    ctx.translate(-size2 / 2, 0);
    ctx.drawImage(canvas, size2 / 2, 0, size2, size2, 0, 0, size2, size2);
  }
  let mode = dark ? "dark" : "light";
  cache[mode] = cache[mode] || {};
  cache[mode][draw] = cache[mode][draw] || {};
  cache[mode][draw][size2] = cache[mode][draw][size2] || {};
  cache[mode][draw][size2][pub] = canvas.toDataURL();
  return cache[mode][draw][size2][pub];
}
function drawGradient(ctx, top2, bottom2, size2, dark = false) {
  var gradient = ctx.createLinearGradient(0, 0, 0, size2);
  let offset2 = 70;
  if (dark)
    offset2 = 0;
  gradient.addColorStop(0, `hsla(0,0%,${offset2 + top2 * 30}%)`);
  gradient.addColorStop(1, `hsla(0,0%,${offset2 + bottom2 * 30}%)`);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size2, size2);
}
function drawSquares(data2, ctx, size2) {
  const chunks = chunkIt(data2, 14);
  chunks.forEach((chunk) => {
    if (chunk.length == 14) {
      let x2 = chunk[0] * size2;
      let y2 = chunk[1] * size2;
      let r2 = size2 / 8 + chunk[2] * size2 * (7 / 8);
      let angle2 = chunk[13] * Math.PI;
      let h1 = chunk[3] * 360;
      let s1 = chunk[4] * 100;
      let l1 = chunk[5] * 100;
      let a1 = chunk[6];
      let x1 = chunk[7];
      let h2 = chunk[8] * 360;
      let s2 = chunk[9] * 100;
      let l2 = chunk[10] * 100;
      let a2 = chunk[11];
      let x22 = chunk[12];
      const gradient = ctx.createLinearGradient(x2 + r2 * x1, 0, x2 + r2 * x22, size2);
      gradient.addColorStop(0, `hsla(${h1},${s1}%,${l1}%,${a1})`);
      gradient.addColorStop(1, `hsla(${h2},${s2}%,${l2}%,${a2})`);
      ctx.fillStyle = gradient;
      ctx.translate(x2, y2);
      ctx.rotate(angle2);
      ctx.fillRect(-r2 / 2, -r2 / 2, r2, r2);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
  });
}
function drawCircles(data2, ctx, size2, radius) {
  const chunks = chunkIt(data2, 7);
  chunks.forEach((chunk) => {
    if (chunk.length == 7) {
      let x2 = size2 / 2 + chunk[0] * size2 / 2;
      let y2 = chunk[1] * size2;
      let r2 = chunk[2] * radius;
      let h2 = chunk[3] * 360;
      let s2 = chunk[4] * 100;
      let l2 = chunk[5] * 100;
      let a2 = chunk[6];
      ctx.beginPath();
      ctx.arc(x2, y2, r2, 0, 2 * Math.PI, false);
      ctx.fillStyle = `hsla(${h2},${s2}%,${l2}%,${a2})`;
      ctx.closePath();
      ctx.fill();
    }
  });
}
function decodeUrlSafeBase64(st) {
  const symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const symbolArray = symbols.split("");
  let arr = [];
  let i2 = 0;
  for (let letter of st) {
    arr[i2++] = symbolArray.indexOf(letter) / 64;
  }
  return arr;
}
function chunkIt(list3, chunkSize = 3) {
  return [...Array(Math.ceil(list3.length / chunkSize))].map(() => list3.splice(0, chunkSize));
}
var jsQR$1 = { exports: {} };
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module2.exports = factory();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module3 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
        module3.l = true;
        return module3.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports3, name, getter) {
        if (!__webpack_require__.o(exports3, name)) {
          Object.defineProperty(exports3, name, {
            configurable: false,
            enumerable: true,
            get: getter
          });
        }
      };
      __webpack_require__.n = function(module3) {
        var getter = module3 && module3.__esModule ? function getDefault() {
          return module3["default"];
        } : function getModuleExports() {
          return module3;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 3);
    }([
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var BitMatrix = function() {
          function BitMatrix2(data2, width) {
            this.width = width;
            this.height = data2.length / width;
            this.data = data2;
          }
          BitMatrix2.createEmpty = function(width, height) {
            return new BitMatrix2(new Uint8ClampedArray(width * height), width);
          };
          BitMatrix2.prototype.get = function(x2, y2) {
            if (x2 < 0 || x2 >= this.width || y2 < 0 || y2 >= this.height) {
              return false;
            }
            return !!this.data[y2 * this.width + x2];
          };
          BitMatrix2.prototype.set = function(x2, y2, v2) {
            this.data[y2 * this.width + x2] = v2 ? 1 : 0;
          };
          BitMatrix2.prototype.setRegion = function(left, top2, width, height, v2) {
            for (var y2 = top2; y2 < top2 + height; y2++) {
              for (var x2 = left; x2 < left + width; x2++) {
                this.set(x2, y2, !!v2);
              }
            }
          };
          return BitMatrix2;
        }();
        exports3.BitMatrix = BitMatrix;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var GenericGFPoly_1 = __webpack_require__(2);
        function addOrSubtractGF(a2, b2) {
          return a2 ^ b2;
        }
        exports3.addOrSubtractGF = addOrSubtractGF;
        var GenericGF = function() {
          function GenericGF2(primitive, size2, genBase) {
            this.primitive = primitive;
            this.size = size2;
            this.generatorBase = genBase;
            this.expTable = new Array(this.size);
            this.logTable = new Array(this.size);
            var x2 = 1;
            for (var i2 = 0; i2 < this.size; i2++) {
              this.expTable[i2] = x2;
              x2 = x2 * 2;
              if (x2 >= this.size) {
                x2 = (x2 ^ this.primitive) & this.size - 1;
              }
            }
            for (var i2 = 0; i2 < this.size - 1; i2++) {
              this.logTable[this.expTable[i2]] = i2;
            }
            this.zero = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([0]));
            this.one = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([1]));
          }
          GenericGF2.prototype.multiply = function(a2, b2) {
            if (a2 === 0 || b2 === 0) {
              return 0;
            }
            return this.expTable[(this.logTable[a2] + this.logTable[b2]) % (this.size - 1)];
          };
          GenericGF2.prototype.inverse = function(a2) {
            if (a2 === 0) {
              throw new Error("Can't invert 0");
            }
            return this.expTable[this.size - this.logTable[a2] - 1];
          };
          GenericGF2.prototype.buildMonomial = function(degree, coefficient) {
            if (degree < 0) {
              throw new Error("Invalid monomial degree less than 0");
            }
            if (coefficient === 0) {
              return this.zero;
            }
            var coefficients = new Uint8ClampedArray(degree + 1);
            coefficients[0] = coefficient;
            return new GenericGFPoly_1.default(this, coefficients);
          };
          GenericGF2.prototype.log = function(a2) {
            if (a2 === 0) {
              throw new Error("Can't take log(0)");
            }
            return this.logTable[a2];
          };
          GenericGF2.prototype.exp = function(a2) {
            return this.expTable[a2];
          };
          return GenericGF2;
        }();
        exports3.default = GenericGF;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var GenericGF_1 = __webpack_require__(1);
        var GenericGFPoly = function() {
          function GenericGFPoly2(field, coefficients) {
            if (coefficients.length === 0) {
              throw new Error("No coefficients.");
            }
            this.field = field;
            var coefficientsLength = coefficients.length;
            if (coefficientsLength > 1 && coefficients[0] === 0) {
              var firstNonZero = 1;
              while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                firstNonZero++;
              }
              if (firstNonZero === coefficientsLength) {
                this.coefficients = field.zero.coefficients;
              } else {
                this.coefficients = new Uint8ClampedArray(coefficientsLength - firstNonZero);
                for (var i2 = 0; i2 < this.coefficients.length; i2++) {
                  this.coefficients[i2] = coefficients[firstNonZero + i2];
                }
              }
            } else {
              this.coefficients = coefficients;
            }
          }
          GenericGFPoly2.prototype.degree = function() {
            return this.coefficients.length - 1;
          };
          GenericGFPoly2.prototype.isZero = function() {
            return this.coefficients[0] === 0;
          };
          GenericGFPoly2.prototype.getCoefficient = function(degree) {
            return this.coefficients[this.coefficients.length - 1 - degree];
          };
          GenericGFPoly2.prototype.addOrSubtract = function(other) {
            var _a2;
            if (this.isZero()) {
              return other;
            }
            if (other.isZero()) {
              return this;
            }
            var smallerCoefficients = this.coefficients;
            var largerCoefficients = other.coefficients;
            if (smallerCoefficients.length > largerCoefficients.length) {
              _a2 = [largerCoefficients, smallerCoefficients], smallerCoefficients = _a2[0], largerCoefficients = _a2[1];
            }
            var sumDiff = new Uint8ClampedArray(largerCoefficients.length);
            var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
            for (var i2 = 0; i2 < lengthDiff; i2++) {
              sumDiff[i2] = largerCoefficients[i2];
            }
            for (var i2 = lengthDiff; i2 < largerCoefficients.length; i2++) {
              sumDiff[i2] = GenericGF_1.addOrSubtractGF(smallerCoefficients[i2 - lengthDiff], largerCoefficients[i2]);
            }
            return new GenericGFPoly2(this.field, sumDiff);
          };
          GenericGFPoly2.prototype.multiply = function(scalar) {
            if (scalar === 0) {
              return this.field.zero;
            }
            if (scalar === 1) {
              return this;
            }
            var size2 = this.coefficients.length;
            var product = new Uint8ClampedArray(size2);
            for (var i2 = 0; i2 < size2; i2++) {
              product[i2] = this.field.multiply(this.coefficients[i2], scalar);
            }
            return new GenericGFPoly2(this.field, product);
          };
          GenericGFPoly2.prototype.multiplyPoly = function(other) {
            if (this.isZero() || other.isZero()) {
              return this.field.zero;
            }
            var aCoefficients = this.coefficients;
            var aLength = aCoefficients.length;
            var bCoefficients = other.coefficients;
            var bLength = bCoefficients.length;
            var product = new Uint8ClampedArray(aLength + bLength - 1);
            for (var i2 = 0; i2 < aLength; i2++) {
              var aCoeff = aCoefficients[i2];
              for (var j2 = 0; j2 < bLength; j2++) {
                product[i2 + j2] = GenericGF_1.addOrSubtractGF(product[i2 + j2], this.field.multiply(aCoeff, bCoefficients[j2]));
              }
            }
            return new GenericGFPoly2(this.field, product);
          };
          GenericGFPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
            if (degree < 0) {
              throw new Error("Invalid degree less than 0");
            }
            if (coefficient === 0) {
              return this.field.zero;
            }
            var size2 = this.coefficients.length;
            var product = new Uint8ClampedArray(size2 + degree);
            for (var i2 = 0; i2 < size2; i2++) {
              product[i2] = this.field.multiply(this.coefficients[i2], coefficient);
            }
            return new GenericGFPoly2(this.field, product);
          };
          GenericGFPoly2.prototype.evaluateAt = function(a2) {
            var result = 0;
            if (a2 === 0) {
              return this.getCoefficient(0);
            }
            var size2 = this.coefficients.length;
            if (a2 === 1) {
              this.coefficients.forEach(function(coefficient) {
                result = GenericGF_1.addOrSubtractGF(result, coefficient);
              });
              return result;
            }
            result = this.coefficients[0];
            for (var i2 = 1; i2 < size2; i2++) {
              result = GenericGF_1.addOrSubtractGF(this.field.multiply(a2, result), this.coefficients[i2]);
            }
            return result;
          };
          return GenericGFPoly2;
        }();
        exports3.default = GenericGFPoly;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var binarizer_1 = __webpack_require__(4);
        var decoder_1 = __webpack_require__(5);
        var extractor_1 = __webpack_require__(11);
        var locator_1 = __webpack_require__(12);
        function scan(matrix) {
          var locations = locator_1.locate(matrix);
          if (!locations) {
            return null;
          }
          for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
            var location_1 = locations_1[_i];
            var extracted = extractor_1.extract(matrix, location_1);
            var decoded = decoder_1.decode(extracted.matrix);
            if (decoded) {
              return {
                binaryData: decoded.bytes,
                data: decoded.text,
                chunks: decoded.chunks,
                version: decoded.version,
                location: {
                  topRightCorner: extracted.mappingFunction(location_1.dimension, 0),
                  topLeftCorner: extracted.mappingFunction(0, 0),
                  bottomRightCorner: extracted.mappingFunction(location_1.dimension, location_1.dimension),
                  bottomLeftCorner: extracted.mappingFunction(0, location_1.dimension),
                  topRightFinderPattern: location_1.topRight,
                  topLeftFinderPattern: location_1.topLeft,
                  bottomLeftFinderPattern: location_1.bottomLeft,
                  bottomRightAlignmentPattern: location_1.alignmentPattern
                }
              };
            }
          }
          return null;
        }
        var defaultOptions2 = {
          inversionAttempts: "attemptBoth"
        };
        function jsQR2(data2, width, height, providedOptions) {
          if (providedOptions === void 0) {
            providedOptions = {};
          }
          var options = defaultOptions2;
          Object.keys(options || {}).forEach(function(opt) {
            options[opt] = providedOptions[opt] || options[opt];
          });
          var shouldInvert = options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst";
          var tryInvertedFirst = options.inversionAttempts === "onlyInvert" || options.inversionAttempts === "invertFirst";
          var _a2 = binarizer_1.binarize(data2, width, height, shouldInvert), binarized = _a2.binarized, inverted = _a2.inverted;
          var result = scan(tryInvertedFirst ? inverted : binarized);
          if (!result && (options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst")) {
            result = scan(tryInvertedFirst ? binarized : inverted);
          }
          return result;
        }
        jsQR2.default = jsQR2;
        exports3.default = jsQR2;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var BitMatrix_1 = __webpack_require__(0);
        var REGION_SIZE = 8;
        var MIN_DYNAMIC_RANGE = 24;
        function numBetween(value, min2, max2) {
          return value < min2 ? min2 : value > max2 ? max2 : value;
        }
        var Matrix = function() {
          function Matrix2(width, height) {
            this.width = width;
            this.data = new Uint8ClampedArray(width * height);
          }
          Matrix2.prototype.get = function(x2, y2) {
            return this.data[y2 * this.width + x2];
          };
          Matrix2.prototype.set = function(x2, y2, value) {
            this.data[y2 * this.width + x2] = value;
          };
          return Matrix2;
        }();
        function binarize(data2, width, height, returnInverted) {
          if (data2.length !== width * height * 4) {
            throw new Error("Malformed data passed to binarizer.");
          }
          var greyscalePixels = new Matrix(width, height);
          for (var x2 = 0; x2 < width; x2++) {
            for (var y2 = 0; y2 < height; y2++) {
              var r2 = data2[(y2 * width + x2) * 4 + 0];
              var g2 = data2[(y2 * width + x2) * 4 + 1];
              var b2 = data2[(y2 * width + x2) * 4 + 2];
              greyscalePixels.set(x2, y2, 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2);
            }
          }
          var horizontalRegionCount = Math.ceil(width / REGION_SIZE);
          var verticalRegionCount = Math.ceil(height / REGION_SIZE);
          var blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);
          for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
            for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
              var sum2 = 0;
              var min2 = Infinity;
              var max2 = 0;
              for (var y2 = 0; y2 < REGION_SIZE; y2++) {
                for (var x2 = 0; x2 < REGION_SIZE; x2++) {
                  var pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x2, verticalRegion * REGION_SIZE + y2);
                  sum2 += pixelLumosity;
                  min2 = Math.min(min2, pixelLumosity);
                  max2 = Math.max(max2, pixelLumosity);
                }
              }
              var average = sum2 / Math.pow(REGION_SIZE, 2);
              if (max2 - min2 <= MIN_DYNAMIC_RANGE) {
                average = min2 / 2;
                if (verticalRegion > 0 && hortizontalRegion > 0) {
                  var averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - 1) + 2 * blackPoints.get(hortizontalRegion - 1, verticalRegion) + blackPoints.get(hortizontalRegion - 1, verticalRegion - 1)) / 4;
                  if (min2 < averageNeighborBlackPoint) {
                    average = averageNeighborBlackPoint;
                  }
                }
              }
              blackPoints.set(hortizontalRegion, verticalRegion, average);
            }
          }
          var binarized = BitMatrix_1.BitMatrix.createEmpty(width, height);
          var inverted = null;
          if (returnInverted) {
            inverted = BitMatrix_1.BitMatrix.createEmpty(width, height);
          }
          for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
            for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
              var left = numBetween(hortizontalRegion, 2, horizontalRegionCount - 3);
              var top_1 = numBetween(verticalRegion, 2, verticalRegionCount - 3);
              var sum2 = 0;
              for (var xRegion = -2; xRegion <= 2; xRegion++) {
                for (var yRegion = -2; yRegion <= 2; yRegion++) {
                  sum2 += blackPoints.get(left + xRegion, top_1 + yRegion);
                }
              }
              var threshold = sum2 / 25;
              for (var xRegion = 0; xRegion < REGION_SIZE; xRegion++) {
                for (var yRegion = 0; yRegion < REGION_SIZE; yRegion++) {
                  var x2 = hortizontalRegion * REGION_SIZE + xRegion;
                  var y2 = verticalRegion * REGION_SIZE + yRegion;
                  var lum = greyscalePixels.get(x2, y2);
                  binarized.set(x2, y2, lum <= threshold);
                  if (returnInverted) {
                    inverted.set(x2, y2, !(lum <= threshold));
                  }
                }
              }
            }
          }
          if (returnInverted) {
            return { binarized, inverted };
          }
          return { binarized };
        }
        exports3.binarize = binarize;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var BitMatrix_1 = __webpack_require__(0);
        var decodeData_1 = __webpack_require__(6);
        var reedsolomon_1 = __webpack_require__(9);
        var version_1 = __webpack_require__(10);
        function numBitsDiffering(x2, y2) {
          var z2 = x2 ^ y2;
          var bitCount = 0;
          while (z2) {
            bitCount++;
            z2 &= z2 - 1;
          }
          return bitCount;
        }
        function pushBit(bit, byte) {
          return byte << 1 | bit;
        }
        var FORMAT_INFO_TABLE = [
          { bits: 21522, formatInfo: { errorCorrectionLevel: 1, dataMask: 0 } },
          { bits: 20773, formatInfo: { errorCorrectionLevel: 1, dataMask: 1 } },
          { bits: 24188, formatInfo: { errorCorrectionLevel: 1, dataMask: 2 } },
          { bits: 23371, formatInfo: { errorCorrectionLevel: 1, dataMask: 3 } },
          { bits: 17913, formatInfo: { errorCorrectionLevel: 1, dataMask: 4 } },
          { bits: 16590, formatInfo: { errorCorrectionLevel: 1, dataMask: 5 } },
          { bits: 20375, formatInfo: { errorCorrectionLevel: 1, dataMask: 6 } },
          { bits: 19104, formatInfo: { errorCorrectionLevel: 1, dataMask: 7 } },
          { bits: 30660, formatInfo: { errorCorrectionLevel: 0, dataMask: 0 } },
          { bits: 29427, formatInfo: { errorCorrectionLevel: 0, dataMask: 1 } },
          { bits: 32170, formatInfo: { errorCorrectionLevel: 0, dataMask: 2 } },
          { bits: 30877, formatInfo: { errorCorrectionLevel: 0, dataMask: 3 } },
          { bits: 26159, formatInfo: { errorCorrectionLevel: 0, dataMask: 4 } },
          { bits: 25368, formatInfo: { errorCorrectionLevel: 0, dataMask: 5 } },
          { bits: 27713, formatInfo: { errorCorrectionLevel: 0, dataMask: 6 } },
          { bits: 26998, formatInfo: { errorCorrectionLevel: 0, dataMask: 7 } },
          { bits: 5769, formatInfo: { errorCorrectionLevel: 3, dataMask: 0 } },
          { bits: 5054, formatInfo: { errorCorrectionLevel: 3, dataMask: 1 } },
          { bits: 7399, formatInfo: { errorCorrectionLevel: 3, dataMask: 2 } },
          { bits: 6608, formatInfo: { errorCorrectionLevel: 3, dataMask: 3 } },
          { bits: 1890, formatInfo: { errorCorrectionLevel: 3, dataMask: 4 } },
          { bits: 597, formatInfo: { errorCorrectionLevel: 3, dataMask: 5 } },
          { bits: 3340, formatInfo: { errorCorrectionLevel: 3, dataMask: 6 } },
          { bits: 2107, formatInfo: { errorCorrectionLevel: 3, dataMask: 7 } },
          { bits: 13663, formatInfo: { errorCorrectionLevel: 2, dataMask: 0 } },
          { bits: 12392, formatInfo: { errorCorrectionLevel: 2, dataMask: 1 } },
          { bits: 16177, formatInfo: { errorCorrectionLevel: 2, dataMask: 2 } },
          { bits: 14854, formatInfo: { errorCorrectionLevel: 2, dataMask: 3 } },
          { bits: 9396, formatInfo: { errorCorrectionLevel: 2, dataMask: 4 } },
          { bits: 8579, formatInfo: { errorCorrectionLevel: 2, dataMask: 5 } },
          { bits: 11994, formatInfo: { errorCorrectionLevel: 2, dataMask: 6 } },
          { bits: 11245, formatInfo: { errorCorrectionLevel: 2, dataMask: 7 } }
        ];
        var DATA_MASKS = [
          function(p2) {
            return (p2.y + p2.x) % 2 === 0;
          },
          function(p2) {
            return p2.y % 2 === 0;
          },
          function(p2) {
            return p2.x % 3 === 0;
          },
          function(p2) {
            return (p2.y + p2.x) % 3 === 0;
          },
          function(p2) {
            return (Math.floor(p2.y / 2) + Math.floor(p2.x / 3)) % 2 === 0;
          },
          function(p2) {
            return p2.x * p2.y % 2 + p2.x * p2.y % 3 === 0;
          },
          function(p2) {
            return (p2.y * p2.x % 2 + p2.y * p2.x % 3) % 2 === 0;
          },
          function(p2) {
            return ((p2.y + p2.x) % 2 + p2.y * p2.x % 3) % 2 === 0;
          }
        ];
        function buildFunctionPatternMask(version2) {
          var dimension = 17 + 4 * version2.versionNumber;
          var matrix = BitMatrix_1.BitMatrix.createEmpty(dimension, dimension);
          matrix.setRegion(0, 0, 9, 9, true);
          matrix.setRegion(dimension - 8, 0, 8, 9, true);
          matrix.setRegion(0, dimension - 8, 9, 8, true);
          for (var _i = 0, _a2 = version2.alignmentPatternCenters; _i < _a2.length; _i++) {
            var x2 = _a2[_i];
            for (var _b = 0, _c = version2.alignmentPatternCenters; _b < _c.length; _b++) {
              var y2 = _c[_b];
              if (!(x2 === 6 && y2 === 6 || x2 === 6 && y2 === dimension - 7 || x2 === dimension - 7 && y2 === 6)) {
                matrix.setRegion(x2 - 2, y2 - 2, 5, 5, true);
              }
            }
          }
          matrix.setRegion(6, 9, 1, dimension - 17, true);
          matrix.setRegion(9, 6, dimension - 17, 1, true);
          if (version2.versionNumber > 6) {
            matrix.setRegion(dimension - 11, 0, 3, 6, true);
            matrix.setRegion(0, dimension - 11, 6, 3, true);
          }
          return matrix;
        }
        function readCodewords(matrix, version2, formatInfo) {
          var dataMask = DATA_MASKS[formatInfo.dataMask];
          var dimension = matrix.height;
          var functionPatternMask = buildFunctionPatternMask(version2);
          var codewords = [];
          var currentByte = 0;
          var bitsRead = 0;
          var readingUp = true;
          for (var columnIndex = dimension - 1; columnIndex > 0; columnIndex -= 2) {
            if (columnIndex === 6) {
              columnIndex--;
            }
            for (var i2 = 0; i2 < dimension; i2++) {
              var y2 = readingUp ? dimension - 1 - i2 : i2;
              for (var columnOffset = 0; columnOffset < 2; columnOffset++) {
                var x2 = columnIndex - columnOffset;
                if (!functionPatternMask.get(x2, y2)) {
                  bitsRead++;
                  var bit = matrix.get(x2, y2);
                  if (dataMask({ y: y2, x: x2 })) {
                    bit = !bit;
                  }
                  currentByte = pushBit(bit, currentByte);
                  if (bitsRead === 8) {
                    codewords.push(currentByte);
                    bitsRead = 0;
                    currentByte = 0;
                  }
                }
              }
            }
            readingUp = !readingUp;
          }
          return codewords;
        }
        function readVersion(matrix) {
          var dimension = matrix.height;
          var provisionalVersion = Math.floor((dimension - 17) / 4);
          if (provisionalVersion <= 6) {
            return version_1.VERSIONS[provisionalVersion - 1];
          }
          var topRightVersionBits = 0;
          for (var y2 = 5; y2 >= 0; y2--) {
            for (var x2 = dimension - 9; x2 >= dimension - 11; x2--) {
              topRightVersionBits = pushBit(matrix.get(x2, y2), topRightVersionBits);
            }
          }
          var bottomLeftVersionBits = 0;
          for (var x2 = 5; x2 >= 0; x2--) {
            for (var y2 = dimension - 9; y2 >= dimension - 11; y2--) {
              bottomLeftVersionBits = pushBit(matrix.get(x2, y2), bottomLeftVersionBits);
            }
          }
          var bestDifference = Infinity;
          var bestVersion;
          for (var _i = 0, VERSIONS_1 = version_1.VERSIONS; _i < VERSIONS_1.length; _i++) {
            var version2 = VERSIONS_1[_i];
            if (version2.infoBits === topRightVersionBits || version2.infoBits === bottomLeftVersionBits) {
              return version2;
            }
            var difference = numBitsDiffering(topRightVersionBits, version2.infoBits);
            if (difference < bestDifference) {
              bestVersion = version2;
              bestDifference = difference;
            }
            difference = numBitsDiffering(bottomLeftVersionBits, version2.infoBits);
            if (difference < bestDifference) {
              bestVersion = version2;
              bestDifference = difference;
            }
          }
          if (bestDifference <= 3) {
            return bestVersion;
          }
        }
        function readFormatInformation(matrix) {
          var topLeftFormatInfoBits = 0;
          for (var x2 = 0; x2 <= 8; x2++) {
            if (x2 !== 6) {
              topLeftFormatInfoBits = pushBit(matrix.get(x2, 8), topLeftFormatInfoBits);
            }
          }
          for (var y2 = 7; y2 >= 0; y2--) {
            if (y2 !== 6) {
              topLeftFormatInfoBits = pushBit(matrix.get(8, y2), topLeftFormatInfoBits);
            }
          }
          var dimension = matrix.height;
          var topRightBottomRightFormatInfoBits = 0;
          for (var y2 = dimension - 1; y2 >= dimension - 7; y2--) {
            topRightBottomRightFormatInfoBits = pushBit(matrix.get(8, y2), topRightBottomRightFormatInfoBits);
          }
          for (var x2 = dimension - 8; x2 < dimension; x2++) {
            topRightBottomRightFormatInfoBits = pushBit(matrix.get(x2, 8), topRightBottomRightFormatInfoBits);
          }
          var bestDifference = Infinity;
          var bestFormatInfo = null;
          for (var _i = 0, FORMAT_INFO_TABLE_1 = FORMAT_INFO_TABLE; _i < FORMAT_INFO_TABLE_1.length; _i++) {
            var _a2 = FORMAT_INFO_TABLE_1[_i], bits2 = _a2.bits, formatInfo = _a2.formatInfo;
            if (bits2 === topLeftFormatInfoBits || bits2 === topRightBottomRightFormatInfoBits) {
              return formatInfo;
            }
            var difference = numBitsDiffering(topLeftFormatInfoBits, bits2);
            if (difference < bestDifference) {
              bestFormatInfo = formatInfo;
              bestDifference = difference;
            }
            if (topLeftFormatInfoBits !== topRightBottomRightFormatInfoBits) {
              difference = numBitsDiffering(topRightBottomRightFormatInfoBits, bits2);
              if (difference < bestDifference) {
                bestFormatInfo = formatInfo;
                bestDifference = difference;
              }
            }
          }
          if (bestDifference <= 3) {
            return bestFormatInfo;
          }
          return null;
        }
        function getDataBlocks(codewords, version2, ecLevel) {
          var ecInfo = version2.errorCorrectionLevels[ecLevel];
          var dataBlocks = [];
          var totalCodewords = 0;
          ecInfo.ecBlocks.forEach(function(block3) {
            for (var i3 = 0; i3 < block3.numBlocks; i3++) {
              dataBlocks.push({ numDataCodewords: block3.dataCodewordsPerBlock, codewords: [] });
              totalCodewords += block3.dataCodewordsPerBlock + ecInfo.ecCodewordsPerBlock;
            }
          });
          if (codewords.length < totalCodewords) {
            return null;
          }
          codewords = codewords.slice(0, totalCodewords);
          var shortBlockSize = ecInfo.ecBlocks[0].dataCodewordsPerBlock;
          for (var i2 = 0; i2 < shortBlockSize; i2++) {
            for (var _i = 0, dataBlocks_1 = dataBlocks; _i < dataBlocks_1.length; _i++) {
              var dataBlock = dataBlocks_1[_i];
              dataBlock.codewords.push(codewords.shift());
            }
          }
          if (ecInfo.ecBlocks.length > 1) {
            var smallBlockCount = ecInfo.ecBlocks[0].numBlocks;
            var largeBlockCount = ecInfo.ecBlocks[1].numBlocks;
            for (var i2 = 0; i2 < largeBlockCount; i2++) {
              dataBlocks[smallBlockCount + i2].codewords.push(codewords.shift());
            }
          }
          while (codewords.length > 0) {
            for (var _a2 = 0, dataBlocks_2 = dataBlocks; _a2 < dataBlocks_2.length; _a2++) {
              var dataBlock = dataBlocks_2[_a2];
              dataBlock.codewords.push(codewords.shift());
            }
          }
          return dataBlocks;
        }
        function decodeMatrix(matrix) {
          var version2 = readVersion(matrix);
          if (!version2) {
            return null;
          }
          var formatInfo = readFormatInformation(matrix);
          if (!formatInfo) {
            return null;
          }
          var codewords = readCodewords(matrix, version2, formatInfo);
          var dataBlocks = getDataBlocks(codewords, version2, formatInfo.errorCorrectionLevel);
          if (!dataBlocks) {
            return null;
          }
          var totalBytes = dataBlocks.reduce(function(a2, b2) {
            return a2 + b2.numDataCodewords;
          }, 0);
          var resultBytes = new Uint8ClampedArray(totalBytes);
          var resultIndex = 0;
          for (var _i = 0, dataBlocks_3 = dataBlocks; _i < dataBlocks_3.length; _i++) {
            var dataBlock = dataBlocks_3[_i];
            var correctedBytes = reedsolomon_1.decode(dataBlock.codewords, dataBlock.codewords.length - dataBlock.numDataCodewords);
            if (!correctedBytes) {
              return null;
            }
            for (var i2 = 0; i2 < dataBlock.numDataCodewords; i2++) {
              resultBytes[resultIndex++] = correctedBytes[i2];
            }
          }
          try {
            return decodeData_1.decode(resultBytes, version2.versionNumber);
          } catch (_a2) {
            return null;
          }
        }
        function decode2(matrix) {
          if (matrix == null) {
            return null;
          }
          var result = decodeMatrix(matrix);
          if (result) {
            return result;
          }
          for (var x2 = 0; x2 < matrix.width; x2++) {
            for (var y2 = x2 + 1; y2 < matrix.height; y2++) {
              if (matrix.get(x2, y2) !== matrix.get(y2, x2)) {
                matrix.set(x2, y2, !matrix.get(x2, y2));
                matrix.set(y2, x2, !matrix.get(y2, x2));
              }
            }
          }
          return decodeMatrix(matrix);
        }
        exports3.decode = decode2;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var BitStream_1 = __webpack_require__(7);
        var shiftJISTable_1 = __webpack_require__(8);
        var Mode;
        (function(Mode2) {
          Mode2["Numeric"] = "numeric";
          Mode2["Alphanumeric"] = "alphanumeric";
          Mode2["Byte"] = "byte";
          Mode2["Kanji"] = "kanji";
          Mode2["ECI"] = "eci";
        })(Mode = exports3.Mode || (exports3.Mode = {}));
        var ModeByte;
        (function(ModeByte2) {
          ModeByte2[ModeByte2["Terminator"] = 0] = "Terminator";
          ModeByte2[ModeByte2["Numeric"] = 1] = "Numeric";
          ModeByte2[ModeByte2["Alphanumeric"] = 2] = "Alphanumeric";
          ModeByte2[ModeByte2["Byte"] = 4] = "Byte";
          ModeByte2[ModeByte2["Kanji"] = 8] = "Kanji";
          ModeByte2[ModeByte2["ECI"] = 7] = "ECI";
        })(ModeByte || (ModeByte = {}));
        function decodeNumeric(stream, size2) {
          var bytes = [];
          var text3 = "";
          var characterCountSize = [10, 12, 14][size2];
          var length = stream.readBits(characterCountSize);
          while (length >= 3) {
            var num2 = stream.readBits(10);
            if (num2 >= 1e3) {
              throw new Error("Invalid numeric value above 999");
            }
            var a2 = Math.floor(num2 / 100);
            var b2 = Math.floor(num2 / 10) % 10;
            var c2 = num2 % 10;
            bytes.push(48 + a2, 48 + b2, 48 + c2);
            text3 += a2.toString() + b2.toString() + c2.toString();
            length -= 3;
          }
          if (length === 2) {
            var num2 = stream.readBits(7);
            if (num2 >= 100) {
              throw new Error("Invalid numeric value above 99");
            }
            var a2 = Math.floor(num2 / 10);
            var b2 = num2 % 10;
            bytes.push(48 + a2, 48 + b2);
            text3 += a2.toString() + b2.toString();
          } else if (length === 1) {
            var num2 = stream.readBits(4);
            if (num2 >= 10) {
              throw new Error("Invalid numeric value above 9");
            }
            bytes.push(48 + num2);
            text3 += num2.toString();
          }
          return { bytes, text: text3 };
        }
        var AlphanumericCharacterCodes = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          " ",
          "$",
          "%",
          "*",
          "+",
          "-",
          ".",
          "/",
          ":"
        ];
        function decodeAlphanumeric(stream, size2) {
          var bytes = [];
          var text3 = "";
          var characterCountSize = [9, 11, 13][size2];
          var length = stream.readBits(characterCountSize);
          while (length >= 2) {
            var v2 = stream.readBits(11);
            var a2 = Math.floor(v2 / 45);
            var b2 = v2 % 45;
            bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0), AlphanumericCharacterCodes[b2].charCodeAt(0));
            text3 += AlphanumericCharacterCodes[a2] + AlphanumericCharacterCodes[b2];
            length -= 2;
          }
          if (length === 1) {
            var a2 = stream.readBits(6);
            bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0));
            text3 += AlphanumericCharacterCodes[a2];
          }
          return { bytes, text: text3 };
        }
        function decodeByte(stream, size2) {
          var bytes = [];
          var text3 = "";
          var characterCountSize = [8, 16, 16][size2];
          var length = stream.readBits(characterCountSize);
          for (var i2 = 0; i2 < length; i2++) {
            var b2 = stream.readBits(8);
            bytes.push(b2);
          }
          try {
            text3 += decodeURIComponent(bytes.map(function(b3) {
              return "%" + ("0" + b3.toString(16)).substr(-2);
            }).join(""));
          } catch (_a2) {
          }
          return { bytes, text: text3 };
        }
        function decodeKanji(stream, size2) {
          var bytes = [];
          var text3 = "";
          var characterCountSize = [8, 10, 12][size2];
          var length = stream.readBits(characterCountSize);
          for (var i2 = 0; i2 < length; i2++) {
            var k2 = stream.readBits(13);
            var c2 = Math.floor(k2 / 192) << 8 | k2 % 192;
            if (c2 < 7936) {
              c2 += 33088;
            } else {
              c2 += 49472;
            }
            bytes.push(c2 >> 8, c2 & 255);
            text3 += String.fromCharCode(shiftJISTable_1.shiftJISTable[c2]);
          }
          return { bytes, text: text3 };
        }
        function decode2(data2, version2) {
          var _a2, _b, _c, _d;
          var stream = new BitStream_1.BitStream(data2);
          var size2 = version2 <= 9 ? 0 : version2 <= 26 ? 1 : 2;
          var result = {
            text: "",
            bytes: [],
            chunks: [],
            version: version2
          };
          while (stream.available() >= 4) {
            var mode = stream.readBits(4);
            if (mode === ModeByte.Terminator) {
              return result;
            } else if (mode === ModeByte.ECI) {
              if (stream.readBits(1) === 0) {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: stream.readBits(7)
                });
              } else if (stream.readBits(1) === 0) {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: stream.readBits(14)
                });
              } else if (stream.readBits(1) === 0) {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: stream.readBits(21)
                });
              } else {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: -1
                });
              }
            } else if (mode === ModeByte.Numeric) {
              var numericResult = decodeNumeric(stream, size2);
              result.text += numericResult.text;
              (_a2 = result.bytes).push.apply(_a2, numericResult.bytes);
              result.chunks.push({
                type: Mode.Numeric,
                text: numericResult.text
              });
            } else if (mode === ModeByte.Alphanumeric) {
              var alphanumericResult = decodeAlphanumeric(stream, size2);
              result.text += alphanumericResult.text;
              (_b = result.bytes).push.apply(_b, alphanumericResult.bytes);
              result.chunks.push({
                type: Mode.Alphanumeric,
                text: alphanumericResult.text
              });
            } else if (mode === ModeByte.Byte) {
              var byteResult = decodeByte(stream, size2);
              result.text += byteResult.text;
              (_c = result.bytes).push.apply(_c, byteResult.bytes);
              result.chunks.push({
                type: Mode.Byte,
                bytes: byteResult.bytes,
                text: byteResult.text
              });
            } else if (mode === ModeByte.Kanji) {
              var kanjiResult = decodeKanji(stream, size2);
              result.text += kanjiResult.text;
              (_d = result.bytes).push.apply(_d, kanjiResult.bytes);
              result.chunks.push({
                type: Mode.Kanji,
                bytes: kanjiResult.bytes,
                text: kanjiResult.text
              });
            }
          }
          if (stream.available() === 0 || stream.readBits(stream.available()) === 0) {
            return result;
          }
        }
        exports3.decode = decode2;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var BitStream = function() {
          function BitStream2(bytes) {
            this.byteOffset = 0;
            this.bitOffset = 0;
            this.bytes = bytes;
          }
          BitStream2.prototype.readBits = function(numBits) {
            if (numBits < 1 || numBits > 32 || numBits > this.available()) {
              throw new Error("Cannot read " + numBits.toString() + " bits");
            }
            var result = 0;
            if (this.bitOffset > 0) {
              var bitsLeft = 8 - this.bitOffset;
              var toRead = numBits < bitsLeft ? numBits : bitsLeft;
              var bitsToNotRead = bitsLeft - toRead;
              var mask = 255 >> 8 - toRead << bitsToNotRead;
              result = (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
              numBits -= toRead;
              this.bitOffset += toRead;
              if (this.bitOffset === 8) {
                this.bitOffset = 0;
                this.byteOffset++;
              }
            }
            if (numBits > 0) {
              while (numBits >= 8) {
                result = result << 8 | this.bytes[this.byteOffset] & 255;
                this.byteOffset++;
                numBits -= 8;
              }
              if (numBits > 0) {
                var bitsToNotRead = 8 - numBits;
                var mask = 255 >> bitsToNotRead << bitsToNotRead;
                result = result << numBits | (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
                this.bitOffset += numBits;
              }
            }
            return result;
          };
          BitStream2.prototype.available = function() {
            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
          };
          return BitStream2;
        }();
        exports3.BitStream = BitStream;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.shiftJISTable = {
          32: 32,
          33: 33,
          34: 34,
          35: 35,
          36: 36,
          37: 37,
          38: 38,
          39: 39,
          40: 40,
          41: 41,
          42: 42,
          43: 43,
          44: 44,
          45: 45,
          46: 46,
          47: 47,
          48: 48,
          49: 49,
          50: 50,
          51: 51,
          52: 52,
          53: 53,
          54: 54,
          55: 55,
          56: 56,
          57: 57,
          58: 58,
          59: 59,
          60: 60,
          61: 61,
          62: 62,
          63: 63,
          64: 64,
          65: 65,
          66: 66,
          67: 67,
          68: 68,
          69: 69,
          70: 70,
          71: 71,
          72: 72,
          73: 73,
          74: 74,
          75: 75,
          76: 76,
          77: 77,
          78: 78,
          79: 79,
          80: 80,
          81: 81,
          82: 82,
          83: 83,
          84: 84,
          85: 85,
          86: 86,
          87: 87,
          88: 88,
          89: 89,
          90: 90,
          91: 91,
          92: 165,
          93: 93,
          94: 94,
          95: 95,
          96: 96,
          97: 97,
          98: 98,
          99: 99,
          100: 100,
          101: 101,
          102: 102,
          103: 103,
          104: 104,
          105: 105,
          106: 106,
          107: 107,
          108: 108,
          109: 109,
          110: 110,
          111: 111,
          112: 112,
          113: 113,
          114: 114,
          115: 115,
          116: 116,
          117: 117,
          118: 118,
          119: 119,
          120: 120,
          121: 121,
          122: 122,
          123: 123,
          124: 124,
          125: 125,
          126: 8254,
          33088: 12288,
          33089: 12289,
          33090: 12290,
          33091: 65292,
          33092: 65294,
          33093: 12539,
          33094: 65306,
          33095: 65307,
          33096: 65311,
          33097: 65281,
          33098: 12443,
          33099: 12444,
          33100: 180,
          33101: 65344,
          33102: 168,
          33103: 65342,
          33104: 65507,
          33105: 65343,
          33106: 12541,
          33107: 12542,
          33108: 12445,
          33109: 12446,
          33110: 12291,
          33111: 20189,
          33112: 12293,
          33113: 12294,
          33114: 12295,
          33115: 12540,
          33116: 8213,
          33117: 8208,
          33118: 65295,
          33119: 92,
          33120: 12316,
          33121: 8214,
          33122: 65372,
          33123: 8230,
          33124: 8229,
          33125: 8216,
          33126: 8217,
          33127: 8220,
          33128: 8221,
          33129: 65288,
          33130: 65289,
          33131: 12308,
          33132: 12309,
          33133: 65339,
          33134: 65341,
          33135: 65371,
          33136: 65373,
          33137: 12296,
          33138: 12297,
          33139: 12298,
          33140: 12299,
          33141: 12300,
          33142: 12301,
          33143: 12302,
          33144: 12303,
          33145: 12304,
          33146: 12305,
          33147: 65291,
          33148: 8722,
          33149: 177,
          33150: 215,
          33152: 247,
          33153: 65309,
          33154: 8800,
          33155: 65308,
          33156: 65310,
          33157: 8806,
          33158: 8807,
          33159: 8734,
          33160: 8756,
          33161: 9794,
          33162: 9792,
          33163: 176,
          33164: 8242,
          33165: 8243,
          33166: 8451,
          33167: 65509,
          33168: 65284,
          33169: 162,
          33170: 163,
          33171: 65285,
          33172: 65283,
          33173: 65286,
          33174: 65290,
          33175: 65312,
          33176: 167,
          33177: 9734,
          33178: 9733,
          33179: 9675,
          33180: 9679,
          33181: 9678,
          33182: 9671,
          33183: 9670,
          33184: 9633,
          33185: 9632,
          33186: 9651,
          33187: 9650,
          33188: 9661,
          33189: 9660,
          33190: 8251,
          33191: 12306,
          33192: 8594,
          33193: 8592,
          33194: 8593,
          33195: 8595,
          33196: 12307,
          33208: 8712,
          33209: 8715,
          33210: 8838,
          33211: 8839,
          33212: 8834,
          33213: 8835,
          33214: 8746,
          33215: 8745,
          33224: 8743,
          33225: 8744,
          33226: 172,
          33227: 8658,
          33228: 8660,
          33229: 8704,
          33230: 8707,
          33242: 8736,
          33243: 8869,
          33244: 8978,
          33245: 8706,
          33246: 8711,
          33247: 8801,
          33248: 8786,
          33249: 8810,
          33250: 8811,
          33251: 8730,
          33252: 8765,
          33253: 8733,
          33254: 8757,
          33255: 8747,
          33256: 8748,
          33264: 8491,
          33265: 8240,
          33266: 9839,
          33267: 9837,
          33268: 9834,
          33269: 8224,
          33270: 8225,
          33271: 182,
          33276: 9711,
          33359: 65296,
          33360: 65297,
          33361: 65298,
          33362: 65299,
          33363: 65300,
          33364: 65301,
          33365: 65302,
          33366: 65303,
          33367: 65304,
          33368: 65305,
          33376: 65313,
          33377: 65314,
          33378: 65315,
          33379: 65316,
          33380: 65317,
          33381: 65318,
          33382: 65319,
          33383: 65320,
          33384: 65321,
          33385: 65322,
          33386: 65323,
          33387: 65324,
          33388: 65325,
          33389: 65326,
          33390: 65327,
          33391: 65328,
          33392: 65329,
          33393: 65330,
          33394: 65331,
          33395: 65332,
          33396: 65333,
          33397: 65334,
          33398: 65335,
          33399: 65336,
          33400: 65337,
          33401: 65338,
          33409: 65345,
          33410: 65346,
          33411: 65347,
          33412: 65348,
          33413: 65349,
          33414: 65350,
          33415: 65351,
          33416: 65352,
          33417: 65353,
          33418: 65354,
          33419: 65355,
          33420: 65356,
          33421: 65357,
          33422: 65358,
          33423: 65359,
          33424: 65360,
          33425: 65361,
          33426: 65362,
          33427: 65363,
          33428: 65364,
          33429: 65365,
          33430: 65366,
          33431: 65367,
          33432: 65368,
          33433: 65369,
          33434: 65370,
          33439: 12353,
          33440: 12354,
          33441: 12355,
          33442: 12356,
          33443: 12357,
          33444: 12358,
          33445: 12359,
          33446: 12360,
          33447: 12361,
          33448: 12362,
          33449: 12363,
          33450: 12364,
          33451: 12365,
          33452: 12366,
          33453: 12367,
          33454: 12368,
          33455: 12369,
          33456: 12370,
          33457: 12371,
          33458: 12372,
          33459: 12373,
          33460: 12374,
          33461: 12375,
          33462: 12376,
          33463: 12377,
          33464: 12378,
          33465: 12379,
          33466: 12380,
          33467: 12381,
          33468: 12382,
          33469: 12383,
          33470: 12384,
          33471: 12385,
          33472: 12386,
          33473: 12387,
          33474: 12388,
          33475: 12389,
          33476: 12390,
          33477: 12391,
          33478: 12392,
          33479: 12393,
          33480: 12394,
          33481: 12395,
          33482: 12396,
          33483: 12397,
          33484: 12398,
          33485: 12399,
          33486: 12400,
          33487: 12401,
          33488: 12402,
          33489: 12403,
          33490: 12404,
          33491: 12405,
          33492: 12406,
          33493: 12407,
          33494: 12408,
          33495: 12409,
          33496: 12410,
          33497: 12411,
          33498: 12412,
          33499: 12413,
          33500: 12414,
          33501: 12415,
          33502: 12416,
          33503: 12417,
          33504: 12418,
          33505: 12419,
          33506: 12420,
          33507: 12421,
          33508: 12422,
          33509: 12423,
          33510: 12424,
          33511: 12425,
          33512: 12426,
          33513: 12427,
          33514: 12428,
          33515: 12429,
          33516: 12430,
          33517: 12431,
          33518: 12432,
          33519: 12433,
          33520: 12434,
          33521: 12435,
          33600: 12449,
          33601: 12450,
          33602: 12451,
          33603: 12452,
          33604: 12453,
          33605: 12454,
          33606: 12455,
          33607: 12456,
          33608: 12457,
          33609: 12458,
          33610: 12459,
          33611: 12460,
          33612: 12461,
          33613: 12462,
          33614: 12463,
          33615: 12464,
          33616: 12465,
          33617: 12466,
          33618: 12467,
          33619: 12468,
          33620: 12469,
          33621: 12470,
          33622: 12471,
          33623: 12472,
          33624: 12473,
          33625: 12474,
          33626: 12475,
          33627: 12476,
          33628: 12477,
          33629: 12478,
          33630: 12479,
          33631: 12480,
          33632: 12481,
          33633: 12482,
          33634: 12483,
          33635: 12484,
          33636: 12485,
          33637: 12486,
          33638: 12487,
          33639: 12488,
          33640: 12489,
          33641: 12490,
          33642: 12491,
          33643: 12492,
          33644: 12493,
          33645: 12494,
          33646: 12495,
          33647: 12496,
          33648: 12497,
          33649: 12498,
          33650: 12499,
          33651: 12500,
          33652: 12501,
          33653: 12502,
          33654: 12503,
          33655: 12504,
          33656: 12505,
          33657: 12506,
          33658: 12507,
          33659: 12508,
          33660: 12509,
          33661: 12510,
          33662: 12511,
          33664: 12512,
          33665: 12513,
          33666: 12514,
          33667: 12515,
          33668: 12516,
          33669: 12517,
          33670: 12518,
          33671: 12519,
          33672: 12520,
          33673: 12521,
          33674: 12522,
          33675: 12523,
          33676: 12524,
          33677: 12525,
          33678: 12526,
          33679: 12527,
          33680: 12528,
          33681: 12529,
          33682: 12530,
          33683: 12531,
          33684: 12532,
          33685: 12533,
          33686: 12534,
          33695: 913,
          33696: 914,
          33697: 915,
          33698: 916,
          33699: 917,
          33700: 918,
          33701: 919,
          33702: 920,
          33703: 921,
          33704: 922,
          33705: 923,
          33706: 924,
          33707: 925,
          33708: 926,
          33709: 927,
          33710: 928,
          33711: 929,
          33712: 931,
          33713: 932,
          33714: 933,
          33715: 934,
          33716: 935,
          33717: 936,
          33718: 937,
          33727: 945,
          33728: 946,
          33729: 947,
          33730: 948,
          33731: 949,
          33732: 950,
          33733: 951,
          33734: 952,
          33735: 953,
          33736: 954,
          33737: 955,
          33738: 956,
          33739: 957,
          33740: 958,
          33741: 959,
          33742: 960,
          33743: 961,
          33744: 963,
          33745: 964,
          33746: 965,
          33747: 966,
          33748: 967,
          33749: 968,
          33750: 969,
          33856: 1040,
          33857: 1041,
          33858: 1042,
          33859: 1043,
          33860: 1044,
          33861: 1045,
          33862: 1025,
          33863: 1046,
          33864: 1047,
          33865: 1048,
          33866: 1049,
          33867: 1050,
          33868: 1051,
          33869: 1052,
          33870: 1053,
          33871: 1054,
          33872: 1055,
          33873: 1056,
          33874: 1057,
          33875: 1058,
          33876: 1059,
          33877: 1060,
          33878: 1061,
          33879: 1062,
          33880: 1063,
          33881: 1064,
          33882: 1065,
          33883: 1066,
          33884: 1067,
          33885: 1068,
          33886: 1069,
          33887: 1070,
          33888: 1071,
          33904: 1072,
          33905: 1073,
          33906: 1074,
          33907: 1075,
          33908: 1076,
          33909: 1077,
          33910: 1105,
          33911: 1078,
          33912: 1079,
          33913: 1080,
          33914: 1081,
          33915: 1082,
          33916: 1083,
          33917: 1084,
          33918: 1085,
          33920: 1086,
          33921: 1087,
          33922: 1088,
          33923: 1089,
          33924: 1090,
          33925: 1091,
          33926: 1092,
          33927: 1093,
          33928: 1094,
          33929: 1095,
          33930: 1096,
          33931: 1097,
          33932: 1098,
          33933: 1099,
          33934: 1100,
          33935: 1101,
          33936: 1102,
          33937: 1103,
          33951: 9472,
          33952: 9474,
          33953: 9484,
          33954: 9488,
          33955: 9496,
          33956: 9492,
          33957: 9500,
          33958: 9516,
          33959: 9508,
          33960: 9524,
          33961: 9532,
          33962: 9473,
          33963: 9475,
          33964: 9487,
          33965: 9491,
          33966: 9499,
          33967: 9495,
          33968: 9507,
          33969: 9523,
          33970: 9515,
          33971: 9531,
          33972: 9547,
          33973: 9504,
          33974: 9519,
          33975: 9512,
          33976: 9527,
          33977: 9535,
          33978: 9501,
          33979: 9520,
          33980: 9509,
          33981: 9528,
          33982: 9538,
          34975: 20124,
          34976: 21782,
          34977: 23043,
          34978: 38463,
          34979: 21696,
          34980: 24859,
          34981: 25384,
          34982: 23030,
          34983: 36898,
          34984: 33909,
          34985: 33564,
          34986: 31312,
          34987: 24746,
          34988: 25569,
          34989: 28197,
          34990: 26093,
          34991: 33894,
          34992: 33446,
          34993: 39925,
          34994: 26771,
          34995: 22311,
          34996: 26017,
          34997: 25201,
          34998: 23451,
          34999: 22992,
          35e3: 34427,
          35001: 39156,
          35002: 32098,
          35003: 32190,
          35004: 39822,
          35005: 25110,
          35006: 31903,
          35007: 34999,
          35008: 23433,
          35009: 24245,
          35010: 25353,
          35011: 26263,
          35012: 26696,
          35013: 38343,
          35014: 38797,
          35015: 26447,
          35016: 20197,
          35017: 20234,
          35018: 20301,
          35019: 20381,
          35020: 20553,
          35021: 22258,
          35022: 22839,
          35023: 22996,
          35024: 23041,
          35025: 23561,
          35026: 24799,
          35027: 24847,
          35028: 24944,
          35029: 26131,
          35030: 26885,
          35031: 28858,
          35032: 30031,
          35033: 30064,
          35034: 31227,
          35035: 32173,
          35036: 32239,
          35037: 32963,
          35038: 33806,
          35039: 34915,
          35040: 35586,
          35041: 36949,
          35042: 36986,
          35043: 21307,
          35044: 20117,
          35045: 20133,
          35046: 22495,
          35047: 32946,
          35048: 37057,
          35049: 30959,
          35050: 19968,
          35051: 22769,
          35052: 28322,
          35053: 36920,
          35054: 31282,
          35055: 33576,
          35056: 33419,
          35057: 39983,
          35058: 20801,
          35059: 21360,
          35060: 21693,
          35061: 21729,
          35062: 22240,
          35063: 23035,
          35064: 24341,
          35065: 39154,
          35066: 28139,
          35067: 32996,
          35068: 34093,
          35136: 38498,
          35137: 38512,
          35138: 38560,
          35139: 38907,
          35140: 21515,
          35141: 21491,
          35142: 23431,
          35143: 28879,
          35144: 32701,
          35145: 36802,
          35146: 38632,
          35147: 21359,
          35148: 40284,
          35149: 31418,
          35150: 19985,
          35151: 30867,
          35152: 33276,
          35153: 28198,
          35154: 22040,
          35155: 21764,
          35156: 27421,
          35157: 34074,
          35158: 39995,
          35159: 23013,
          35160: 21417,
          35161: 28006,
          35162: 29916,
          35163: 38287,
          35164: 22082,
          35165: 20113,
          35166: 36939,
          35167: 38642,
          35168: 33615,
          35169: 39180,
          35170: 21473,
          35171: 21942,
          35172: 23344,
          35173: 24433,
          35174: 26144,
          35175: 26355,
          35176: 26628,
          35177: 27704,
          35178: 27891,
          35179: 27945,
          35180: 29787,
          35181: 30408,
          35182: 31310,
          35183: 38964,
          35184: 33521,
          35185: 34907,
          35186: 35424,
          35187: 37613,
          35188: 28082,
          35189: 30123,
          35190: 30410,
          35191: 39365,
          35192: 24742,
          35193: 35585,
          35194: 36234,
          35195: 38322,
          35196: 27022,
          35197: 21421,
          35198: 20870,
          35200: 22290,
          35201: 22576,
          35202: 22852,
          35203: 23476,
          35204: 24310,
          35205: 24616,
          35206: 25513,
          35207: 25588,
          35208: 27839,
          35209: 28436,
          35210: 28814,
          35211: 28948,
          35212: 29017,
          35213: 29141,
          35214: 29503,
          35215: 32257,
          35216: 33398,
          35217: 33489,
          35218: 34199,
          35219: 36960,
          35220: 37467,
          35221: 40219,
          35222: 22633,
          35223: 26044,
          35224: 27738,
          35225: 29989,
          35226: 20985,
          35227: 22830,
          35228: 22885,
          35229: 24448,
          35230: 24540,
          35231: 25276,
          35232: 26106,
          35233: 27178,
          35234: 27431,
          35235: 27572,
          35236: 29579,
          35237: 32705,
          35238: 35158,
          35239: 40236,
          35240: 40206,
          35241: 40644,
          35242: 23713,
          35243: 27798,
          35244: 33659,
          35245: 20740,
          35246: 23627,
          35247: 25014,
          35248: 33222,
          35249: 26742,
          35250: 29281,
          35251: 20057,
          35252: 20474,
          35253: 21368,
          35254: 24681,
          35255: 28201,
          35256: 31311,
          35257: 38899,
          35258: 19979,
          35259: 21270,
          35260: 20206,
          35261: 20309,
          35262: 20285,
          35263: 20385,
          35264: 20339,
          35265: 21152,
          35266: 21487,
          35267: 22025,
          35268: 22799,
          35269: 23233,
          35270: 23478,
          35271: 23521,
          35272: 31185,
          35273: 26247,
          35274: 26524,
          35275: 26550,
          35276: 27468,
          35277: 27827,
          35278: 28779,
          35279: 29634,
          35280: 31117,
          35281: 31166,
          35282: 31292,
          35283: 31623,
          35284: 33457,
          35285: 33499,
          35286: 33540,
          35287: 33655,
          35288: 33775,
          35289: 33747,
          35290: 34662,
          35291: 35506,
          35292: 22057,
          35293: 36008,
          35294: 36838,
          35295: 36942,
          35296: 38686,
          35297: 34442,
          35298: 20420,
          35299: 23784,
          35300: 25105,
          35301: 29273,
          35302: 30011,
          35303: 33253,
          35304: 33469,
          35305: 34558,
          35306: 36032,
          35307: 38597,
          35308: 39187,
          35309: 39381,
          35310: 20171,
          35311: 20250,
          35312: 35299,
          35313: 22238,
          35314: 22602,
          35315: 22730,
          35316: 24315,
          35317: 24555,
          35318: 24618,
          35319: 24724,
          35320: 24674,
          35321: 25040,
          35322: 25106,
          35323: 25296,
          35324: 25913,
          35392: 39745,
          35393: 26214,
          35394: 26800,
          35395: 28023,
          35396: 28784,
          35397: 30028,
          35398: 30342,
          35399: 32117,
          35400: 33445,
          35401: 34809,
          35402: 38283,
          35403: 38542,
          35404: 35997,
          35405: 20977,
          35406: 21182,
          35407: 22806,
          35408: 21683,
          35409: 23475,
          35410: 23830,
          35411: 24936,
          35412: 27010,
          35413: 28079,
          35414: 30861,
          35415: 33995,
          35416: 34903,
          35417: 35442,
          35418: 37799,
          35419: 39608,
          35420: 28012,
          35421: 39336,
          35422: 34521,
          35423: 22435,
          35424: 26623,
          35425: 34510,
          35426: 37390,
          35427: 21123,
          35428: 22151,
          35429: 21508,
          35430: 24275,
          35431: 25313,
          35432: 25785,
          35433: 26684,
          35434: 26680,
          35435: 27579,
          35436: 29554,
          35437: 30906,
          35438: 31339,
          35439: 35226,
          35440: 35282,
          35441: 36203,
          35442: 36611,
          35443: 37101,
          35444: 38307,
          35445: 38548,
          35446: 38761,
          35447: 23398,
          35448: 23731,
          35449: 27005,
          35450: 38989,
          35451: 38990,
          35452: 25499,
          35453: 31520,
          35454: 27179,
          35456: 27263,
          35457: 26806,
          35458: 39949,
          35459: 28511,
          35460: 21106,
          35461: 21917,
          35462: 24688,
          35463: 25324,
          35464: 27963,
          35465: 28167,
          35466: 28369,
          35467: 33883,
          35468: 35088,
          35469: 36676,
          35470: 19988,
          35471: 39993,
          35472: 21494,
          35473: 26907,
          35474: 27194,
          35475: 38788,
          35476: 26666,
          35477: 20828,
          35478: 31427,
          35479: 33970,
          35480: 37340,
          35481: 37772,
          35482: 22107,
          35483: 40232,
          35484: 26658,
          35485: 33541,
          35486: 33841,
          35487: 31909,
          35488: 21e3,
          35489: 33477,
          35490: 29926,
          35491: 20094,
          35492: 20355,
          35493: 20896,
          35494: 23506,
          35495: 21002,
          35496: 21208,
          35497: 21223,
          35498: 24059,
          35499: 21914,
          35500: 22570,
          35501: 23014,
          35502: 23436,
          35503: 23448,
          35504: 23515,
          35505: 24178,
          35506: 24185,
          35507: 24739,
          35508: 24863,
          35509: 24931,
          35510: 25022,
          35511: 25563,
          35512: 25954,
          35513: 26577,
          35514: 26707,
          35515: 26874,
          35516: 27454,
          35517: 27475,
          35518: 27735,
          35519: 28450,
          35520: 28567,
          35521: 28485,
          35522: 29872,
          35523: 29976,
          35524: 30435,
          35525: 30475,
          35526: 31487,
          35527: 31649,
          35528: 31777,
          35529: 32233,
          35530: 32566,
          35531: 32752,
          35532: 32925,
          35533: 33382,
          35534: 33694,
          35535: 35251,
          35536: 35532,
          35537: 36011,
          35538: 36996,
          35539: 37969,
          35540: 38291,
          35541: 38289,
          35542: 38306,
          35543: 38501,
          35544: 38867,
          35545: 39208,
          35546: 33304,
          35547: 20024,
          35548: 21547,
          35549: 23736,
          35550: 24012,
          35551: 29609,
          35552: 30284,
          35553: 30524,
          35554: 23721,
          35555: 32747,
          35556: 36107,
          35557: 38593,
          35558: 38929,
          35559: 38996,
          35560: 39e3,
          35561: 20225,
          35562: 20238,
          35563: 21361,
          35564: 21916,
          35565: 22120,
          35566: 22522,
          35567: 22855,
          35568: 23305,
          35569: 23492,
          35570: 23696,
          35571: 24076,
          35572: 24190,
          35573: 24524,
          35574: 25582,
          35575: 26426,
          35576: 26071,
          35577: 26082,
          35578: 26399,
          35579: 26827,
          35580: 26820,
          35648: 27231,
          35649: 24112,
          35650: 27589,
          35651: 27671,
          35652: 27773,
          35653: 30079,
          35654: 31048,
          35655: 23395,
          35656: 31232,
          35657: 32e3,
          35658: 24509,
          35659: 35215,
          35660: 35352,
          35661: 36020,
          35662: 36215,
          35663: 36556,
          35664: 36637,
          35665: 39138,
          35666: 39438,
          35667: 39740,
          35668: 20096,
          35669: 20605,
          35670: 20736,
          35671: 22931,
          35672: 23452,
          35673: 25135,
          35674: 25216,
          35675: 25836,
          35676: 27450,
          35677: 29344,
          35678: 30097,
          35679: 31047,
          35680: 32681,
          35681: 34811,
          35682: 35516,
          35683: 35696,
          35684: 25516,
          35685: 33738,
          35686: 38816,
          35687: 21513,
          35688: 21507,
          35689: 21931,
          35690: 26708,
          35691: 27224,
          35692: 35440,
          35693: 30759,
          35694: 26485,
          35695: 40653,
          35696: 21364,
          35697: 23458,
          35698: 33050,
          35699: 34384,
          35700: 36870,
          35701: 19992,
          35702: 20037,
          35703: 20167,
          35704: 20241,
          35705: 21450,
          35706: 21560,
          35707: 23470,
          35708: 24339,
          35709: 24613,
          35710: 25937,
          35712: 26429,
          35713: 27714,
          35714: 27762,
          35715: 27875,
          35716: 28792,
          35717: 29699,
          35718: 31350,
          35719: 31406,
          35720: 31496,
          35721: 32026,
          35722: 31998,
          35723: 32102,
          35724: 26087,
          35725: 29275,
          35726: 21435,
          35727: 23621,
          35728: 24040,
          35729: 25298,
          35730: 25312,
          35731: 25369,
          35732: 28192,
          35733: 34394,
          35734: 35377,
          35735: 36317,
          35736: 37624,
          35737: 28417,
          35738: 31142,
          35739: 39770,
          35740: 20136,
          35741: 20139,
          35742: 20140,
          35743: 20379,
          35744: 20384,
          35745: 20689,
          35746: 20807,
          35747: 31478,
          35748: 20849,
          35749: 20982,
          35750: 21332,
          35751: 21281,
          35752: 21375,
          35753: 21483,
          35754: 21932,
          35755: 22659,
          35756: 23777,
          35757: 24375,
          35758: 24394,
          35759: 24623,
          35760: 24656,
          35761: 24685,
          35762: 25375,
          35763: 25945,
          35764: 27211,
          35765: 27841,
          35766: 29378,
          35767: 29421,
          35768: 30703,
          35769: 33016,
          35770: 33029,
          35771: 33288,
          35772: 34126,
          35773: 37111,
          35774: 37857,
          35775: 38911,
          35776: 39255,
          35777: 39514,
          35778: 20208,
          35779: 20957,
          35780: 23597,
          35781: 26241,
          35782: 26989,
          35783: 23616,
          35784: 26354,
          35785: 26997,
          35786: 29577,
          35787: 26704,
          35788: 31873,
          35789: 20677,
          35790: 21220,
          35791: 22343,
          35792: 24062,
          35793: 37670,
          35794: 26020,
          35795: 27427,
          35796: 27453,
          35797: 29748,
          35798: 31105,
          35799: 31165,
          35800: 31563,
          35801: 32202,
          35802: 33465,
          35803: 33740,
          35804: 34943,
          35805: 35167,
          35806: 35641,
          35807: 36817,
          35808: 37329,
          35809: 21535,
          35810: 37504,
          35811: 20061,
          35812: 20534,
          35813: 21477,
          35814: 21306,
          35815: 29399,
          35816: 29590,
          35817: 30697,
          35818: 33510,
          35819: 36527,
          35820: 39366,
          35821: 39368,
          35822: 39378,
          35823: 20855,
          35824: 24858,
          35825: 34398,
          35826: 21936,
          35827: 31354,
          35828: 20598,
          35829: 23507,
          35830: 36935,
          35831: 38533,
          35832: 20018,
          35833: 27355,
          35834: 37351,
          35835: 23633,
          35836: 23624,
          35904: 25496,
          35905: 31391,
          35906: 27795,
          35907: 38772,
          35908: 36705,
          35909: 31402,
          35910: 29066,
          35911: 38536,
          35912: 31874,
          35913: 26647,
          35914: 32368,
          35915: 26705,
          35916: 37740,
          35917: 21234,
          35918: 21531,
          35919: 34219,
          35920: 35347,
          35921: 32676,
          35922: 36557,
          35923: 37089,
          35924: 21350,
          35925: 34952,
          35926: 31041,
          35927: 20418,
          35928: 20670,
          35929: 21009,
          35930: 20804,
          35931: 21843,
          35932: 22317,
          35933: 29674,
          35934: 22411,
          35935: 22865,
          35936: 24418,
          35937: 24452,
          35938: 24693,
          35939: 24950,
          35940: 24935,
          35941: 25001,
          35942: 25522,
          35943: 25658,
          35944: 25964,
          35945: 26223,
          35946: 26690,
          35947: 28179,
          35948: 30054,
          35949: 31293,
          35950: 31995,
          35951: 32076,
          35952: 32153,
          35953: 32331,
          35954: 32619,
          35955: 33550,
          35956: 33610,
          35957: 34509,
          35958: 35336,
          35959: 35427,
          35960: 35686,
          35961: 36605,
          35962: 38938,
          35963: 40335,
          35964: 33464,
          35965: 36814,
          35966: 39912,
          35968: 21127,
          35969: 25119,
          35970: 25731,
          35971: 28608,
          35972: 38553,
          35973: 26689,
          35974: 20625,
          35975: 27424,
          35976: 27770,
          35977: 28500,
          35978: 31348,
          35979: 32080,
          35980: 34880,
          35981: 35363,
          35982: 26376,
          35983: 20214,
          35984: 20537,
          35985: 20518,
          35986: 20581,
          35987: 20860,
          35988: 21048,
          35989: 21091,
          35990: 21927,
          35991: 22287,
          35992: 22533,
          35993: 23244,
          35994: 24314,
          35995: 25010,
          35996: 25080,
          35997: 25331,
          35998: 25458,
          35999: 26908,
          36e3: 27177,
          36001: 29309,
          36002: 29356,
          36003: 29486,
          36004: 30740,
          36005: 30831,
          36006: 32121,
          36007: 30476,
          36008: 32937,
          36009: 35211,
          36010: 35609,
          36011: 36066,
          36012: 36562,
          36013: 36963,
          36014: 37749,
          36015: 38522,
          36016: 38997,
          36017: 39443,
          36018: 40568,
          36019: 20803,
          36020: 21407,
          36021: 21427,
          36022: 24187,
          36023: 24358,
          36024: 28187,
          36025: 28304,
          36026: 29572,
          36027: 29694,
          36028: 32067,
          36029: 33335,
          36030: 35328,
          36031: 35578,
          36032: 38480,
          36033: 20046,
          36034: 20491,
          36035: 21476,
          36036: 21628,
          36037: 22266,
          36038: 22993,
          36039: 23396,
          36040: 24049,
          36041: 24235,
          36042: 24359,
          36043: 25144,
          36044: 25925,
          36045: 26543,
          36046: 28246,
          36047: 29392,
          36048: 31946,
          36049: 34996,
          36050: 32929,
          36051: 32993,
          36052: 33776,
          36053: 34382,
          36054: 35463,
          36055: 36328,
          36056: 37431,
          36057: 38599,
          36058: 39015,
          36059: 40723,
          36060: 20116,
          36061: 20114,
          36062: 20237,
          36063: 21320,
          36064: 21577,
          36065: 21566,
          36066: 23087,
          36067: 24460,
          36068: 24481,
          36069: 24735,
          36070: 26791,
          36071: 27278,
          36072: 29786,
          36073: 30849,
          36074: 35486,
          36075: 35492,
          36076: 35703,
          36077: 37264,
          36078: 20062,
          36079: 39881,
          36080: 20132,
          36081: 20348,
          36082: 20399,
          36083: 20505,
          36084: 20502,
          36085: 20809,
          36086: 20844,
          36087: 21151,
          36088: 21177,
          36089: 21246,
          36090: 21402,
          36091: 21475,
          36092: 21521,
          36160: 21518,
          36161: 21897,
          36162: 22353,
          36163: 22434,
          36164: 22909,
          36165: 23380,
          36166: 23389,
          36167: 23439,
          36168: 24037,
          36169: 24039,
          36170: 24055,
          36171: 24184,
          36172: 24195,
          36173: 24218,
          36174: 24247,
          36175: 24344,
          36176: 24658,
          36177: 24908,
          36178: 25239,
          36179: 25304,
          36180: 25511,
          36181: 25915,
          36182: 26114,
          36183: 26179,
          36184: 26356,
          36185: 26477,
          36186: 26657,
          36187: 26775,
          36188: 27083,
          36189: 27743,
          36190: 27946,
          36191: 28009,
          36192: 28207,
          36193: 28317,
          36194: 30002,
          36195: 30343,
          36196: 30828,
          36197: 31295,
          36198: 31968,
          36199: 32005,
          36200: 32024,
          36201: 32094,
          36202: 32177,
          36203: 32789,
          36204: 32771,
          36205: 32943,
          36206: 32945,
          36207: 33108,
          36208: 33167,
          36209: 33322,
          36210: 33618,
          36211: 34892,
          36212: 34913,
          36213: 35611,
          36214: 36002,
          36215: 36092,
          36216: 37066,
          36217: 37237,
          36218: 37489,
          36219: 30783,
          36220: 37628,
          36221: 38308,
          36222: 38477,
          36224: 38917,
          36225: 39321,
          36226: 39640,
          36227: 40251,
          36228: 21083,
          36229: 21163,
          36230: 21495,
          36231: 21512,
          36232: 22741,
          36233: 25335,
          36234: 28640,
          36235: 35946,
          36236: 36703,
          36237: 40633,
          36238: 20811,
          36239: 21051,
          36240: 21578,
          36241: 22269,
          36242: 31296,
          36243: 37239,
          36244: 40288,
          36245: 40658,
          36246: 29508,
          36247: 28425,
          36248: 33136,
          36249: 29969,
          36250: 24573,
          36251: 24794,
          36252: 39592,
          36253: 29403,
          36254: 36796,
          36255: 27492,
          36256: 38915,
          36257: 20170,
          36258: 22256,
          36259: 22372,
          36260: 22718,
          36261: 23130,
          36262: 24680,
          36263: 25031,
          36264: 26127,
          36265: 26118,
          36266: 26681,
          36267: 26801,
          36268: 28151,
          36269: 30165,
          36270: 32058,
          36271: 33390,
          36272: 39746,
          36273: 20123,
          36274: 20304,
          36275: 21449,
          36276: 21766,
          36277: 23919,
          36278: 24038,
          36279: 24046,
          36280: 26619,
          36281: 27801,
          36282: 29811,
          36283: 30722,
          36284: 35408,
          36285: 37782,
          36286: 35039,
          36287: 22352,
          36288: 24231,
          36289: 25387,
          36290: 20661,
          36291: 20652,
          36292: 20877,
          36293: 26368,
          36294: 21705,
          36295: 22622,
          36296: 22971,
          36297: 23472,
          36298: 24425,
          36299: 25165,
          36300: 25505,
          36301: 26685,
          36302: 27507,
          36303: 28168,
          36304: 28797,
          36305: 37319,
          36306: 29312,
          36307: 30741,
          36308: 30758,
          36309: 31085,
          36310: 25998,
          36311: 32048,
          36312: 33756,
          36313: 35009,
          36314: 36617,
          36315: 38555,
          36316: 21092,
          36317: 22312,
          36318: 26448,
          36319: 32618,
          36320: 36001,
          36321: 20916,
          36322: 22338,
          36323: 38442,
          36324: 22586,
          36325: 27018,
          36326: 32948,
          36327: 21682,
          36328: 23822,
          36329: 22524,
          36330: 30869,
          36331: 40442,
          36332: 20316,
          36333: 21066,
          36334: 21643,
          36335: 25662,
          36336: 26152,
          36337: 26388,
          36338: 26613,
          36339: 31364,
          36340: 31574,
          36341: 32034,
          36342: 37679,
          36343: 26716,
          36344: 39853,
          36345: 31545,
          36346: 21273,
          36347: 20874,
          36348: 21047,
          36416: 23519,
          36417: 25334,
          36418: 25774,
          36419: 25830,
          36420: 26413,
          36421: 27578,
          36422: 34217,
          36423: 38609,
          36424: 30352,
          36425: 39894,
          36426: 25420,
          36427: 37638,
          36428: 39851,
          36429: 30399,
          36430: 26194,
          36431: 19977,
          36432: 20632,
          36433: 21442,
          36434: 23665,
          36435: 24808,
          36436: 25746,
          36437: 25955,
          36438: 26719,
          36439: 29158,
          36440: 29642,
          36441: 29987,
          36442: 31639,
          36443: 32386,
          36444: 34453,
          36445: 35715,
          36446: 36059,
          36447: 37240,
          36448: 39184,
          36449: 26028,
          36450: 26283,
          36451: 27531,
          36452: 20181,
          36453: 20180,
          36454: 20282,
          36455: 20351,
          36456: 21050,
          36457: 21496,
          36458: 21490,
          36459: 21987,
          36460: 22235,
          36461: 22763,
          36462: 22987,
          36463: 22985,
          36464: 23039,
          36465: 23376,
          36466: 23629,
          36467: 24066,
          36468: 24107,
          36469: 24535,
          36470: 24605,
          36471: 25351,
          36472: 25903,
          36473: 23388,
          36474: 26031,
          36475: 26045,
          36476: 26088,
          36477: 26525,
          36478: 27490,
          36480: 27515,
          36481: 27663,
          36482: 29509,
          36483: 31049,
          36484: 31169,
          36485: 31992,
          36486: 32025,
          36487: 32043,
          36488: 32930,
          36489: 33026,
          36490: 33267,
          36491: 35222,
          36492: 35422,
          36493: 35433,
          36494: 35430,
          36495: 35468,
          36496: 35566,
          36497: 36039,
          36498: 36060,
          36499: 38604,
          36500: 39164,
          36501: 27503,
          36502: 20107,
          36503: 20284,
          36504: 20365,
          36505: 20816,
          36506: 23383,
          36507: 23546,
          36508: 24904,
          36509: 25345,
          36510: 26178,
          36511: 27425,
          36512: 28363,
          36513: 27835,
          36514: 29246,
          36515: 29885,
          36516: 30164,
          36517: 30913,
          36518: 31034,
          36519: 32780,
          36520: 32819,
          36521: 33258,
          36522: 33940,
          36523: 36766,
          36524: 27728,
          36525: 40575,
          36526: 24335,
          36527: 35672,
          36528: 40235,
          36529: 31482,
          36530: 36600,
          36531: 23437,
          36532: 38635,
          36533: 19971,
          36534: 21489,
          36535: 22519,
          36536: 22833,
          36537: 23241,
          36538: 23460,
          36539: 24713,
          36540: 28287,
          36541: 28422,
          36542: 30142,
          36543: 36074,
          36544: 23455,
          36545: 34048,
          36546: 31712,
          36547: 20594,
          36548: 26612,
          36549: 33437,
          36550: 23649,
          36551: 34122,
          36552: 32286,
          36553: 33294,
          36554: 20889,
          36555: 23556,
          36556: 25448,
          36557: 36198,
          36558: 26012,
          36559: 29038,
          36560: 31038,
          36561: 32023,
          36562: 32773,
          36563: 35613,
          36564: 36554,
          36565: 36974,
          36566: 34503,
          36567: 37034,
          36568: 20511,
          36569: 21242,
          36570: 23610,
          36571: 26451,
          36572: 28796,
          36573: 29237,
          36574: 37196,
          36575: 37320,
          36576: 37675,
          36577: 33509,
          36578: 23490,
          36579: 24369,
          36580: 24825,
          36581: 20027,
          36582: 21462,
          36583: 23432,
          36584: 25163,
          36585: 26417,
          36586: 27530,
          36587: 29417,
          36588: 29664,
          36589: 31278,
          36590: 33131,
          36591: 36259,
          36592: 37202,
          36593: 39318,
          36594: 20754,
          36595: 21463,
          36596: 21610,
          36597: 23551,
          36598: 25480,
          36599: 27193,
          36600: 32172,
          36601: 38656,
          36602: 22234,
          36603: 21454,
          36604: 21608,
          36672: 23447,
          36673: 23601,
          36674: 24030,
          36675: 20462,
          36676: 24833,
          36677: 25342,
          36678: 27954,
          36679: 31168,
          36680: 31179,
          36681: 32066,
          36682: 32333,
          36683: 32722,
          36684: 33261,
          36685: 33311,
          36686: 33936,
          36687: 34886,
          36688: 35186,
          36689: 35728,
          36690: 36468,
          36691: 36655,
          36692: 36913,
          36693: 37195,
          36694: 37228,
          36695: 38598,
          36696: 37276,
          36697: 20160,
          36698: 20303,
          36699: 20805,
          36700: 21313,
          36701: 24467,
          36702: 25102,
          36703: 26580,
          36704: 27713,
          36705: 28171,
          36706: 29539,
          36707: 32294,
          36708: 37325,
          36709: 37507,
          36710: 21460,
          36711: 22809,
          36712: 23487,
          36713: 28113,
          36714: 31069,
          36715: 32302,
          36716: 31899,
          36717: 22654,
          36718: 29087,
          36719: 20986,
          36720: 34899,
          36721: 36848,
          36722: 20426,
          36723: 23803,
          36724: 26149,
          36725: 30636,
          36726: 31459,
          36727: 33308,
          36728: 39423,
          36729: 20934,
          36730: 24490,
          36731: 26092,
          36732: 26991,
          36733: 27529,
          36734: 28147,
          36736: 28310,
          36737: 28516,
          36738: 30462,
          36739: 32020,
          36740: 24033,
          36741: 36981,
          36742: 37255,
          36743: 38918,
          36744: 20966,
          36745: 21021,
          36746: 25152,
          36747: 26257,
          36748: 26329,
          36749: 28186,
          36750: 24246,
          36751: 32210,
          36752: 32626,
          36753: 26360,
          36754: 34223,
          36755: 34295,
          36756: 35576,
          36757: 21161,
          36758: 21465,
          36759: 22899,
          36760: 24207,
          36761: 24464,
          36762: 24661,
          36763: 37604,
          36764: 38500,
          36765: 20663,
          36766: 20767,
          36767: 21213,
          36768: 21280,
          36769: 21319,
          36770: 21484,
          36771: 21736,
          36772: 21830,
          36773: 21809,
          36774: 22039,
          36775: 22888,
          36776: 22974,
          36777: 23100,
          36778: 23477,
          36779: 23558,
          36780: 23567,
          36781: 23569,
          36782: 23578,
          36783: 24196,
          36784: 24202,
          36785: 24288,
          36786: 24432,
          36787: 25215,
          36788: 25220,
          36789: 25307,
          36790: 25484,
          36791: 25463,
          36792: 26119,
          36793: 26124,
          36794: 26157,
          36795: 26230,
          36796: 26494,
          36797: 26786,
          36798: 27167,
          36799: 27189,
          36800: 27836,
          36801: 28040,
          36802: 28169,
          36803: 28248,
          36804: 28988,
          36805: 28966,
          36806: 29031,
          36807: 30151,
          36808: 30465,
          36809: 30813,
          36810: 30977,
          36811: 31077,
          36812: 31216,
          36813: 31456,
          36814: 31505,
          36815: 31911,
          36816: 32057,
          36817: 32918,
          36818: 33750,
          36819: 33931,
          36820: 34121,
          36821: 34909,
          36822: 35059,
          36823: 35359,
          36824: 35388,
          36825: 35412,
          36826: 35443,
          36827: 35937,
          36828: 36062,
          36829: 37284,
          36830: 37478,
          36831: 37758,
          36832: 37912,
          36833: 38556,
          36834: 38808,
          36835: 19978,
          36836: 19976,
          36837: 19998,
          36838: 20055,
          36839: 20887,
          36840: 21104,
          36841: 22478,
          36842: 22580,
          36843: 22732,
          36844: 23330,
          36845: 24120,
          36846: 24773,
          36847: 25854,
          36848: 26465,
          36849: 26454,
          36850: 27972,
          36851: 29366,
          36852: 30067,
          36853: 31331,
          36854: 33976,
          36855: 35698,
          36856: 37304,
          36857: 37664,
          36858: 22065,
          36859: 22516,
          36860: 39166,
          36928: 25325,
          36929: 26893,
          36930: 27542,
          36931: 29165,
          36932: 32340,
          36933: 32887,
          36934: 33394,
          36935: 35302,
          36936: 39135,
          36937: 34645,
          36938: 36785,
          36939: 23611,
          36940: 20280,
          36941: 20449,
          36942: 20405,
          36943: 21767,
          36944: 23072,
          36945: 23517,
          36946: 23529,
          36947: 24515,
          36948: 24910,
          36949: 25391,
          36950: 26032,
          36951: 26187,
          36952: 26862,
          36953: 27035,
          36954: 28024,
          36955: 28145,
          36956: 30003,
          36957: 30137,
          36958: 30495,
          36959: 31070,
          36960: 31206,
          36961: 32051,
          36962: 33251,
          36963: 33455,
          36964: 34218,
          36965: 35242,
          36966: 35386,
          36967: 36523,
          36968: 36763,
          36969: 36914,
          36970: 37341,
          36971: 38663,
          36972: 20154,
          36973: 20161,
          36974: 20995,
          36975: 22645,
          36976: 22764,
          36977: 23563,
          36978: 29978,
          36979: 23613,
          36980: 33102,
          36981: 35338,
          36982: 36805,
          36983: 38499,
          36984: 38765,
          36985: 31525,
          36986: 35535,
          36987: 38920,
          36988: 37218,
          36989: 22259,
          36990: 21416,
          36992: 36887,
          36993: 21561,
          36994: 22402,
          36995: 24101,
          36996: 25512,
          36997: 27700,
          36998: 28810,
          36999: 30561,
          37e3: 31883,
          37001: 32736,
          37002: 34928,
          37003: 36930,
          37004: 37204,
          37005: 37648,
          37006: 37656,
          37007: 38543,
          37008: 29790,
          37009: 39620,
          37010: 23815,
          37011: 23913,
          37012: 25968,
          37013: 26530,
          37014: 36264,
          37015: 38619,
          37016: 25454,
          37017: 26441,
          37018: 26905,
          37019: 33733,
          37020: 38935,
          37021: 38592,
          37022: 35070,
          37023: 28548,
          37024: 25722,
          37025: 23544,
          37026: 19990,
          37027: 28716,
          37028: 30045,
          37029: 26159,
          37030: 20932,
          37031: 21046,
          37032: 21218,
          37033: 22995,
          37034: 24449,
          37035: 24615,
          37036: 25104,
          37037: 25919,
          37038: 25972,
          37039: 26143,
          37040: 26228,
          37041: 26866,
          37042: 26646,
          37043: 27491,
          37044: 28165,
          37045: 29298,
          37046: 29983,
          37047: 30427,
          37048: 31934,
          37049: 32854,
          37050: 22768,
          37051: 35069,
          37052: 35199,
          37053: 35488,
          37054: 35475,
          37055: 35531,
          37056: 36893,
          37057: 37266,
          37058: 38738,
          37059: 38745,
          37060: 25993,
          37061: 31246,
          37062: 33030,
          37063: 38587,
          37064: 24109,
          37065: 24796,
          37066: 25114,
          37067: 26021,
          37068: 26132,
          37069: 26512,
          37070: 30707,
          37071: 31309,
          37072: 31821,
          37073: 32318,
          37074: 33034,
          37075: 36012,
          37076: 36196,
          37077: 36321,
          37078: 36447,
          37079: 30889,
          37080: 20999,
          37081: 25305,
          37082: 25509,
          37083: 25666,
          37084: 25240,
          37085: 35373,
          37086: 31363,
          37087: 31680,
          37088: 35500,
          37089: 38634,
          37090: 32118,
          37091: 33292,
          37092: 34633,
          37093: 20185,
          37094: 20808,
          37095: 21315,
          37096: 21344,
          37097: 23459,
          37098: 23554,
          37099: 23574,
          37100: 24029,
          37101: 25126,
          37102: 25159,
          37103: 25776,
          37104: 26643,
          37105: 26676,
          37106: 27849,
          37107: 27973,
          37108: 27927,
          37109: 26579,
          37110: 28508,
          37111: 29006,
          37112: 29053,
          37113: 26059,
          37114: 31359,
          37115: 31661,
          37116: 32218,
          37184: 32330,
          37185: 32680,
          37186: 33146,
          37187: 33307,
          37188: 33337,
          37189: 34214,
          37190: 35438,
          37191: 36046,
          37192: 36341,
          37193: 36984,
          37194: 36983,
          37195: 37549,
          37196: 37521,
          37197: 38275,
          37198: 39854,
          37199: 21069,
          37200: 21892,
          37201: 28472,
          37202: 28982,
          37203: 20840,
          37204: 31109,
          37205: 32341,
          37206: 33203,
          37207: 31950,
          37208: 22092,
          37209: 22609,
          37210: 23720,
          37211: 25514,
          37212: 26366,
          37213: 26365,
          37214: 26970,
          37215: 29401,
          37216: 30095,
          37217: 30094,
          37218: 30990,
          37219: 31062,
          37220: 31199,
          37221: 31895,
          37222: 32032,
          37223: 32068,
          37224: 34311,
          37225: 35380,
          37226: 38459,
          37227: 36961,
          37228: 40736,
          37229: 20711,
          37230: 21109,
          37231: 21452,
          37232: 21474,
          37233: 20489,
          37234: 21930,
          37235: 22766,
          37236: 22863,
          37237: 29245,
          37238: 23435,
          37239: 23652,
          37240: 21277,
          37241: 24803,
          37242: 24819,
          37243: 25436,
          37244: 25475,
          37245: 25407,
          37246: 25531,
          37248: 25805,
          37249: 26089,
          37250: 26361,
          37251: 24035,
          37252: 27085,
          37253: 27133,
          37254: 28437,
          37255: 29157,
          37256: 20105,
          37257: 30185,
          37258: 30456,
          37259: 31379,
          37260: 31967,
          37261: 32207,
          37262: 32156,
          37263: 32865,
          37264: 33609,
          37265: 33624,
          37266: 33900,
          37267: 33980,
          37268: 34299,
          37269: 35013,
          37270: 36208,
          37271: 36865,
          37272: 36973,
          37273: 37783,
          37274: 38684,
          37275: 39442,
          37276: 20687,
          37277: 22679,
          37278: 24974,
          37279: 33235,
          37280: 34101,
          37281: 36104,
          37282: 36896,
          37283: 20419,
          37284: 20596,
          37285: 21063,
          37286: 21363,
          37287: 24687,
          37288: 25417,
          37289: 26463,
          37290: 28204,
          37291: 36275,
          37292: 36895,
          37293: 20439,
          37294: 23646,
          37295: 36042,
          37296: 26063,
          37297: 32154,
          37298: 21330,
          37299: 34966,
          37300: 20854,
          37301: 25539,
          37302: 23384,
          37303: 23403,
          37304: 23562,
          37305: 25613,
          37306: 26449,
          37307: 36956,
          37308: 20182,
          37309: 22810,
          37310: 22826,
          37311: 27760,
          37312: 35409,
          37313: 21822,
          37314: 22549,
          37315: 22949,
          37316: 24816,
          37317: 25171,
          37318: 26561,
          37319: 33333,
          37320: 26965,
          37321: 38464,
          37322: 39364,
          37323: 39464,
          37324: 20307,
          37325: 22534,
          37326: 23550,
          37327: 32784,
          37328: 23729,
          37329: 24111,
          37330: 24453,
          37331: 24608,
          37332: 24907,
          37333: 25140,
          37334: 26367,
          37335: 27888,
          37336: 28382,
          37337: 32974,
          37338: 33151,
          37339: 33492,
          37340: 34955,
          37341: 36024,
          37342: 36864,
          37343: 36910,
          37344: 38538,
          37345: 40667,
          37346: 39899,
          37347: 20195,
          37348: 21488,
          37349: 22823,
          37350: 31532,
          37351: 37261,
          37352: 38988,
          37353: 40441,
          37354: 28381,
          37355: 28711,
          37356: 21331,
          37357: 21828,
          37358: 23429,
          37359: 25176,
          37360: 25246,
          37361: 25299,
          37362: 27810,
          37363: 28655,
          37364: 29730,
          37365: 35351,
          37366: 37944,
          37367: 28609,
          37368: 35582,
          37369: 33592,
          37370: 20967,
          37371: 34552,
          37372: 21482,
          37440: 21481,
          37441: 20294,
          37442: 36948,
          37443: 36784,
          37444: 22890,
          37445: 33073,
          37446: 24061,
          37447: 31466,
          37448: 36799,
          37449: 26842,
          37450: 35895,
          37451: 29432,
          37452: 40008,
          37453: 27197,
          37454: 35504,
          37455: 20025,
          37456: 21336,
          37457: 22022,
          37458: 22374,
          37459: 25285,
          37460: 25506,
          37461: 26086,
          37462: 27470,
          37463: 28129,
          37464: 28251,
          37465: 28845,
          37466: 30701,
          37467: 31471,
          37468: 31658,
          37469: 32187,
          37470: 32829,
          37471: 32966,
          37472: 34507,
          37473: 35477,
          37474: 37723,
          37475: 22243,
          37476: 22727,
          37477: 24382,
          37478: 26029,
          37479: 26262,
          37480: 27264,
          37481: 27573,
          37482: 30007,
          37483: 35527,
          37484: 20516,
          37485: 30693,
          37486: 22320,
          37487: 24347,
          37488: 24677,
          37489: 26234,
          37490: 27744,
          37491: 30196,
          37492: 31258,
          37493: 32622,
          37494: 33268,
          37495: 34584,
          37496: 36933,
          37497: 39347,
          37498: 31689,
          37499: 30044,
          37500: 31481,
          37501: 31569,
          37502: 33988,
          37504: 36880,
          37505: 31209,
          37506: 31378,
          37507: 33590,
          37508: 23265,
          37509: 30528,
          37510: 20013,
          37511: 20210,
          37512: 23449,
          37513: 24544,
          37514: 25277,
          37515: 26172,
          37516: 26609,
          37517: 27880,
          37518: 34411,
          37519: 34935,
          37520: 35387,
          37521: 37198,
          37522: 37619,
          37523: 39376,
          37524: 27159,
          37525: 28710,
          37526: 29482,
          37527: 33511,
          37528: 33879,
          37529: 36015,
          37530: 19969,
          37531: 20806,
          37532: 20939,
          37533: 21899,
          37534: 23541,
          37535: 24086,
          37536: 24115,
          37537: 24193,
          37538: 24340,
          37539: 24373,
          37540: 24427,
          37541: 24500,
          37542: 25074,
          37543: 25361,
          37544: 26274,
          37545: 26397,
          37546: 28526,
          37547: 29266,
          37548: 30010,
          37549: 30522,
          37550: 32884,
          37551: 33081,
          37552: 33144,
          37553: 34678,
          37554: 35519,
          37555: 35548,
          37556: 36229,
          37557: 36339,
          37558: 37530,
          37559: 38263,
          37560: 38914,
          37561: 40165,
          37562: 21189,
          37563: 25431,
          37564: 30452,
          37565: 26389,
          37566: 27784,
          37567: 29645,
          37568: 36035,
          37569: 37806,
          37570: 38515,
          37571: 27941,
          37572: 22684,
          37573: 26894,
          37574: 27084,
          37575: 36861,
          37576: 37786,
          37577: 30171,
          37578: 36890,
          37579: 22618,
          37580: 26626,
          37581: 25524,
          37582: 27131,
          37583: 20291,
          37584: 28460,
          37585: 26584,
          37586: 36795,
          37587: 34086,
          37588: 32180,
          37589: 37716,
          37590: 26943,
          37591: 28528,
          37592: 22378,
          37593: 22775,
          37594: 23340,
          37595: 32044,
          37596: 29226,
          37597: 21514,
          37598: 37347,
          37599: 40372,
          37600: 20141,
          37601: 20302,
          37602: 20572,
          37603: 20597,
          37604: 21059,
          37605: 35998,
          37606: 21576,
          37607: 22564,
          37608: 23450,
          37609: 24093,
          37610: 24213,
          37611: 24237,
          37612: 24311,
          37613: 24351,
          37614: 24716,
          37615: 25269,
          37616: 25402,
          37617: 25552,
          37618: 26799,
          37619: 27712,
          37620: 30855,
          37621: 31118,
          37622: 31243,
          37623: 32224,
          37624: 33351,
          37625: 35330,
          37626: 35558,
          37627: 36420,
          37628: 36883,
          37696: 37048,
          37697: 37165,
          37698: 37336,
          37699: 40718,
          37700: 27877,
          37701: 25688,
          37702: 25826,
          37703: 25973,
          37704: 28404,
          37705: 30340,
          37706: 31515,
          37707: 36969,
          37708: 37841,
          37709: 28346,
          37710: 21746,
          37711: 24505,
          37712: 25764,
          37713: 36685,
          37714: 36845,
          37715: 37444,
          37716: 20856,
          37717: 22635,
          37718: 22825,
          37719: 23637,
          37720: 24215,
          37721: 28155,
          37722: 32399,
          37723: 29980,
          37724: 36028,
          37725: 36578,
          37726: 39003,
          37727: 28857,
          37728: 20253,
          37729: 27583,
          37730: 28593,
          37731: 3e4,
          37732: 38651,
          37733: 20814,
          37734: 21520,
          37735: 22581,
          37736: 22615,
          37737: 22956,
          37738: 23648,
          37739: 24466,
          37740: 26007,
          37741: 26460,
          37742: 28193,
          37743: 30331,
          37744: 33759,
          37745: 36077,
          37746: 36884,
          37747: 37117,
          37748: 37709,
          37749: 30757,
          37750: 30778,
          37751: 21162,
          37752: 24230,
          37753: 22303,
          37754: 22900,
          37755: 24594,
          37756: 20498,
          37757: 20826,
          37758: 20908,
          37760: 20941,
          37761: 20992,
          37762: 21776,
          37763: 22612,
          37764: 22616,
          37765: 22871,
          37766: 23445,
          37767: 23798,
          37768: 23947,
          37769: 24764,
          37770: 25237,
          37771: 25645,
          37772: 26481,
          37773: 26691,
          37774: 26812,
          37775: 26847,
          37776: 30423,
          37777: 28120,
          37778: 28271,
          37779: 28059,
          37780: 28783,
          37781: 29128,
          37782: 24403,
          37783: 30168,
          37784: 31095,
          37785: 31561,
          37786: 31572,
          37787: 31570,
          37788: 31958,
          37789: 32113,
          37790: 21040,
          37791: 33891,
          37792: 34153,
          37793: 34276,
          37794: 35342,
          37795: 35588,
          37796: 35910,
          37797: 36367,
          37798: 36867,
          37799: 36879,
          37800: 37913,
          37801: 38518,
          37802: 38957,
          37803: 39472,
          37804: 38360,
          37805: 20685,
          37806: 21205,
          37807: 21516,
          37808: 22530,
          37809: 23566,
          37810: 24999,
          37811: 25758,
          37812: 27934,
          37813: 30643,
          37814: 31461,
          37815: 33012,
          37816: 33796,
          37817: 36947,
          37818: 37509,
          37819: 23776,
          37820: 40199,
          37821: 21311,
          37822: 24471,
          37823: 24499,
          37824: 28060,
          37825: 29305,
          37826: 30563,
          37827: 31167,
          37828: 31716,
          37829: 27602,
          37830: 29420,
          37831: 35501,
          37832: 26627,
          37833: 27233,
          37834: 20984,
          37835: 31361,
          37836: 26932,
          37837: 23626,
          37838: 40182,
          37839: 33515,
          37840: 23493,
          37841: 37193,
          37842: 28702,
          37843: 22136,
          37844: 23663,
          37845: 24775,
          37846: 25958,
          37847: 27788,
          37848: 35930,
          37849: 36929,
          37850: 38931,
          37851: 21585,
          37852: 26311,
          37853: 37389,
          37854: 22856,
          37855: 37027,
          37856: 20869,
          37857: 20045,
          37858: 20970,
          37859: 34201,
          37860: 35598,
          37861: 28760,
          37862: 25466,
          37863: 37707,
          37864: 26978,
          37865: 39348,
          37866: 32260,
          37867: 30071,
          37868: 21335,
          37869: 26976,
          37870: 36575,
          37871: 38627,
          37872: 27741,
          37873: 20108,
          37874: 23612,
          37875: 24336,
          37876: 36841,
          37877: 21250,
          37878: 36049,
          37879: 32905,
          37880: 34425,
          37881: 24319,
          37882: 26085,
          37883: 20083,
          37884: 20837,
          37952: 22914,
          37953: 23615,
          37954: 38894,
          37955: 20219,
          37956: 22922,
          37957: 24525,
          37958: 35469,
          37959: 28641,
          37960: 31152,
          37961: 31074,
          37962: 23527,
          37963: 33905,
          37964: 29483,
          37965: 29105,
          37966: 24180,
          37967: 24565,
          37968: 25467,
          37969: 25754,
          37970: 29123,
          37971: 31896,
          37972: 20035,
          37973: 24316,
          37974: 20043,
          37975: 22492,
          37976: 22178,
          37977: 24745,
          37978: 28611,
          37979: 32013,
          37980: 33021,
          37981: 33075,
          37982: 33215,
          37983: 36786,
          37984: 35223,
          37985: 34468,
          37986: 24052,
          37987: 25226,
          37988: 25773,
          37989: 35207,
          37990: 26487,
          37991: 27874,
          37992: 27966,
          37993: 29750,
          37994: 30772,
          37995: 23110,
          37996: 32629,
          37997: 33453,
          37998: 39340,
          37999: 20467,
          38e3: 24259,
          38001: 25309,
          38002: 25490,
          38003: 25943,
          38004: 26479,
          38005: 30403,
          38006: 29260,
          38007: 32972,
          38008: 32954,
          38009: 36649,
          38010: 37197,
          38011: 20493,
          38012: 22521,
          38013: 23186,
          38014: 26757,
          38016: 26995,
          38017: 29028,
          38018: 29437,
          38019: 36023,
          38020: 22770,
          38021: 36064,
          38022: 38506,
          38023: 36889,
          38024: 34687,
          38025: 31204,
          38026: 30695,
          38027: 33833,
          38028: 20271,
          38029: 21093,
          38030: 21338,
          38031: 25293,
          38032: 26575,
          38033: 27850,
          38034: 30333,
          38035: 31636,
          38036: 31893,
          38037: 33334,
          38038: 34180,
          38039: 36843,
          38040: 26333,
          38041: 28448,
          38042: 29190,
          38043: 32283,
          38044: 33707,
          38045: 39361,
          38046: 40614,
          38047: 20989,
          38048: 31665,
          38049: 30834,
          38050: 31672,
          38051: 32903,
          38052: 31560,
          38053: 27368,
          38054: 24161,
          38055: 32908,
          38056: 30033,
          38057: 30048,
          38058: 20843,
          38059: 37474,
          38060: 28300,
          38061: 30330,
          38062: 37271,
          38063: 39658,
          38064: 20240,
          38065: 32624,
          38066: 25244,
          38067: 31567,
          38068: 38309,
          38069: 40169,
          38070: 22138,
          38071: 22617,
          38072: 34532,
          38073: 38588,
          38074: 20276,
          38075: 21028,
          38076: 21322,
          38077: 21453,
          38078: 21467,
          38079: 24070,
          38080: 25644,
          38081: 26001,
          38082: 26495,
          38083: 27710,
          38084: 27726,
          38085: 29256,
          38086: 29359,
          38087: 29677,
          38088: 30036,
          38089: 32321,
          38090: 33324,
          38091: 34281,
          38092: 36009,
          38093: 31684,
          38094: 37318,
          38095: 29033,
          38096: 38930,
          38097: 39151,
          38098: 25405,
          38099: 26217,
          38100: 30058,
          38101: 30436,
          38102: 30928,
          38103: 34115,
          38104: 34542,
          38105: 21290,
          38106: 21329,
          38107: 21542,
          38108: 22915,
          38109: 24199,
          38110: 24444,
          38111: 24754,
          38112: 25161,
          38113: 25209,
          38114: 25259,
          38115: 26e3,
          38116: 27604,
          38117: 27852,
          38118: 30130,
          38119: 30382,
          38120: 30865,
          38121: 31192,
          38122: 32203,
          38123: 32631,
          38124: 32933,
          38125: 34987,
          38126: 35513,
          38127: 36027,
          38128: 36991,
          38129: 38750,
          38130: 39131,
          38131: 27147,
          38132: 31800,
          38133: 20633,
          38134: 23614,
          38135: 24494,
          38136: 26503,
          38137: 27608,
          38138: 29749,
          38139: 30473,
          38140: 32654,
          38208: 40763,
          38209: 26570,
          38210: 31255,
          38211: 21305,
          38212: 30091,
          38213: 39661,
          38214: 24422,
          38215: 33181,
          38216: 33777,
          38217: 32920,
          38218: 24380,
          38219: 24517,
          38220: 30050,
          38221: 31558,
          38222: 36924,
          38223: 26727,
          38224: 23019,
          38225: 23195,
          38226: 32016,
          38227: 30334,
          38228: 35628,
          38229: 20469,
          38230: 24426,
          38231: 27161,
          38232: 27703,
          38233: 28418,
          38234: 29922,
          38235: 31080,
          38236: 34920,
          38237: 35413,
          38238: 35961,
          38239: 24287,
          38240: 25551,
          38241: 30149,
          38242: 31186,
          38243: 33495,
          38244: 37672,
          38245: 37618,
          38246: 33948,
          38247: 34541,
          38248: 39981,
          38249: 21697,
          38250: 24428,
          38251: 25996,
          38252: 27996,
          38253: 28693,
          38254: 36007,
          38255: 36051,
          38256: 38971,
          38257: 25935,
          38258: 29942,
          38259: 19981,
          38260: 20184,
          38261: 22496,
          38262: 22827,
          38263: 23142,
          38264: 23500,
          38265: 20904,
          38266: 24067,
          38267: 24220,
          38268: 24598,
          38269: 25206,
          38270: 25975,
          38272: 26023,
          38273: 26222,
          38274: 28014,
          38275: 29238,
          38276: 31526,
          38277: 33104,
          38278: 33178,
          38279: 33433,
          38280: 35676,
          38281: 36e3,
          38282: 36070,
          38283: 36212,
          38284: 38428,
          38285: 38468,
          38286: 20398,
          38287: 25771,
          38288: 27494,
          38289: 33310,
          38290: 33889,
          38291: 34154,
          38292: 37096,
          38293: 23553,
          38294: 26963,
          38295: 39080,
          38296: 33914,
          38297: 34135,
          38298: 20239,
          38299: 21103,
          38300: 24489,
          38301: 24133,
          38302: 26381,
          38303: 31119,
          38304: 33145,
          38305: 35079,
          38306: 35206,
          38307: 28149,
          38308: 24343,
          38309: 25173,
          38310: 27832,
          38311: 20175,
          38312: 29289,
          38313: 39826,
          38314: 20998,
          38315: 21563,
          38316: 22132,
          38317: 22707,
          38318: 24996,
          38319: 25198,
          38320: 28954,
          38321: 22894,
          38322: 31881,
          38323: 31966,
          38324: 32027,
          38325: 38640,
          38326: 25991,
          38327: 32862,
          38328: 19993,
          38329: 20341,
          38330: 20853,
          38331: 22592,
          38332: 24163,
          38333: 24179,
          38334: 24330,
          38335: 26564,
          38336: 20006,
          38337: 34109,
          38338: 38281,
          38339: 38491,
          38340: 31859,
          38341: 38913,
          38342: 20731,
          38343: 22721,
          38344: 30294,
          38345: 30887,
          38346: 21029,
          38347: 30629,
          38348: 34065,
          38349: 31622,
          38350: 20559,
          38351: 22793,
          38352: 29255,
          38353: 31687,
          38354: 32232,
          38355: 36794,
          38356: 36820,
          38357: 36941,
          38358: 20415,
          38359: 21193,
          38360: 23081,
          38361: 24321,
          38362: 38829,
          38363: 20445,
          38364: 33303,
          38365: 37610,
          38366: 22275,
          38367: 25429,
          38368: 27497,
          38369: 29995,
          38370: 35036,
          38371: 36628,
          38372: 31298,
          38373: 21215,
          38374: 22675,
          38375: 24917,
          38376: 25098,
          38377: 26286,
          38378: 27597,
          38379: 31807,
          38380: 33769,
          38381: 20515,
          38382: 20472,
          38383: 21253,
          38384: 21574,
          38385: 22577,
          38386: 22857,
          38387: 23453,
          38388: 23792,
          38389: 23791,
          38390: 23849,
          38391: 24214,
          38392: 25265,
          38393: 25447,
          38394: 25918,
          38395: 26041,
          38396: 26379,
          38464: 27861,
          38465: 27873,
          38466: 28921,
          38467: 30770,
          38468: 32299,
          38469: 32990,
          38470: 33459,
          38471: 33804,
          38472: 34028,
          38473: 34562,
          38474: 35090,
          38475: 35370,
          38476: 35914,
          38477: 37030,
          38478: 37586,
          38479: 39165,
          38480: 40179,
          38481: 40300,
          38482: 20047,
          38483: 20129,
          38484: 20621,
          38485: 21078,
          38486: 22346,
          38487: 22952,
          38488: 24125,
          38489: 24536,
          38490: 24537,
          38491: 25151,
          38492: 26292,
          38493: 26395,
          38494: 26576,
          38495: 26834,
          38496: 20882,
          38497: 32033,
          38498: 32938,
          38499: 33192,
          38500: 35584,
          38501: 35980,
          38502: 36031,
          38503: 37502,
          38504: 38450,
          38505: 21536,
          38506: 38956,
          38507: 21271,
          38508: 20693,
          38509: 21340,
          38510: 22696,
          38511: 25778,
          38512: 26420,
          38513: 29287,
          38514: 30566,
          38515: 31302,
          38516: 37350,
          38517: 21187,
          38518: 27809,
          38519: 27526,
          38520: 22528,
          38521: 24140,
          38522: 22868,
          38523: 26412,
          38524: 32763,
          38525: 20961,
          38526: 30406,
          38528: 25705,
          38529: 30952,
          38530: 39764,
          38531: 40635,
          38532: 22475,
          38533: 22969,
          38534: 26151,
          38535: 26522,
          38536: 27598,
          38537: 21737,
          38538: 27097,
          38539: 24149,
          38540: 33180,
          38541: 26517,
          38542: 39850,
          38543: 26622,
          38544: 40018,
          38545: 26717,
          38546: 20134,
          38547: 20451,
          38548: 21448,
          38549: 25273,
          38550: 26411,
          38551: 27819,
          38552: 36804,
          38553: 20397,
          38554: 32365,
          38555: 40639,
          38556: 19975,
          38557: 24930,
          38558: 28288,
          38559: 28459,
          38560: 34067,
          38561: 21619,
          38562: 26410,
          38563: 39749,
          38564: 24051,
          38565: 31637,
          38566: 23724,
          38567: 23494,
          38568: 34588,
          38569: 28234,
          38570: 34001,
          38571: 31252,
          38572: 33032,
          38573: 22937,
          38574: 31885,
          38575: 27665,
          38576: 30496,
          38577: 21209,
          38578: 22818,
          38579: 28961,
          38580: 29279,
          38581: 30683,
          38582: 38695,
          38583: 40289,
          38584: 26891,
          38585: 23167,
          38586: 23064,
          38587: 20901,
          38588: 21517,
          38589: 21629,
          38590: 26126,
          38591: 30431,
          38592: 36855,
          38593: 37528,
          38594: 40180,
          38595: 23018,
          38596: 29277,
          38597: 28357,
          38598: 20813,
          38599: 26825,
          38600: 32191,
          38601: 32236,
          38602: 38754,
          38603: 40634,
          38604: 25720,
          38605: 27169,
          38606: 33538,
          38607: 22916,
          38608: 23391,
          38609: 27611,
          38610: 29467,
          38611: 30450,
          38612: 32178,
          38613: 32791,
          38614: 33945,
          38615: 20786,
          38616: 26408,
          38617: 40665,
          38618: 30446,
          38619: 26466,
          38620: 21247,
          38621: 39173,
          38622: 23588,
          38623: 25147,
          38624: 31870,
          38625: 36016,
          38626: 21839,
          38627: 24758,
          38628: 32011,
          38629: 38272,
          38630: 21249,
          38631: 20063,
          38632: 20918,
          38633: 22812,
          38634: 29242,
          38635: 32822,
          38636: 37326,
          38637: 24357,
          38638: 30690,
          38639: 21380,
          38640: 24441,
          38641: 32004,
          38642: 34220,
          38643: 35379,
          38644: 36493,
          38645: 38742,
          38646: 26611,
          38647: 34222,
          38648: 37971,
          38649: 24841,
          38650: 24840,
          38651: 27833,
          38652: 30290,
          38720: 35565,
          38721: 36664,
          38722: 21807,
          38723: 20305,
          38724: 20778,
          38725: 21191,
          38726: 21451,
          38727: 23461,
          38728: 24189,
          38729: 24736,
          38730: 24962,
          38731: 25558,
          38732: 26377,
          38733: 26586,
          38734: 28263,
          38735: 28044,
          38736: 29494,
          38737: 29495,
          38738: 30001,
          38739: 31056,
          38740: 35029,
          38741: 35480,
          38742: 36938,
          38743: 37009,
          38744: 37109,
          38745: 38596,
          38746: 34701,
          38747: 22805,
          38748: 20104,
          38749: 20313,
          38750: 19982,
          38751: 35465,
          38752: 36671,
          38753: 38928,
          38754: 20653,
          38755: 24188,
          38756: 22934,
          38757: 23481,
          38758: 24248,
          38759: 25562,
          38760: 25594,
          38761: 25793,
          38762: 26332,
          38763: 26954,
          38764: 27096,
          38765: 27915,
          38766: 28342,
          38767: 29076,
          38768: 29992,
          38769: 31407,
          38770: 32650,
          38771: 32768,
          38772: 33865,
          38773: 33993,
          38774: 35201,
          38775: 35617,
          38776: 36362,
          38777: 36965,
          38778: 38525,
          38779: 39178,
          38780: 24958,
          38781: 25233,
          38782: 27442,
          38784: 27779,
          38785: 28020,
          38786: 32716,
          38787: 32764,
          38788: 28096,
          38789: 32645,
          38790: 34746,
          38791: 35064,
          38792: 26469,
          38793: 33713,
          38794: 38972,
          38795: 38647,
          38796: 27931,
          38797: 32097,
          38798: 33853,
          38799: 37226,
          38800: 20081,
          38801: 21365,
          38802: 23888,
          38803: 27396,
          38804: 28651,
          38805: 34253,
          38806: 34349,
          38807: 35239,
          38808: 21033,
          38809: 21519,
          38810: 23653,
          38811: 26446,
          38812: 26792,
          38813: 29702,
          38814: 29827,
          38815: 30178,
          38816: 35023,
          38817: 35041,
          38818: 37324,
          38819: 38626,
          38820: 38520,
          38821: 24459,
          38822: 29575,
          38823: 31435,
          38824: 33870,
          38825: 25504,
          38826: 30053,
          38827: 21129,
          38828: 27969,
          38829: 28316,
          38830: 29705,
          38831: 30041,
          38832: 30827,
          38833: 31890,
          38834: 38534,
          38835: 31452,
          38836: 40845,
          38837: 20406,
          38838: 24942,
          38839: 26053,
          38840: 34396,
          38841: 20102,
          38842: 20142,
          38843: 20698,
          38844: 20001,
          38845: 20940,
          38846: 23534,
          38847: 26009,
          38848: 26753,
          38849: 28092,
          38850: 29471,
          38851: 30274,
          38852: 30637,
          38853: 31260,
          38854: 31975,
          38855: 33391,
          38856: 35538,
          38857: 36988,
          38858: 37327,
          38859: 38517,
          38860: 38936,
          38861: 21147,
          38862: 32209,
          38863: 20523,
          38864: 21400,
          38865: 26519,
          38866: 28107,
          38867: 29136,
          38868: 29747,
          38869: 33256,
          38870: 36650,
          38871: 38563,
          38872: 40023,
          38873: 40607,
          38874: 29792,
          38875: 22593,
          38876: 28057,
          38877: 32047,
          38878: 39006,
          38879: 20196,
          38880: 20278,
          38881: 20363,
          38882: 20919,
          38883: 21169,
          38884: 23994,
          38885: 24604,
          38886: 29618,
          38887: 31036,
          38888: 33491,
          38889: 37428,
          38890: 38583,
          38891: 38646,
          38892: 38666,
          38893: 40599,
          38894: 40802,
          38895: 26278,
          38896: 27508,
          38897: 21015,
          38898: 21155,
          38899: 28872,
          38900: 35010,
          38901: 24265,
          38902: 24651,
          38903: 24976,
          38904: 28451,
          38905: 29001,
          38906: 31806,
          38907: 32244,
          38908: 32879,
          38976: 34030,
          38977: 36899,
          38978: 37676,
          38979: 21570,
          38980: 39791,
          38981: 27347,
          38982: 28809,
          38983: 36034,
          38984: 36335,
          38985: 38706,
          38986: 21172,
          38987: 23105,
          38988: 24266,
          38989: 24324,
          38990: 26391,
          38991: 27004,
          38992: 27028,
          38993: 28010,
          38994: 28431,
          38995: 29282,
          38996: 29436,
          38997: 31725,
          38998: 32769,
          38999: 32894,
          39e3: 34635,
          39001: 37070,
          39002: 20845,
          39003: 40595,
          39004: 31108,
          39005: 32907,
          39006: 37682,
          39007: 35542,
          39008: 20525,
          39009: 21644,
          39010: 35441,
          39011: 27498,
          39012: 36036,
          39013: 33031,
          39014: 24785,
          39015: 26528,
          39016: 40434,
          39017: 20121,
          39018: 20120,
          39019: 39952,
          39020: 35435,
          39021: 34241,
          39022: 34152,
          39023: 26880,
          39024: 28286,
          39025: 30871,
          39026: 33109,
          39071: 24332,
          39072: 19984,
          39073: 19989,
          39074: 20010,
          39075: 20017,
          39076: 20022,
          39077: 20028,
          39078: 20031,
          39079: 20034,
          39080: 20054,
          39081: 20056,
          39082: 20098,
          39083: 20101,
          39084: 35947,
          39085: 20106,
          39086: 33298,
          39087: 24333,
          39088: 20110,
          39089: 20126,
          39090: 20127,
          39091: 20128,
          39092: 20130,
          39093: 20144,
          39094: 20147,
          39095: 20150,
          39096: 20174,
          39097: 20173,
          39098: 20164,
          39099: 20166,
          39100: 20162,
          39101: 20183,
          39102: 20190,
          39103: 20205,
          39104: 20191,
          39105: 20215,
          39106: 20233,
          39107: 20314,
          39108: 20272,
          39109: 20315,
          39110: 20317,
          39111: 20311,
          39112: 20295,
          39113: 20342,
          39114: 20360,
          39115: 20367,
          39116: 20376,
          39117: 20347,
          39118: 20329,
          39119: 20336,
          39120: 20369,
          39121: 20335,
          39122: 20358,
          39123: 20374,
          39124: 20760,
          39125: 20436,
          39126: 20447,
          39127: 20430,
          39128: 20440,
          39129: 20443,
          39130: 20433,
          39131: 20442,
          39132: 20432,
          39133: 20452,
          39134: 20453,
          39135: 20506,
          39136: 20520,
          39137: 20500,
          39138: 20522,
          39139: 20517,
          39140: 20485,
          39141: 20252,
          39142: 20470,
          39143: 20513,
          39144: 20521,
          39145: 20524,
          39146: 20478,
          39147: 20463,
          39148: 20497,
          39149: 20486,
          39150: 20547,
          39151: 20551,
          39152: 26371,
          39153: 20565,
          39154: 20560,
          39155: 20552,
          39156: 20570,
          39157: 20566,
          39158: 20588,
          39159: 20600,
          39160: 20608,
          39161: 20634,
          39162: 20613,
          39163: 20660,
          39164: 20658,
          39232: 20681,
          39233: 20682,
          39234: 20659,
          39235: 20674,
          39236: 20694,
          39237: 20702,
          39238: 20709,
          39239: 20717,
          39240: 20707,
          39241: 20718,
          39242: 20729,
          39243: 20725,
          39244: 20745,
          39245: 20737,
          39246: 20738,
          39247: 20758,
          39248: 20757,
          39249: 20756,
          39250: 20762,
          39251: 20769,
          39252: 20794,
          39253: 20791,
          39254: 20796,
          39255: 20795,
          39256: 20799,
          39257: 20800,
          39258: 20818,
          39259: 20812,
          39260: 20820,
          39261: 20834,
          39262: 31480,
          39263: 20841,
          39264: 20842,
          39265: 20846,
          39266: 20864,
          39267: 20866,
          39268: 22232,
          39269: 20876,
          39270: 20873,
          39271: 20879,
          39272: 20881,
          39273: 20883,
          39274: 20885,
          39275: 20886,
          39276: 20900,
          39277: 20902,
          39278: 20898,
          39279: 20905,
          39280: 20906,
          39281: 20907,
          39282: 20915,
          39283: 20913,
          39284: 20914,
          39285: 20912,
          39286: 20917,
          39287: 20925,
          39288: 20933,
          39289: 20937,
          39290: 20955,
          39291: 20960,
          39292: 34389,
          39293: 20969,
          39294: 20973,
          39296: 20976,
          39297: 20981,
          39298: 20990,
          39299: 20996,
          39300: 21003,
          39301: 21012,
          39302: 21006,
          39303: 21031,
          39304: 21034,
          39305: 21038,
          39306: 21043,
          39307: 21049,
          39308: 21071,
          39309: 21060,
          39310: 21067,
          39311: 21068,
          39312: 21086,
          39313: 21076,
          39314: 21098,
          39315: 21108,
          39316: 21097,
          39317: 21107,
          39318: 21119,
          39319: 21117,
          39320: 21133,
          39321: 21140,
          39322: 21138,
          39323: 21105,
          39324: 21128,
          39325: 21137,
          39326: 36776,
          39327: 36775,
          39328: 21164,
          39329: 21165,
          39330: 21180,
          39331: 21173,
          39332: 21185,
          39333: 21197,
          39334: 21207,
          39335: 21214,
          39336: 21219,
          39337: 21222,
          39338: 39149,
          39339: 21216,
          39340: 21235,
          39341: 21237,
          39342: 21240,
          39343: 21241,
          39344: 21254,
          39345: 21256,
          39346: 30008,
          39347: 21261,
          39348: 21264,
          39349: 21263,
          39350: 21269,
          39351: 21274,
          39352: 21283,
          39353: 21295,
          39354: 21297,
          39355: 21299,
          39356: 21304,
          39357: 21312,
          39358: 21318,
          39359: 21317,
          39360: 19991,
          39361: 21321,
          39362: 21325,
          39363: 20950,
          39364: 21342,
          39365: 21353,
          39366: 21358,
          39367: 22808,
          39368: 21371,
          39369: 21367,
          39370: 21378,
          39371: 21398,
          39372: 21408,
          39373: 21414,
          39374: 21413,
          39375: 21422,
          39376: 21424,
          39377: 21430,
          39378: 21443,
          39379: 31762,
          39380: 38617,
          39381: 21471,
          39382: 26364,
          39383: 29166,
          39384: 21486,
          39385: 21480,
          39386: 21485,
          39387: 21498,
          39388: 21505,
          39389: 21565,
          39390: 21568,
          39391: 21548,
          39392: 21549,
          39393: 21564,
          39394: 21550,
          39395: 21558,
          39396: 21545,
          39397: 21533,
          39398: 21582,
          39399: 21647,
          39400: 21621,
          39401: 21646,
          39402: 21599,
          39403: 21617,
          39404: 21623,
          39405: 21616,
          39406: 21650,
          39407: 21627,
          39408: 21632,
          39409: 21622,
          39410: 21636,
          39411: 21648,
          39412: 21638,
          39413: 21703,
          39414: 21666,
          39415: 21688,
          39416: 21669,
          39417: 21676,
          39418: 21700,
          39419: 21704,
          39420: 21672,
          39488: 21675,
          39489: 21698,
          39490: 21668,
          39491: 21694,
          39492: 21692,
          39493: 21720,
          39494: 21733,
          39495: 21734,
          39496: 21775,
          39497: 21780,
          39498: 21757,
          39499: 21742,
          39500: 21741,
          39501: 21754,
          39502: 21730,
          39503: 21817,
          39504: 21824,
          39505: 21859,
          39506: 21836,
          39507: 21806,
          39508: 21852,
          39509: 21829,
          39510: 21846,
          39511: 21847,
          39512: 21816,
          39513: 21811,
          39514: 21853,
          39515: 21913,
          39516: 21888,
          39517: 21679,
          39518: 21898,
          39519: 21919,
          39520: 21883,
          39521: 21886,
          39522: 21912,
          39523: 21918,
          39524: 21934,
          39525: 21884,
          39526: 21891,
          39527: 21929,
          39528: 21895,
          39529: 21928,
          39530: 21978,
          39531: 21957,
          39532: 21983,
          39533: 21956,
          39534: 21980,
          39535: 21988,
          39536: 21972,
          39537: 22036,
          39538: 22007,
          39539: 22038,
          39540: 22014,
          39541: 22013,
          39542: 22043,
          39543: 22009,
          39544: 22094,
          39545: 22096,
          39546: 29151,
          39547: 22068,
          39548: 22070,
          39549: 22066,
          39550: 22072,
          39552: 22123,
          39553: 22116,
          39554: 22063,
          39555: 22124,
          39556: 22122,
          39557: 22150,
          39558: 22144,
          39559: 22154,
          39560: 22176,
          39561: 22164,
          39562: 22159,
          39563: 22181,
          39564: 22190,
          39565: 22198,
          39566: 22196,
          39567: 22210,
          39568: 22204,
          39569: 22209,
          39570: 22211,
          39571: 22208,
          39572: 22216,
          39573: 22222,
          39574: 22225,
          39575: 22227,
          39576: 22231,
          39577: 22254,
          39578: 22265,
          39579: 22272,
          39580: 22271,
          39581: 22276,
          39582: 22281,
          39583: 22280,
          39584: 22283,
          39585: 22285,
          39586: 22291,
          39587: 22296,
          39588: 22294,
          39589: 21959,
          39590: 22300,
          39591: 22310,
          39592: 22327,
          39593: 22328,
          39594: 22350,
          39595: 22331,
          39596: 22336,
          39597: 22351,
          39598: 22377,
          39599: 22464,
          39600: 22408,
          39601: 22369,
          39602: 22399,
          39603: 22409,
          39604: 22419,
          39605: 22432,
          39606: 22451,
          39607: 22436,
          39608: 22442,
          39609: 22448,
          39610: 22467,
          39611: 22470,
          39612: 22484,
          39613: 22482,
          39614: 22483,
          39615: 22538,
          39616: 22486,
          39617: 22499,
          39618: 22539,
          39619: 22553,
          39620: 22557,
          39621: 22642,
          39622: 22561,
          39623: 22626,
          39624: 22603,
          39625: 22640,
          39626: 27584,
          39627: 22610,
          39628: 22589,
          39629: 22649,
          39630: 22661,
          39631: 22713,
          39632: 22687,
          39633: 22699,
          39634: 22714,
          39635: 22750,
          39636: 22715,
          39637: 22712,
          39638: 22702,
          39639: 22725,
          39640: 22739,
          39641: 22737,
          39642: 22743,
          39643: 22745,
          39644: 22744,
          39645: 22757,
          39646: 22748,
          39647: 22756,
          39648: 22751,
          39649: 22767,
          39650: 22778,
          39651: 22777,
          39652: 22779,
          39653: 22780,
          39654: 22781,
          39655: 22786,
          39656: 22794,
          39657: 22800,
          39658: 22811,
          39659: 26790,
          39660: 22821,
          39661: 22828,
          39662: 22829,
          39663: 22834,
          39664: 22840,
          39665: 22846,
          39666: 31442,
          39667: 22869,
          39668: 22864,
          39669: 22862,
          39670: 22874,
          39671: 22872,
          39672: 22882,
          39673: 22880,
          39674: 22887,
          39675: 22892,
          39676: 22889,
          39744: 22904,
          39745: 22913,
          39746: 22941,
          39747: 20318,
          39748: 20395,
          39749: 22947,
          39750: 22962,
          39751: 22982,
          39752: 23016,
          39753: 23004,
          39754: 22925,
          39755: 23001,
          39756: 23002,
          39757: 23077,
          39758: 23071,
          39759: 23057,
          39760: 23068,
          39761: 23049,
          39762: 23066,
          39763: 23104,
          39764: 23148,
          39765: 23113,
          39766: 23093,
          39767: 23094,
          39768: 23138,
          39769: 23146,
          39770: 23194,
          39771: 23228,
          39772: 23230,
          39773: 23243,
          39774: 23234,
          39775: 23229,
          39776: 23267,
          39777: 23255,
          39778: 23270,
          39779: 23273,
          39780: 23254,
          39781: 23290,
          39782: 23291,
          39783: 23308,
          39784: 23307,
          39785: 23318,
          39786: 23346,
          39787: 23248,
          39788: 23338,
          39789: 23350,
          39790: 23358,
          39791: 23363,
          39792: 23365,
          39793: 23360,
          39794: 23377,
          39795: 23381,
          39796: 23386,
          39797: 23387,
          39798: 23397,
          39799: 23401,
          39800: 23408,
          39801: 23411,
          39802: 23413,
          39803: 23416,
          39804: 25992,
          39805: 23418,
          39806: 23424,
          39808: 23427,
          39809: 23462,
          39810: 23480,
          39811: 23491,
          39812: 23495,
          39813: 23497,
          39814: 23508,
          39815: 23504,
          39816: 23524,
          39817: 23526,
          39818: 23522,
          39819: 23518,
          39820: 23525,
          39821: 23531,
          39822: 23536,
          39823: 23542,
          39824: 23539,
          39825: 23557,
          39826: 23559,
          39827: 23560,
          39828: 23565,
          39829: 23571,
          39830: 23584,
          39831: 23586,
          39832: 23592,
          39833: 23608,
          39834: 23609,
          39835: 23617,
          39836: 23622,
          39837: 23630,
          39838: 23635,
          39839: 23632,
          39840: 23631,
          39841: 23409,
          39842: 23660,
          39843: 23662,
          39844: 20066,
          39845: 23670,
          39846: 23673,
          39847: 23692,
          39848: 23697,
          39849: 23700,
          39850: 22939,
          39851: 23723,
          39852: 23739,
          39853: 23734,
          39854: 23740,
          39855: 23735,
          39856: 23749,
          39857: 23742,
          39858: 23751,
          39859: 23769,
          39860: 23785,
          39861: 23805,
          39862: 23802,
          39863: 23789,
          39864: 23948,
          39865: 23786,
          39866: 23819,
          39867: 23829,
          39868: 23831,
          39869: 23900,
          39870: 23839,
          39871: 23835,
          39872: 23825,
          39873: 23828,
          39874: 23842,
          39875: 23834,
          39876: 23833,
          39877: 23832,
          39878: 23884,
          39879: 23890,
          39880: 23886,
          39881: 23883,
          39882: 23916,
          39883: 23923,
          39884: 23926,
          39885: 23943,
          39886: 23940,
          39887: 23938,
          39888: 23970,
          39889: 23965,
          39890: 23980,
          39891: 23982,
          39892: 23997,
          39893: 23952,
          39894: 23991,
          39895: 23996,
          39896: 24009,
          39897: 24013,
          39898: 24019,
          39899: 24018,
          39900: 24022,
          39901: 24027,
          39902: 24043,
          39903: 24050,
          39904: 24053,
          39905: 24075,
          39906: 24090,
          39907: 24089,
          39908: 24081,
          39909: 24091,
          39910: 24118,
          39911: 24119,
          39912: 24132,
          39913: 24131,
          39914: 24128,
          39915: 24142,
          39916: 24151,
          39917: 24148,
          39918: 24159,
          39919: 24162,
          39920: 24164,
          39921: 24135,
          39922: 24181,
          39923: 24182,
          39924: 24186,
          39925: 40636,
          39926: 24191,
          39927: 24224,
          39928: 24257,
          39929: 24258,
          39930: 24264,
          39931: 24272,
          39932: 24271,
          4e4: 24278,
          40001: 24291,
          40002: 24285,
          40003: 24282,
          40004: 24283,
          40005: 24290,
          40006: 24289,
          40007: 24296,
          40008: 24297,
          40009: 24300,
          40010: 24305,
          40011: 24307,
          40012: 24304,
          40013: 24308,
          40014: 24312,
          40015: 24318,
          40016: 24323,
          40017: 24329,
          40018: 24413,
          40019: 24412,
          40020: 24331,
          40021: 24337,
          40022: 24342,
          40023: 24361,
          40024: 24365,
          40025: 24376,
          40026: 24385,
          40027: 24392,
          40028: 24396,
          40029: 24398,
          40030: 24367,
          40031: 24401,
          40032: 24406,
          40033: 24407,
          40034: 24409,
          40035: 24417,
          40036: 24429,
          40037: 24435,
          40038: 24439,
          40039: 24451,
          40040: 24450,
          40041: 24447,
          40042: 24458,
          40043: 24456,
          40044: 24465,
          40045: 24455,
          40046: 24478,
          40047: 24473,
          40048: 24472,
          40049: 24480,
          40050: 24488,
          40051: 24493,
          40052: 24508,
          40053: 24534,
          40054: 24571,
          40055: 24548,
          40056: 24568,
          40057: 24561,
          40058: 24541,
          40059: 24755,
          40060: 24575,
          40061: 24609,
          40062: 24672,
          40064: 24601,
          40065: 24592,
          40066: 24617,
          40067: 24590,
          40068: 24625,
          40069: 24603,
          40070: 24597,
          40071: 24619,
          40072: 24614,
          40073: 24591,
          40074: 24634,
          40075: 24666,
          40076: 24641,
          40077: 24682,
          40078: 24695,
          40079: 24671,
          40080: 24650,
          40081: 24646,
          40082: 24653,
          40083: 24675,
          40084: 24643,
          40085: 24676,
          40086: 24642,
          40087: 24684,
          40088: 24683,
          40089: 24665,
          40090: 24705,
          40091: 24717,
          40092: 24807,
          40093: 24707,
          40094: 24730,
          40095: 24708,
          40096: 24731,
          40097: 24726,
          40098: 24727,
          40099: 24722,
          40100: 24743,
          40101: 24715,
          40102: 24801,
          40103: 24760,
          40104: 24800,
          40105: 24787,
          40106: 24756,
          40107: 24560,
          40108: 24765,
          40109: 24774,
          40110: 24757,
          40111: 24792,
          40112: 24909,
          40113: 24853,
          40114: 24838,
          40115: 24822,
          40116: 24823,
          40117: 24832,
          40118: 24820,
          40119: 24826,
          40120: 24835,
          40121: 24865,
          40122: 24827,
          40123: 24817,
          40124: 24845,
          40125: 24846,
          40126: 24903,
          40127: 24894,
          40128: 24872,
          40129: 24871,
          40130: 24906,
          40131: 24895,
          40132: 24892,
          40133: 24876,
          40134: 24884,
          40135: 24893,
          40136: 24898,
          40137: 24900,
          40138: 24947,
          40139: 24951,
          40140: 24920,
          40141: 24921,
          40142: 24922,
          40143: 24939,
          40144: 24948,
          40145: 24943,
          40146: 24933,
          40147: 24945,
          40148: 24927,
          40149: 24925,
          40150: 24915,
          40151: 24949,
          40152: 24985,
          40153: 24982,
          40154: 24967,
          40155: 25004,
          40156: 24980,
          40157: 24986,
          40158: 24970,
          40159: 24977,
          40160: 25003,
          40161: 25006,
          40162: 25036,
          40163: 25034,
          40164: 25033,
          40165: 25079,
          40166: 25032,
          40167: 25027,
          40168: 25030,
          40169: 25018,
          40170: 25035,
          40171: 32633,
          40172: 25037,
          40173: 25062,
          40174: 25059,
          40175: 25078,
          40176: 25082,
          40177: 25076,
          40178: 25087,
          40179: 25085,
          40180: 25084,
          40181: 25086,
          40182: 25088,
          40183: 25096,
          40184: 25097,
          40185: 25101,
          40186: 25100,
          40187: 25108,
          40188: 25115,
          40256: 25118,
          40257: 25121,
          40258: 25130,
          40259: 25134,
          40260: 25136,
          40261: 25138,
          40262: 25139,
          40263: 25153,
          40264: 25166,
          40265: 25182,
          40266: 25187,
          40267: 25179,
          40268: 25184,
          40269: 25192,
          40270: 25212,
          40271: 25218,
          40272: 25225,
          40273: 25214,
          40274: 25234,
          40275: 25235,
          40276: 25238,
          40277: 25300,
          40278: 25219,
          40279: 25236,
          40280: 25303,
          40281: 25297,
          40282: 25275,
          40283: 25295,
          40284: 25343,
          40285: 25286,
          40286: 25812,
          40287: 25288,
          40288: 25308,
          40289: 25292,
          40290: 25290,
          40291: 25282,
          40292: 25287,
          40293: 25243,
          40294: 25289,
          40295: 25356,
          40296: 25326,
          40297: 25329,
          40298: 25383,
          40299: 25346,
          40300: 25352,
          40301: 25327,
          40302: 25333,
          40303: 25424,
          40304: 25406,
          40305: 25421,
          40306: 25628,
          40307: 25423,
          40308: 25494,
          40309: 25486,
          40310: 25472,
          40311: 25515,
          40312: 25462,
          40313: 25507,
          40314: 25487,
          40315: 25481,
          40316: 25503,
          40317: 25525,
          40318: 25451,
          40320: 25449,
          40321: 25534,
          40322: 25577,
          40323: 25536,
          40324: 25542,
          40325: 25571,
          40326: 25545,
          40327: 25554,
          40328: 25590,
          40329: 25540,
          40330: 25622,
          40331: 25652,
          40332: 25606,
          40333: 25619,
          40334: 25638,
          40335: 25654,
          40336: 25885,
          40337: 25623,
          40338: 25640,
          40339: 25615,
          40340: 25703,
          40341: 25711,
          40342: 25718,
          40343: 25678,
          40344: 25898,
          40345: 25749,
          40346: 25747,
          40347: 25765,
          40348: 25769,
          40349: 25736,
          40350: 25788,
          40351: 25818,
          40352: 25810,
          40353: 25797,
          40354: 25799,
          40355: 25787,
          40356: 25816,
          40357: 25794,
          40358: 25841,
          40359: 25831,
          40360: 33289,
          40361: 25824,
          40362: 25825,
          40363: 25260,
          40364: 25827,
          40365: 25839,
          40366: 25900,
          40367: 25846,
          40368: 25844,
          40369: 25842,
          40370: 25850,
          40371: 25856,
          40372: 25853,
          40373: 25880,
          40374: 25884,
          40375: 25861,
          40376: 25892,
          40377: 25891,
          40378: 25899,
          40379: 25908,
          40380: 25909,
          40381: 25911,
          40382: 25910,
          40383: 25912,
          40384: 30027,
          40385: 25928,
          40386: 25942,
          40387: 25941,
          40388: 25933,
          40389: 25944,
          40390: 25950,
          40391: 25949,
          40392: 25970,
          40393: 25976,
          40394: 25986,
          40395: 25987,
          40396: 35722,
          40397: 26011,
          40398: 26015,
          40399: 26027,
          40400: 26039,
          40401: 26051,
          40402: 26054,
          40403: 26049,
          40404: 26052,
          40405: 26060,
          40406: 26066,
          40407: 26075,
          40408: 26073,
          40409: 26080,
          40410: 26081,
          40411: 26097,
          40412: 26482,
          40413: 26122,
          40414: 26115,
          40415: 26107,
          40416: 26483,
          40417: 26165,
          40418: 26166,
          40419: 26164,
          40420: 26140,
          40421: 26191,
          40422: 26180,
          40423: 26185,
          40424: 26177,
          40425: 26206,
          40426: 26205,
          40427: 26212,
          40428: 26215,
          40429: 26216,
          40430: 26207,
          40431: 26210,
          40432: 26224,
          40433: 26243,
          40434: 26248,
          40435: 26254,
          40436: 26249,
          40437: 26244,
          40438: 26264,
          40439: 26269,
          40440: 26305,
          40441: 26297,
          40442: 26313,
          40443: 26302,
          40444: 26300,
          40512: 26308,
          40513: 26296,
          40514: 26326,
          40515: 26330,
          40516: 26336,
          40517: 26175,
          40518: 26342,
          40519: 26345,
          40520: 26352,
          40521: 26357,
          40522: 26359,
          40523: 26383,
          40524: 26390,
          40525: 26398,
          40526: 26406,
          40527: 26407,
          40528: 38712,
          40529: 26414,
          40530: 26431,
          40531: 26422,
          40532: 26433,
          40533: 26424,
          40534: 26423,
          40535: 26438,
          40536: 26462,
          40537: 26464,
          40538: 26457,
          40539: 26467,
          40540: 26468,
          40541: 26505,
          40542: 26480,
          40543: 26537,
          40544: 26492,
          40545: 26474,
          40546: 26508,
          40547: 26507,
          40548: 26534,
          40549: 26529,
          40550: 26501,
          40551: 26551,
          40552: 26607,
          40553: 26548,
          40554: 26604,
          40555: 26547,
          40556: 26601,
          40557: 26552,
          40558: 26596,
          40559: 26590,
          40560: 26589,
          40561: 26594,
          40562: 26606,
          40563: 26553,
          40564: 26574,
          40565: 26566,
          40566: 26599,
          40567: 27292,
          40568: 26654,
          40569: 26694,
          40570: 26665,
          40571: 26688,
          40572: 26701,
          40573: 26674,
          40574: 26702,
          40576: 26803,
          40577: 26667,
          40578: 26713,
          40579: 26723,
          40580: 26743,
          40581: 26751,
          40582: 26783,
          40583: 26767,
          40584: 26797,
          40585: 26772,
          40586: 26781,
          40587: 26779,
          40588: 26755,
          40589: 27310,
          40590: 26809,
          40591: 26740,
          40592: 26805,
          40593: 26784,
          40594: 26810,
          40595: 26895,
          40596: 26765,
          40597: 26750,
          40598: 26881,
          40599: 26826,
          40600: 26888,
          40601: 26840,
          40602: 26914,
          40603: 26918,
          40604: 26849,
          40605: 26892,
          40606: 26829,
          40607: 26836,
          40608: 26855,
          40609: 26837,
          40610: 26934,
          40611: 26898,
          40612: 26884,
          40613: 26839,
          40614: 26851,
          40615: 26917,
          40616: 26873,
          40617: 26848,
          40618: 26863,
          40619: 26920,
          40620: 26922,
          40621: 26906,
          40622: 26915,
          40623: 26913,
          40624: 26822,
          40625: 27001,
          40626: 26999,
          40627: 26972,
          40628: 27e3,
          40629: 26987,
          40630: 26964,
          40631: 27006,
          40632: 26990,
          40633: 26937,
          40634: 26996,
          40635: 26941,
          40636: 26969,
          40637: 26928,
          40638: 26977,
          40639: 26974,
          40640: 26973,
          40641: 27009,
          40642: 26986,
          40643: 27058,
          40644: 27054,
          40645: 27088,
          40646: 27071,
          40647: 27073,
          40648: 27091,
          40649: 27070,
          40650: 27086,
          40651: 23528,
          40652: 27082,
          40653: 27101,
          40654: 27067,
          40655: 27075,
          40656: 27047,
          40657: 27182,
          40658: 27025,
          40659: 27040,
          40660: 27036,
          40661: 27029,
          40662: 27060,
          40663: 27102,
          40664: 27112,
          40665: 27138,
          40666: 27163,
          40667: 27135,
          40668: 27402,
          40669: 27129,
          40670: 27122,
          40671: 27111,
          40672: 27141,
          40673: 27057,
          40674: 27166,
          40675: 27117,
          40676: 27156,
          40677: 27115,
          40678: 27146,
          40679: 27154,
          40680: 27329,
          40681: 27171,
          40682: 27155,
          40683: 27204,
          40684: 27148,
          40685: 27250,
          40686: 27190,
          40687: 27256,
          40688: 27207,
          40689: 27234,
          40690: 27225,
          40691: 27238,
          40692: 27208,
          40693: 27192,
          40694: 27170,
          40695: 27280,
          40696: 27277,
          40697: 27296,
          40698: 27268,
          40699: 27298,
          40700: 27299,
          40768: 27287,
          40769: 34327,
          40770: 27323,
          40771: 27331,
          40772: 27330,
          40773: 27320,
          40774: 27315,
          40775: 27308,
          40776: 27358,
          40777: 27345,
          40778: 27359,
          40779: 27306,
          40780: 27354,
          40781: 27370,
          40782: 27387,
          40783: 27397,
          40784: 34326,
          40785: 27386,
          40786: 27410,
          40787: 27414,
          40788: 39729,
          40789: 27423,
          40790: 27448,
          40791: 27447,
          40792: 30428,
          40793: 27449,
          40794: 39150,
          40795: 27463,
          40796: 27459,
          40797: 27465,
          40798: 27472,
          40799: 27481,
          40800: 27476,
          40801: 27483,
          40802: 27487,
          40803: 27489,
          40804: 27512,
          40805: 27513,
          40806: 27519,
          40807: 27520,
          40808: 27524,
          40809: 27523,
          40810: 27533,
          40811: 27544,
          40812: 27541,
          40813: 27550,
          40814: 27556,
          40815: 27562,
          40816: 27563,
          40817: 27567,
          40818: 27570,
          40819: 27569,
          40820: 27571,
          40821: 27575,
          40822: 27580,
          40823: 27590,
          40824: 27595,
          40825: 27603,
          40826: 27615,
          40827: 27628,
          40828: 27627,
          40829: 27635,
          40830: 27631,
          40832: 40638,
          40833: 27656,
          40834: 27667,
          40835: 27668,
          40836: 27675,
          40837: 27684,
          40838: 27683,
          40839: 27742,
          40840: 27733,
          40841: 27746,
          40842: 27754,
          40843: 27778,
          40844: 27789,
          40845: 27802,
          40846: 27777,
          40847: 27803,
          40848: 27774,
          40849: 27752,
          40850: 27763,
          40851: 27794,
          40852: 27792,
          40853: 27844,
          40854: 27889,
          40855: 27859,
          40856: 27837,
          40857: 27863,
          40858: 27845,
          40859: 27869,
          40860: 27822,
          40861: 27825,
          40862: 27838,
          40863: 27834,
          40864: 27867,
          40865: 27887,
          40866: 27865,
          40867: 27882,
          40868: 27935,
          40869: 34893,
          40870: 27958,
          40871: 27947,
          40872: 27965,
          40873: 27960,
          40874: 27929,
          40875: 27957,
          40876: 27955,
          40877: 27922,
          40878: 27916,
          40879: 28003,
          40880: 28051,
          40881: 28004,
          40882: 27994,
          40883: 28025,
          40884: 27993,
          40885: 28046,
          40886: 28053,
          40887: 28644,
          40888: 28037,
          40889: 28153,
          40890: 28181,
          40891: 28170,
          40892: 28085,
          40893: 28103,
          40894: 28134,
          40895: 28088,
          40896: 28102,
          40897: 28140,
          40898: 28126,
          40899: 28108,
          40900: 28136,
          40901: 28114,
          40902: 28101,
          40903: 28154,
          40904: 28121,
          40905: 28132,
          40906: 28117,
          40907: 28138,
          40908: 28142,
          40909: 28205,
          40910: 28270,
          40911: 28206,
          40912: 28185,
          40913: 28274,
          40914: 28255,
          40915: 28222,
          40916: 28195,
          40917: 28267,
          40918: 28203,
          40919: 28278,
          40920: 28237,
          40921: 28191,
          40922: 28227,
          40923: 28218,
          40924: 28238,
          40925: 28196,
          40926: 28415,
          40927: 28189,
          40928: 28216,
          40929: 28290,
          40930: 28330,
          40931: 28312,
          40932: 28361,
          40933: 28343,
          40934: 28371,
          40935: 28349,
          40936: 28335,
          40937: 28356,
          40938: 28338,
          40939: 28372,
          40940: 28373,
          40941: 28303,
          40942: 28325,
          40943: 28354,
          40944: 28319,
          40945: 28481,
          40946: 28433,
          40947: 28748,
          40948: 28396,
          40949: 28408,
          40950: 28414,
          40951: 28479,
          40952: 28402,
          40953: 28465,
          40954: 28399,
          40955: 28466,
          40956: 28364,
          161: 65377,
          162: 65378,
          163: 65379,
          164: 65380,
          165: 65381,
          166: 65382,
          167: 65383,
          168: 65384,
          169: 65385,
          170: 65386,
          171: 65387,
          172: 65388,
          173: 65389,
          174: 65390,
          175: 65391,
          176: 65392,
          177: 65393,
          178: 65394,
          179: 65395,
          180: 65396,
          181: 65397,
          182: 65398,
          183: 65399,
          184: 65400,
          185: 65401,
          186: 65402,
          187: 65403,
          188: 65404,
          189: 65405,
          190: 65406,
          191: 65407,
          192: 65408,
          193: 65409,
          194: 65410,
          195: 65411,
          196: 65412,
          197: 65413,
          198: 65414,
          199: 65415,
          200: 65416,
          201: 65417,
          202: 65418,
          203: 65419,
          204: 65420,
          205: 65421,
          206: 65422,
          207: 65423,
          208: 65424,
          209: 65425,
          210: 65426,
          211: 65427,
          212: 65428,
          213: 65429,
          214: 65430,
          215: 65431,
          216: 65432,
          217: 65433,
          218: 65434,
          219: 65435,
          220: 65436,
          221: 65437,
          222: 65438,
          223: 65439,
          57408: 28478,
          57409: 28435,
          57410: 28407,
          57411: 28550,
          57412: 28538,
          57413: 28536,
          57414: 28545,
          57415: 28544,
          57416: 28527,
          57417: 28507,
          57418: 28659,
          57419: 28525,
          57420: 28546,
          57421: 28540,
          57422: 28504,
          57423: 28558,
          57424: 28561,
          57425: 28610,
          57426: 28518,
          57427: 28595,
          57428: 28579,
          57429: 28577,
          57430: 28580,
          57431: 28601,
          57432: 28614,
          57433: 28586,
          57434: 28639,
          57435: 28629,
          57436: 28652,
          57437: 28628,
          57438: 28632,
          57439: 28657,
          57440: 28654,
          57441: 28635,
          57442: 28681,
          57443: 28683,
          57444: 28666,
          57445: 28689,
          57446: 28673,
          57447: 28687,
          57448: 28670,
          57449: 28699,
          57450: 28698,
          57451: 28532,
          57452: 28701,
          57453: 28696,
          57454: 28703,
          57455: 28720,
          57456: 28734,
          57457: 28722,
          57458: 28753,
          57459: 28771,
          57460: 28825,
          57461: 28818,
          57462: 28847,
          57463: 28913,
          57464: 28844,
          57465: 28856,
          57466: 28851,
          57467: 28846,
          57468: 28895,
          57469: 28875,
          57470: 28893,
          57472: 28889,
          57473: 28937,
          57474: 28925,
          57475: 28956,
          57476: 28953,
          57477: 29029,
          57478: 29013,
          57479: 29064,
          57480: 29030,
          57481: 29026,
          57482: 29004,
          57483: 29014,
          57484: 29036,
          57485: 29071,
          57486: 29179,
          57487: 29060,
          57488: 29077,
          57489: 29096,
          57490: 29100,
          57491: 29143,
          57492: 29113,
          57493: 29118,
          57494: 29138,
          57495: 29129,
          57496: 29140,
          57497: 29134,
          57498: 29152,
          57499: 29164,
          57500: 29159,
          57501: 29173,
          57502: 29180,
          57503: 29177,
          57504: 29183,
          57505: 29197,
          57506: 29200,
          57507: 29211,
          57508: 29224,
          57509: 29229,
          57510: 29228,
          57511: 29232,
          57512: 29234,
          57513: 29243,
          57514: 29244,
          57515: 29247,
          57516: 29248,
          57517: 29254,
          57518: 29259,
          57519: 29272,
          57520: 29300,
          57521: 29310,
          57522: 29314,
          57523: 29313,
          57524: 29319,
          57525: 29330,
          57526: 29334,
          57527: 29346,
          57528: 29351,
          57529: 29369,
          57530: 29362,
          57531: 29379,
          57532: 29382,
          57533: 29380,
          57534: 29390,
          57535: 29394,
          57536: 29410,
          57537: 29408,
          57538: 29409,
          57539: 29433,
          57540: 29431,
          57541: 20495,
          57542: 29463,
          57543: 29450,
          57544: 29468,
          57545: 29462,
          57546: 29469,
          57547: 29492,
          57548: 29487,
          57549: 29481,
          57550: 29477,
          57551: 29502,
          57552: 29518,
          57553: 29519,
          57554: 40664,
          57555: 29527,
          57556: 29546,
          57557: 29544,
          57558: 29552,
          57559: 29560,
          57560: 29557,
          57561: 29563,
          57562: 29562,
          57563: 29640,
          57564: 29619,
          57565: 29646,
          57566: 29627,
          57567: 29632,
          57568: 29669,
          57569: 29678,
          57570: 29662,
          57571: 29858,
          57572: 29701,
          57573: 29807,
          57574: 29733,
          57575: 29688,
          57576: 29746,
          57577: 29754,
          57578: 29781,
          57579: 29759,
          57580: 29791,
          57581: 29785,
          57582: 29761,
          57583: 29788,
          57584: 29801,
          57585: 29808,
          57586: 29795,
          57587: 29802,
          57588: 29814,
          57589: 29822,
          57590: 29835,
          57591: 29854,
          57592: 29863,
          57593: 29898,
          57594: 29903,
          57595: 29908,
          57596: 29681,
          57664: 29920,
          57665: 29923,
          57666: 29927,
          57667: 29929,
          57668: 29934,
          57669: 29938,
          57670: 29936,
          57671: 29937,
          57672: 29944,
          57673: 29943,
          57674: 29956,
          57675: 29955,
          57676: 29957,
          57677: 29964,
          57678: 29966,
          57679: 29965,
          57680: 29973,
          57681: 29971,
          57682: 29982,
          57683: 29990,
          57684: 29996,
          57685: 30012,
          57686: 30020,
          57687: 30029,
          57688: 30026,
          57689: 30025,
          57690: 30043,
          57691: 30022,
          57692: 30042,
          57693: 30057,
          57694: 30052,
          57695: 30055,
          57696: 30059,
          57697: 30061,
          57698: 30072,
          57699: 30070,
          57700: 30086,
          57701: 30087,
          57702: 30068,
          57703: 30090,
          57704: 30089,
          57705: 30082,
          57706: 30100,
          57707: 30106,
          57708: 30109,
          57709: 30117,
          57710: 30115,
          57711: 30146,
          57712: 30131,
          57713: 30147,
          57714: 30133,
          57715: 30141,
          57716: 30136,
          57717: 30140,
          57718: 30129,
          57719: 30157,
          57720: 30154,
          57721: 30162,
          57722: 30169,
          57723: 30179,
          57724: 30174,
          57725: 30206,
          57726: 30207,
          57728: 30204,
          57729: 30209,
          57730: 30192,
          57731: 30202,
          57732: 30194,
          57733: 30195,
          57734: 30219,
          57735: 30221,
          57736: 30217,
          57737: 30239,
          57738: 30247,
          57739: 30240,
          57740: 30241,
          57741: 30242,
          57742: 30244,
          57743: 30260,
          57744: 30256,
          57745: 30267,
          57746: 30279,
          57747: 30280,
          57748: 30278,
          57749: 30300,
          57750: 30296,
          57751: 30305,
          57752: 30306,
          57753: 30312,
          57754: 30313,
          57755: 30314,
          57756: 30311,
          57757: 30316,
          57758: 30320,
          57759: 30322,
          57760: 30326,
          57761: 30328,
          57762: 30332,
          57763: 30336,
          57764: 30339,
          57765: 30344,
          57766: 30347,
          57767: 30350,
          57768: 30358,
          57769: 30355,
          57770: 30361,
          57771: 30362,
          57772: 30384,
          57773: 30388,
          57774: 30392,
          57775: 30393,
          57776: 30394,
          57777: 30402,
          57778: 30413,
          57779: 30422,
          57780: 30418,
          57781: 30430,
          57782: 30433,
          57783: 30437,
          57784: 30439,
          57785: 30442,
          57786: 34351,
          57787: 30459,
          57788: 30472,
          57789: 30471,
          57790: 30468,
          57791: 30505,
          57792: 30500,
          57793: 30494,
          57794: 30501,
          57795: 30502,
          57796: 30491,
          57797: 30519,
          57798: 30520,
          57799: 30535,
          57800: 30554,
          57801: 30568,
          57802: 30571,
          57803: 30555,
          57804: 30565,
          57805: 30591,
          57806: 30590,
          57807: 30585,
          57808: 30606,
          57809: 30603,
          57810: 30609,
          57811: 30624,
          57812: 30622,
          57813: 30640,
          57814: 30646,
          57815: 30649,
          57816: 30655,
          57817: 30652,
          57818: 30653,
          57819: 30651,
          57820: 30663,
          57821: 30669,
          57822: 30679,
          57823: 30682,
          57824: 30684,
          57825: 30691,
          57826: 30702,
          57827: 30716,
          57828: 30732,
          57829: 30738,
          57830: 31014,
          57831: 30752,
          57832: 31018,
          57833: 30789,
          57834: 30862,
          57835: 30836,
          57836: 30854,
          57837: 30844,
          57838: 30874,
          57839: 30860,
          57840: 30883,
          57841: 30901,
          57842: 30890,
          57843: 30895,
          57844: 30929,
          57845: 30918,
          57846: 30923,
          57847: 30932,
          57848: 30910,
          57849: 30908,
          57850: 30917,
          57851: 30922,
          57852: 30956,
          57920: 30951,
          57921: 30938,
          57922: 30973,
          57923: 30964,
          57924: 30983,
          57925: 30994,
          57926: 30993,
          57927: 31001,
          57928: 31020,
          57929: 31019,
          57930: 31040,
          57931: 31072,
          57932: 31063,
          57933: 31071,
          57934: 31066,
          57935: 31061,
          57936: 31059,
          57937: 31098,
          57938: 31103,
          57939: 31114,
          57940: 31133,
          57941: 31143,
          57942: 40779,
          57943: 31146,
          57944: 31150,
          57945: 31155,
          57946: 31161,
          57947: 31162,
          57948: 31177,
          57949: 31189,
          57950: 31207,
          57951: 31212,
          57952: 31201,
          57953: 31203,
          57954: 31240,
          57955: 31245,
          57956: 31256,
          57957: 31257,
          57958: 31264,
          57959: 31263,
          57960: 31104,
          57961: 31281,
          57962: 31291,
          57963: 31294,
          57964: 31287,
          57965: 31299,
          57966: 31319,
          57967: 31305,
          57968: 31329,
          57969: 31330,
          57970: 31337,
          57971: 40861,
          57972: 31344,
          57973: 31353,
          57974: 31357,
          57975: 31368,
          57976: 31383,
          57977: 31381,
          57978: 31384,
          57979: 31382,
          57980: 31401,
          57981: 31432,
          57982: 31408,
          57984: 31414,
          57985: 31429,
          57986: 31428,
          57987: 31423,
          57988: 36995,
          57989: 31431,
          57990: 31434,
          57991: 31437,
          57992: 31439,
          57993: 31445,
          57994: 31443,
          57995: 31449,
          57996: 31450,
          57997: 31453,
          57998: 31457,
          57999: 31458,
          58e3: 31462,
          58001: 31469,
          58002: 31472,
          58003: 31490,
          58004: 31503,
          58005: 31498,
          58006: 31494,
          58007: 31539,
          58008: 31512,
          58009: 31513,
          58010: 31518,
          58011: 31541,
          58012: 31528,
          58013: 31542,
          58014: 31568,
          58015: 31610,
          58016: 31492,
          58017: 31565,
          58018: 31499,
          58019: 31564,
          58020: 31557,
          58021: 31605,
          58022: 31589,
          58023: 31604,
          58024: 31591,
          58025: 31600,
          58026: 31601,
          58027: 31596,
          58028: 31598,
          58029: 31645,
          58030: 31640,
          58031: 31647,
          58032: 31629,
          58033: 31644,
          58034: 31642,
          58035: 31627,
          58036: 31634,
          58037: 31631,
          58038: 31581,
          58039: 31641,
          58040: 31691,
          58041: 31681,
          58042: 31692,
          58043: 31695,
          58044: 31668,
          58045: 31686,
          58046: 31709,
          58047: 31721,
          58048: 31761,
          58049: 31764,
          58050: 31718,
          58051: 31717,
          58052: 31840,
          58053: 31744,
          58054: 31751,
          58055: 31763,
          58056: 31731,
          58057: 31735,
          58058: 31767,
          58059: 31757,
          58060: 31734,
          58061: 31779,
          58062: 31783,
          58063: 31786,
          58064: 31775,
          58065: 31799,
          58066: 31787,
          58067: 31805,
          58068: 31820,
          58069: 31811,
          58070: 31828,
          58071: 31823,
          58072: 31808,
          58073: 31824,
          58074: 31832,
          58075: 31839,
          58076: 31844,
          58077: 31830,
          58078: 31845,
          58079: 31852,
          58080: 31861,
          58081: 31875,
          58082: 31888,
          58083: 31908,
          58084: 31917,
          58085: 31906,
          58086: 31915,
          58087: 31905,
          58088: 31912,
          58089: 31923,
          58090: 31922,
          58091: 31921,
          58092: 31918,
          58093: 31929,
          58094: 31933,
          58095: 31936,
          58096: 31941,
          58097: 31938,
          58098: 31960,
          58099: 31954,
          58100: 31964,
          58101: 31970,
          58102: 39739,
          58103: 31983,
          58104: 31986,
          58105: 31988,
          58106: 31990,
          58107: 31994,
          58108: 32006,
          58176: 32002,
          58177: 32028,
          58178: 32021,
          58179: 32010,
          58180: 32069,
          58181: 32075,
          58182: 32046,
          58183: 32050,
          58184: 32063,
          58185: 32053,
          58186: 32070,
          58187: 32115,
          58188: 32086,
          58189: 32078,
          58190: 32114,
          58191: 32104,
          58192: 32110,
          58193: 32079,
          58194: 32099,
          58195: 32147,
          58196: 32137,
          58197: 32091,
          58198: 32143,
          58199: 32125,
          58200: 32155,
          58201: 32186,
          58202: 32174,
          58203: 32163,
          58204: 32181,
          58205: 32199,
          58206: 32189,
          58207: 32171,
          58208: 32317,
          58209: 32162,
          58210: 32175,
          58211: 32220,
          58212: 32184,
          58213: 32159,
          58214: 32176,
          58215: 32216,
          58216: 32221,
          58217: 32228,
          58218: 32222,
          58219: 32251,
          58220: 32242,
          58221: 32225,
          58222: 32261,
          58223: 32266,
          58224: 32291,
          58225: 32289,
          58226: 32274,
          58227: 32305,
          58228: 32287,
          58229: 32265,
          58230: 32267,
          58231: 32290,
          58232: 32326,
          58233: 32358,
          58234: 32315,
          58235: 32309,
          58236: 32313,
          58237: 32323,
          58238: 32311,
          58240: 32306,
          58241: 32314,
          58242: 32359,
          58243: 32349,
          58244: 32342,
          58245: 32350,
          58246: 32345,
          58247: 32346,
          58248: 32377,
          58249: 32362,
          58250: 32361,
          58251: 32380,
          58252: 32379,
          58253: 32387,
          58254: 32213,
          58255: 32381,
          58256: 36782,
          58257: 32383,
          58258: 32392,
          58259: 32393,
          58260: 32396,
          58261: 32402,
          58262: 32400,
          58263: 32403,
          58264: 32404,
          58265: 32406,
          58266: 32398,
          58267: 32411,
          58268: 32412,
          58269: 32568,
          58270: 32570,
          58271: 32581,
          58272: 32588,
          58273: 32589,
          58274: 32590,
          58275: 32592,
          58276: 32593,
          58277: 32597,
          58278: 32596,
          58279: 32600,
          58280: 32607,
          58281: 32608,
          58282: 32616,
          58283: 32617,
          58284: 32615,
          58285: 32632,
          58286: 32642,
          58287: 32646,
          58288: 32643,
          58289: 32648,
          58290: 32647,
          58291: 32652,
          58292: 32660,
          58293: 32670,
          58294: 32669,
          58295: 32666,
          58296: 32675,
          58297: 32687,
          58298: 32690,
          58299: 32697,
          58300: 32686,
          58301: 32694,
          58302: 32696,
          58303: 35697,
          58304: 32709,
          58305: 32710,
          58306: 32714,
          58307: 32725,
          58308: 32724,
          58309: 32737,
          58310: 32742,
          58311: 32745,
          58312: 32755,
          58313: 32761,
          58314: 39132,
          58315: 32774,
          58316: 32772,
          58317: 32779,
          58318: 32786,
          58319: 32792,
          58320: 32793,
          58321: 32796,
          58322: 32801,
          58323: 32808,
          58324: 32831,
          58325: 32827,
          58326: 32842,
          58327: 32838,
          58328: 32850,
          58329: 32856,
          58330: 32858,
          58331: 32863,
          58332: 32866,
          58333: 32872,
          58334: 32883,
          58335: 32882,
          58336: 32880,
          58337: 32886,
          58338: 32889,
          58339: 32893,
          58340: 32895,
          58341: 32900,
          58342: 32902,
          58343: 32901,
          58344: 32923,
          58345: 32915,
          58346: 32922,
          58347: 32941,
          58348: 20880,
          58349: 32940,
          58350: 32987,
          58351: 32997,
          58352: 32985,
          58353: 32989,
          58354: 32964,
          58355: 32986,
          58356: 32982,
          58357: 33033,
          58358: 33007,
          58359: 33009,
          58360: 33051,
          58361: 33065,
          58362: 33059,
          58363: 33071,
          58364: 33099,
          58432: 38539,
          58433: 33094,
          58434: 33086,
          58435: 33107,
          58436: 33105,
          58437: 33020,
          58438: 33137,
          58439: 33134,
          58440: 33125,
          58441: 33126,
          58442: 33140,
          58443: 33155,
          58444: 33160,
          58445: 33162,
          58446: 33152,
          58447: 33154,
          58448: 33184,
          58449: 33173,
          58450: 33188,
          58451: 33187,
          58452: 33119,
          58453: 33171,
          58454: 33193,
          58455: 33200,
          58456: 33205,
          58457: 33214,
          58458: 33208,
          58459: 33213,
          58460: 33216,
          58461: 33218,
          58462: 33210,
          58463: 33225,
          58464: 33229,
          58465: 33233,
          58466: 33241,
          58467: 33240,
          58468: 33224,
          58469: 33242,
          58470: 33247,
          58471: 33248,
          58472: 33255,
          58473: 33274,
          58474: 33275,
          58475: 33278,
          58476: 33281,
          58477: 33282,
          58478: 33285,
          58479: 33287,
          58480: 33290,
          58481: 33293,
          58482: 33296,
          58483: 33302,
          58484: 33321,
          58485: 33323,
          58486: 33336,
          58487: 33331,
          58488: 33344,
          58489: 33369,
          58490: 33368,
          58491: 33373,
          58492: 33370,
          58493: 33375,
          58494: 33380,
          58496: 33378,
          58497: 33384,
          58498: 33386,
          58499: 33387,
          58500: 33326,
          58501: 33393,
          58502: 33399,
          58503: 33400,
          58504: 33406,
          58505: 33421,
          58506: 33426,
          58507: 33451,
          58508: 33439,
          58509: 33467,
          58510: 33452,
          58511: 33505,
          58512: 33507,
          58513: 33503,
          58514: 33490,
          58515: 33524,
          58516: 33523,
          58517: 33530,
          58518: 33683,
          58519: 33539,
          58520: 33531,
          58521: 33529,
          58522: 33502,
          58523: 33542,
          58524: 33500,
          58525: 33545,
          58526: 33497,
          58527: 33589,
          58528: 33588,
          58529: 33558,
          58530: 33586,
          58531: 33585,
          58532: 33600,
          58533: 33593,
          58534: 33616,
          58535: 33605,
          58536: 33583,
          58537: 33579,
          58538: 33559,
          58539: 33560,
          58540: 33669,
          58541: 33690,
          58542: 33706,
          58543: 33695,
          58544: 33698,
          58545: 33686,
          58546: 33571,
          58547: 33678,
          58548: 33671,
          58549: 33674,
          58550: 33660,
          58551: 33717,
          58552: 33651,
          58553: 33653,
          58554: 33696,
          58555: 33673,
          58556: 33704,
          58557: 33780,
          58558: 33811,
          58559: 33771,
          58560: 33742,
          58561: 33789,
          58562: 33795,
          58563: 33752,
          58564: 33803,
          58565: 33729,
          58566: 33783,
          58567: 33799,
          58568: 33760,
          58569: 33778,
          58570: 33805,
          58571: 33826,
          58572: 33824,
          58573: 33725,
          58574: 33848,
          58575: 34054,
          58576: 33787,
          58577: 33901,
          58578: 33834,
          58579: 33852,
          58580: 34138,
          58581: 33924,
          58582: 33911,
          58583: 33899,
          58584: 33965,
          58585: 33902,
          58586: 33922,
          58587: 33897,
          58588: 33862,
          58589: 33836,
          58590: 33903,
          58591: 33913,
          58592: 33845,
          58593: 33994,
          58594: 33890,
          58595: 33977,
          58596: 33983,
          58597: 33951,
          58598: 34009,
          58599: 33997,
          58600: 33979,
          58601: 34010,
          58602: 34e3,
          58603: 33985,
          58604: 33990,
          58605: 34006,
          58606: 33953,
          58607: 34081,
          58608: 34047,
          58609: 34036,
          58610: 34071,
          58611: 34072,
          58612: 34092,
          58613: 34079,
          58614: 34069,
          58615: 34068,
          58616: 34044,
          58617: 34112,
          58618: 34147,
          58619: 34136,
          58620: 34120,
          58688: 34113,
          58689: 34306,
          58690: 34123,
          58691: 34133,
          58692: 34176,
          58693: 34212,
          58694: 34184,
          58695: 34193,
          58696: 34186,
          58697: 34216,
          58698: 34157,
          58699: 34196,
          58700: 34203,
          58701: 34282,
          58702: 34183,
          58703: 34204,
          58704: 34167,
          58705: 34174,
          58706: 34192,
          58707: 34249,
          58708: 34234,
          58709: 34255,
          58710: 34233,
          58711: 34256,
          58712: 34261,
          58713: 34269,
          58714: 34277,
          58715: 34268,
          58716: 34297,
          58717: 34314,
          58718: 34323,
          58719: 34315,
          58720: 34302,
          58721: 34298,
          58722: 34310,
          58723: 34338,
          58724: 34330,
          58725: 34352,
          58726: 34367,
          58727: 34381,
          58728: 20053,
          58729: 34388,
          58730: 34399,
          58731: 34407,
          58732: 34417,
          58733: 34451,
          58734: 34467,
          58735: 34473,
          58736: 34474,
          58737: 34443,
          58738: 34444,
          58739: 34486,
          58740: 34479,
          58741: 34500,
          58742: 34502,
          58743: 34480,
          58744: 34505,
          58745: 34851,
          58746: 34475,
          58747: 34516,
          58748: 34526,
          58749: 34537,
          58750: 34540,
          58752: 34527,
          58753: 34523,
          58754: 34543,
          58755: 34578,
          58756: 34566,
          58757: 34568,
          58758: 34560,
          58759: 34563,
          58760: 34555,
          58761: 34577,
          58762: 34569,
          58763: 34573,
          58764: 34553,
          58765: 34570,
          58766: 34612,
          58767: 34623,
          58768: 34615,
          58769: 34619,
          58770: 34597,
          58771: 34601,
          58772: 34586,
          58773: 34656,
          58774: 34655,
          58775: 34680,
          58776: 34636,
          58777: 34638,
          58778: 34676,
          58779: 34647,
          58780: 34664,
          58781: 34670,
          58782: 34649,
          58783: 34643,
          58784: 34659,
          58785: 34666,
          58786: 34821,
          58787: 34722,
          58788: 34719,
          58789: 34690,
          58790: 34735,
          58791: 34763,
          58792: 34749,
          58793: 34752,
          58794: 34768,
          58795: 38614,
          58796: 34731,
          58797: 34756,
          58798: 34739,
          58799: 34759,
          58800: 34758,
          58801: 34747,
          58802: 34799,
          58803: 34802,
          58804: 34784,
          58805: 34831,
          58806: 34829,
          58807: 34814,
          58808: 34806,
          58809: 34807,
          58810: 34830,
          58811: 34770,
          58812: 34833,
          58813: 34838,
          58814: 34837,
          58815: 34850,
          58816: 34849,
          58817: 34865,
          58818: 34870,
          58819: 34873,
          58820: 34855,
          58821: 34875,
          58822: 34884,
          58823: 34882,
          58824: 34898,
          58825: 34905,
          58826: 34910,
          58827: 34914,
          58828: 34923,
          58829: 34945,
          58830: 34942,
          58831: 34974,
          58832: 34933,
          58833: 34941,
          58834: 34997,
          58835: 34930,
          58836: 34946,
          58837: 34967,
          58838: 34962,
          58839: 34990,
          58840: 34969,
          58841: 34978,
          58842: 34957,
          58843: 34980,
          58844: 34992,
          58845: 35007,
          58846: 34993,
          58847: 35011,
          58848: 35012,
          58849: 35028,
          58850: 35032,
          58851: 35033,
          58852: 35037,
          58853: 35065,
          58854: 35074,
          58855: 35068,
          58856: 35060,
          58857: 35048,
          58858: 35058,
          58859: 35076,
          58860: 35084,
          58861: 35082,
          58862: 35091,
          58863: 35139,
          58864: 35102,
          58865: 35109,
          58866: 35114,
          58867: 35115,
          58868: 35137,
          58869: 35140,
          58870: 35131,
          58871: 35126,
          58872: 35128,
          58873: 35148,
          58874: 35101,
          58875: 35168,
          58876: 35166,
          58944: 35174,
          58945: 35172,
          58946: 35181,
          58947: 35178,
          58948: 35183,
          58949: 35188,
          58950: 35191,
          58951: 35198,
          58952: 35203,
          58953: 35208,
          58954: 35210,
          58955: 35219,
          58956: 35224,
          58957: 35233,
          58958: 35241,
          58959: 35238,
          58960: 35244,
          58961: 35247,
          58962: 35250,
          58963: 35258,
          58964: 35261,
          58965: 35263,
          58966: 35264,
          58967: 35290,
          58968: 35292,
          58969: 35293,
          58970: 35303,
          58971: 35316,
          58972: 35320,
          58973: 35331,
          58974: 35350,
          58975: 35344,
          58976: 35340,
          58977: 35355,
          58978: 35357,
          58979: 35365,
          58980: 35382,
          58981: 35393,
          58982: 35419,
          58983: 35410,
          58984: 35398,
          58985: 35400,
          58986: 35452,
          58987: 35437,
          58988: 35436,
          58989: 35426,
          58990: 35461,
          58991: 35458,
          58992: 35460,
          58993: 35496,
          58994: 35489,
          58995: 35473,
          58996: 35493,
          58997: 35494,
          58998: 35482,
          58999: 35491,
          59e3: 35524,
          59001: 35533,
          59002: 35522,
          59003: 35546,
          59004: 35563,
          59005: 35571,
          59006: 35559,
          59008: 35556,
          59009: 35569,
          59010: 35604,
          59011: 35552,
          59012: 35554,
          59013: 35575,
          59014: 35550,
          59015: 35547,
          59016: 35596,
          59017: 35591,
          59018: 35610,
          59019: 35553,
          59020: 35606,
          59021: 35600,
          59022: 35607,
          59023: 35616,
          59024: 35635,
          59025: 38827,
          59026: 35622,
          59027: 35627,
          59028: 35646,
          59029: 35624,
          59030: 35649,
          59031: 35660,
          59032: 35663,
          59033: 35662,
          59034: 35657,
          59035: 35670,
          59036: 35675,
          59037: 35674,
          59038: 35691,
          59039: 35679,
          59040: 35692,
          59041: 35695,
          59042: 35700,
          59043: 35709,
          59044: 35712,
          59045: 35724,
          59046: 35726,
          59047: 35730,
          59048: 35731,
          59049: 35734,
          59050: 35737,
          59051: 35738,
          59052: 35898,
          59053: 35905,
          59054: 35903,
          59055: 35912,
          59056: 35916,
          59057: 35918,
          59058: 35920,
          59059: 35925,
          59060: 35938,
          59061: 35948,
          59062: 35960,
          59063: 35962,
          59064: 35970,
          59065: 35977,
          59066: 35973,
          59067: 35978,
          59068: 35981,
          59069: 35982,
          59070: 35988,
          59071: 35964,
          59072: 35992,
          59073: 25117,
          59074: 36013,
          59075: 36010,
          59076: 36029,
          59077: 36018,
          59078: 36019,
          59079: 36014,
          59080: 36022,
          59081: 36040,
          59082: 36033,
          59083: 36068,
          59084: 36067,
          59085: 36058,
          59086: 36093,
          59087: 36090,
          59088: 36091,
          59089: 36100,
          59090: 36101,
          59091: 36106,
          59092: 36103,
          59093: 36111,
          59094: 36109,
          59095: 36112,
          59096: 40782,
          59097: 36115,
          59098: 36045,
          59099: 36116,
          59100: 36118,
          59101: 36199,
          59102: 36205,
          59103: 36209,
          59104: 36211,
          59105: 36225,
          59106: 36249,
          59107: 36290,
          59108: 36286,
          59109: 36282,
          59110: 36303,
          59111: 36314,
          59112: 36310,
          59113: 36300,
          59114: 36315,
          59115: 36299,
          59116: 36330,
          59117: 36331,
          59118: 36319,
          59119: 36323,
          59120: 36348,
          59121: 36360,
          59122: 36361,
          59123: 36351,
          59124: 36381,
          59125: 36382,
          59126: 36368,
          59127: 36383,
          59128: 36418,
          59129: 36405,
          59130: 36400,
          59131: 36404,
          59132: 36426,
          59200: 36423,
          59201: 36425,
          59202: 36428,
          59203: 36432,
          59204: 36424,
          59205: 36441,
          59206: 36452,
          59207: 36448,
          59208: 36394,
          59209: 36451,
          59210: 36437,
          59211: 36470,
          59212: 36466,
          59213: 36476,
          59214: 36481,
          59215: 36487,
          59216: 36485,
          59217: 36484,
          59218: 36491,
          59219: 36490,
          59220: 36499,
          59221: 36497,
          59222: 36500,
          59223: 36505,
          59224: 36522,
          59225: 36513,
          59226: 36524,
          59227: 36528,
          59228: 36550,
          59229: 36529,
          59230: 36542,
          59231: 36549,
          59232: 36552,
          59233: 36555,
          59234: 36571,
          59235: 36579,
          59236: 36604,
          59237: 36603,
          59238: 36587,
          59239: 36606,
          59240: 36618,
          59241: 36613,
          59242: 36629,
          59243: 36626,
          59244: 36633,
          59245: 36627,
          59246: 36636,
          59247: 36639,
          59248: 36635,
          59249: 36620,
          59250: 36646,
          59251: 36659,
          59252: 36667,
          59253: 36665,
          59254: 36677,
          59255: 36674,
          59256: 36670,
          59257: 36684,
          59258: 36681,
          59259: 36678,
          59260: 36686,
          59261: 36695,
          59262: 36700,
          59264: 36706,
          59265: 36707,
          59266: 36708,
          59267: 36764,
          59268: 36767,
          59269: 36771,
          59270: 36781,
          59271: 36783,
          59272: 36791,
          59273: 36826,
          59274: 36837,
          59275: 36834,
          59276: 36842,
          59277: 36847,
          59278: 36999,
          59279: 36852,
          59280: 36869,
          59281: 36857,
          59282: 36858,
          59283: 36881,
          59284: 36885,
          59285: 36897,
          59286: 36877,
          59287: 36894,
          59288: 36886,
          59289: 36875,
          59290: 36903,
          59291: 36918,
          59292: 36917,
          59293: 36921,
          59294: 36856,
          59295: 36943,
          59296: 36944,
          59297: 36945,
          59298: 36946,
          59299: 36878,
          59300: 36937,
          59301: 36926,
          59302: 36950,
          59303: 36952,
          59304: 36958,
          59305: 36968,
          59306: 36975,
          59307: 36982,
          59308: 38568,
          59309: 36978,
          59310: 36994,
          59311: 36989,
          59312: 36993,
          59313: 36992,
          59314: 37002,
          59315: 37001,
          59316: 37007,
          59317: 37032,
          59318: 37039,
          59319: 37041,
          59320: 37045,
          59321: 37090,
          59322: 37092,
          59323: 25160,
          59324: 37083,
          59325: 37122,
          59326: 37138,
          59327: 37145,
          59328: 37170,
          59329: 37168,
          59330: 37194,
          59331: 37206,
          59332: 37208,
          59333: 37219,
          59334: 37221,
          59335: 37225,
          59336: 37235,
          59337: 37234,
          59338: 37259,
          59339: 37257,
          59340: 37250,
          59341: 37282,
          59342: 37291,
          59343: 37295,
          59344: 37290,
          59345: 37301,
          59346: 37300,
          59347: 37306,
          59348: 37312,
          59349: 37313,
          59350: 37321,
          59351: 37323,
          59352: 37328,
          59353: 37334,
          59354: 37343,
          59355: 37345,
          59356: 37339,
          59357: 37372,
          59358: 37365,
          59359: 37366,
          59360: 37406,
          59361: 37375,
          59362: 37396,
          59363: 37420,
          59364: 37397,
          59365: 37393,
          59366: 37470,
          59367: 37463,
          59368: 37445,
          59369: 37449,
          59370: 37476,
          59371: 37448,
          59372: 37525,
          59373: 37439,
          59374: 37451,
          59375: 37456,
          59376: 37532,
          59377: 37526,
          59378: 37523,
          59379: 37531,
          59380: 37466,
          59381: 37583,
          59382: 37561,
          59383: 37559,
          59384: 37609,
          59385: 37647,
          59386: 37626,
          59387: 37700,
          59388: 37678,
          59456: 37657,
          59457: 37666,
          59458: 37658,
          59459: 37667,
          59460: 37690,
          59461: 37685,
          59462: 37691,
          59463: 37724,
          59464: 37728,
          59465: 37756,
          59466: 37742,
          59467: 37718,
          59468: 37808,
          59469: 37804,
          59470: 37805,
          59471: 37780,
          59472: 37817,
          59473: 37846,
          59474: 37847,
          59475: 37864,
          59476: 37861,
          59477: 37848,
          59478: 37827,
          59479: 37853,
          59480: 37840,
          59481: 37832,
          59482: 37860,
          59483: 37914,
          59484: 37908,
          59485: 37907,
          59486: 37891,
          59487: 37895,
          59488: 37904,
          59489: 37942,
          59490: 37931,
          59491: 37941,
          59492: 37921,
          59493: 37946,
          59494: 37953,
          59495: 37970,
          59496: 37956,
          59497: 37979,
          59498: 37984,
          59499: 37986,
          59500: 37982,
          59501: 37994,
          59502: 37417,
          59503: 38e3,
          59504: 38005,
          59505: 38007,
          59506: 38013,
          59507: 37978,
          59508: 38012,
          59509: 38014,
          59510: 38017,
          59511: 38015,
          59512: 38274,
          59513: 38279,
          59514: 38282,
          59515: 38292,
          59516: 38294,
          59517: 38296,
          59518: 38297,
          59520: 38304,
          59521: 38312,
          59522: 38311,
          59523: 38317,
          59524: 38332,
          59525: 38331,
          59526: 38329,
          59527: 38334,
          59528: 38346,
          59529: 28662,
          59530: 38339,
          59531: 38349,
          59532: 38348,
          59533: 38357,
          59534: 38356,
          59535: 38358,
          59536: 38364,
          59537: 38369,
          59538: 38373,
          59539: 38370,
          59540: 38433,
          59541: 38440,
          59542: 38446,
          59543: 38447,
          59544: 38466,
          59545: 38476,
          59546: 38479,
          59547: 38475,
          59548: 38519,
          59549: 38492,
          59550: 38494,
          59551: 38493,
          59552: 38495,
          59553: 38502,
          59554: 38514,
          59555: 38508,
          59556: 38541,
          59557: 38552,
          59558: 38549,
          59559: 38551,
          59560: 38570,
          59561: 38567,
          59562: 38577,
          59563: 38578,
          59564: 38576,
          59565: 38580,
          59566: 38582,
          59567: 38584,
          59568: 38585,
          59569: 38606,
          59570: 38603,
          59571: 38601,
          59572: 38605,
          59573: 35149,
          59574: 38620,
          59575: 38669,
          59576: 38613,
          59577: 38649,
          59578: 38660,
          59579: 38662,
          59580: 38664,
          59581: 38675,
          59582: 38670,
          59583: 38673,
          59584: 38671,
          59585: 38678,
          59586: 38681,
          59587: 38692,
          59588: 38698,
          59589: 38704,
          59590: 38713,
          59591: 38717,
          59592: 38718,
          59593: 38724,
          59594: 38726,
          59595: 38728,
          59596: 38722,
          59597: 38729,
          59598: 38748,
          59599: 38752,
          59600: 38756,
          59601: 38758,
          59602: 38760,
          59603: 21202,
          59604: 38763,
          59605: 38769,
          59606: 38777,
          59607: 38789,
          59608: 38780,
          59609: 38785,
          59610: 38778,
          59611: 38790,
          59612: 38795,
          59613: 38799,
          59614: 38800,
          59615: 38812,
          59616: 38824,
          59617: 38822,
          59618: 38819,
          59619: 38835,
          59620: 38836,
          59621: 38851,
          59622: 38854,
          59623: 38856,
          59624: 38859,
          59625: 38876,
          59626: 38893,
          59627: 40783,
          59628: 38898,
          59629: 31455,
          59630: 38902,
          59631: 38901,
          59632: 38927,
          59633: 38924,
          59634: 38968,
          59635: 38948,
          59636: 38945,
          59637: 38967,
          59638: 38973,
          59639: 38982,
          59640: 38991,
          59641: 38987,
          59642: 39019,
          59643: 39023,
          59644: 39024,
          59712: 39025,
          59713: 39028,
          59714: 39027,
          59715: 39082,
          59716: 39087,
          59717: 39089,
          59718: 39094,
          59719: 39108,
          59720: 39107,
          59721: 39110,
          59722: 39145,
          59723: 39147,
          59724: 39171,
          59725: 39177,
          59726: 39186,
          59727: 39188,
          59728: 39192,
          59729: 39201,
          59730: 39197,
          59731: 39198,
          59732: 39204,
          59733: 39200,
          59734: 39212,
          59735: 39214,
          59736: 39229,
          59737: 39230,
          59738: 39234,
          59739: 39241,
          59740: 39237,
          59741: 39248,
          59742: 39243,
          59743: 39249,
          59744: 39250,
          59745: 39244,
          59746: 39253,
          59747: 39319,
          59748: 39320,
          59749: 39333,
          59750: 39341,
          59751: 39342,
          59752: 39356,
          59753: 39391,
          59754: 39387,
          59755: 39389,
          59756: 39384,
          59757: 39377,
          59758: 39405,
          59759: 39406,
          59760: 39409,
          59761: 39410,
          59762: 39419,
          59763: 39416,
          59764: 39425,
          59765: 39439,
          59766: 39429,
          59767: 39394,
          59768: 39449,
          59769: 39467,
          59770: 39479,
          59771: 39493,
          59772: 39490,
          59773: 39488,
          59774: 39491,
          59776: 39486,
          59777: 39509,
          59778: 39501,
          59779: 39515,
          59780: 39511,
          59781: 39519,
          59782: 39522,
          59783: 39525,
          59784: 39524,
          59785: 39529,
          59786: 39531,
          59787: 39530,
          59788: 39597,
          59789: 39600,
          59790: 39612,
          59791: 39616,
          59792: 39631,
          59793: 39633,
          59794: 39635,
          59795: 39636,
          59796: 39646,
          59797: 39647,
          59798: 39650,
          59799: 39651,
          59800: 39654,
          59801: 39663,
          59802: 39659,
          59803: 39662,
          59804: 39668,
          59805: 39665,
          59806: 39671,
          59807: 39675,
          59808: 39686,
          59809: 39704,
          59810: 39706,
          59811: 39711,
          59812: 39714,
          59813: 39715,
          59814: 39717,
          59815: 39719,
          59816: 39720,
          59817: 39721,
          59818: 39722,
          59819: 39726,
          59820: 39727,
          59821: 39730,
          59822: 39748,
          59823: 39747,
          59824: 39759,
          59825: 39757,
          59826: 39758,
          59827: 39761,
          59828: 39768,
          59829: 39796,
          59830: 39827,
          59831: 39811,
          59832: 39825,
          59833: 39830,
          59834: 39831,
          59835: 39839,
          59836: 39840,
          59837: 39848,
          59838: 39860,
          59839: 39872,
          59840: 39882,
          59841: 39865,
          59842: 39878,
          59843: 39887,
          59844: 39889,
          59845: 39890,
          59846: 39907,
          59847: 39906,
          59848: 39908,
          59849: 39892,
          59850: 39905,
          59851: 39994,
          59852: 39922,
          59853: 39921,
          59854: 39920,
          59855: 39957,
          59856: 39956,
          59857: 39945,
          59858: 39955,
          59859: 39948,
          59860: 39942,
          59861: 39944,
          59862: 39954,
          59863: 39946,
          59864: 39940,
          59865: 39982,
          59866: 39963,
          59867: 39973,
          59868: 39972,
          59869: 39969,
          59870: 39984,
          59871: 40007,
          59872: 39986,
          59873: 40006,
          59874: 39998,
          59875: 40026,
          59876: 40032,
          59877: 40039,
          59878: 40054,
          59879: 40056,
          59880: 40167,
          59881: 40172,
          59882: 40176,
          59883: 40201,
          59884: 40200,
          59885: 40171,
          59886: 40195,
          59887: 40198,
          59888: 40234,
          59889: 40230,
          59890: 40367,
          59891: 40227,
          59892: 40223,
          59893: 40260,
          59894: 40213,
          59895: 40210,
          59896: 40257,
          59897: 40255,
          59898: 40254,
          59899: 40262,
          59900: 40264,
          59968: 40285,
          59969: 40286,
          59970: 40292,
          59971: 40273,
          59972: 40272,
          59973: 40281,
          59974: 40306,
          59975: 40329,
          59976: 40327,
          59977: 40363,
          59978: 40303,
          59979: 40314,
          59980: 40346,
          59981: 40356,
          59982: 40361,
          59983: 40370,
          59984: 40388,
          59985: 40385,
          59986: 40379,
          59987: 40376,
          59988: 40378,
          59989: 40390,
          59990: 40399,
          59991: 40386,
          59992: 40409,
          59993: 40403,
          59994: 40440,
          59995: 40422,
          59996: 40429,
          59997: 40431,
          59998: 40445,
          59999: 40474,
          6e4: 40475,
          60001: 40478,
          60002: 40565,
          60003: 40569,
          60004: 40573,
          60005: 40577,
          60006: 40584,
          60007: 40587,
          60008: 40588,
          60009: 40594,
          60010: 40597,
          60011: 40593,
          60012: 40605,
          60013: 40613,
          60014: 40617,
          60015: 40632,
          60016: 40618,
          60017: 40621,
          60018: 38753,
          60019: 40652,
          60020: 40654,
          60021: 40655,
          60022: 40656,
          60023: 40660,
          60024: 40668,
          60025: 40670,
          60026: 40669,
          60027: 40672,
          60028: 40677,
          60029: 40680,
          60030: 40687,
          60032: 40692,
          60033: 40694,
          60034: 40695,
          60035: 40697,
          60036: 40699,
          60037: 40700,
          60038: 40701,
          60039: 40711,
          60040: 40712,
          60041: 30391,
          60042: 40725,
          60043: 40737,
          60044: 40748,
          60045: 40766,
          60046: 40778,
          60047: 40786,
          60048: 40788,
          60049: 40803,
          60050: 40799,
          60051: 40800,
          60052: 40801,
          60053: 40806,
          60054: 40807,
          60055: 40812,
          60056: 40810,
          60057: 40823,
          60058: 40818,
          60059: 40822,
          60060: 40853,
          60061: 40860,
          60062: 40864,
          60063: 22575,
          60064: 27079,
          60065: 36953,
          60066: 29796,
          60067: 20956,
          60068: 29081
        };
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var GenericGF_1 = __webpack_require__(1);
        var GenericGFPoly_1 = __webpack_require__(2);
        function runEuclideanAlgorithm(field, a2, b2, R2) {
          var _a2;
          if (a2.degree() < b2.degree()) {
            _a2 = [b2, a2], a2 = _a2[0], b2 = _a2[1];
          }
          var rLast = a2;
          var r2 = b2;
          var tLast = field.zero;
          var t2 = field.one;
          while (r2.degree() >= R2 / 2) {
            var rLastLast = rLast;
            var tLastLast = tLast;
            rLast = r2;
            tLast = t2;
            if (rLast.isZero()) {
              return null;
            }
            r2 = rLastLast;
            var q2 = field.zero;
            var denominatorLeadingTerm = rLast.getCoefficient(rLast.degree());
            var dltInverse = field.inverse(denominatorLeadingTerm);
            while (r2.degree() >= rLast.degree() && !r2.isZero()) {
              var degreeDiff = r2.degree() - rLast.degree();
              var scale = field.multiply(r2.getCoefficient(r2.degree()), dltInverse);
              q2 = q2.addOrSubtract(field.buildMonomial(degreeDiff, scale));
              r2 = r2.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
            }
            t2 = q2.multiplyPoly(tLast).addOrSubtract(tLastLast);
            if (r2.degree() >= rLast.degree()) {
              return null;
            }
          }
          var sigmaTildeAtZero = t2.getCoefficient(0);
          if (sigmaTildeAtZero === 0) {
            return null;
          }
          var inverse = field.inverse(sigmaTildeAtZero);
          return [t2.multiply(inverse), r2.multiply(inverse)];
        }
        function findErrorLocations(field, errorLocator) {
          var numErrors = errorLocator.degree();
          if (numErrors === 1) {
            return [errorLocator.getCoefficient(1)];
          }
          var result = new Array(numErrors);
          var errorCount = 0;
          for (var i2 = 1; i2 < field.size && errorCount < numErrors; i2++) {
            if (errorLocator.evaluateAt(i2) === 0) {
              result[errorCount] = field.inverse(i2);
              errorCount++;
            }
          }
          if (errorCount !== numErrors) {
            return null;
          }
          return result;
        }
        function findErrorMagnitudes(field, errorEvaluator, errorLocations) {
          var s2 = errorLocations.length;
          var result = new Array(s2);
          for (var i2 = 0; i2 < s2; i2++) {
            var xiInverse = field.inverse(errorLocations[i2]);
            var denominator = 1;
            for (var j2 = 0; j2 < s2; j2++) {
              if (i2 !== j2) {
                denominator = field.multiply(denominator, GenericGF_1.addOrSubtractGF(1, field.multiply(errorLocations[j2], xiInverse)));
              }
            }
            result[i2] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
            if (field.generatorBase !== 0) {
              result[i2] = field.multiply(result[i2], xiInverse);
            }
          }
          return result;
        }
        function decode2(bytes, twoS) {
          var outputBytes = new Uint8ClampedArray(bytes.length);
          outputBytes.set(bytes);
          var field = new GenericGF_1.default(285, 256, 0);
          var poly = new GenericGFPoly_1.default(field, outputBytes);
          var syndromeCoefficients = new Uint8ClampedArray(twoS);
          var error2 = false;
          for (var s2 = 0; s2 < twoS; s2++) {
            var evaluation = poly.evaluateAt(field.exp(s2 + field.generatorBase));
            syndromeCoefficients[syndromeCoefficients.length - 1 - s2] = evaluation;
            if (evaluation !== 0) {
              error2 = true;
            }
          }
          if (!error2) {
            return outputBytes;
          }
          var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
          var sigmaOmega = runEuclideanAlgorithm(field, field.buildMonomial(twoS, 1), syndrome, twoS);
          if (sigmaOmega === null) {
            return null;
          }
          var errorLocations = findErrorLocations(field, sigmaOmega[0]);
          if (errorLocations == null) {
            return null;
          }
          var errorMagnitudes = findErrorMagnitudes(field, sigmaOmega[1], errorLocations);
          for (var i2 = 0; i2 < errorLocations.length; i2++) {
            var position = outputBytes.length - 1 - field.log(errorLocations[i2]);
            if (position < 0) {
              return null;
            }
            outputBytes[position] = GenericGF_1.addOrSubtractGF(outputBytes[position], errorMagnitudes[i2]);
          }
          return outputBytes;
        }
        exports3.decode = decode2;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.VERSIONS = [
          {
            infoBits: null,
            versionNumber: 1,
            alignmentPatternCenters: [],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 7,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 19 }]
              },
              {
                ecCodewordsPerBlock: 10,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
              },
              {
                ecCodewordsPerBlock: 13,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 13 }]
              },
              {
                ecCodewordsPerBlock: 17,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 9 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 2,
            alignmentPatternCenters: [6, 18],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 10,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 34 }]
              },
              {
                ecCodewordsPerBlock: 16,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 28 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 22 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 3,
            alignmentPatternCenters: [6, 22],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 15,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 55 }]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 44 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 17 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 13 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 4,
            alignmentPatternCenters: [6, 26],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 80 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 32 }]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 24 }]
              },
              {
                ecCodewordsPerBlock: 16,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 9 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 5,
            alignmentPatternCenters: [6, 30],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 108 }]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 43 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 15 },
                  { numBlocks: 2, dataCodewordsPerBlock: 16 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 11 },
                  { numBlocks: 2, dataCodewordsPerBlock: 12 }
                ]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 6,
            alignmentPatternCenters: [6, 34],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 68 }]
              },
              {
                ecCodewordsPerBlock: 16,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 27 }]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 19 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 15 }]
              }
            ]
          },
          {
            infoBits: 31892,
            versionNumber: 7,
            alignmentPatternCenters: [6, 22, 38],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 78 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 31 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 14 },
                  { numBlocks: 4, dataCodewordsPerBlock: 15 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 13 },
                  { numBlocks: 1, dataCodewordsPerBlock: 14 }
                ]
              }
            ]
          },
          {
            infoBits: 34236,
            versionNumber: 8,
            alignmentPatternCenters: [6, 24, 42],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 97 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 38 },
                  { numBlocks: 2, dataCodewordsPerBlock: 39 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 18 },
                  { numBlocks: 2, dataCodewordsPerBlock: 19 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 14 },
                  { numBlocks: 2, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 39577,
            versionNumber: 9,
            alignmentPatternCenters: [6, 26, 46],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 116 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 36 },
                  { numBlocks: 2, dataCodewordsPerBlock: 37 }
                ]
              },
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 16 },
                  { numBlocks: 4, dataCodewordsPerBlock: 17 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 12 },
                  { numBlocks: 4, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 42195,
            versionNumber: 10,
            alignmentPatternCenters: [6, 28, 50],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 68 },
                  { numBlocks: 2, dataCodewordsPerBlock: 69 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 43 },
                  { numBlocks: 1, dataCodewordsPerBlock: 44 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 19 },
                  { numBlocks: 2, dataCodewordsPerBlock: 20 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 15 },
                  { numBlocks: 2, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 48118,
            versionNumber: 11,
            alignmentPatternCenters: [6, 30, 54],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 81 }]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 50 },
                  { numBlocks: 4, dataCodewordsPerBlock: 51 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 22 },
                  { numBlocks: 4, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 12 },
                  { numBlocks: 8, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 51042,
            versionNumber: 12,
            alignmentPatternCenters: [6, 32, 58],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 92 },
                  { numBlocks: 2, dataCodewordsPerBlock: 93 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 36 },
                  { numBlocks: 2, dataCodewordsPerBlock: 37 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 20 },
                  { numBlocks: 6, dataCodewordsPerBlock: 21 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 14 },
                  { numBlocks: 4, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 55367,
            versionNumber: 13,
            alignmentPatternCenters: [6, 34, 62],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 107 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 37 },
                  { numBlocks: 1, dataCodewordsPerBlock: 38 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 20 },
                  { numBlocks: 4, dataCodewordsPerBlock: 21 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 11 },
                  { numBlocks: 4, dataCodewordsPerBlock: 12 }
                ]
              }
            ]
          },
          {
            infoBits: 58893,
            versionNumber: 14,
            alignmentPatternCenters: [6, 26, 46, 66],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 115 },
                  { numBlocks: 1, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 40 },
                  { numBlocks: 5, dataCodewordsPerBlock: 41 }
                ]
              },
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 16 },
                  { numBlocks: 5, dataCodewordsPerBlock: 17 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 12 },
                  { numBlocks: 5, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 63784,
            versionNumber: 15,
            alignmentPatternCenters: [6, 26, 48, 70],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 87 },
                  { numBlocks: 1, dataCodewordsPerBlock: 88 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 41 },
                  { numBlocks: 5, dataCodewordsPerBlock: 42 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 24 },
                  { numBlocks: 7, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 12 },
                  { numBlocks: 7, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 68472,
            versionNumber: 16,
            alignmentPatternCenters: [6, 26, 50, 74],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 98 },
                  { numBlocks: 1, dataCodewordsPerBlock: 99 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 45 },
                  { numBlocks: 3, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 19 },
                  { numBlocks: 2, dataCodewordsPerBlock: 20 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 15 },
                  { numBlocks: 13, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 70749,
            versionNumber: 17,
            alignmentPatternCenters: [6, 30, 54, 78],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 107 },
                  { numBlocks: 5, dataCodewordsPerBlock: 108 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 46 },
                  { numBlocks: 1, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 22 },
                  { numBlocks: 15, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 14 },
                  { numBlocks: 17, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 76311,
            versionNumber: 18,
            alignmentPatternCenters: [6, 30, 56, 82],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 120 },
                  { numBlocks: 1, dataCodewordsPerBlock: 121 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 9, dataCodewordsPerBlock: 43 },
                  { numBlocks: 4, dataCodewordsPerBlock: 44 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 22 },
                  { numBlocks: 1, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 14 },
                  { numBlocks: 19, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 79154,
            versionNumber: 19,
            alignmentPatternCenters: [6, 30, 58, 86],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 113 },
                  { numBlocks: 4, dataCodewordsPerBlock: 114 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 44 },
                  { numBlocks: 11, dataCodewordsPerBlock: 45 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 21 },
                  { numBlocks: 4, dataCodewordsPerBlock: 22 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 9, dataCodewordsPerBlock: 13 },
                  { numBlocks: 16, dataCodewordsPerBlock: 14 }
                ]
              }
            ]
          },
          {
            infoBits: 84390,
            versionNumber: 20,
            alignmentPatternCenters: [6, 34, 62, 90],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 107 },
                  { numBlocks: 5, dataCodewordsPerBlock: 108 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 41 },
                  { numBlocks: 13, dataCodewordsPerBlock: 42 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 24 },
                  { numBlocks: 5, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 15 },
                  { numBlocks: 10, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 87683,
            versionNumber: 21,
            alignmentPatternCenters: [6, 28, 50, 72, 94],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 116 },
                  { numBlocks: 4, dataCodewordsPerBlock: 117 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 42 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 22 },
                  { numBlocks: 6, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 16 },
                  { numBlocks: 6, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 92361,
            versionNumber: 22,
            alignmentPatternCenters: [6, 26, 50, 74, 98],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 111 },
                  { numBlocks: 7, dataCodewordsPerBlock: 112 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 46 }]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 24 },
                  { numBlocks: 16, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 34, dataCodewordsPerBlock: 13 }]
              }
            ]
          },
          {
            infoBits: 96236,
            versionNumber: 23,
            alignmentPatternCenters: [6, 30, 54, 74, 102],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 121 },
                  { numBlocks: 5, dataCodewordsPerBlock: 122 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 47 },
                  { numBlocks: 14, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 24 },
                  { numBlocks: 14, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 16, dataCodewordsPerBlock: 15 },
                  { numBlocks: 14, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 102084,
            versionNumber: 24,
            alignmentPatternCenters: [6, 28, 54, 80, 106],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 117 },
                  { numBlocks: 4, dataCodewordsPerBlock: 118 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 45 },
                  { numBlocks: 14, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 24 },
                  { numBlocks: 16, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 30, dataCodewordsPerBlock: 16 },
                  { numBlocks: 2, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 102881,
            versionNumber: 25,
            alignmentPatternCenters: [6, 32, 58, 84, 110],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 106 },
                  { numBlocks: 4, dataCodewordsPerBlock: 107 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 47 },
                  { numBlocks: 13, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 24 },
                  { numBlocks: 22, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 22, dataCodewordsPerBlock: 15 },
                  { numBlocks: 13, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 110507,
            versionNumber: 26,
            alignmentPatternCenters: [6, 30, 58, 86, 114],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 114 },
                  { numBlocks: 2, dataCodewordsPerBlock: 115 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 46 },
                  { numBlocks: 4, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 28, dataCodewordsPerBlock: 22 },
                  { numBlocks: 6, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 33, dataCodewordsPerBlock: 16 },
                  { numBlocks: 4, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 110734,
            versionNumber: 27,
            alignmentPatternCenters: [6, 34, 62, 90, 118],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 122 },
                  { numBlocks: 4, dataCodewordsPerBlock: 123 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 22, dataCodewordsPerBlock: 45 },
                  { numBlocks: 3, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 23 },
                  { numBlocks: 26, dataCodewordsPerBlock: 24 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 15 },
                  { numBlocks: 28, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 117786,
            versionNumber: 28,
            alignmentPatternCenters: [6, 26, 50, 74, 98, 122],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 117 },
                  { numBlocks: 10, dataCodewordsPerBlock: 118 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 45 },
                  { numBlocks: 23, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 24 },
                  { numBlocks: 31, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 15 },
                  { numBlocks: 31, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 119615,
            versionNumber: 29,
            alignmentPatternCenters: [6, 30, 54, 78, 102, 126],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 116 },
                  { numBlocks: 7, dataCodewordsPerBlock: 117 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 21, dataCodewordsPerBlock: 45 },
                  { numBlocks: 7, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 23 },
                  { numBlocks: 37, dataCodewordsPerBlock: 24 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 15 },
                  { numBlocks: 26, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 126325,
            versionNumber: 30,
            alignmentPatternCenters: [6, 26, 52, 78, 104, 130],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 115 },
                  { numBlocks: 10, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 47 },
                  { numBlocks: 10, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 24 },
                  { numBlocks: 25, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 23, dataCodewordsPerBlock: 15 },
                  { numBlocks: 25, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 127568,
            versionNumber: 31,
            alignmentPatternCenters: [6, 30, 56, 82, 108, 134],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 13, dataCodewordsPerBlock: 115 },
                  { numBlocks: 3, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 46 },
                  { numBlocks: 29, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 42, dataCodewordsPerBlock: 24 },
                  { numBlocks: 1, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 23, dataCodewordsPerBlock: 15 },
                  { numBlocks: 28, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 133589,
            versionNumber: 32,
            alignmentPatternCenters: [6, 34, 60, 86, 112, 138],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 115 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 46 },
                  { numBlocks: 23, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 24 },
                  { numBlocks: 35, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 15 },
                  { numBlocks: 35, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 136944,
            versionNumber: 33,
            alignmentPatternCenters: [6, 30, 58, 86, 114, 142],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 115 },
                  { numBlocks: 1, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 14, dataCodewordsPerBlock: 46 },
                  { numBlocks: 21, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 29, dataCodewordsPerBlock: 24 },
                  { numBlocks: 19, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 15 },
                  { numBlocks: 46, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 141498,
            versionNumber: 34,
            alignmentPatternCenters: [6, 34, 62, 90, 118, 146],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 13, dataCodewordsPerBlock: 115 },
                  { numBlocks: 6, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 14, dataCodewordsPerBlock: 46 },
                  { numBlocks: 23, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 44, dataCodewordsPerBlock: 24 },
                  { numBlocks: 7, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 59, dataCodewordsPerBlock: 16 },
                  { numBlocks: 1, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 145311,
            versionNumber: 35,
            alignmentPatternCenters: [6, 30, 54, 78, 102, 126, 150],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 121 },
                  { numBlocks: 7, dataCodewordsPerBlock: 122 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 47 },
                  { numBlocks: 26, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 39, dataCodewordsPerBlock: 24 },
                  { numBlocks: 14, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 22, dataCodewordsPerBlock: 15 },
                  { numBlocks: 41, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 150283,
            versionNumber: 36,
            alignmentPatternCenters: [6, 24, 50, 76, 102, 128, 154],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 121 },
                  { numBlocks: 14, dataCodewordsPerBlock: 122 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 47 },
                  { numBlocks: 34, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 46, dataCodewordsPerBlock: 24 },
                  { numBlocks: 10, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 15 },
                  { numBlocks: 64, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 152622,
            versionNumber: 37,
            alignmentPatternCenters: [6, 28, 54, 80, 106, 132, 158],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 122 },
                  { numBlocks: 4, dataCodewordsPerBlock: 123 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 29, dataCodewordsPerBlock: 46 },
                  { numBlocks: 14, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 49, dataCodewordsPerBlock: 24 },
                  { numBlocks: 10, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 24, dataCodewordsPerBlock: 15 },
                  { numBlocks: 46, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 158308,
            versionNumber: 38,
            alignmentPatternCenters: [6, 32, 58, 84, 110, 136, 162],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 122 },
                  { numBlocks: 18, dataCodewordsPerBlock: 123 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 13, dataCodewordsPerBlock: 46 },
                  { numBlocks: 32, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 48, dataCodewordsPerBlock: 24 },
                  { numBlocks: 14, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 42, dataCodewordsPerBlock: 15 },
                  { numBlocks: 32, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 161089,
            versionNumber: 39,
            alignmentPatternCenters: [6, 26, 54, 82, 110, 138, 166],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 20, dataCodewordsPerBlock: 117 },
                  { numBlocks: 4, dataCodewordsPerBlock: 118 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 40, dataCodewordsPerBlock: 47 },
                  { numBlocks: 7, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 43, dataCodewordsPerBlock: 24 },
                  { numBlocks: 22, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 15 },
                  { numBlocks: 67, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 167017,
            versionNumber: 40,
            alignmentPatternCenters: [6, 30, 58, 86, 114, 142, 170],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 118 },
                  { numBlocks: 6, dataCodewordsPerBlock: 119 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 18, dataCodewordsPerBlock: 47 },
                  { numBlocks: 31, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 34, dataCodewordsPerBlock: 24 },
                  { numBlocks: 34, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 20, dataCodewordsPerBlock: 15 },
                  { numBlocks: 61, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          }
        ];
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var BitMatrix_1 = __webpack_require__(0);
        function squareToQuadrilateral(p1, p2, p3, p4) {
          var dx3 = p1.x - p2.x + p3.x - p4.x;
          var dy3 = p1.y - p2.y + p3.y - p4.y;
          if (dx3 === 0 && dy3 === 0) {
            return {
              a11: p2.x - p1.x,
              a12: p2.y - p1.y,
              a13: 0,
              a21: p3.x - p2.x,
              a22: p3.y - p2.y,
              a23: 0,
              a31: p1.x,
              a32: p1.y,
              a33: 1
            };
          } else {
            var dx1 = p2.x - p3.x;
            var dx2 = p4.x - p3.x;
            var dy1 = p2.y - p3.y;
            var dy2 = p4.y - p3.y;
            var denominator = dx1 * dy2 - dx2 * dy1;
            var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
            var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
            return {
              a11: p2.x - p1.x + a13 * p2.x,
              a12: p2.y - p1.y + a13 * p2.y,
              a13,
              a21: p4.x - p1.x + a23 * p4.x,
              a22: p4.y - p1.y + a23 * p4.y,
              a23,
              a31: p1.x,
              a32: p1.y,
              a33: 1
            };
          }
        }
        function quadrilateralToSquare(p1, p2, p3, p4) {
          var sToQ = squareToQuadrilateral(p1, p2, p3, p4);
          return {
            a11: sToQ.a22 * sToQ.a33 - sToQ.a23 * sToQ.a32,
            a12: sToQ.a13 * sToQ.a32 - sToQ.a12 * sToQ.a33,
            a13: sToQ.a12 * sToQ.a23 - sToQ.a13 * sToQ.a22,
            a21: sToQ.a23 * sToQ.a31 - sToQ.a21 * sToQ.a33,
            a22: sToQ.a11 * sToQ.a33 - sToQ.a13 * sToQ.a31,
            a23: sToQ.a13 * sToQ.a21 - sToQ.a11 * sToQ.a23,
            a31: sToQ.a21 * sToQ.a32 - sToQ.a22 * sToQ.a31,
            a32: sToQ.a12 * sToQ.a31 - sToQ.a11 * sToQ.a32,
            a33: sToQ.a11 * sToQ.a22 - sToQ.a12 * sToQ.a21
          };
        }
        function times2(a2, b2) {
          return {
            a11: a2.a11 * b2.a11 + a2.a21 * b2.a12 + a2.a31 * b2.a13,
            a12: a2.a12 * b2.a11 + a2.a22 * b2.a12 + a2.a32 * b2.a13,
            a13: a2.a13 * b2.a11 + a2.a23 * b2.a12 + a2.a33 * b2.a13,
            a21: a2.a11 * b2.a21 + a2.a21 * b2.a22 + a2.a31 * b2.a23,
            a22: a2.a12 * b2.a21 + a2.a22 * b2.a22 + a2.a32 * b2.a23,
            a23: a2.a13 * b2.a21 + a2.a23 * b2.a22 + a2.a33 * b2.a23,
            a31: a2.a11 * b2.a31 + a2.a21 * b2.a32 + a2.a31 * b2.a33,
            a32: a2.a12 * b2.a31 + a2.a22 * b2.a32 + a2.a32 * b2.a33,
            a33: a2.a13 * b2.a31 + a2.a23 * b2.a32 + a2.a33 * b2.a33
          };
        }
        function extract(image3, location2) {
          var qToS = quadrilateralToSquare({ x: 3.5, y: 3.5 }, { x: location2.dimension - 3.5, y: 3.5 }, { x: location2.dimension - 6.5, y: location2.dimension - 6.5 }, { x: 3.5, y: location2.dimension - 3.5 });
          var sToQ = squareToQuadrilateral(location2.topLeft, location2.topRight, location2.alignmentPattern, location2.bottomLeft);
          var transform2 = times2(sToQ, qToS);
          var matrix = BitMatrix_1.BitMatrix.createEmpty(location2.dimension, location2.dimension);
          var mappingFunction = function(x3, y3) {
            var denominator = transform2.a13 * x3 + transform2.a23 * y3 + transform2.a33;
            return {
              x: (transform2.a11 * x3 + transform2.a21 * y3 + transform2.a31) / denominator,
              y: (transform2.a12 * x3 + transform2.a22 * y3 + transform2.a32) / denominator
            };
          };
          for (var y2 = 0; y2 < location2.dimension; y2++) {
            for (var x2 = 0; x2 < location2.dimension; x2++) {
              var xValue = x2 + 0.5;
              var yValue = y2 + 0.5;
              var sourcePixel = mappingFunction(xValue, yValue);
              matrix.set(x2, y2, image3.get(Math.floor(sourcePixel.x), Math.floor(sourcePixel.y)));
            }
          }
          return {
            matrix,
            mappingFunction
          };
        }
        exports3.extract = extract;
      },
      function(module3, exports3, __webpack_require__) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var MAX_FINDERPATTERNS_TO_SEARCH = 4;
        var MIN_QUAD_RATIO = 0.5;
        var MAX_QUAD_RATIO = 1.5;
        var distance = function(a2, b2) {
          return Math.sqrt(Math.pow(b2.x - a2.x, 2) + Math.pow(b2.y - a2.y, 2));
        };
        function sum2(values) {
          return values.reduce(function(a2, b2) {
            return a2 + b2;
          });
        }
        function reorderFinderPatterns(pattern1, pattern2, pattern3) {
          var _a2, _b, _c, _d;
          var oneTwoDistance = distance(pattern1, pattern2);
          var twoThreeDistance = distance(pattern2, pattern3);
          var oneThreeDistance = distance(pattern1, pattern3);
          var bottomLeft;
          var topLeft;
          var topRight;
          if (twoThreeDistance >= oneTwoDistance && twoThreeDistance >= oneThreeDistance) {
            _a2 = [pattern2, pattern1, pattern3], bottomLeft = _a2[0], topLeft = _a2[1], topRight = _a2[2];
          } else if (oneThreeDistance >= twoThreeDistance && oneThreeDistance >= oneTwoDistance) {
            _b = [pattern1, pattern2, pattern3], bottomLeft = _b[0], topLeft = _b[1], topRight = _b[2];
          } else {
            _c = [pattern1, pattern3, pattern2], bottomLeft = _c[0], topLeft = _c[1], topRight = _c[2];
          }
          if ((topRight.x - topLeft.x) * (bottomLeft.y - topLeft.y) - (topRight.y - topLeft.y) * (bottomLeft.x - topLeft.x) < 0) {
            _d = [topRight, bottomLeft], bottomLeft = _d[0], topRight = _d[1];
          }
          return { bottomLeft, topLeft, topRight };
        }
        function computeDimension(topLeft, topRight, bottomLeft, matrix) {
          var moduleSize = (sum2(countBlackWhiteRun(topLeft, bottomLeft, matrix, 5)) / 7 + sum2(countBlackWhiteRun(topLeft, topRight, matrix, 5)) / 7 + sum2(countBlackWhiteRun(bottomLeft, topLeft, matrix, 5)) / 7 + sum2(countBlackWhiteRun(topRight, topLeft, matrix, 5)) / 7) / 4;
          if (moduleSize < 1) {
            throw new Error("Invalid module size");
          }
          var topDimension = Math.round(distance(topLeft, topRight) / moduleSize);
          var sideDimension = Math.round(distance(topLeft, bottomLeft) / moduleSize);
          var dimension = Math.floor((topDimension + sideDimension) / 2) + 7;
          switch (dimension % 4) {
            case 0:
              dimension++;
              break;
            case 2:
              dimension--;
              break;
          }
          return { dimension, moduleSize };
        }
        function countBlackWhiteRunTowardsPoint(origin, end, matrix, length) {
          var switchPoints = [{ x: Math.floor(origin.x), y: Math.floor(origin.y) }];
          var steep = Math.abs(end.y - origin.y) > Math.abs(end.x - origin.x);
          var fromX;
          var fromY;
          var toX;
          var toY;
          if (steep) {
            fromX = Math.floor(origin.y);
            fromY = Math.floor(origin.x);
            toX = Math.floor(end.y);
            toY = Math.floor(end.x);
          } else {
            fromX = Math.floor(origin.x);
            fromY = Math.floor(origin.y);
            toX = Math.floor(end.x);
            toY = Math.floor(end.y);
          }
          var dx = Math.abs(toX - fromX);
          var dy = Math.abs(toY - fromY);
          var error2 = Math.floor(-dx / 2);
          var xStep = fromX < toX ? 1 : -1;
          var yStep = fromY < toY ? 1 : -1;
          var currentPixel = true;
          for (var x2 = fromX, y2 = fromY; x2 !== toX + xStep; x2 += xStep) {
            var realX = steep ? y2 : x2;
            var realY = steep ? x2 : y2;
            if (matrix.get(realX, realY) !== currentPixel) {
              currentPixel = !currentPixel;
              switchPoints.push({ x: realX, y: realY });
              if (switchPoints.length === length + 1) {
                break;
              }
            }
            error2 += dy;
            if (error2 > 0) {
              if (y2 === toY) {
                break;
              }
              y2 += yStep;
              error2 -= dx;
            }
          }
          var distances = [];
          for (var i2 = 0; i2 < length; i2++) {
            if (switchPoints[i2] && switchPoints[i2 + 1]) {
              distances.push(distance(switchPoints[i2], switchPoints[i2 + 1]));
            } else {
              distances.push(0);
            }
          }
          return distances;
        }
        function countBlackWhiteRun(origin, end, matrix, length) {
          var _a2;
          var rise = end.y - origin.y;
          var run = end.x - origin.x;
          var towardsEnd = countBlackWhiteRunTowardsPoint(origin, end, matrix, Math.ceil(length / 2));
          var awayFromEnd = countBlackWhiteRunTowardsPoint(origin, { x: origin.x - run, y: origin.y - rise }, matrix, Math.ceil(length / 2));
          var middleValue = towardsEnd.shift() + awayFromEnd.shift() - 1;
          return (_a2 = awayFromEnd.concat(middleValue)).concat.apply(_a2, towardsEnd);
        }
        function scoreBlackWhiteRun(sequence, ratios) {
          var averageSize = sum2(sequence) / sum2(ratios);
          var error2 = 0;
          ratios.forEach(function(ratio2, i2) {
            error2 += Math.pow(sequence[i2] - ratio2 * averageSize, 2);
          });
          return { averageSize, error: error2 };
        }
        function scorePattern(point, ratios, matrix) {
          try {
            var horizontalRun = countBlackWhiteRun(point, { x: -1, y: point.y }, matrix, ratios.length);
            var verticalRun = countBlackWhiteRun(point, { x: point.x, y: -1 }, matrix, ratios.length);
            var topLeftPoint = {
              x: Math.max(0, point.x - point.y) - 1,
              y: Math.max(0, point.y - point.x) - 1
            };
            var topLeftBottomRightRun = countBlackWhiteRun(point, topLeftPoint, matrix, ratios.length);
            var bottomLeftPoint = {
              x: Math.min(matrix.width, point.x + point.y) + 1,
              y: Math.min(matrix.height, point.y + point.x) + 1
            };
            var bottomLeftTopRightRun = countBlackWhiteRun(point, bottomLeftPoint, matrix, ratios.length);
            var horzError = scoreBlackWhiteRun(horizontalRun, ratios);
            var vertError = scoreBlackWhiteRun(verticalRun, ratios);
            var diagDownError = scoreBlackWhiteRun(topLeftBottomRightRun, ratios);
            var diagUpError = scoreBlackWhiteRun(bottomLeftTopRightRun, ratios);
            var ratioError = Math.sqrt(horzError.error * horzError.error + vertError.error * vertError.error + diagDownError.error * diagDownError.error + diagUpError.error * diagUpError.error);
            var avgSize = (horzError.averageSize + vertError.averageSize + diagDownError.averageSize + diagUpError.averageSize) / 4;
            var sizeError = (Math.pow(horzError.averageSize - avgSize, 2) + Math.pow(vertError.averageSize - avgSize, 2) + Math.pow(diagDownError.averageSize - avgSize, 2) + Math.pow(diagUpError.averageSize - avgSize, 2)) / avgSize;
            return ratioError + sizeError;
          } catch (_a2) {
            return Infinity;
          }
        }
        function recenterLocation(matrix, p2) {
          var leftX = Math.round(p2.x);
          while (matrix.get(leftX, Math.round(p2.y))) {
            leftX--;
          }
          var rightX = Math.round(p2.x);
          while (matrix.get(rightX, Math.round(p2.y))) {
            rightX++;
          }
          var x2 = (leftX + rightX) / 2;
          var topY = Math.round(p2.y);
          while (matrix.get(Math.round(x2), topY)) {
            topY--;
          }
          var bottomY = Math.round(p2.y);
          while (matrix.get(Math.round(x2), bottomY)) {
            bottomY++;
          }
          var y2 = (topY + bottomY) / 2;
          return { x: x2, y: y2 };
        }
        function locate(matrix) {
          var finderPatternQuads = [];
          var activeFinderPatternQuads = [];
          var alignmentPatternQuads = [];
          var activeAlignmentPatternQuads = [];
          var _loop_1 = function(y3) {
            var length_1 = 0;
            var lastBit = false;
            var scans = [0, 0, 0, 0, 0];
            var _loop_2 = function(x3) {
              var v2 = matrix.get(x3, y3);
              if (v2 === lastBit) {
                length_1++;
              } else {
                scans = [scans[1], scans[2], scans[3], scans[4], length_1];
                length_1 = 1;
                lastBit = v2;
                var averageFinderPatternBlocksize = sum2(scans) / 7;
                var validFinderPattern = Math.abs(scans[0] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[1] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[2] - 3 * averageFinderPatternBlocksize) < 3 * averageFinderPatternBlocksize && Math.abs(scans[3] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[4] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && !v2;
                var averageAlignmentPatternBlocksize = sum2(scans.slice(-3)) / 3;
                var validAlignmentPattern = Math.abs(scans[2] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[3] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[4] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && v2;
                if (validFinderPattern) {
                  var endX_1 = x3 - scans[3] - scans[4];
                  var startX_1 = endX_1 - scans[2];
                  var line2 = { startX: startX_1, endX: endX_1, y: y3 };
                  var matchingQuads = activeFinderPatternQuads.filter(function(q2) {
                    return startX_1 >= q2.bottom.startX && startX_1 <= q2.bottom.endX || endX_1 >= q2.bottom.startX && startX_1 <= q2.bottom.endX || startX_1 <= q2.bottom.startX && endX_1 >= q2.bottom.endX && (scans[2] / (q2.bottom.endX - q2.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q2.bottom.endX - q2.bottom.startX) > MIN_QUAD_RATIO);
                  });
                  if (matchingQuads.length > 0) {
                    matchingQuads[0].bottom = line2;
                  } else {
                    activeFinderPatternQuads.push({ top: line2, bottom: line2 });
                  }
                }
                if (validAlignmentPattern) {
                  var endX_2 = x3 - scans[4];
                  var startX_2 = endX_2 - scans[3];
                  var line2 = { startX: startX_2, y: y3, endX: endX_2 };
                  var matchingQuads = activeAlignmentPatternQuads.filter(function(q2) {
                    return startX_2 >= q2.bottom.startX && startX_2 <= q2.bottom.endX || endX_2 >= q2.bottom.startX && startX_2 <= q2.bottom.endX || startX_2 <= q2.bottom.startX && endX_2 >= q2.bottom.endX && (scans[2] / (q2.bottom.endX - q2.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q2.bottom.endX - q2.bottom.startX) > MIN_QUAD_RATIO);
                  });
                  if (matchingQuads.length > 0) {
                    matchingQuads[0].bottom = line2;
                  } else {
                    activeAlignmentPatternQuads.push({ top: line2, bottom: line2 });
                  }
                }
              }
            };
            for (var x2 = -1; x2 <= matrix.width; x2++) {
              _loop_2(x2);
            }
            finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q2) {
              return q2.bottom.y !== y3 && q2.bottom.y - q2.top.y >= 2;
            }));
            activeFinderPatternQuads = activeFinderPatternQuads.filter(function(q2) {
              return q2.bottom.y === y3;
            });
            alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads.filter(function(q2) {
              return q2.bottom.y !== y3;
            }));
            activeAlignmentPatternQuads = activeAlignmentPatternQuads.filter(function(q2) {
              return q2.bottom.y === y3;
            });
          };
          for (var y2 = 0; y2 <= matrix.height; y2++) {
            _loop_1(y2);
          }
          finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q2) {
            return q2.bottom.y - q2.top.y >= 2;
          }));
          alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads);
          var finderPatternGroups = finderPatternQuads.filter(function(q2) {
            return q2.bottom.y - q2.top.y >= 2;
          }).map(function(q2) {
            var x2 = (q2.top.startX + q2.top.endX + q2.bottom.startX + q2.bottom.endX) / 4;
            var y3 = (q2.top.y + q2.bottom.y + 1) / 2;
            if (!matrix.get(Math.round(x2), Math.round(y3))) {
              return;
            }
            var lengths2 = [q2.top.endX - q2.top.startX, q2.bottom.endX - q2.bottom.startX, q2.bottom.y - q2.top.y + 1];
            var size2 = sum2(lengths2) / lengths2.length;
            var score = scorePattern({ x: Math.round(x2), y: Math.round(y3) }, [1, 1, 3, 1, 1], matrix);
            return { score, x: x2, y: y3, size: size2 };
          }).filter(function(q2) {
            return !!q2;
          }).sort(function(a2, b2) {
            return a2.score - b2.score;
          }).map(function(point, i2, finderPatterns) {
            if (i2 > MAX_FINDERPATTERNS_TO_SEARCH) {
              return null;
            }
            var otherPoints = finderPatterns.filter(function(p2, ii2) {
              return i2 !== ii2;
            }).map(function(p2) {
              return { x: p2.x, y: p2.y, score: p2.score + Math.pow(p2.size - point.size, 2) / point.size, size: p2.size };
            }).sort(function(a2, b2) {
              return a2.score - b2.score;
            });
            if (otherPoints.length < 2) {
              return null;
            }
            var score = point.score + otherPoints[0].score + otherPoints[1].score;
            return { points: [point].concat(otherPoints.slice(0, 2)), score };
          }).filter(function(q2) {
            return !!q2;
          }).sort(function(a2, b2) {
            return a2.score - b2.score;
          });
          if (finderPatternGroups.length === 0) {
            return null;
          }
          var _a2 = reorderFinderPatterns(finderPatternGroups[0].points[0], finderPatternGroups[0].points[1], finderPatternGroups[0].points[2]), topRight = _a2.topRight, topLeft = _a2.topLeft, bottomLeft = _a2.bottomLeft;
          var alignment = findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft);
          var result = [];
          if (alignment) {
            result.push({
              alignmentPattern: { x: alignment.alignmentPattern.x, y: alignment.alignmentPattern.y },
              bottomLeft: { x: bottomLeft.x, y: bottomLeft.y },
              dimension: alignment.dimension,
              topLeft: { x: topLeft.x, y: topLeft.y },
              topRight: { x: topRight.x, y: topRight.y }
            });
          }
          var midTopRight = recenterLocation(matrix, topRight);
          var midTopLeft = recenterLocation(matrix, topLeft);
          var midBottomLeft = recenterLocation(matrix, bottomLeft);
          var centeredAlignment = findAlignmentPattern(matrix, alignmentPatternQuads, midTopRight, midTopLeft, midBottomLeft);
          if (centeredAlignment) {
            result.push({
              alignmentPattern: { x: centeredAlignment.alignmentPattern.x, y: centeredAlignment.alignmentPattern.y },
              bottomLeft: { x: midBottomLeft.x, y: midBottomLeft.y },
              topLeft: { x: midTopLeft.x, y: midTopLeft.y },
              topRight: { x: midTopRight.x, y: midTopRight.y },
              dimension: centeredAlignment.dimension
            });
          }
          if (result.length === 0) {
            return null;
          }
          return result;
        }
        exports3.locate = locate;
        function findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft) {
          var _a2;
          var dimension;
          var moduleSize;
          try {
            _a2 = computeDimension(topLeft, topRight, bottomLeft, matrix), dimension = _a2.dimension, moduleSize = _a2.moduleSize;
          } catch (e2) {
            return null;
          }
          var bottomRightFinderPattern = {
            x: topRight.x - topLeft.x + bottomLeft.x,
            y: topRight.y - topLeft.y + bottomLeft.y
          };
          var modulesBetweenFinderPatterns = (distance(topLeft, bottomLeft) + distance(topLeft, topRight)) / 2 / moduleSize;
          var correctionToTopLeft = 1 - 3 / modulesBetweenFinderPatterns;
          var expectedAlignmentPattern = {
            x: topLeft.x + correctionToTopLeft * (bottomRightFinderPattern.x - topLeft.x),
            y: topLeft.y + correctionToTopLeft * (bottomRightFinderPattern.y - topLeft.y)
          };
          var alignmentPatterns = alignmentPatternQuads.map(function(q2) {
            var x2 = (q2.top.startX + q2.top.endX + q2.bottom.startX + q2.bottom.endX) / 4;
            var y2 = (q2.top.y + q2.bottom.y + 1) / 2;
            if (!matrix.get(Math.floor(x2), Math.floor(y2))) {
              return;
            }
            var lengths2 = [q2.top.endX - q2.top.startX, q2.bottom.endX - q2.bottom.startX, q2.bottom.y - q2.top.y + 1];
            sum2(lengths2) / lengths2.length;
            var sizeScore = scorePattern({ x: Math.floor(x2), y: Math.floor(y2) }, [1, 1, 1], matrix);
            var score = sizeScore + distance({ x: x2, y: y2 }, expectedAlignmentPattern);
            return { x: x2, y: y2, score };
          }).filter(function(v2) {
            return !!v2;
          }).sort(function(a2, b2) {
            return a2.score - b2.score;
          });
          var alignmentPattern = modulesBetweenFinderPatterns >= 15 && alignmentPatterns.length ? alignmentPatterns[0] : expectedAlignmentPattern;
          return { alignmentPattern, dimension };
        }
      }
    ])["default"];
  });
})(jsQR$1);
var jsQR = /* @__PURE__ */ getDefaultExportFromCjs(jsQR$1.exports);
var dist = {};
var t$1;
Object.defineProperty(dist, "__esModule", { value: true });
var r = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706], e = function(t2) {
  if (!t2)
    throw new Error('"version" cannot be null or undefined');
  if (t2 < 1 || t2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return 4 * t2 + 17;
}, n = function(t2) {
  return r[t2];
}, o = function(t2) {
  for (var r2 = 0; 0 !== t2; )
    r2++, t2 >>>= 1;
  return r2;
}, i = function(r2) {
  if ("function" != typeof r2)
    throw new Error('"toSJISFunc" is not a valid function.');
  t$1 = r2;
}, a$1 = function() {
  return void 0 !== t$1;
}, u = function(r2) {
  return t$1(r2);
};
function s(t2, r2) {
  return t2(r2 = { exports: {} }, r2.exports), r2.exports;
}
var f = s(function(t2, r2) {
  r2.L = { bit: 1 }, r2.M = { bit: 0 }, r2.Q = { bit: 3 }, r2.H = { bit: 2 }, r2.isValid = function(t3) {
    return t3 && void 0 !== t3.bit && t3.bit >= 0 && t3.bit < 4;
  }, r2.from = function(t3, e2) {
    if (r2.isValid(t3))
      return t3;
    try {
      return function(t4) {
        if ("string" != typeof t4)
          throw new Error("Param is not a string");
        switch (t4.toLowerCase()) {
          case "l":
          case "low":
            return r2.L;
          case "m":
          case "medium":
            return r2.M;
          case "q":
          case "quartile":
            return r2.Q;
          case "h":
          case "high":
            return r2.H;
          default:
            throw new Error("Unknown EC Level: " + t4);
        }
      }(t3);
    } catch (t4) {
      return e2;
    }
  };
});
f.L, f.M, f.Q, f.H, f.isValid;
function h() {
  this.buffer = [], this.length = 0;
}
h.prototype = { get: function(t2) {
  var r2 = Math.floor(t2 / 8);
  return 1 == (this.buffer[r2] >>> 7 - t2 % 8 & 1);
}, put: function(t2, r2) {
  for (var e2 = 0; e2 < r2; e2++)
    this.putBit(1 == (t2 >>> r2 - e2 - 1 & 1));
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(t2) {
  var r2 = Math.floor(this.length / 8);
  this.buffer.length <= r2 && this.buffer.push(0), t2 && (this.buffer[r2] |= 128 >>> this.length % 8), this.length++;
} };
var c$1 = h;
function g(t2) {
  if (!t2 || t2 < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = t2, this.data = new Uint8Array(t2 * t2), this.reservedBit = new Uint8Array(t2 * t2);
}
g.prototype.set = function(t2, r2, e2, n2) {
  var o2 = t2 * this.size + r2;
  this.data[o2] = e2, n2 && (this.reservedBit[o2] = true);
}, g.prototype.get = function(t2, r2) {
  return this.data[t2 * this.size + r2];
}, g.prototype.xor = function(t2, r2, e2) {
  this.data[t2 * this.size + r2] ^= e2;
}, g.prototype.isReserved = function(t2, r2) {
  return this.reservedBit[t2 * this.size + r2];
};
var d = g, l = s(function(t2, r2) {
  var n2 = e;
  r2.getRowColCoords = function(t3) {
    if (1 === t3)
      return [];
    for (var r3 = Math.floor(t3 / 7) + 2, e2 = n2(t3), o2 = 145 === e2 ? 26 : 2 * Math.ceil((e2 - 13) / (2 * r3 - 2)), i2 = [e2 - 7], a2 = 1; a2 < r3 - 1; a2++)
      i2[a2] = i2[a2 - 1] - o2;
    return i2.push(6), i2.reverse();
  }, r2.getPositions = function(t3) {
    for (var e2 = [], n3 = r2.getRowColCoords(t3), o2 = n3.length, i2 = 0; i2 < o2; i2++)
      for (var a2 = 0; a2 < o2; a2++)
        0 === i2 && 0 === a2 || 0 === i2 && a2 === o2 - 1 || i2 === o2 - 1 && 0 === a2 || e2.push([n3[i2], n3[a2]]);
    return e2;
  };
}), v = (l.getRowColCoords, l.getPositions, e), p = function(t2) {
  var r2 = v(t2);
  return [[0, 0], [r2 - 7, 0], [0, r2 - 7]];
}, E = s(function(t2, r2) {
  r2.Patterns = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
  var e2 = 3, n2 = 3, o2 = 40, i2 = 10;
  function a2(t3, e3, n3) {
    switch (t3) {
      case r2.Patterns.PATTERN000:
        return (e3 + n3) % 2 == 0;
      case r2.Patterns.PATTERN001:
        return e3 % 2 == 0;
      case r2.Patterns.PATTERN010:
        return n3 % 3 == 0;
      case r2.Patterns.PATTERN011:
        return (e3 + n3) % 3 == 0;
      case r2.Patterns.PATTERN100:
        return (Math.floor(e3 / 2) + Math.floor(n3 / 3)) % 2 == 0;
      case r2.Patterns.PATTERN101:
        return e3 * n3 % 2 + e3 * n3 % 3 == 0;
      case r2.Patterns.PATTERN110:
        return (e3 * n3 % 2 + e3 * n3 % 3) % 2 == 0;
      case r2.Patterns.PATTERN111:
        return (e3 * n3 % 3 + (e3 + n3) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + t3);
    }
  }
  r2.isValid = function(t3) {
    return null != t3 && "" !== t3 && !isNaN(t3) && t3 >= 0 && t3 <= 7;
  }, r2.from = function(t3) {
    return r2.isValid(t3) ? parseInt(t3, 10) : void 0;
  }, r2.getPenaltyN1 = function(t3) {
    for (var r3 = t3.size, n3 = 0, o3 = 0, i3 = 0, a3 = null, u2 = null, s2 = 0; s2 < r3; s2++) {
      o3 = i3 = 0, a3 = u2 = null;
      for (var f2 = 0; f2 < r3; f2++) {
        var h2 = t3.get(s2, f2);
        h2 === a3 ? o3++ : (o3 >= 5 && (n3 += e2 + (o3 - 5)), a3 = h2, o3 = 1), (h2 = t3.get(f2, s2)) === u2 ? i3++ : (i3 >= 5 && (n3 += e2 + (i3 - 5)), u2 = h2, i3 = 1);
      }
      o3 >= 5 && (n3 += e2 + (o3 - 5)), i3 >= 5 && (n3 += e2 + (i3 - 5));
    }
    return n3;
  }, r2.getPenaltyN2 = function(t3) {
    for (var r3 = t3.size, e3 = 0, o3 = 0; o3 < r3 - 1; o3++)
      for (var i3 = 0; i3 < r3 - 1; i3++) {
        var a3 = t3.get(o3, i3) + t3.get(o3, i3 + 1) + t3.get(o3 + 1, i3) + t3.get(o3 + 1, i3 + 1);
        4 !== a3 && 0 !== a3 || e3++;
      }
    return e3 * n2;
  }, r2.getPenaltyN3 = function(t3) {
    for (var r3 = t3.size, e3 = 0, n3 = 0, i3 = 0, a3 = 0; a3 < r3; a3++) {
      n3 = i3 = 0;
      for (var u2 = 0; u2 < r3; u2++)
        n3 = n3 << 1 & 2047 | t3.get(a3, u2), u2 >= 10 && (1488 === n3 || 93 === n3) && e3++, i3 = i3 << 1 & 2047 | t3.get(u2, a3), u2 >= 10 && (1488 === i3 || 93 === i3) && e3++;
    }
    return e3 * o2;
  }, r2.getPenaltyN4 = function(t3) {
    for (var r3 = 0, e3 = t3.data.length, n3 = 0; n3 < e3; n3++)
      r3 += t3.data[n3];
    return Math.abs(Math.ceil(100 * r3 / e3 / 5) - 10) * i2;
  }, r2.applyMask = function(t3, r3) {
    for (var e3 = r3.size, n3 = 0; n3 < e3; n3++)
      for (var o3 = 0; o3 < e3; o3++)
        r3.isReserved(o3, n3) || r3.xor(o3, n3, a2(t3, o3, n3));
  }, r2.getBestMask = function(t3, e3) {
    for (var n3 = Object.keys(r2.Patterns).length, o3 = 0, i3 = 1 / 0, a3 = 0; a3 < n3; a3++) {
      e3(a3), r2.applyMask(a3, t3);
      var u2 = r2.getPenaltyN1(t3) + r2.getPenaltyN2(t3) + r2.getPenaltyN3(t3) + r2.getPenaltyN4(t3);
      r2.applyMask(a3, t3), u2 < i3 && (i3 = u2, o3 = a3);
    }
    return o3;
  };
}), w = (E.Patterns, E.isValid, E.getPenaltyN1, E.getPenaltyN2, E.getPenaltyN3, E.getPenaltyN4, E.applyMask, E.getBestMask, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]), A = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430], m$1 = function(t2, r2) {
  switch (r2) {
    case f.L:
      return w[4 * (t2 - 1) + 0];
    case f.M:
      return w[4 * (t2 - 1) + 1];
    case f.Q:
      return w[4 * (t2 - 1) + 2];
    case f.H:
      return w[4 * (t2 - 1) + 3];
    default:
      return;
  }
}, y$1 = function(t2, r2) {
  switch (r2) {
    case f.L:
      return A[4 * (t2 - 1) + 0];
    case f.M:
      return A[4 * (t2 - 1) + 1];
    case f.Q:
      return A[4 * (t2 - 1) + 2];
    case f.H:
      return A[4 * (t2 - 1) + 3];
    default:
      return;
  }
}, N = new Uint8Array(512), B = new Uint8Array(256);
!function() {
  for (var t2 = 1, r2 = 0; r2 < 255; r2++)
    N[r2] = t2, B[t2] = r2, 256 & (t2 <<= 1) && (t2 ^= 285);
  for (r2 = 255; r2 < 512; r2++)
    N[r2] = N[r2 - 255];
}();
var P = function(t2) {
  return N[t2];
}, M = function(t2, r2) {
  return 0 === t2 || 0 === r2 ? 0 : N[B[t2] + B[r2]];
}, I = s(function(t2, r2) {
  r2.mul = function(t3, r3) {
    for (var e2 = new Uint8Array(t3.length + r3.length - 1), n2 = 0; n2 < t3.length; n2++)
      for (var o2 = 0; o2 < r3.length; o2++)
        e2[n2 + o2] ^= M(t3[n2], r3[o2]);
    return e2;
  }, r2.mod = function(t3, r3) {
    for (var e2 = new Uint8Array(t3); e2.length - r3.length >= 0; ) {
      for (var n2 = e2[0], o2 = 0; o2 < r3.length; o2++)
        e2[o2] ^= M(r3[o2], n2);
      for (var i2 = 0; i2 < e2.length && 0 === e2[i2]; )
        i2++;
      e2 = e2.slice(i2);
    }
    return e2;
  }, r2.generateECPolynomial = function(t3) {
    for (var e2 = new Uint8Array([1]), n2 = 0; n2 < t3; n2++)
      e2 = r2.mul(e2, new Uint8Array([1, P(n2)]));
    return e2;
  };
});
I.mul, I.mod, I.generateECPolynomial;
function C(t2) {
  this.genPoly = void 0, this.degree = t2, this.degree && this.initialize(this.degree);
}
C.prototype.initialize = function(t2) {
  this.degree = t2, this.genPoly = I.generateECPolynomial(this.degree);
}, C.prototype.encode = function(t2) {
  if (!this.genPoly)
    throw new Error("Encoder not initialized");
  var r2 = new Uint8Array(t2.length + this.degree);
  r2.set(t2);
  var e2 = I.mod(r2, this.genPoly), n2 = this.degree - e2.length;
  if (n2 > 0) {
    var o2 = new Uint8Array(this.degree);
    return o2.set(e2, n2), o2;
  }
  return e2;
};
var R = C, T = function(t2) {
  return !isNaN(t2) && t2 >= 1 && t2 <= 40;
}, L = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+", b = "(?:(?![A-Z0-9 $%*+\\-./:]|" + (L = L.replace(/u/g, "\\u")) + ")(?:.|[\r\n]))+", U = new RegExp(L, "g"), x$1 = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"), F = new RegExp(b, "g"), _ = new RegExp("[0-9]+", "g"), Y = new RegExp("[A-Z $%*+\\-./:]+", "g"), k = new RegExp("^" + L + "$"), S = new RegExp("^[0-9]+$"), J = new RegExp("^[A-Z0-9 $%*+\\-./:]+$"), H = { KANJI: U, BYTE_KANJI: x$1, BYTE: F, NUMERIC: _, ALPHANUMERIC: Y, testKanji: function(t2) {
  return k.test(t2);
}, testNumeric: function(t2) {
  return S.test(t2);
}, testAlphanumeric: function(t2) {
  return J.test(t2);
} }, K = s(function(t2, r2) {
  r2.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] }, r2.ALPHANUMERIC = { id: "Alphanumeric", bit: 2, ccBits: [9, 11, 13] }, r2.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] }, r2.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] }, r2.MIXED = { bit: -1 }, r2.getCharCountIndicator = function(t3, r3) {
    if (!t3.ccBits)
      throw new Error("Invalid mode: " + t3);
    if (!T(r3))
      throw new Error("Invalid version: " + r3);
    return r3 >= 1 && r3 < 10 ? t3.ccBits[0] : r3 < 27 ? t3.ccBits[1] : t3.ccBits[2];
  }, r2.getBestModeForData = function(t3) {
    return H.testNumeric(t3) ? r2.NUMERIC : H.testAlphanumeric(t3) ? r2.ALPHANUMERIC : H.testKanji(t3) ? r2.KANJI : r2.BYTE;
  }, r2.toString = function(t3) {
    if (t3 && t3.id)
      return t3.id;
    throw new Error("Invalid mode");
  }, r2.isValid = function(t3) {
    return t3 && t3.bit && t3.ccBits;
  }, r2.from = function(t3, e2) {
    if (r2.isValid(t3))
      return t3;
    try {
      return function(t4) {
        if ("string" != typeof t4)
          throw new Error("Param is not a string");
        switch (t4.toLowerCase()) {
          case "numeric":
            return r2.NUMERIC;
          case "alphanumeric":
            return r2.ALPHANUMERIC;
          case "kanji":
            return r2.KANJI;
          case "byte":
            return r2.BYTE;
          default:
            throw new Error("Unknown mode: " + t4);
        }
      }(t3);
    } catch (t4) {
      return e2;
    }
  };
}), z$1 = (K.NUMERIC, K.ALPHANUMERIC, K.BYTE, K.KANJI, K.MIXED, K.getCharCountIndicator, K.getBestModeForData, K.isValid, {}.toString), D = Array.isArray || function(t2) {
  return "[object Array]" == z$1.call(t2);
}, V = s(function(t2, r2) {
  var e2 = o(7973);
  function i2(t3, r3) {
    return K.getCharCountIndicator(t3, r3) + 4;
  }
  function a2(t3, r3) {
    var e3 = 0;
    return t3.forEach(function(t4) {
      var n2 = i2(t4.mode, r3);
      e3 += n2 + t4.getBitsLength();
    }), e3;
  }
  r2.from = function(t3, r3) {
    return T(t3) ? parseInt(t3, 10) : r3;
  }, r2.getCapacity = function(t3, r3, e3) {
    if (!T(t3))
      throw new Error("Invalid QR Code version");
    void 0 === e3 && (e3 = K.BYTE);
    var o2 = 8 * (n(t3) - y$1(t3, r3));
    if (e3 === K.MIXED)
      return o2;
    var a3 = o2 - i2(e3, t3);
    switch (e3) {
      case K.NUMERIC:
        return Math.floor(a3 / 10 * 3);
      case K.ALPHANUMERIC:
        return Math.floor(a3 / 11 * 2);
      case K.KANJI:
        return Math.floor(a3 / 13);
      case K.BYTE:
      default:
        return Math.floor(a3 / 8);
    }
  }, r2.getBestVersionForData = function(t3, e3) {
    var n2, o2 = f.from(e3, f.M);
    if (D(t3)) {
      if (t3.length > 1)
        return function(t4, e4) {
          for (var n3 = 1; n3 <= 40; n3++) {
            if (a2(t4, n3) <= r2.getCapacity(n3, e4, K.MIXED))
              return n3;
          }
        }(t3, o2);
      if (0 === t3.length)
        return 1;
      n2 = t3[0];
    } else
      n2 = t3;
    return function(t4, e4, n3) {
      for (var o3 = 1; o3 <= 40; o3++)
        if (e4 <= r2.getCapacity(o3, n3, t4))
          return o3;
    }(n2.mode, n2.getLength(), o2);
  }, r2.getEncodedBits = function(t3) {
    if (!T(t3) || t3 < 7)
      throw new Error("Invalid QR Code version");
    for (var r3 = t3 << 12; o(r3) - e2 >= 0; )
      r3 ^= 7973 << o(r3) - e2;
    return t3 << 12 | r3;
  };
}), Q = (V.getCapacity, V.getBestVersionForData, V.getEncodedBits, o(1335)), j = function(t2, r2) {
  for (var e2 = t2.bit << 3 | r2, n2 = e2 << 10; o(n2) - Q >= 0; )
    n2 ^= 1335 << o(n2) - Q;
  return 21522 ^ (e2 << 10 | n2);
};
function q(t2) {
  this.mode = K.NUMERIC, this.data = t2.toString();
}
q.getBitsLength = function(t2) {
  return 10 * Math.floor(t2 / 3) + (t2 % 3 ? t2 % 3 * 3 + 1 : 0);
}, q.prototype.getLength = function() {
  return this.data.length;
}, q.prototype.getBitsLength = function() {
  return q.getBitsLength(this.data.length);
}, q.prototype.write = function(t2) {
  var r2, e2, n2;
  for (r2 = 0; r2 + 3 <= this.data.length; r2 += 3)
    e2 = this.data.substr(r2, 3), n2 = parseInt(e2, 10), t2.put(n2, 10);
  var o2 = this.data.length - r2;
  o2 > 0 && (e2 = this.data.substr(r2), n2 = parseInt(e2, 10), t2.put(n2, 3 * o2 + 1));
};
var O = q, $ = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function X(t2) {
  this.mode = K.ALPHANUMERIC, this.data = t2;
}
X.getBitsLength = function(t2) {
  return 11 * Math.floor(t2 / 2) + t2 % 2 * 6;
}, X.prototype.getLength = function() {
  return this.data.length;
}, X.prototype.getBitsLength = function() {
  return X.getBitsLength(this.data.length);
}, X.prototype.write = function(t2) {
  var r2;
  for (r2 = 0; r2 + 2 <= this.data.length; r2 += 2) {
    var e2 = 45 * $.indexOf(this.data[r2]);
    e2 += $.indexOf(this.data[r2 + 1]), t2.put(e2, 11);
  }
  this.data.length % 2 && t2.put($.indexOf(this.data[r2]), 6);
};
var Z = X;
function G(t2) {
  this.mode = K.BYTE, this.data = new Uint8Array(function(t3) {
    for (var r2 = [], e2 = t3.length, n2 = 0; n2 < e2; n2++) {
      var o2 = t3.charCodeAt(n2);
      if (o2 >= 55296 && o2 <= 56319 && e2 > n2 + 1) {
        var i2 = t3.charCodeAt(n2 + 1);
        i2 >= 56320 && i2 <= 57343 && (o2 = 1024 * (o2 - 55296) + i2 - 56320 + 65536, n2 += 1);
      }
      o2 < 128 ? r2.push(o2) : o2 < 2048 ? (r2.push(o2 >> 6 | 192), r2.push(63 & o2 | 128)) : o2 < 55296 || o2 >= 57344 && o2 < 65536 ? (r2.push(o2 >> 12 | 224), r2.push(o2 >> 6 & 63 | 128), r2.push(63 & o2 | 128)) : o2 >= 65536 && o2 <= 1114111 ? (r2.push(o2 >> 18 | 240), r2.push(o2 >> 12 & 63 | 128), r2.push(o2 >> 6 & 63 | 128), r2.push(63 & o2 | 128)) : r2.push(239, 191, 189);
    }
    return new Uint8Array(r2).buffer;
  }(t2));
}
G.getBitsLength = function(t2) {
  return 8 * t2;
}, G.prototype.getLength = function() {
  return this.data.length;
}, G.prototype.getBitsLength = function() {
  return G.getBitsLength(this.data.length);
}, G.prototype.write = function(t2) {
  for (var r2 = 0, e2 = this.data.length; r2 < e2; r2++)
    t2.put(this.data[r2], 8);
};
var W = G;
function tt(t2) {
  this.mode = K.KANJI, this.data = t2;
}
tt.getBitsLength = function(t2) {
  return 13 * t2;
}, tt.prototype.getLength = function() {
  return this.data.length;
}, tt.prototype.getBitsLength = function() {
  return tt.getBitsLength(this.data.length);
}, tt.prototype.write = function(t2) {
  var r2;
  for (r2 = 0; r2 < this.data.length; r2++) {
    var e2 = u(this.data[r2]);
    if (e2 >= 33088 && e2 <= 40956)
      e2 -= 33088;
    else {
      if (!(e2 >= 57408 && e2 <= 60351))
        throw new Error("Invalid SJIS character: " + this.data[r2] + "\nMake sure your charset is UTF-8");
      e2 -= 49472;
    }
    e2 = 192 * (e2 >>> 8 & 255) + (255 & e2), t2.put(e2, 13);
  }
};
var rt = tt, et = s(function(t2) {
  var r2 = { single_source_shortest_paths: function(t3, e2, n2) {
    var o2 = {}, i2 = {};
    i2[e2] = 0;
    var a2, u2, s2, f2, h2, c2, g2, d2 = r2.PriorityQueue.make();
    for (d2.push(e2, 0); !d2.empty(); )
      for (s2 in u2 = (a2 = d2.pop()).value, f2 = a2.cost, h2 = t3[u2] || {})
        h2.hasOwnProperty(s2) && (c2 = f2 + h2[s2], g2 = i2[s2], (void 0 === i2[s2] || g2 > c2) && (i2[s2] = c2, d2.push(s2, c2), o2[s2] = u2));
    if (void 0 !== n2 && void 0 === i2[n2]) {
      var l2 = ["Could not find a path from ", e2, " to ", n2, "."].join("");
      throw new Error(l2);
    }
    return o2;
  }, extract_shortest_path_from_predecessor_list: function(t3, r3) {
    for (var e2 = [], n2 = r3; n2; )
      e2.push(n2), t3[n2], n2 = t3[n2];
    return e2.reverse(), e2;
  }, find_path: function(t3, e2, n2) {
    var o2 = r2.single_source_shortest_paths(t3, e2, n2);
    return r2.extract_shortest_path_from_predecessor_list(o2, n2);
  }, PriorityQueue: { make: function(t3) {
    var e2, n2 = r2.PriorityQueue, o2 = {};
    for (e2 in t3 = t3 || {}, n2)
      n2.hasOwnProperty(e2) && (o2[e2] = n2[e2]);
    return o2.queue = [], o2.sorter = t3.sorter || n2.default_sorter, o2;
  }, default_sorter: function(t3, r3) {
    return t3.cost - r3.cost;
  }, push: function(t3, r3) {
    var e2 = { value: t3, cost: r3 };
    this.queue.push(e2), this.queue.sort(this.sorter);
  }, pop: function() {
    return this.queue.shift();
  }, empty: function() {
    return 0 === this.queue.length;
  } } };
  t2.exports = r2;
}), nt = s(function(t2, r2) {
  function e2(t3) {
    return unescape(encodeURIComponent(t3)).length;
  }
  function n2(t3, r3, e3) {
    for (var n3, o3 = []; null !== (n3 = t3.exec(e3)); )
      o3.push({ data: n3[0], index: n3.index, mode: r3, length: n3[0].length });
    return o3;
  }
  function o2(t3) {
    var r3, e3, o3 = n2(H.NUMERIC, K.NUMERIC, t3), i3 = n2(H.ALPHANUMERIC, K.ALPHANUMERIC, t3);
    return a$1() ? (r3 = n2(H.BYTE, K.BYTE, t3), e3 = n2(H.KANJI, K.KANJI, t3)) : (r3 = n2(H.BYTE_KANJI, K.BYTE, t3), e3 = []), o3.concat(i3, r3, e3).sort(function(t4, r4) {
      return t4.index - r4.index;
    }).map(function(t4) {
      return { data: t4.data, mode: t4.mode, length: t4.length };
    });
  }
  function i2(t3, r3) {
    switch (r3) {
      case K.NUMERIC:
        return O.getBitsLength(t3);
      case K.ALPHANUMERIC:
        return Z.getBitsLength(t3);
      case K.KANJI:
        return rt.getBitsLength(t3);
      case K.BYTE:
        return W.getBitsLength(t3);
    }
  }
  function u2(t3, r3) {
    var e3, n3 = K.getBestModeForData(t3);
    if ((e3 = K.from(r3, n3)) !== K.BYTE && e3.bit < n3.bit)
      throw new Error('"' + t3 + '" cannot be encoded with mode ' + K.toString(e3) + ".\n Suggested mode is: " + K.toString(n3));
    switch (e3 !== K.KANJI || a$1() || (e3 = K.BYTE), e3) {
      case K.NUMERIC:
        return new O(t3);
      case K.ALPHANUMERIC:
        return new Z(t3);
      case K.KANJI:
        return new rt(t3);
      case K.BYTE:
        return new W(t3);
    }
  }
  r2.fromArray = function(t3) {
    return t3.reduce(function(t4, r3) {
      return "string" == typeof r3 ? t4.push(u2(r3, null)) : r3.data && t4.push(u2(r3.data, r3.mode)), t4;
    }, []);
  }, r2.fromString = function(t3, n3) {
    for (var u3 = function(t4, r3) {
      for (var e3 = {}, n4 = { start: {} }, o3 = ["start"], a2 = 0; a2 < t4.length; a2++) {
        for (var u4 = t4[a2], s3 = [], f3 = 0; f3 < u4.length; f3++) {
          var h3 = u4[f3], c2 = "" + a2 + f3;
          s3.push(c2), e3[c2] = { node: h3, lastCount: 0 }, n4[c2] = {};
          for (var g2 = 0; g2 < o3.length; g2++) {
            var d2 = o3[g2];
            e3[d2] && e3[d2].node.mode === h3.mode ? (n4[d2][c2] = i2(e3[d2].lastCount + h3.length, h3.mode) - i2(e3[d2].lastCount, h3.mode), e3[d2].lastCount += h3.length) : (e3[d2] && (e3[d2].lastCount = h3.length), n4[d2][c2] = i2(h3.length, h3.mode) + 4 + K.getCharCountIndicator(h3.mode, r3));
          }
        }
        o3 = s3;
      }
      for (g2 = 0; g2 < o3.length; g2++)
        n4[o3[g2]].end = 0;
      return { map: n4, table: e3 };
    }(function(t4) {
      for (var r3 = [], n4 = 0; n4 < t4.length; n4++) {
        var o3 = t4[n4];
        switch (o3.mode) {
          case K.NUMERIC:
            r3.push([o3, { data: o3.data, mode: K.ALPHANUMERIC, length: o3.length }, { data: o3.data, mode: K.BYTE, length: o3.length }]);
            break;
          case K.ALPHANUMERIC:
            r3.push([o3, { data: o3.data, mode: K.BYTE, length: o3.length }]);
            break;
          case K.KANJI:
            r3.push([o3, { data: o3.data, mode: K.BYTE, length: e2(o3.data) }]);
            break;
          case K.BYTE:
            r3.push([{ data: o3.data, mode: K.BYTE, length: e2(o3.data) }]);
        }
      }
      return r3;
    }(o2(t3)), n3), s2 = et.find_path(u3.map, "start", "end"), f2 = [], h2 = 1; h2 < s2.length - 1; h2++)
      f2.push(u3.table[s2[h2]].node);
    return r2.fromArray(function(t4) {
      return t4.reduce(function(t5, r3) {
        var e3 = t5.length - 1 >= 0 ? t5[t5.length - 1] : null;
        return e3 && e3.mode === r3.mode ? (t5[t5.length - 1].data += r3.data, t5) : (t5.push(r3), t5);
      }, []);
    }(f2));
  }, r2.rawSplit = function(t3) {
    return r2.fromArray(o2(t3));
  };
});
nt.fromArray, nt.fromString, nt.rawSplit;
function ot(t2, r2, e2) {
  var n2, o2, i2 = t2.size, a2 = j(r2, e2);
  for (n2 = 0; n2 < 15; n2++)
    o2 = 1 == (a2 >> n2 & 1), n2 < 6 ? t2.set(n2, 8, o2, true) : n2 < 8 ? t2.set(n2 + 1, 8, o2, true) : t2.set(i2 - 15 + n2, 8, o2, true), n2 < 8 ? t2.set(8, i2 - n2 - 1, o2, true) : n2 < 9 ? t2.set(8, 15 - n2 - 1 + 1, o2, true) : t2.set(8, 15 - n2 - 1, o2, true);
  t2.set(i2 - 8, 8, 1, true);
}
function it(t2, r2, e2) {
  var o2 = new c$1();
  e2.forEach(function(r3) {
    o2.put(r3.mode.bit, 4), o2.put(r3.getLength(), K.getCharCountIndicator(r3.mode, t2)), r3.write(o2);
  });
  var i2 = 8 * (n(t2) - y$1(t2, r2));
  for (o2.getLengthInBits() + 4 <= i2 && o2.put(0, 4); o2.getLengthInBits() % 8 != 0; )
    o2.putBit(0);
  for (var a2 = (i2 - o2.getLengthInBits()) / 8, u2 = 0; u2 < a2; u2++)
    o2.put(u2 % 2 ? 17 : 236, 8);
  return function(t3, r3, e3) {
    for (var o3 = n(r3), i3 = y$1(r3, e3), a3 = o3 - i3, u3 = m$1(r3, e3), s2 = u3 - o3 % u3, f2 = Math.floor(o3 / u3), h2 = Math.floor(a3 / u3), c2 = h2 + 1, g2 = f2 - h2, d2 = new R(g2), l2 = 0, v2 = new Array(u3), p2 = new Array(u3), E2 = 0, w2 = new Uint8Array(t3.buffer), A2 = 0; A2 < u3; A2++) {
      var N2 = A2 < s2 ? h2 : c2;
      v2[A2] = w2.slice(l2, l2 + N2), p2[A2] = d2.encode(v2[A2]), l2 += N2, E2 = Math.max(E2, N2);
    }
    var B2, P2, M2 = new Uint8Array(o3), I2 = 0;
    for (B2 = 0; B2 < E2; B2++)
      for (P2 = 0; P2 < u3; P2++)
        B2 < v2[P2].length && (M2[I2++] = v2[P2][B2]);
    for (B2 = 0; B2 < g2; B2++)
      for (P2 = 0; P2 < u3; P2++)
        M2[I2++] = p2[P2][B2];
    return M2;
  }(o2, t2, r2);
}
function at(t2, r2, n2, o2) {
  var i2;
  if (D(t2))
    i2 = nt.fromArray(t2);
  else {
    if ("string" != typeof t2)
      throw new Error("Invalid data");
    var a2 = r2;
    if (!a2) {
      var u2 = nt.rawSplit(t2);
      a2 = V.getBestVersionForData(u2, n2);
    }
    i2 = nt.fromString(t2, a2 || 40);
  }
  var s2 = V.getBestVersionForData(i2, n2);
  if (!s2)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (r2) {
    if (r2 < s2)
      throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + s2 + ".\n");
  } else
    r2 = s2;
  var f2 = it(r2, n2, i2), h2 = e(r2), c2 = new d(h2);
  return function(t3, r3) {
    for (var e2 = t3.size, n3 = p(r3), o3 = 0; o3 < n3.length; o3++)
      for (var i3 = n3[o3][0], a3 = n3[o3][1], u3 = -1; u3 <= 7; u3++)
        if (!(i3 + u3 <= -1 || e2 <= i3 + u3))
          for (var s3 = -1; s3 <= 7; s3++)
            a3 + s3 <= -1 || e2 <= a3 + s3 || (u3 >= 0 && u3 <= 6 && (0 === s3 || 6 === s3) || s3 >= 0 && s3 <= 6 && (0 === u3 || 6 === u3) || u3 >= 2 && u3 <= 4 && s3 >= 2 && s3 <= 4 ? t3.set(i3 + u3, a3 + s3, true, true) : t3.set(i3 + u3, a3 + s3, false, true));
  }(c2, r2), function(t3) {
    for (var r3 = t3.size, e2 = 8; e2 < r3 - 8; e2++) {
      var n3 = e2 % 2 == 0;
      t3.set(e2, 6, n3, true), t3.set(6, e2, n3, true);
    }
  }(c2), function(t3, r3) {
    for (var e2 = l.getPositions(r3), n3 = 0; n3 < e2.length; n3++)
      for (var o3 = e2[n3][0], i3 = e2[n3][1], a3 = -2; a3 <= 2; a3++)
        for (var u3 = -2; u3 <= 2; u3++)
          -2 === a3 || 2 === a3 || -2 === u3 || 2 === u3 || 0 === a3 && 0 === u3 ? t3.set(o3 + a3, i3 + u3, true, true) : t3.set(o3 + a3, i3 + u3, false, true);
  }(c2, r2), ot(c2, n2, 0), r2 >= 7 && function(t3, r3) {
    for (var e2, n3, o3, i3 = t3.size, a3 = V.getEncodedBits(r3), u3 = 0; u3 < 18; u3++)
      e2 = Math.floor(u3 / 3), n3 = u3 % 3 + i3 - 8 - 3, o3 = 1 == (a3 >> u3 & 1), t3.set(e2, n3, o3, true), t3.set(n3, e2, o3, true);
  }(c2, r2), function(t3, r3) {
    for (var e2 = t3.size, n3 = -1, o3 = e2 - 1, i3 = 7, a3 = 0, u3 = e2 - 1; u3 > 0; u3 -= 2)
      for (6 === u3 && u3--; ; ) {
        for (var s3 = 0; s3 < 2; s3++)
          if (!t3.isReserved(o3, u3 - s3)) {
            var f3 = false;
            a3 < r3.length && (f3 = 1 == (r3[a3] >>> i3 & 1)), t3.set(o3, u3 - s3, f3), -1 === --i3 && (a3++, i3 = 7);
          }
        if ((o3 += n3) < 0 || e2 <= o3) {
          o3 -= n3, n3 = -n3;
          break;
        }
      }
  }(c2, f2), isNaN(o2) && (o2 = E.getBestMask(c2, ot.bind(null, c2, n2))), E.applyMask(o2, c2), ot(c2, n2, o2), { modules: c2, version: r2, errorCorrectionLevel: n2, maskPattern: o2, segments: i2 };
}
dist.create = function(t2, r2) {
  if (void 0 === t2 || "" === t2)
    throw new Error("No input text");
  var e2, n2, o2 = f.M;
  return void 0 !== r2 && (o2 = f.from(r2.errorCorrectionLevel, f.M), e2 = V.from(r2.version), n2 = E.from(r2.maskPattern), r2.toSJISFunc && i(r2.toSJISFunc)), at(t2, e2, o2, n2);
};
const core = dist;
function createPath(data2, size2, margin) {
  let path2 = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i2 = 0; i2 < data2.length; i2++) {
    const col = Math.floor(i2 % size2);
    const row = Math.floor(i2 / size2);
    if (col === 0) {
      newRow = true;
    }
    if (!data2[i2]) {
      moveBy++;
      continue;
    }
    lineLength++;
    if (!(i2 > 0 && col > 0 && data2[i2 - 1])) {
      path2 += newRow ? `M${margin + col},${margin + 0.5 + row}` : `m${moveBy},0`;
      moveBy = 0;
      newRow = false;
    }
    if (!(col + 1 < size2 && data2[i2 + 1])) {
      path2 += `h${lineLength}`;
      lineLength = 0;
    }
  }
  return path2;
}
var svg = function qrcodeSvg(input, options = {}) {
  const { size: size2, data: data2 } = core.create(input).modules;
  const margin = options.margin || 0;
  const fullSize = size2 + margin * 2;
  const viewBox = `viewBox="0 0 ${fullSize} ${fullSize}"`;
  const dimensions = options.size ? ` width="${options.size}" height="${options.size}"` : "";
  const bg = options.backgroundColor === "transparent" ? "" : `<path fill="${options.backgroundColor || "white"}" d="M0,0h${fullSize}v${fullSize}H0z"/>`;
  const path2 = `<path stroke="${options.color || "black"}" d="${createPath(data2, size2, margin)}"/>`;
  return `<svg xmlns="http://www.w3.org/2000/svg" ${viewBox}${dimensions} shape-rendering="crispEdges">${bg}${path2}</svg>`;
};
var codemirror = { exports: {} };
(function(module2, exports2) {
  (function(global2, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    var userAgent = navigator.userAgent;
    var platform2 = navigator.platform;
    var gecko = /gecko\/\d/i.test(userAgent);
    var ie_upto10 = /MSIE \d/.test(userAgent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
    var edge = /Edge\/(\d+)/.exec(userAgent);
    var ie2 = ie_upto10 || ie_11up || edge;
    var ie_version = ie2 && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
    var webkit = !edge && /WebKit\//.test(userAgent);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
    var chrome2 = !edge && /Chrome\//.test(userAgent);
    var presto = /Opera\//.test(userAgent);
    var safari = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
    var phantom = /PhantomJS/.test(userAgent);
    var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
    var android = /Android/.test(userAgent);
    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
    var mac = ios || /Mac/.test(platform2);
    var chromeOS = /\bCrOS\b/.test(userAgent);
    var windows = /win/i.test(platform2);
    var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version) {
      presto_version = Number(presto_version[1]);
    }
    if (presto_version && presto_version >= 15) {
      presto = false;
      webkit = true;
    }
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || ie2 && ie_version >= 9;
    function classTest(cls) {
      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    var rmClass = function(node, cls) {
      var current = node.className;
      var match5 = classTest(cls).exec(current);
      if (match5) {
        var after = current.slice(match5.index + match5[0].length);
        node.className = current.slice(0, match5.index) + (after ? match5[1] + after : "");
      }
    };
    function removeChildren(e2) {
      for (var count2 = e2.childNodes.length; count2 > 0; --count2) {
        e2.removeChild(e2.firstChild);
      }
      return e2;
    }
    function removeChildrenAndAdd(parent, e2) {
      return removeChildren(parent).appendChild(e2);
    }
    function elt(tag, content, className, style2) {
      var e2 = document.createElement(tag);
      if (className) {
        e2.className = className;
      }
      if (style2) {
        e2.style.cssText = style2;
      }
      if (typeof content == "string") {
        e2.appendChild(document.createTextNode(content));
      } else if (content) {
        for (var i3 = 0; i3 < content.length; ++i3) {
          e2.appendChild(content[i3]);
        }
      }
      return e2;
    }
    function eltP(tag, content, className, style2) {
      var e2 = elt(tag, content, className, style2);
      e2.setAttribute("role", "presentation");
      return e2;
    }
    var range2;
    if (document.createRange) {
      range2 = function(node, start2, end, endNode) {
        var r2 = document.createRange();
        r2.setEnd(endNode || node, end);
        r2.setStart(node, start2);
        return r2;
      };
    } else {
      range2 = function(node, start2, end) {
        var r2 = document.body.createTextRange();
        try {
          r2.moveToElementText(node.parentNode);
        } catch (e2) {
          return r2;
        }
        r2.collapse(true);
        r2.moveEnd("character", end);
        r2.moveStart("character", start2);
        return r2;
      };
    }
    function contains2(parent, child) {
      if (child.nodeType == 3) {
        child = child.parentNode;
      }
      if (parent.contains) {
        return parent.contains(child);
      }
      do {
        if (child.nodeType == 11) {
          child = child.host;
        }
        if (child == parent) {
          return true;
        }
      } while (child = child.parentNode);
    }
    function activeElt() {
      var activeElement;
      try {
        activeElement = document.activeElement;
      } catch (e2) {
        activeElement = document.body || null;
      }
      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      return activeElement;
    }
    function addClass(node, cls) {
      var current = node.className;
      if (!classTest(cls).test(current)) {
        node.className += (current ? " " : "") + cls;
      }
    }
    function joinClasses(a2, b2) {
      var as2 = a2.split(" ");
      for (var i3 = 0; i3 < as2.length; i3++) {
        if (as2[i3] && !classTest(as2[i3]).test(b2)) {
          b2 += " " + as2[i3];
        }
      }
      return b2;
    }
    var selectInput = function(node) {
      node.select();
    };
    if (ios) {
      selectInput = function(node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie2) {
      selectInput = function(node) {
        try {
          node.select();
        } catch (_e) {
        }
      };
    }
    function bind2(f2) {
      var args = Array.prototype.slice.call(arguments, 1);
      return function() {
        return f2.apply(null, args);
      };
    }
    function copyObj(obj, target2, overwrite) {
      if (!target2) {
        target2 = {};
      }
      for (var prop3 in obj) {
        if (obj.hasOwnProperty(prop3) && (overwrite !== false || !target2.hasOwnProperty(prop3))) {
          target2[prop3] = obj[prop3];
        }
      }
      return target2;
    }
    function countColumn(string2, end, tabSize, startIndex, startValue) {
      if (end == null) {
        end = string2.search(/[^\s\u00a0]/);
        if (end == -1) {
          end = string2.length;
        }
      }
      for (var i3 = startIndex || 0, n2 = startValue || 0; ; ) {
        var nextTab = string2.indexOf("	", i3);
        if (nextTab < 0 || nextTab >= end) {
          return n2 + (end - i3);
        }
        n2 += nextTab - i3;
        n2 += tabSize - n2 % tabSize;
        i3 = nextTab + 1;
      }
    }
    var Delayed = function() {
      this.id = null;
      this.f = null;
      this.time = 0;
      this.handler = bind2(this.onTimeout, this);
    };
    Delayed.prototype.onTimeout = function(self2) {
      self2.id = 0;
      if (self2.time <= +new Date()) {
        self2.f();
      } else {
        setTimeout(self2.handler, self2.time - +new Date());
      }
    };
    Delayed.prototype.set = function(ms2, f2) {
      this.f = f2;
      var time = +new Date() + ms2;
      if (!this.id || time < this.time) {
        clearTimeout(this.id);
        this.id = setTimeout(this.handler, ms2);
        this.time = time;
      }
    };
    function indexOf2(array2, elt2) {
      for (var i3 = 0; i3 < array2.length; ++i3) {
        if (array2[i3] == elt2) {
          return i3;
        }
      }
      return -1;
    }
    var scrollerGap = 50;
    var Pass = { toString: function() {
      return "CodeMirror.Pass";
    } };
    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
    function findColumn(string2, goal, tabSize) {
      for (var pos = 0, col = 0; ; ) {
        var nextTab = string2.indexOf("	", pos);
        if (nextTab == -1) {
          nextTab = string2.length;
        }
        var skipped = nextTab - pos;
        if (nextTab == string2.length || col + skipped >= goal) {
          return pos + Math.min(skipped, goal - col);
        }
        col += nextTab - pos;
        col += tabSize - col % tabSize;
        pos = nextTab + 1;
        if (col >= goal) {
          return pos;
        }
      }
    }
    var spaceStrs = [""];
    function spaceStr(n2) {
      while (spaceStrs.length <= n2) {
        spaceStrs.push(lst(spaceStrs) + " ");
      }
      return spaceStrs[n2];
    }
    function lst(arr) {
      return arr[arr.length - 1];
    }
    function map2(array2, f2) {
      var out = [];
      for (var i3 = 0; i3 < array2.length; i3++) {
        out[i3] = f2(array2[i3], i3);
      }
      return out;
    }
    function insertSorted(array2, value, score) {
      var pos = 0, priority = score(value);
      while (pos < array2.length && score(array2[pos]) <= priority) {
        pos++;
      }
      array2.splice(pos, 0, value);
    }
    function nothing() {
    }
    function createObj(base2, props) {
      var inst;
      if (Object.create) {
        inst = Object.create(base2);
      } else {
        nothing.prototype = base2;
        inst = new nothing();
      }
      if (props) {
        copyObj(props, inst);
      }
      return inst;
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
      return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function isWordChar(ch, helper) {
      if (!helper) {
        return isWordCharBasic(ch);
      }
      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
        return true;
      }
      return helper.test(ch);
    }
    function isEmpty3(obj) {
      for (var n2 in obj) {
        if (obj.hasOwnProperty(n2) && obj[n2]) {
          return false;
        }
      }
      return true;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
      return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function skipExtendingChars(str, pos, dir) {
      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
        pos += dir;
      }
      return pos;
    }
    function findFirst(pred, from2, to2) {
      var dir = from2 > to2 ? -1 : 1;
      for (; ; ) {
        if (from2 == to2) {
          return from2;
        }
        var midF = (from2 + to2) / 2, mid2 = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
        if (mid2 == from2) {
          return pred(mid2) ? from2 : to2;
        }
        if (pred(mid2)) {
          to2 = mid2;
        } else {
          from2 = mid2 + dir;
        }
      }
    }
    function iterateBidiSections(order2, from2, to2, f2) {
      if (!order2) {
        return f2(from2, to2, "ltr", 0);
      }
      var found = false;
      for (var i3 = 0; i3 < order2.length; ++i3) {
        var part2 = order2[i3];
        if (part2.from < to2 && part2.to > from2 || from2 == to2 && part2.to == from2) {
          f2(Math.max(part2.from, from2), Math.min(part2.to, to2), part2.level == 1 ? "rtl" : "ltr", i3);
          found = true;
        }
      }
      if (!found) {
        f2(from2, to2, "ltr");
      }
    }
    var bidiOther = null;
    function getBidiPartAt(order2, ch, sticky) {
      var found;
      bidiOther = null;
      for (var i3 = 0; i3 < order2.length; ++i3) {
        var cur = order2[i3];
        if (cur.from < ch && cur.to > ch) {
          return i3;
        }
        if (cur.to == ch) {
          if (cur.from != cur.to && sticky == "before") {
            found = i3;
          } else {
            bidiOther = i3;
          }
        }
        if (cur.from == ch) {
          if (cur.from != cur.to && sticky != "before") {
            found = i3;
          } else {
            bidiOther = i3;
          }
        }
      }
      return found != null ? found : bidiOther;
    }
    var bidiOrdering = function() {
      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
      function charType(code3) {
        if (code3 <= 247) {
          return lowTypes.charAt(code3);
        } else if (1424 <= code3 && code3 <= 1524) {
          return "R";
        } else if (1536 <= code3 && code3 <= 1785) {
          return arabicTypes.charAt(code3 - 1536);
        } else if (1774 <= code3 && code3 <= 2220) {
          return "r";
        } else if (8192 <= code3 && code3 <= 8203) {
          return "w";
        } else if (code3 == 8204) {
          return "b";
        } else {
          return "L";
        }
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      function BidiSpan(level, from2, to2) {
        this.level = level;
        this.from = from2;
        this.to = to2;
      }
      return function(str, direction) {
        var outerType = direction == "ltr" ? "L" : "R";
        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
          return false;
        }
        var len2 = str.length, types = [];
        for (var i3 = 0; i3 < len2; ++i3) {
          types.push(charType(str.charCodeAt(i3)));
        }
        for (var i$13 = 0, prev = outerType; i$13 < len2; ++i$13) {
          var type = types[i$13];
          if (type == "m") {
            types[i$13] = prev;
          } else {
            prev = type;
          }
        }
        for (var i$23 = 0, cur = outerType; i$23 < len2; ++i$23) {
          var type$1 = types[i$23];
          if (type$1 == "1" && cur == "r") {
            types[i$23] = "n";
          } else if (isStrong.test(type$1)) {
            cur = type$1;
            if (type$1 == "r") {
              types[i$23] = "R";
            }
          }
        }
        for (var i$3 = 1, prev$1 = types[0]; i$3 < len2 - 1; ++i$3) {
          var type$2 = types[i$3];
          if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
            types[i$3] = "1";
          } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
            types[i$3] = prev$1;
          }
          prev$1 = type$2;
        }
        for (var i$4 = 0; i$4 < len2; ++i$4) {
          var type$3 = types[i$4];
          if (type$3 == ",") {
            types[i$4] = "N";
          } else if (type$3 == "%") {
            var end = void 0;
            for (end = i$4 + 1; end < len2 && types[end] == "%"; ++end) {
            }
            var replace2 = i$4 && types[i$4 - 1] == "!" || end < len2 && types[end] == "1" ? "1" : "N";
            for (var j2 = i$4; j2 < end; ++j2) {
              types[j2] = replace2;
            }
            i$4 = end - 1;
          }
        }
        for (var i$5 = 0, cur$1 = outerType; i$5 < len2; ++i$5) {
          var type$4 = types[i$5];
          if (cur$1 == "L" && type$4 == "1") {
            types[i$5] = "L";
          } else if (isStrong.test(type$4)) {
            cur$1 = type$4;
          }
        }
        for (var i$6 = 0; i$6 < len2; ++i$6) {
          if (isNeutral.test(types[i$6])) {
            var end$1 = void 0;
            for (end$1 = i$6 + 1; end$1 < len2 && isNeutral.test(types[end$1]); ++end$1) {
            }
            var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
            var after = (end$1 < len2 ? types[end$1] : outerType) == "L";
            var replace$1 = before == after ? before ? "L" : "R" : outerType;
            for (var j$12 = i$6; j$12 < end$1; ++j$12) {
              types[j$12] = replace$1;
            }
            i$6 = end$1 - 1;
          }
        }
        var order2 = [], m2;
        for (var i$7 = 0; i$7 < len2; ) {
          if (countsAsLeft.test(types[i$7])) {
            var start2 = i$7;
            for (++i$7; i$7 < len2 && countsAsLeft.test(types[i$7]); ++i$7) {
            }
            order2.push(new BidiSpan(0, start2, i$7));
          } else {
            var pos = i$7, at2 = order2.length, isRTL = direction == "rtl" ? 1 : 0;
            for (++i$7; i$7 < len2 && types[i$7] != "L"; ++i$7) {
            }
            for (var j$2 = pos; j$2 < i$7; ) {
              if (countsAsNum.test(types[j$2])) {
                if (pos < j$2) {
                  order2.splice(at2, 0, new BidiSpan(1, pos, j$2));
                  at2 += isRTL;
                }
                var nstart = j$2;
                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                }
                order2.splice(at2, 0, new BidiSpan(2, nstart, j$2));
                at2 += isRTL;
                pos = j$2;
              } else {
                ++j$2;
              }
            }
            if (pos < i$7) {
              order2.splice(at2, 0, new BidiSpan(1, pos, i$7));
            }
          }
        }
        if (direction == "ltr") {
          if (order2[0].level == 1 && (m2 = str.match(/^\s+/))) {
            order2[0].from = m2[0].length;
            order2.unshift(new BidiSpan(0, 0, m2[0].length));
          }
          if (lst(order2).level == 1 && (m2 = str.match(/\s+$/))) {
            lst(order2).to -= m2[0].length;
            order2.push(new BidiSpan(0, len2 - m2[0].length, len2));
          }
        }
        return direction == "rtl" ? order2.reverse() : order2;
      };
    }();
    function getOrder(line2, direction) {
      var order2 = line2.order;
      if (order2 == null) {
        order2 = line2.order = bidiOrdering(line2.text, direction);
      }
      return order2;
    }
    var noHandlers = [];
    var on = function(emitter, type, f2) {
      if (emitter.addEventListener) {
        emitter.addEventListener(type, f2, false);
      } else if (emitter.attachEvent) {
        emitter.attachEvent("on" + type, f2);
      } else {
        var map3 = emitter._handlers || (emitter._handlers = {});
        map3[type] = (map3[type] || noHandlers).concat(f2);
      }
    };
    function getHandlers(emitter, type) {
      return emitter._handlers && emitter._handlers[type] || noHandlers;
    }
    function off(emitter, type, f2) {
      if (emitter.removeEventListener) {
        emitter.removeEventListener(type, f2, false);
      } else if (emitter.detachEvent) {
        emitter.detachEvent("on" + type, f2);
      } else {
        var map3 = emitter._handlers, arr = map3 && map3[type];
        if (arr) {
          var index2 = indexOf2(arr, f2);
          if (index2 > -1) {
            map3[type] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
          }
        }
      }
    }
    function signal(emitter, type) {
      var handlers2 = getHandlers(emitter, type);
      if (!handlers2.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i3 = 0; i3 < handlers2.length; ++i3) {
        handlers2[i3].apply(null, args);
      }
    }
    function signalDOMEvent(cm, e2, override) {
      if (typeof e2 == "string") {
        e2 = { type: e2, preventDefault: function() {
          this.defaultPrevented = true;
        } };
      }
      signal(cm, override || e2.type, cm, e2);
      return e_defaultPrevented(e2) || e2.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
      var arr = cm._handlers && cm._handlers.cursorActivity;
      if (!arr) {
        return;
      }
      var set3 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
      for (var i3 = 0; i3 < arr.length; ++i3) {
        if (indexOf2(set3, arr[i3]) == -1) {
          set3.push(arr[i3]);
        }
      }
    }
    function hasHandler(emitter, type) {
      return getHandlers(emitter, type).length > 0;
    }
    function eventMixin(ctor) {
      ctor.prototype.on = function(type, f2) {
        on(this, type, f2);
      };
      ctor.prototype.off = function(type, f2) {
        off(this, type, f2);
      };
    }
    function e_preventDefault(e2) {
      if (e2.preventDefault) {
        e2.preventDefault();
      } else {
        e2.returnValue = false;
      }
    }
    function e_stopPropagation(e2) {
      if (e2.stopPropagation) {
        e2.stopPropagation();
      } else {
        e2.cancelBubble = true;
      }
    }
    function e_defaultPrevented(e2) {
      return e2.defaultPrevented != null ? e2.defaultPrevented : e2.returnValue == false;
    }
    function e_stop(e2) {
      e_preventDefault(e2);
      e_stopPropagation(e2);
    }
    function e_target(e2) {
      return e2.target || e2.srcElement;
    }
    function e_button(e2) {
      var b2 = e2.which;
      if (b2 == null) {
        if (e2.button & 1) {
          b2 = 1;
        } else if (e2.button & 2) {
          b2 = 3;
        } else if (e2.button & 4) {
          b2 = 2;
        }
      }
      if (mac && e2.ctrlKey && b2 == 1) {
        b2 = 3;
      }
      return b2;
    }
    var dragAndDrop = function() {
      if (ie2 && ie_version < 9) {
        return false;
      }
      var div2 = elt("div");
      return "draggable" in div2 || "dragDrop" in div2;
    }();
    var zwspSupported;
    function zeroWidthElement(measure) {
      if (zwspSupported == null) {
        var test2 = elt("span", "\u200B");
        removeChildrenAndAdd(measure, elt("span", [test2, document.createTextNode("x")]));
        if (measure.firstChild.offsetHeight != 0) {
          zwspSupported = test2.offsetWidth <= 1 && test2.offsetHeight > 2 && !(ie2 && ie_version < 8);
        }
      }
      var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
      node.setAttribute("cm-text", "");
      return node;
    }
    var badBidiRects;
    function hasBadBidiRects(measure) {
      if (badBidiRects != null) {
        return badBidiRects;
      }
      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
      var r0 = range2(txt, 0, 1).getBoundingClientRect();
      var r1 = range2(txt, 1, 2).getBoundingClientRect();
      removeChildren(measure);
      if (!r0 || r0.left == r0.right) {
        return false;
      }
      return badBidiRects = r1.right - r0.right < 3;
    }
    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string2) {
      var pos = 0, result = [], l2 = string2.length;
      while (pos <= l2) {
        var nl = string2.indexOf("\n", pos);
        if (nl == -1) {
          nl = string2.length;
        }
        var line2 = string2.slice(pos, string2.charAt(nl - 1) == "\r" ? nl - 1 : nl);
        var rt2 = line2.indexOf("\r");
        if (rt2 != -1) {
          result.push(line2.slice(0, rt2));
          pos += rt2 + 1;
        } else {
          result.push(line2);
          pos = nl + 1;
        }
      }
      return result;
    } : function(string2) {
      return string2.split(/\r\n?|\n/);
    };
    var hasSelection = window.getSelection ? function(te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e2) {
        return false;
      }
    } : function(te) {
      var range3;
      try {
        range3 = te.ownerDocument.selection.createRange();
      } catch (e2) {
      }
      if (!range3 || range3.parentElement() != te) {
        return false;
      }
      return range3.compareEndPoints("StartToEnd", range3) != 0;
    };
    var hasCopyEvent = function() {
      var e2 = elt("div");
      if ("oncopy" in e2) {
        return true;
      }
      e2.setAttribute("oncopy", "return;");
      return typeof e2.oncopy == "function";
    }();
    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
      if (badZoomedRects != null) {
        return badZoomedRects;
      }
      var node = removeChildrenAndAdd(measure, elt("span", "x"));
      var normal = node.getBoundingClientRect();
      var fromRange = range2(node, 0, 1).getBoundingClientRect();
      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    var modes = {}, mimeModes = {};
    function defineMode(name, mode) {
      if (arguments.length > 2) {
        mode.dependencies = Array.prototype.slice.call(arguments, 2);
      }
      modes[name] = mode;
    }
    function defineMIME(mime, spec) {
      mimeModes[mime] = spec;
    }
    function resolveMode(spec) {
      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
        spec = mimeModes[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
        var found = mimeModes[spec.name];
        if (typeof found == "string") {
          found = { name: found };
        }
        spec = createObj(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return resolveMode("application/xml");
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
        return resolveMode("application/json");
      }
      if (typeof spec == "string") {
        return { name: spec };
      } else {
        return spec || { name: "null" };
      }
    }
    function getMode(options, spec) {
      spec = resolveMode(spec);
      var mfactory = modes[spec.name];
      if (!mfactory) {
        return getMode(options, "text/plain");
      }
      var modeObj = mfactory(options, spec);
      if (modeExtensions.hasOwnProperty(spec.name)) {
        var exts = modeExtensions[spec.name];
        for (var prop3 in exts) {
          if (!exts.hasOwnProperty(prop3)) {
            continue;
          }
          if (modeObj.hasOwnProperty(prop3)) {
            modeObj["_" + prop3] = modeObj[prop3];
          }
          modeObj[prop3] = exts[prop3];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) {
        modeObj.helperType = spec.helperType;
      }
      if (spec.modeProps) {
        for (var prop$1 in spec.modeProps) {
          modeObj[prop$1] = spec.modeProps[prop$1];
        }
      }
      return modeObj;
    }
    var modeExtensions = {};
    function extendMode(mode, properties) {
      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
      copyObj(properties, exts);
    }
    function copyState(mode, state) {
      if (state === true) {
        return state;
      }
      if (mode.copyState) {
        return mode.copyState(state);
      }
      var nstate = {};
      for (var n2 in state) {
        var val = state[n2];
        if (val instanceof Array) {
          val = val.concat([]);
        }
        nstate[n2] = val;
      }
      return nstate;
    }
    function innerMode(mode, state) {
      var info;
      while (mode.innerMode) {
        info = mode.innerMode(state);
        if (!info || info.mode == mode) {
          break;
        }
        state = info.state;
        mode = info.mode;
      }
      return info || { mode, state };
    }
    function startState(mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true;
    }
    var StringStream = function(string2, tabSize, lineOracle) {
      this.pos = this.start = 0;
      this.string = string2;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
      this.lineOracle = lineOracle;
    };
    StringStream.prototype.eol = function() {
      return this.pos >= this.string.length;
    };
    StringStream.prototype.sol = function() {
      return this.pos == this.lineStart;
    };
    StringStream.prototype.peek = function() {
      return this.string.charAt(this.pos) || void 0;
    };
    StringStream.prototype.next = function() {
      if (this.pos < this.string.length) {
        return this.string.charAt(this.pos++);
      }
    };
    StringStream.prototype.eat = function(match5) {
      var ch = this.string.charAt(this.pos);
      var ok;
      if (typeof match5 == "string") {
        ok = ch == match5;
      } else {
        ok = ch && (match5.test ? match5.test(ch) : match5(ch));
      }
      if (ok) {
        ++this.pos;
        return ch;
      }
    };
    StringStream.prototype.eatWhile = function(match5) {
      var start2 = this.pos;
      while (this.eat(match5)) {
      }
      return this.pos > start2;
    };
    StringStream.prototype.eatSpace = function() {
      var start2 = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
        ++this.pos;
      }
      return this.pos > start2;
    };
    StringStream.prototype.skipToEnd = function() {
      this.pos = this.string.length;
    };
    StringStream.prototype.skipTo = function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    };
    StringStream.prototype.backUp = function(n2) {
      this.pos -= n2;
    };
    StringStream.prototype.column = function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.indentation = function() {
      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) {
            this.pos += pattern.length;
          }
          return true;
        }
      } else {
        var match5 = this.string.slice(this.pos).match(pattern);
        if (match5 && match5.index > 0) {
          return null;
        }
        if (match5 && consume !== false) {
          this.pos += match5[0].length;
        }
        return match5;
      }
    };
    StringStream.prototype.current = function() {
      return this.string.slice(this.start, this.pos);
    };
    StringStream.prototype.hideFirstChars = function(n2, inner) {
      this.lineStart += n2;
      try {
        return inner();
      } finally {
        this.lineStart -= n2;
      }
    };
    StringStream.prototype.lookAhead = function(n2) {
      var oracle = this.lineOracle;
      return oracle && oracle.lookAhead(n2);
    };
    StringStream.prototype.baseToken = function() {
      var oracle = this.lineOracle;
      return oracle && oracle.baseToken(this.pos);
    };
    function getLine2(doc2, n2) {
      n2 -= doc2.first;
      if (n2 < 0 || n2 >= doc2.size) {
        throw new Error("There is no line " + (n2 + doc2.first) + " in the document.");
      }
      var chunk = doc2;
      while (!chunk.lines) {
        for (var i3 = 0; ; ++i3) {
          var child = chunk.children[i3], sz = child.chunkSize();
          if (n2 < sz) {
            chunk = child;
            break;
          }
          n2 -= sz;
        }
      }
      return chunk.lines[n2];
    }
    function getBetween(doc2, start2, end) {
      var out = [], n2 = start2.line;
      doc2.iter(start2.line, end.line + 1, function(line2) {
        var text3 = line2.text;
        if (n2 == end.line) {
          text3 = text3.slice(0, end.ch);
        }
        if (n2 == start2.line) {
          text3 = text3.slice(start2.ch);
        }
        out.push(text3);
        ++n2;
      });
      return out;
    }
    function getLines2(doc2, from2, to2) {
      var out = [];
      doc2.iter(from2, to2, function(line2) {
        out.push(line2.text);
      });
      return out;
    }
    function updateLineHeight(line2, height) {
      var diff2 = height - line2.height;
      if (diff2) {
        for (var n2 = line2; n2; n2 = n2.parent) {
          n2.height += diff2;
        }
      }
    }
    function lineNo(line2) {
      if (line2.parent == null) {
        return null;
      }
      var cur = line2.parent, no = indexOf2(cur.lines, line2);
      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
        for (var i3 = 0; ; ++i3) {
          if (chunk.children[i3] == cur) {
            break;
          }
          no += chunk.children[i3].chunkSize();
        }
      }
      return no + cur.first;
    }
    function lineAtHeight(chunk, h2) {
      var n2 = chunk.first;
      outer:
        do {
          for (var i$13 = 0; i$13 < chunk.children.length; ++i$13) {
            var child = chunk.children[i$13], ch = child.height;
            if (h2 < ch) {
              chunk = child;
              continue outer;
            }
            h2 -= ch;
            n2 += child.chunkSize();
          }
          return n2;
        } while (!chunk.lines);
      var i3 = 0;
      for (; i3 < chunk.lines.length; ++i3) {
        var line2 = chunk.lines[i3], lh = line2.height;
        if (h2 < lh) {
          break;
        }
        h2 -= lh;
      }
      return n2 + i3;
    }
    function isLine(doc2, l2) {
      return l2 >= doc2.first && l2 < doc2.first + doc2.size;
    }
    function lineNumberFor(options, i3) {
      return String(options.lineNumberFormatter(i3 + options.firstLineNumber));
    }
    function Pos(line2, ch, sticky) {
      if (sticky === void 0)
        sticky = null;
      if (!(this instanceof Pos)) {
        return new Pos(line2, ch, sticky);
      }
      this.line = line2;
      this.ch = ch;
      this.sticky = sticky;
    }
    function cmp(a2, b2) {
      return a2.line - b2.line || a2.ch - b2.ch;
    }
    function equalCursorPos(a2, b2) {
      return a2.sticky == b2.sticky && cmp(a2, b2) == 0;
    }
    function copyPos(x2) {
      return Pos(x2.line, x2.ch);
    }
    function maxPos(a2, b2) {
      return cmp(a2, b2) < 0 ? b2 : a2;
    }
    function minPos(a2, b2) {
      return cmp(a2, b2) < 0 ? a2 : b2;
    }
    function clipLine(doc2, n2) {
      return Math.max(doc2.first, Math.min(n2, doc2.first + doc2.size - 1));
    }
    function clipPos(doc2, pos) {
      if (pos.line < doc2.first) {
        return Pos(doc2.first, 0);
      }
      var last = doc2.first + doc2.size - 1;
      if (pos.line > last) {
        return Pos(last, getLine2(doc2, last).text.length);
      }
      return clipToLen(pos, getLine2(doc2, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
      var ch = pos.ch;
      if (ch == null || ch > linelen) {
        return Pos(pos.line, linelen);
      } else if (ch < 0) {
        return Pos(pos.line, 0);
      } else {
        return pos;
      }
    }
    function clipPosArray(doc2, array2) {
      var out = [];
      for (var i3 = 0; i3 < array2.length; i3++) {
        out[i3] = clipPos(doc2, array2[i3]);
      }
      return out;
    }
    var SavedContext = function(state, lookAhead) {
      this.state = state;
      this.lookAhead = lookAhead;
    };
    var Context = function(doc2, state, line2, lookAhead) {
      this.state = state;
      this.doc = doc2;
      this.line = line2;
      this.maxLookAhead = lookAhead || 0;
      this.baseTokens = null;
      this.baseTokenPos = 1;
    };
    Context.prototype.lookAhead = function(n2) {
      var line2 = this.doc.getLine(this.line + n2);
      if (line2 != null && n2 > this.maxLookAhead) {
        this.maxLookAhead = n2;
      }
      return line2;
    };
    Context.prototype.baseToken = function(n2) {
      if (!this.baseTokens) {
        return null;
      }
      while (this.baseTokens[this.baseTokenPos] <= n2) {
        this.baseTokenPos += 2;
      }
      var type = this.baseTokens[this.baseTokenPos + 1];
      return {
        type: type && type.replace(/( |^)overlay .*/, ""),
        size: this.baseTokens[this.baseTokenPos] - n2
      };
    };
    Context.prototype.nextLine = function() {
      this.line++;
      if (this.maxLookAhead > 0) {
        this.maxLookAhead--;
      }
    };
    Context.fromSaved = function(doc2, saved, line2) {
      if (saved instanceof SavedContext) {
        return new Context(doc2, copyState(doc2.mode, saved.state), line2, saved.lookAhead);
      } else {
        return new Context(doc2, copyState(doc2.mode, saved), line2);
      }
    };
    Context.prototype.save = function(copy2) {
      var state = copy2 !== false ? copyState(this.doc.mode, this.state) : this.state;
      return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
    };
    function highlightLine(cm, line2, context, forceToEnd) {
      var st = [cm.state.modeGen], lineClasses = {};
      runMode(cm, line2.text, cm.doc.mode, context, function(end, style2) {
        return st.push(end, style2);
      }, lineClasses, forceToEnd);
      var state = context.state;
      var loop = function(o3) {
        context.baseTokens = st;
        var overlay2 = cm.state.overlays[o3], i3 = 1, at2 = 0;
        context.state = true;
        runMode(cm, line2.text, overlay2.mode, context, function(end, style2) {
          var start2 = i3;
          while (at2 < end) {
            var i_end = st[i3];
            if (i_end > end) {
              st.splice(i3, 1, end, st[i3 + 1], i_end);
            }
            i3 += 2;
            at2 = Math.min(end, i_end);
          }
          if (!style2) {
            return;
          }
          if (overlay2.opaque) {
            st.splice(start2, i3 - start2, end, "overlay " + style2);
            i3 = start2 + 2;
          } else {
            for (; start2 < i3; start2 += 2) {
              var cur = st[start2 + 1];
              st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style2;
            }
          }
        }, lineClasses);
        context.state = state;
        context.baseTokens = null;
        context.baseTokenPos = 1;
      };
      for (var o2 = 0; o2 < cm.state.overlays.length; ++o2)
        loop(o2);
      return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
    }
    function getLineStyles(cm, line2, updateFrontier) {
      if (!line2.styles || line2.styles[0] != cm.state.modeGen) {
        var context = getContextBefore(cm, lineNo(line2));
        var resetState = line2.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
        var result = highlightLine(cm, line2, context);
        if (resetState) {
          context.state = resetState;
        }
        line2.stateAfter = context.save(!resetState);
        line2.styles = result.styles;
        if (result.classes) {
          line2.styleClasses = result.classes;
        } else if (line2.styleClasses) {
          line2.styleClasses = null;
        }
        if (updateFrontier === cm.doc.highlightFrontier) {
          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
        }
      }
      return line2.styles;
    }
    function getContextBefore(cm, n2, precise) {
      var doc2 = cm.doc, display = cm.display;
      if (!doc2.mode.startState) {
        return new Context(doc2, true, n2);
      }
      var start2 = findStartLine(cm, n2, precise);
      var saved = start2 > doc2.first && getLine2(doc2, start2 - 1).stateAfter;
      var context = saved ? Context.fromSaved(doc2, saved, start2) : new Context(doc2, startState(doc2.mode), start2);
      doc2.iter(start2, n2, function(line2) {
        processLine(cm, line2.text, context);
        var pos = context.line;
        line2.stateAfter = pos == n2 - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
        context.nextLine();
      });
      if (precise) {
        doc2.modeFrontier = context.line;
      }
      return context;
    }
    function processLine(cm, text3, context, startAt) {
      var mode = cm.doc.mode;
      var stream = new StringStream(text3, cm.options.tabSize, context);
      stream.start = stream.pos = startAt || 0;
      if (text3 == "") {
        callBlankLine(mode, context.state);
      }
      while (!stream.eol()) {
        readToken(mode, stream, context.state);
        stream.start = stream.pos;
      }
    }
    function callBlankLine(mode, state) {
      if (mode.blankLine) {
        return mode.blankLine(state);
      }
      if (!mode.innerMode) {
        return;
      }
      var inner = innerMode(mode, state);
      if (inner.mode.blankLine) {
        return inner.mode.blankLine(inner.state);
      }
    }
    function readToken(mode, stream, state, inner) {
      for (var i3 = 0; i3 < 10; i3++) {
        if (inner) {
          inner[0] = innerMode(mode, state).mode;
        }
        var style2 = mode.token(stream, state);
        if (stream.pos > stream.start) {
          return style2;
        }
      }
      throw new Error("Mode " + mode.name + " failed to advance stream.");
    }
    var Token2 = function(stream, type, state) {
      this.start = stream.start;
      this.end = stream.pos;
      this.string = stream.current();
      this.type = type || null;
      this.state = state;
    };
    function takeToken(cm, pos, precise, asArray) {
      var doc2 = cm.doc, mode = doc2.mode, style2;
      pos = clipPos(doc2, pos);
      var line2 = getLine2(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
      var stream = new StringStream(line2.text, cm.options.tabSize, context), tokens2;
      if (asArray) {
        tokens2 = [];
      }
      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
        stream.start = stream.pos;
        style2 = readToken(mode, stream, context.state);
        if (asArray) {
          tokens2.push(new Token2(stream, style2, copyState(doc2.mode, context.state)));
        }
      }
      return asArray ? tokens2 : new Token2(stream, style2, context.state);
    }
    function extractLineClasses(type, output) {
      if (type) {
        for (; ; ) {
          var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!lineClass) {
            break;
          }
          type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
          var prop3 = lineClass[1] ? "bgClass" : "textClass";
          if (output[prop3] == null) {
            output[prop3] = lineClass[2];
          } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop3])) {
            output[prop3] += " " + lineClass[2];
          }
        }
      }
      return type;
    }
    function runMode(cm, text3, mode, context, f2, lineClasses, forceToEnd) {
      var flattenSpans = mode.flattenSpans;
      if (flattenSpans == null) {
        flattenSpans = cm.options.flattenSpans;
      }
      var curStart = 0, curStyle = null;
      var stream = new StringStream(text3, cm.options.tabSize, context), style2;
      var inner = cm.options.addModeClass && [null];
      if (text3 == "") {
        extractLineClasses(callBlankLine(mode, context.state), lineClasses);
      }
      while (!stream.eol()) {
        if (stream.pos > cm.options.maxHighlightLength) {
          flattenSpans = false;
          if (forceToEnd) {
            processLine(cm, text3, context, stream.pos);
          }
          stream.pos = text3.length;
          style2 = null;
        } else {
          style2 = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
        }
        if (inner) {
          var mName = inner[0].name;
          if (mName) {
            style2 = "m-" + (style2 ? mName + " " + style2 : mName);
          }
        }
        if (!flattenSpans || curStyle != style2) {
          while (curStart < stream.start) {
            curStart = Math.min(stream.start, curStart + 5e3);
            f2(curStart, curStyle);
          }
          curStyle = style2;
        }
        stream.start = stream.pos;
      }
      while (curStart < stream.pos) {
        var pos = Math.min(stream.pos, curStart + 5e3);
        f2(pos, curStyle);
        curStart = pos;
      }
    }
    function findStartLine(cm, n2, precise) {
      var minindent, minline, doc2 = cm.doc;
      var lim = precise ? -1 : n2 - (cm.doc.mode.innerMode ? 1e3 : 100);
      for (var search2 = n2; search2 > lim; --search2) {
        if (search2 <= doc2.first) {
          return doc2.first;
        }
        var line2 = getLine2(doc2, search2 - 1), after = line2.stateAfter;
        if (after && (!precise || search2 + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
          return search2;
        }
        var indented = countColumn(line2.text, null, cm.options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search2 - 1;
          minindent = indented;
        }
      }
      return minline;
    }
    function retreatFrontier(doc2, n2) {
      doc2.modeFrontier = Math.min(doc2.modeFrontier, n2);
      if (doc2.highlightFrontier < n2 - 10) {
        return;
      }
      var start2 = doc2.first;
      for (var line2 = n2 - 1; line2 > start2; line2--) {
        var saved = getLine2(doc2, line2).stateAfter;
        if (saved && (!(saved instanceof SavedContext) || line2 + saved.lookAhead < n2)) {
          start2 = line2 + 1;
          break;
        }
      }
      doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start2);
    }
    var sawReadOnlySpans = false, sawCollapsedSpans = false;
    function seeReadOnlySpans() {
      sawReadOnlySpans = true;
    }
    function seeCollapsedSpans() {
      sawCollapsedSpans = true;
    }
    function MarkedSpan(marker2, from2, to2) {
      this.marker = marker2;
      this.from = from2;
      this.to = to2;
    }
    function getMarkedSpanFor(spans, marker2) {
      if (spans) {
        for (var i3 = 0; i3 < spans.length; ++i3) {
          var span = spans[i3];
          if (span.marker == marker2) {
            return span;
          }
        }
      }
    }
    function removeMarkedSpan(spans, span) {
      var r2;
      for (var i3 = 0; i3 < spans.length; ++i3) {
        if (spans[i3] != span) {
          (r2 || (r2 = [])).push(spans[i3]);
        }
      }
      return r2;
    }
    function addMarkedSpan(line2, span, op) {
      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
      if (inThisOp && line2.markedSpans && inThisOp.has(line2.markedSpans)) {
        line2.markedSpans.push(span);
      } else {
        line2.markedSpans = line2.markedSpans ? line2.markedSpans.concat([span]) : [span];
        if (inThisOp) {
          inThisOp.add(line2.markedSpans);
        }
      }
      span.marker.attachLine(line2);
    }
    function markedSpansBefore(old, startCh, isInsert) {
      var nw;
      if (old) {
        for (var i3 = 0; i3 < old.length; ++i3) {
          var span = old[i3], marker2 = span.marker;
          var startsBefore = span.from == null || (marker2.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || span.from == startCh && marker2.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker2.inclusiveRight ? span.to >= startCh : span.to > startCh);
            (nw || (nw = [])).push(new MarkedSpan(marker2, span.from, endsAfter ? null : span.to));
          }
        }
      }
      return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
      var nw;
      if (old) {
        for (var i3 = 0; i3 < old.length; ++i3) {
          var span = old[i3], marker2 = span.marker;
          var endsAfter = span.to == null || (marker2.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || span.from == endCh && marker2.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker2.inclusiveLeft ? span.from <= endCh : span.from < endCh);
            (nw || (nw = [])).push(new MarkedSpan(marker2, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
          }
        }
      }
      return nw;
    }
    function stretchSpansOverChange(doc2, change) {
      if (change.full) {
        return null;
      }
      var oldFirst = isLine(doc2, change.from.line) && getLine2(doc2, change.from.line).markedSpans;
      var oldLast = isLine(doc2, change.to.line) && getLine2(doc2, change.to.line).markedSpans;
      if (!oldFirst && !oldLast) {
        return null;
      }
      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
      var first = markedSpansBefore(oldFirst, startCh, isInsert);
      var last = markedSpansAfter(oldLast, endCh, isInsert);
      var sameLine = change.text.length == 1, offset2 = lst(change.text).length + (sameLine ? startCh : 0);
      if (first) {
        for (var i3 = 0; i3 < first.length; ++i3) {
          var span = first[i3];
          if (span.to == null) {
            var found = getMarkedSpanFor(last, span.marker);
            if (!found) {
              span.to = startCh;
            } else if (sameLine) {
              span.to = found.to == null ? null : found.to + offset2;
            }
          }
        }
      }
      if (last) {
        for (var i$13 = 0; i$13 < last.length; ++i$13) {
          var span$1 = last[i$13];
          if (span$1.to != null) {
            span$1.to += offset2;
          }
          if (span$1.from == null) {
            var found$1 = getMarkedSpanFor(first, span$1.marker);
            if (!found$1) {
              span$1.from = offset2;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          } else {
            span$1.from += offset2;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        }
      }
      if (first) {
        first = clearEmptySpans(first);
      }
      if (last && last != first) {
        last = clearEmptySpans(last);
      }
      var newMarkers = [first];
      if (!sameLine) {
        var gap2 = change.text.length - 2, gapMarkers;
        if (gap2 > 0 && first) {
          for (var i$23 = 0; i$23 < first.length; ++i$23) {
            if (first[i$23].to == null) {
              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$23].marker, null, null));
            }
          }
        }
        for (var i$3 = 0; i$3 < gap2; ++i$3) {
          newMarkers.push(gapMarkers);
        }
        newMarkers.push(last);
      }
      return newMarkers;
    }
    function clearEmptySpans(spans) {
      for (var i3 = 0; i3 < spans.length; ++i3) {
        var span = spans[i3];
        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
          spans.splice(i3--, 1);
        }
      }
      if (!spans.length) {
        return null;
      }
      return spans;
    }
    function removeReadOnlyRanges(doc2, from2, to2) {
      var markers = null;
      doc2.iter(from2.line, to2.line + 1, function(line2) {
        if (line2.markedSpans) {
          for (var i4 = 0; i4 < line2.markedSpans.length; ++i4) {
            var mark = line2.markedSpans[i4].marker;
            if (mark.readOnly && (!markers || indexOf2(markers, mark) == -1)) {
              (markers || (markers = [])).push(mark);
            }
          }
        }
      });
      if (!markers) {
        return null;
      }
      var parts = [{ from: from2, to: to2 }];
      for (var i3 = 0; i3 < markers.length; ++i3) {
        var mk = markers[i3], m2 = mk.find(0);
        for (var j2 = 0; j2 < parts.length; ++j2) {
          var p2 = parts[j2];
          if (cmp(p2.to, m2.from) < 0 || cmp(p2.from, m2.to) > 0) {
            continue;
          }
          var newParts = [j2, 1], dfrom = cmp(p2.from, m2.from), dto = cmp(p2.to, m2.to);
          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
            newParts.push({ from: p2.from, to: m2.from });
          }
          if (dto > 0 || !mk.inclusiveRight && !dto) {
            newParts.push({ from: m2.to, to: p2.to });
          }
          parts.splice.apply(parts, newParts);
          j2 += newParts.length - 3;
        }
      }
      return parts;
    }
    function detachMarkedSpans(line2) {
      var spans = line2.markedSpans;
      if (!spans) {
        return;
      }
      for (var i3 = 0; i3 < spans.length; ++i3) {
        spans[i3].marker.detachLine(line2);
      }
      line2.markedSpans = null;
    }
    function attachMarkedSpans(line2, spans) {
      if (!spans) {
        return;
      }
      for (var i3 = 0; i3 < spans.length; ++i3) {
        spans[i3].marker.attachLine(line2);
      }
      line2.markedSpans = spans;
    }
    function extraLeft(marker2) {
      return marker2.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker2) {
      return marker2.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a2, b2) {
      var lenDiff = a2.lines.length - b2.lines.length;
      if (lenDiff != 0) {
        return lenDiff;
      }
      var aPos = a2.find(), bPos = b2.find();
      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a2) - extraLeft(b2);
      if (fromCmp) {
        return -fromCmp;
      }
      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a2) - extraRight(b2);
      if (toCmp) {
        return toCmp;
      }
      return b2.id - a2.id;
    }
    function collapsedSpanAtSide(line2, start2) {
      var sps = sawCollapsedSpans && line2.markedSpans, found;
      if (sps) {
        for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
          sp = sps[i3];
          if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function collapsedSpanAtStart(line2) {
      return collapsedSpanAtSide(line2, true);
    }
    function collapsedSpanAtEnd(line2) {
      return collapsedSpanAtSide(line2, false);
    }
    function collapsedSpanAround(line2, ch) {
      var sps = sawCollapsedSpans && line2.markedSpans, found;
      if (sps) {
        for (var i3 = 0; i3 < sps.length; ++i3) {
          var sp = sps[i3];
          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function conflictingCollapsedRange(doc2, lineNo2, from2, to2, marker2) {
      var line2 = getLine2(doc2, lineNo2);
      var sps = sawCollapsedSpans && line2.markedSpans;
      if (sps) {
        for (var i3 = 0; i3 < sps.length; ++i3) {
          var sp = sps[i3];
          if (!sp.marker.collapsed) {
            continue;
          }
          var found = sp.marker.find(0);
          var fromCmp = cmp(found.from, from2) || extraLeft(sp.marker) - extraLeft(marker2);
          var toCmp = cmp(found.to, to2) || extraRight(sp.marker) - extraRight(marker2);
          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
            continue;
          }
          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker2.inclusiveLeft ? cmp(found.to, from2) >= 0 : cmp(found.to, from2) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker2.inclusiveLeft ? cmp(found.from, to2) <= 0 : cmp(found.from, to2) < 0)) {
            return true;
          }
        }
      }
    }
    function visualLine(line2) {
      var merged;
      while (merged = collapsedSpanAtStart(line2)) {
        line2 = merged.find(-1, true).line;
      }
      return line2;
    }
    function visualLineEnd(line2) {
      var merged;
      while (merged = collapsedSpanAtEnd(line2)) {
        line2 = merged.find(1, true).line;
      }
      return line2;
    }
    function visualLineContinued(line2) {
      var merged, lines;
      while (merged = collapsedSpanAtEnd(line2)) {
        line2 = merged.find(1, true).line;
        (lines || (lines = [])).push(line2);
      }
      return lines;
    }
    function visualLineNo(doc2, lineN) {
      var line2 = getLine2(doc2, lineN), vis = visualLine(line2);
      if (line2 == vis) {
        return lineN;
      }
      return lineNo(vis);
    }
    function visualLineEndNo(doc2, lineN) {
      if (lineN > doc2.lastLine()) {
        return lineN;
      }
      var line2 = getLine2(doc2, lineN), merged;
      if (!lineIsHidden(doc2, line2)) {
        return lineN;
      }
      while (merged = collapsedSpanAtEnd(line2)) {
        line2 = merged.find(1, true).line;
      }
      return lineNo(line2) + 1;
    }
    function lineIsHidden(doc2, line2) {
      var sps = sawCollapsedSpans && line2.markedSpans;
      if (sps) {
        for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
          sp = sps[i3];
          if (!sp.marker.collapsed) {
            continue;
          }
          if (sp.from == null) {
            return true;
          }
          if (sp.marker.widgetNode) {
            continue;
          }
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line2, sp)) {
            return true;
          }
        }
      }
    }
    function lineIsHiddenInner(doc2, line2, span) {
      if (span.to == null) {
        var end = span.marker.find(1, true);
        return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
      }
      if (span.marker.inclusiveRight && span.to == line2.text.length) {
        return true;
      }
      for (var sp = void 0, i3 = 0; i3 < line2.markedSpans.length; ++i3) {
        sp = line2.markedSpans[i3];
        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line2, sp)) {
          return true;
        }
      }
    }
    function heightAtLine(lineObj) {
      lineObj = visualLine(lineObj);
      var h2 = 0, chunk = lineObj.parent;
      for (var i3 = 0; i3 < chunk.lines.length; ++i3) {
        var line2 = chunk.lines[i3];
        if (line2 == lineObj) {
          break;
        } else {
          h2 += line2.height;
        }
      }
      for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {
        for (var i$13 = 0; i$13 < p2.children.length; ++i$13) {
          var cur = p2.children[i$13];
          if (cur == chunk) {
            break;
          } else {
            h2 += cur.height;
          }
        }
      }
      return h2;
    }
    function lineLength(line2) {
      if (line2.height == 0) {
        return 0;
      }
      var len2 = line2.text.length, merged, cur = line2;
      while (merged = collapsedSpanAtStart(cur)) {
        var found = merged.find(0, true);
        cur = found.from.line;
        len2 += found.from.ch - found.to.ch;
      }
      cur = line2;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found$1 = merged.find(0, true);
        len2 -= cur.text.length - found$1.from.ch;
        cur = found$1.to.line;
        len2 += cur.text.length - found$1.to.ch;
      }
      return len2;
    }
    function findMaxLine(cm) {
      var d2 = cm.display, doc2 = cm.doc;
      d2.maxLine = getLine2(doc2, doc2.first);
      d2.maxLineLength = lineLength(d2.maxLine);
      d2.maxLineChanged = true;
      doc2.iter(function(line2) {
        var len2 = lineLength(line2);
        if (len2 > d2.maxLineLength) {
          d2.maxLineLength = len2;
          d2.maxLine = line2;
        }
      });
    }
    var Line = function(text3, markedSpans, estimateHeight2) {
      this.text = text3;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight2 ? estimateHeight2(this) : 1;
    };
    Line.prototype.lineNo = function() {
      return lineNo(this);
    };
    eventMixin(Line);
    function updateLine(line2, text3, markedSpans, estimateHeight2) {
      line2.text = text3;
      if (line2.stateAfter) {
        line2.stateAfter = null;
      }
      if (line2.styles) {
        line2.styles = null;
      }
      if (line2.order != null) {
        line2.order = null;
      }
      detachMarkedSpans(line2);
      attachMarkedSpans(line2, markedSpans);
      var estHeight = estimateHeight2 ? estimateHeight2(line2) : 1;
      if (estHeight != line2.height) {
        updateLineHeight(line2, estHeight);
      }
    }
    function cleanUpLine(line2) {
      line2.parent = null;
      detachMarkedSpans(line2);
    }
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style2, options) {
      if (!style2 || /^\s*$/.test(style2)) {
        return null;
      }
      var cache2 = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
      return cache2[style2] || (cache2[style2] = style2.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent(cm, lineView) {
      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
      var builder = {
        pre: eltP("pre", [content], "CodeMirror-line"),
        content,
        col: 0,
        pos: 0,
        cm,
        trailingSpace: false,
        splitSpaces: cm.getOption("lineWrapping")
      };
      lineView.measure = {};
      for (var i3 = 0; i3 <= (lineView.rest ? lineView.rest.length : 0); i3++) {
        var line2 = i3 ? lineView.rest[i3 - 1] : lineView.line, order2 = void 0;
        builder.pos = 0;
        builder.addToken = buildToken;
        if (hasBadBidiRects(cm.display.measure) && (order2 = getOrder(line2, cm.doc.direction))) {
          builder.addToken = buildTokenBadBidi(builder.addToken, order2);
        }
        builder.map = [];
        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line2);
        insertLineContent(line2, builder, getLineStyles(cm, line2, allowFrontierUpdate));
        if (line2.styleClasses) {
          if (line2.styleClasses.bgClass) {
            builder.bgClass = joinClasses(line2.styleClasses.bgClass, builder.bgClass || "");
          }
          if (line2.styleClasses.textClass) {
            builder.textClass = joinClasses(line2.styleClasses.textClass, builder.textClass || "");
          }
        }
        if (builder.map.length == 0) {
          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
        }
        if (i3 == 0) {
          lineView.measure.map = builder.map;
          lineView.measure.cache = {};
        } else {
          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
        }
      }
      if (webkit) {
        var last = builder.content.lastChild;
        if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
          builder.content.className = "cm-tab-wrap-hack";
        }
      }
      signal(cm, "renderLine", cm, lineView.line, builder.pre);
      if (builder.pre.className) {
        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
      }
      return builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
      var token2 = elt("span", "\u2022", "cm-invalidchar");
      token2.title = "\\u" + ch.charCodeAt(0).toString(16);
      token2.setAttribute("aria-label", token2.title);
      return token2;
    }
    function buildToken(builder, text3, style2, startStyle, endStyle, css, attributes) {
      if (!text3) {
        return;
      }
      var displayText = builder.splitSpaces ? splitSpaces(text3, builder.trailingSpace) : text3;
      var special = builder.cm.state.specialChars, mustWrap = false;
      var content;
      if (!special.test(text3)) {
        builder.col += text3.length;
        content = document.createTextNode(displayText);
        builder.map.push(builder.pos, builder.pos + text3.length, content);
        if (ie2 && ie_version < 9) {
          mustWrap = true;
        }
        builder.pos += text3.length;
      } else {
        content = document.createDocumentFragment();
        var pos = 0;
        while (true) {
          special.lastIndex = pos;
          var m2 = special.exec(text3);
          var skipped = m2 ? m2.index - pos : text3.length - pos;
          if (skipped) {
            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
            if (ie2 && ie_version < 9) {
              content.appendChild(elt("span", [txt]));
            } else {
              content.appendChild(txt);
            }
            builder.map.push(builder.pos, builder.pos + skipped, txt);
            builder.col += skipped;
            builder.pos += skipped;
          }
          if (!m2) {
            break;
          }
          pos += skipped + 1;
          var txt$1 = void 0;
          if (m2[0] == "	") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
            txt$1.setAttribute("role", "presentation");
            txt$1.setAttribute("cm-text", "	");
            builder.col += tabWidth;
          } else if (m2[0] == "\r" || m2[0] == "\n") {
            txt$1 = content.appendChild(elt("span", m2[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
            txt$1.setAttribute("cm-text", m2[0]);
            builder.col += 1;
          } else {
            txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);
            txt$1.setAttribute("cm-text", m2[0]);
            if (ie2 && ie_version < 9) {
              content.appendChild(elt("span", [txt$1]));
            } else {
              content.appendChild(txt$1);
            }
            builder.col += 1;
          }
          builder.map.push(builder.pos, builder.pos + 1, txt$1);
          builder.pos++;
        }
      }
      builder.trailingSpace = displayText.charCodeAt(text3.length - 1) == 32;
      if (style2 || startStyle || endStyle || mustWrap || css || attributes) {
        var fullStyle = style2 || "";
        if (startStyle) {
          fullStyle += startStyle;
        }
        if (endStyle) {
          fullStyle += endStyle;
        }
        var token2 = elt("span", [content], fullStyle, css);
        if (attributes) {
          for (var attr in attributes) {
            if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
              token2.setAttribute(attr, attributes[attr]);
            }
          }
        }
        return builder.content.appendChild(token2);
      }
      builder.content.appendChild(content);
    }
    function splitSpaces(text3, trailingBefore) {
      if (text3.length > 1 && !/  /.test(text3)) {
        return text3;
      }
      var spaceBefore = trailingBefore, result = "";
      for (var i3 = 0; i3 < text3.length; i3++) {
        var ch = text3.charAt(i3);
        if (ch == " " && spaceBefore && (i3 == text3.length - 1 || text3.charCodeAt(i3 + 1) == 32)) {
          ch = "\xA0";
        }
        result += ch;
        spaceBefore = ch == " ";
      }
      return result;
    }
    function buildTokenBadBidi(inner, order2) {
      return function(builder, text3, style2, startStyle, endStyle, css, attributes) {
        style2 = style2 ? style2 + " cm-force-border" : "cm-force-border";
        var start2 = builder.pos, end = start2 + text3.length;
        for (; ; ) {
          var part2 = void 0;
          for (var i3 = 0; i3 < order2.length; i3++) {
            part2 = order2[i3];
            if (part2.to > start2 && part2.from <= start2) {
              break;
            }
          }
          if (part2.to >= end) {
            return inner(builder, text3, style2, startStyle, endStyle, css, attributes);
          }
          inner(builder, text3.slice(0, part2.to - start2), style2, startStyle, null, css, attributes);
          startStyle = null;
          text3 = text3.slice(part2.to - start2);
          start2 = part2.to;
        }
      };
    }
    function buildCollapsedSpan(builder, size2, marker2, ignoreWidget) {
      var widget = !ignoreWidget && marker2.widgetNode;
      if (widget) {
        builder.map.push(builder.pos, builder.pos + size2, widget);
      }
      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
        if (!widget) {
          widget = builder.content.appendChild(document.createElement("span"));
        }
        widget.setAttribute("cm-marker", marker2.id);
      }
      if (widget) {
        builder.cm.display.input.setUneditable(widget);
        builder.content.appendChild(widget);
      }
      builder.pos += size2;
      builder.trailingSpace = false;
    }
    function insertLineContent(line2, builder, styles) {
      var spans = line2.markedSpans, allText = line2.text, at2 = 0;
      if (!spans) {
        for (var i$13 = 1; i$13 < styles.length; i$13 += 2) {
          builder.addToken(builder, allText.slice(at2, at2 = styles[i$13]), interpretTokenStyle(styles[i$13 + 1], builder.cm.options));
        }
        return;
      }
      var len2 = allText.length, pos = 0, i3 = 1, text3 = "", style2, css;
      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
      for (; ; ) {
        if (nextChange == pos) {
          spanStyle = spanEndStyle = spanStartStyle = css = "";
          attributes = null;
          collapsed = null;
          nextChange = Infinity;
          var foundBookmarks = [], endStyles = void 0;
          for (var j2 = 0; j2 < spans.length; ++j2) {
            var sp = spans[j2], m2 = sp.marker;
            if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {
              foundBookmarks.push(m2);
            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {
              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                nextChange = sp.to;
                spanEndStyle = "";
              }
              if (m2.className) {
                spanStyle += " " + m2.className;
              }
              if (m2.css) {
                css = (css ? css + ";" : "") + m2.css;
              }
              if (m2.startStyle && sp.from == pos) {
                spanStartStyle += " " + m2.startStyle;
              }
              if (m2.endStyle && sp.to == nextChange) {
                (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);
              }
              if (m2.title) {
                (attributes || (attributes = {})).title = m2.title;
              }
              if (m2.attributes) {
                for (var attr in m2.attributes) {
                  (attributes || (attributes = {}))[attr] = m2.attributes[attr];
                }
              }
              if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {
                collapsed = sp;
              }
            } else if (sp.from > pos && nextChange > sp.from) {
              nextChange = sp.from;
            }
          }
          if (endStyles) {
            for (var j$12 = 0; j$12 < endStyles.length; j$12 += 2) {
              if (endStyles[j$12 + 1] == nextChange) {
                spanEndStyle += " " + endStyles[j$12];
              }
            }
          }
          if (!collapsed || collapsed.from == pos) {
            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
            }
          }
          if (collapsed && (collapsed.from || 0) == pos) {
            buildCollapsedSpan(builder, (collapsed.to == null ? len2 + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
            if (collapsed.to == null) {
              return;
            }
            if (collapsed.to == pos) {
              collapsed = false;
            }
          }
        }
        if (pos >= len2) {
          break;
        }
        var upto = Math.min(len2, nextChange);
        while (true) {
          if (text3) {
            var end = pos + text3.length;
            if (!collapsed) {
              var tokenText = end > upto ? text3.slice(0, upto - pos) : text3;
              builder.addToken(builder, tokenText, style2 ? style2 + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
            }
            if (end >= upto) {
              text3 = text3.slice(upto - pos);
              pos = upto;
              break;
            }
            pos = end;
            spanStartStyle = "";
          }
          text3 = allText.slice(at2, at2 = styles[i3++]);
          style2 = interpretTokenStyle(styles[i3++], builder.cm.options);
        }
      }
    }
    function LineView(doc2, line2, lineN) {
      this.line = line2;
      this.rest = visualLineContinued(line2);
      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
      this.node = this.text = null;
      this.hidden = lineIsHidden(doc2, line2);
    }
    function buildViewArray(cm, from2, to2) {
      var array2 = [], nextPos;
      for (var pos = from2; pos < to2; pos = nextPos) {
        var view = new LineView(cm.doc, getLine2(cm.doc, pos), pos);
        nextPos = pos + view.size;
        array2.push(view);
      }
      return array2;
    }
    var operationGroup = null;
    function pushOperation(op) {
      if (operationGroup) {
        operationGroup.ops.push(op);
      } else {
        op.ownsGroup = operationGroup = {
          ops: [op],
          delayedCallbacks: []
        };
      }
    }
    function fireCallbacksForOps(group) {
      var callbacks2 = group.delayedCallbacks, i3 = 0;
      do {
        for (; i3 < callbacks2.length; i3++) {
          callbacks2[i3].call(null);
        }
        for (var j2 = 0; j2 < group.ops.length; j2++) {
          var op = group.ops[j2];
          if (op.cursorActivityHandlers) {
            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
            }
          }
        }
      } while (i3 < callbacks2.length);
    }
    function finishOperation(op, endCb) {
      var group = op.ownsGroup;
      if (!group) {
        return;
      }
      try {
        fireCallbacksForOps(group);
      } finally {
        operationGroup = null;
        endCb(group);
      }
    }
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type) {
      var arr = getHandlers(emitter, type);
      if (!arr.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2), list3;
      if (operationGroup) {
        list3 = operationGroup.delayedCallbacks;
      } else if (orphanDelayedCallbacks) {
        list3 = orphanDelayedCallbacks;
      } else {
        list3 = orphanDelayedCallbacks = [];
        setTimeout(fireOrphanDelayed, 0);
      }
      var loop = function(i4) {
        list3.push(function() {
          return arr[i4].apply(null, args);
        });
      };
      for (var i3 = 0; i3 < arr.length; ++i3)
        loop(i3);
    }
    function fireOrphanDelayed() {
      var delayed = orphanDelayedCallbacks;
      orphanDelayedCallbacks = null;
      for (var i3 = 0; i3 < delayed.length; ++i3) {
        delayed[i3]();
      }
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
      for (var j2 = 0; j2 < lineView.changes.length; j2++) {
        var type = lineView.changes[j2];
        if (type == "text") {
          updateLineText(cm, lineView);
        } else if (type == "gutter") {
          updateLineGutter(cm, lineView, lineN, dims);
        } else if (type == "class") {
          updateLineClasses(cm, lineView);
        } else if (type == "widget") {
          updateLineWidgets(cm, lineView, dims);
        }
      }
      lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
      if (lineView.node == lineView.text) {
        lineView.node = elt("div", null, null, "position: relative");
        if (lineView.text.parentNode) {
          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
        }
        lineView.node.appendChild(lineView.text);
        if (ie2 && ie_version < 8) {
          lineView.node.style.zIndex = 2;
        }
      }
      return lineView.node;
    }
    function updateLineBackground(cm, lineView) {
      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
      if (cls) {
        cls += " CodeMirror-linebackground";
      }
      if (lineView.background) {
        if (cls) {
          lineView.background.className = cls;
        } else {
          lineView.background.parentNode.removeChild(lineView.background);
          lineView.background = null;
        }
      } else if (cls) {
        var wrap2 = ensureLineWrapped(lineView);
        lineView.background = wrap2.insertBefore(elt("div", null, cls), wrap2.firstChild);
        cm.display.input.setUneditable(lineView.background);
      }
    }
    function getLineContent(cm, lineView) {
      var ext = cm.display.externalMeasured;
      if (ext && ext.line == lineView.line) {
        cm.display.externalMeasured = null;
        lineView.measure = ext.measure;
        return ext.built;
      }
      return buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
      var cls = lineView.text.className;
      var built = getLineContent(cm, lineView);
      if (lineView.text == lineView.node) {
        lineView.node = built.pre;
      }
      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
      lineView.text = built.pre;
      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
        lineView.bgClass = built.bgClass;
        lineView.textClass = built.textClass;
        updateLineClasses(cm, lineView);
      } else if (cls) {
        lineView.text.className = cls;
      }
    }
    function updateLineClasses(cm, lineView) {
      updateLineBackground(cm, lineView);
      if (lineView.line.wrapClass) {
        ensureLineWrapped(lineView).className = lineView.line.wrapClass;
      } else if (lineView.node != lineView.text) {
        lineView.node.className = "";
      }
      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
      lineView.text.className = textClass || "";
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
      if (lineView.gutter) {
        lineView.node.removeChild(lineView.gutter);
        lineView.gutter = null;
      }
      if (lineView.gutterBackground) {
        lineView.node.removeChild(lineView.gutterBackground);
        lineView.gutterBackground = null;
      }
      if (lineView.line.gutterClass) {
        var wrap2 = ensureLineWrapped(lineView);
        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
        cm.display.input.setUneditable(lineView.gutterBackground);
        wrap2.insertBefore(lineView.gutterBackground, lineView.text);
      }
      var markers = lineView.line.gutterMarkers;
      if (cm.options.lineNumbers || markers) {
        var wrap$1 = ensureLineWrapped(lineView);
        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
        gutterWrap.setAttribute("aria-hidden", "true");
        cm.display.input.setUneditable(gutterWrap);
        wrap$1.insertBefore(gutterWrap, lineView.text);
        if (lineView.line.gutterClass) {
          gutterWrap.className += " " + lineView.line.gutterClass;
        }
        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
          lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
        }
        if (markers) {
          for (var k2 = 0; k2 < cm.display.gutterSpecs.length; ++k2) {
            var id2 = cm.display.gutterSpecs[k2].className, found = markers.hasOwnProperty(id2) && markers[id2];
            if (found) {
              gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id2] + "px; width: " + dims.gutterWidth[id2] + "px"));
            }
          }
        }
      }
    }
    function updateLineWidgets(cm, lineView, dims) {
      if (lineView.alignable) {
        lineView.alignable = null;
      }
      var isWidget = classTest("CodeMirror-linewidget");
      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
        next = node.nextSibling;
        if (isWidget.test(node.className)) {
          lineView.node.removeChild(node);
        }
      }
      insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
      var built = getLineContent(cm, lineView);
      lineView.text = lineView.node = built.pre;
      if (built.bgClass) {
        lineView.bgClass = built.bgClass;
      }
      if (built.textClass) {
        lineView.textClass = built.textClass;
      }
      updateLineClasses(cm, lineView);
      updateLineGutter(cm, lineView, lineN, dims);
      insertLineWidgets(cm, lineView, dims);
      return lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
      if (lineView.rest) {
        for (var i3 = 0; i3 < lineView.rest.length; i3++) {
          insertLineWidgetsFor(cm, lineView.rest[i3], lineView, dims, false);
        }
      }
    }
    function insertLineWidgetsFor(cm, line2, lineView, dims, allowAbove) {
      if (!line2.widgets) {
        return;
      }
      var wrap2 = ensureLineWrapped(lineView);
      for (var i3 = 0, ws = line2.widgets; i3 < ws.length; ++i3) {
        var widget = ws[i3], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
        if (!widget.handleMouseEvents) {
          node.setAttribute("cm-ignore-events", "true");
        }
        positionLineWidget(widget, node, lineView, dims);
        cm.display.input.setUneditable(node);
        if (allowAbove && widget.above) {
          wrap2.insertBefore(node, lineView.gutter || lineView.text);
        } else {
          wrap2.appendChild(node);
        }
        signalLater(widget, "redraw");
      }
    }
    function positionLineWidget(widget, node, lineView, dims) {
      if (widget.noHScroll) {
        (lineView.alignable || (lineView.alignable = [])).push(node);
        var width = dims.wrapperWidth;
        node.style.left = dims.fixedPos + "px";
        if (!widget.coverGutter) {
          width -= dims.gutterTotalWidth;
          node.style.paddingLeft = dims.gutterTotalWidth + "px";
        }
        node.style.width = width + "px";
      }
      if (widget.coverGutter) {
        node.style.zIndex = 5;
        node.style.position = "relative";
        if (!widget.noHScroll) {
          node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }
    }
    function widgetHeight(widget) {
      if (widget.height != null) {
        return widget.height;
      }
      var cm = widget.doc.cm;
      if (!cm) {
        return 0;
      }
      if (!contains2(document.body, widget.node)) {
        var parentStyle = "position: relative;";
        if (widget.coverGutter) {
          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
        }
        if (widget.noHScroll) {
          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
        }
        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
      }
      return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget(display, e2) {
      for (var n2 = e_target(e2); n2 != display.wrapper; n2 = n2.parentNode) {
        if (!n2 || n2.nodeType == 1 && n2.getAttribute("cm-ignore-events") == "true" || n2.parentNode == display.sizer && n2 != display.mover) {
          return true;
        }
      }
    }
    function paddingTop(display) {
      return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
      return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
      if (display.cachedPaddingH) {
        return display.cachedPaddingH;
      }
      var e2 = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
      var style2 = window.getComputedStyle ? window.getComputedStyle(e2) : e2.currentStyle;
      var data2 = { left: parseInt(style2.paddingLeft), right: parseInt(style2.paddingRight) };
      if (!isNaN(data2.left) && !isNaN(data2.right)) {
        display.cachedPaddingH = data2;
      }
      return data2;
    }
    function scrollGap(cm) {
      return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect2) {
      var wrapping = cm.options.lineWrapping;
      var curWidth = wrapping && displayWidth(cm);
      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
        var heights = lineView.measure.heights = [];
        if (wrapping) {
          lineView.measure.width = curWidth;
          var rects = lineView.text.firstChild.getClientRects();
          for (var i3 = 0; i3 < rects.length - 1; i3++) {
            var cur = rects[i3], next = rects[i3 + 1];
            if (Math.abs(cur.bottom - next.bottom) > 2) {
              heights.push((cur.bottom + next.top) / 2 - rect2.top);
            }
          }
        }
        heights.push(rect2.bottom - rect2.top);
      }
    }
    function mapFromLineView(lineView, line2, lineN) {
      if (lineView.line == line2) {
        return { map: lineView.measure.map, cache: lineView.measure.cache };
      }
      if (lineView.rest) {
        for (var i3 = 0; i3 < lineView.rest.length; i3++) {
          if (lineView.rest[i3] == line2) {
            return { map: lineView.measure.maps[i3], cache: lineView.measure.caches[i3] };
          }
        }
        for (var i$13 = 0; i$13 < lineView.rest.length; i$13++) {
          if (lineNo(lineView.rest[i$13]) > lineN) {
            return { map: lineView.measure.maps[i$13], cache: lineView.measure.caches[i$13], before: true };
          }
        }
      }
    }
    function updateExternalMeasurement(cm, line2) {
      line2 = visualLine(line2);
      var lineN = lineNo(line2);
      var view = cm.display.externalMeasured = new LineView(cm.doc, line2, lineN);
      view.lineN = lineN;
      var built = view.built = buildLineContent(cm, view);
      view.text = built.pre;
      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
      return view;
    }
    function measureChar(cm, line2, ch, bias) {
      return measureCharPrepared(cm, prepareMeasureForLine(cm, line2), ch, bias);
    }
    function findViewForLine(cm, lineN) {
      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
        return cm.display.view[findViewIndex(cm, lineN)];
      }
      var ext = cm.display.externalMeasured;
      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
        return ext;
      }
    }
    function prepareMeasureForLine(cm, line2) {
      var lineN = lineNo(line2);
      var view = findViewForLine(cm, lineN);
      if (view && !view.text) {
        view = null;
      } else if (view && view.changes) {
        updateLineForChanges(cm, view, lineN, getDimensions2(cm));
        cm.curOp.forceUpdate = true;
      }
      if (!view) {
        view = updateExternalMeasurement(cm, line2);
      }
      var info = mapFromLineView(view, line2, lineN);
      return {
        line: line2,
        view,
        rect: null,
        map: info.map,
        cache: info.cache,
        before: info.before,
        hasHeights: false
      };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
      if (prepared.before) {
        ch = -1;
      }
      var key = ch + (bias || ""), found;
      if (prepared.cache.hasOwnProperty(key)) {
        found = prepared.cache[key];
      } else {
        if (!prepared.rect) {
          prepared.rect = prepared.view.text.getBoundingClientRect();
        }
        if (!prepared.hasHeights) {
          ensureLineHeights(cm, prepared.view, prepared.rect);
          prepared.hasHeights = true;
        }
        found = measureCharInner(cm, prepared, ch, bias);
        if (!found.bogus) {
          prepared.cache[key] = found;
        }
      }
      return {
        left: found.left,
        right: found.right,
        top: varHeight ? found.rtop : found.top,
        bottom: varHeight ? found.rbottom : found.bottom
      };
    }
    var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
    function nodeAndOffsetInLineMap(map3, ch, bias) {
      var node, start2, end, collapse, mStart, mEnd;
      for (var i3 = 0; i3 < map3.length; i3 += 3) {
        mStart = map3[i3];
        mEnd = map3[i3 + 1];
        if (ch < mStart) {
          start2 = 0;
          end = 1;
          collapse = "left";
        } else if (ch < mEnd) {
          start2 = ch - mStart;
          end = start2 + 1;
        } else if (i3 == map3.length - 3 || ch == mEnd && map3[i3 + 3] > ch) {
          end = mEnd - mStart;
          start2 = end - 1;
          if (ch >= mEnd) {
            collapse = "right";
          }
        }
        if (start2 != null) {
          node = map3[i3 + 2];
          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
            collapse = bias;
          }
          if (bias == "left" && start2 == 0) {
            while (i3 && map3[i3 - 2] == map3[i3 - 3] && map3[i3 - 1].insertLeft) {
              node = map3[(i3 -= 3) + 2];
              collapse = "left";
            }
          }
          if (bias == "right" && start2 == mEnd - mStart) {
            while (i3 < map3.length - 3 && map3[i3 + 3] == map3[i3 + 4] && !map3[i3 + 5].insertLeft) {
              node = map3[(i3 += 3) + 2];
              collapse = "right";
            }
          }
          break;
        }
      }
      return { node, start: start2, end, collapse, coverStart: mStart, coverEnd: mEnd };
    }
    function getUsefulRect(rects, bias) {
      var rect2 = nullRect;
      if (bias == "left") {
        for (var i3 = 0; i3 < rects.length; i3++) {
          if ((rect2 = rects[i3]).left != rect2.right) {
            break;
          }
        }
      } else {
        for (var i$13 = rects.length - 1; i$13 >= 0; i$13--) {
          if ((rect2 = rects[i$13]).left != rect2.right) {
            break;
          }
        }
      }
      return rect2;
    }
    function measureCharInner(cm, prepared, ch, bias) {
      var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
      var node = place.node, start2 = place.start, end = place.end, collapse = place.collapse;
      var rect2;
      if (node.nodeType == 3) {
        for (var i$13 = 0; i$13 < 4; i$13++) {
          while (start2 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start2))) {
            --start2;
          }
          while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
            ++end;
          }
          if (ie2 && ie_version < 9 && start2 == 0 && end == place.coverEnd - place.coverStart) {
            rect2 = node.parentNode.getBoundingClientRect();
          } else {
            rect2 = getUsefulRect(range2(node, start2, end).getClientRects(), bias);
          }
          if (rect2.left || rect2.right || start2 == 0) {
            break;
          }
          end = start2;
          start2 = start2 - 1;
          collapse = "right";
        }
        if (ie2 && ie_version < 11) {
          rect2 = maybeUpdateRectForZooming(cm.display.measure, rect2);
        }
      } else {
        if (start2 > 0) {
          collapse = bias = "right";
        }
        var rects;
        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
          rect2 = rects[bias == "right" ? rects.length - 1 : 0];
        } else {
          rect2 = node.getBoundingClientRect();
        }
      }
      if (ie2 && ie_version < 9 && !start2 && (!rect2 || !rect2.left && !rect2.right)) {
        var rSpan = node.parentNode.getClientRects()[0];
        if (rSpan) {
          rect2 = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
        } else {
          rect2 = nullRect;
        }
      }
      var rtop = rect2.top - prepared.rect.top, rbot = rect2.bottom - prepared.rect.top;
      var mid2 = (rtop + rbot) / 2;
      var heights = prepared.view.measure.heights;
      var i3 = 0;
      for (; i3 < heights.length - 1; i3++) {
        if (mid2 < heights[i3]) {
          break;
        }
      }
      var top2 = i3 ? heights[i3 - 1] : 0, bot2 = heights[i3];
      var result = {
        left: (collapse == "right" ? rect2.right : rect2.left) - prepared.rect.left,
        right: (collapse == "left" ? rect2.left : rect2.right) - prepared.rect.left,
        top: top2,
        bottom: bot2
      };
      if (!rect2.left && !rect2.right) {
        result.bogus = true;
      }
      if (!cm.options.singleCursorHeightPerLine) {
        result.rtop = rtop;
        result.rbottom = rbot;
      }
      return result;
    }
    function maybeUpdateRectForZooming(measure, rect2) {
      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
        return rect2;
      }
      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
      return {
        left: rect2.left * scaleX,
        right: rect2.right * scaleX,
        top: rect2.top * scaleY,
        bottom: rect2.bottom * scaleY
      };
    }
    function clearLineMeasurementCacheFor(lineView) {
      if (lineView.measure) {
        lineView.measure.cache = {};
        lineView.measure.heights = null;
        if (lineView.rest) {
          for (var i3 = 0; i3 < lineView.rest.length; i3++) {
            lineView.measure.caches[i3] = {};
          }
        }
      }
    }
    function clearLineMeasurementCache(cm) {
      cm.display.externalMeasure = null;
      removeChildren(cm.display.lineMeasure);
      for (var i3 = 0; i3 < cm.display.view.length; i3++) {
        clearLineMeasurementCacheFor(cm.display.view[i3]);
      }
    }
    function clearCaches(cm) {
      clearLineMeasurementCache(cm);
      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
      if (!cm.options.lineWrapping) {
        cm.display.maxLineChanged = true;
      }
      cm.display.lineNumChars = null;
    }
    function pageScrollX() {
      if (chrome2 && android) {
        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
      }
      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
      if (chrome2 && android) {
        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
      }
      return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight(lineObj) {
      var ref2 = visualLine(lineObj);
      var widgets = ref2.widgets;
      var height = 0;
      if (widgets) {
        for (var i3 = 0; i3 < widgets.length; ++i3) {
          if (widgets[i3].above) {
            height += widgetHeight(widgets[i3]);
          }
        }
      }
      return height;
    }
    function intoCoordSystem(cm, lineObj, rect2, context, includeWidgets) {
      if (!includeWidgets) {
        var height = widgetTopHeight(lineObj);
        rect2.top += height;
        rect2.bottom += height;
      }
      if (context == "line") {
        return rect2;
      }
      if (!context) {
        context = "local";
      }
      var yOff = heightAtLine(lineObj);
      if (context == "local") {
        yOff += paddingTop(cm.display);
      } else {
        yOff -= cm.display.viewOffset;
      }
      if (context == "page" || context == "window") {
        var lOff = cm.display.lineSpace.getBoundingClientRect();
        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
        rect2.left += xOff;
        rect2.right += xOff;
      }
      rect2.top += yOff;
      rect2.bottom += yOff;
      return rect2;
    }
    function fromCoordSystem(cm, coords, context) {
      if (context == "div") {
        return coords;
      }
      var left = coords.left, top2 = coords.top;
      if (context == "page") {
        left -= pageScrollX();
        top2 -= pageScrollY();
      } else if (context == "local" || !context) {
        var localBox = cm.display.sizer.getBoundingClientRect();
        left += localBox.left;
        top2 += localBox.top;
      }
      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
      return { left: left - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
      if (!lineObj) {
        lineObj = getLine2(cm.doc, pos.line);
      }
      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
      lineObj = lineObj || getLine2(cm.doc, pos.line);
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      function get2(ch2, right) {
        var m2 = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
        if (right) {
          m2.left = m2.right;
        } else {
          m2.right = m2.left;
        }
        return intoCoordSystem(cm, lineObj, m2, context);
      }
      var order2 = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
      if (ch >= lineObj.text.length) {
        ch = lineObj.text.length;
        sticky = "before";
      } else if (ch <= 0) {
        ch = 0;
        sticky = "after";
      }
      if (!order2) {
        return get2(sticky == "before" ? ch - 1 : ch, sticky == "before");
      }
      function getBidi(ch2, partPos2, invert) {
        var part2 = order2[partPos2], right = part2.level == 1;
        return get2(invert ? ch2 - 1 : ch2, right != invert);
      }
      var partPos = getBidiPartAt(order2, ch, sticky);
      var other = bidiOther;
      var val = getBidi(ch, partPos, sticky == "before");
      if (other != null) {
        val.other = getBidi(ch, other, sticky != "before");
      }
      return val;
    }
    function estimateCoords(cm, pos) {
      var left = 0;
      pos = clipPos(cm.doc, pos);
      if (!cm.options.lineWrapping) {
        left = charWidth(cm.display) * pos.ch;
      }
      var lineObj = getLine2(cm.doc, pos.line);
      var top2 = heightAtLine(lineObj) + paddingTop(cm.display);
      return { left, right: left, top: top2, bottom: top2 + lineObj.height };
    }
    function PosWithInfo(line2, ch, sticky, outside, xRel) {
      var pos = Pos(line2, ch, sticky);
      pos.xRel = xRel;
      if (outside) {
        pos.outside = outside;
      }
      return pos;
    }
    function coordsChar(cm, x2, y2) {
      var doc2 = cm.doc;
      y2 += cm.display.viewOffset;
      if (y2 < 0) {
        return PosWithInfo(doc2.first, 0, null, -1, -1);
      }
      var lineN = lineAtHeight(doc2, y2), last = doc2.first + doc2.size - 1;
      if (lineN > last) {
        return PosWithInfo(doc2.first + doc2.size - 1, getLine2(doc2, last).text.length, null, 1, 1);
      }
      if (x2 < 0) {
        x2 = 0;
      }
      var lineObj = getLine2(doc2, lineN);
      for (; ; ) {
        var found = coordsCharInner(cm, lineObj, lineN, x2, y2);
        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
        if (!collapsed) {
          return found;
        }
        var rangeEnd = collapsed.find(1);
        if (rangeEnd.line == lineN) {
          return rangeEnd;
        }
        lineObj = getLine2(doc2, lineN = rangeEnd.line);
      }
    }
    function wrappedLineExtent(cm, lineObj, preparedMeasure, y2) {
      y2 -= widgetTopHeight(lineObj);
      var end = lineObj.text.length;
      var begin = findFirst(function(ch) {
        return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y2;
      }, end, 0);
      end = findFirst(function(ch) {
        return measureCharPrepared(cm, preparedMeasure, ch).top > y2;
      }, begin, end);
      return { begin, end };
    }
    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target2) {
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target2), "line").top;
      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
    }
    function boxIsAfter(box, x2, y2, left) {
      return box.bottom <= y2 ? false : box.top > y2 ? true : (left ? box.left : box.right) > x2;
    }
    function coordsCharInner(cm, lineObj, lineNo2, x2, y2) {
      y2 -= heightAtLine(lineObj);
      var preparedMeasure = prepareMeasureForLine(cm, lineObj);
      var widgetHeight2 = widgetTopHeight(lineObj);
      var begin = 0, end = lineObj.text.length, ltr = true;
      var order2 = getOrder(lineObj, cm.doc.direction);
      if (order2) {
        var part2 = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2);
        ltr = part2.level != 1;
        begin = ltr ? part2.from : part2.to - 1;
        end = ltr ? part2.to : part2.from - 1;
      }
      var chAround = null, boxAround = null;
      var ch = findFirst(function(ch2) {
        var box = measureCharPrepared(cm, preparedMeasure, ch2);
        box.top += widgetHeight2;
        box.bottom += widgetHeight2;
        if (!boxIsAfter(box, x2, y2, false)) {
          return false;
        }
        if (box.top <= y2 && box.left <= x2) {
          chAround = ch2;
          boxAround = box;
        }
        return true;
      }, begin, end);
      var baseX, sticky, outside = false;
      if (boxAround) {
        var atLeft = x2 - boxAround.left < boxAround.right - x2, atStart = atLeft == ltr;
        ch = chAround + (atStart ? 0 : 1);
        sticky = atStart ? "after" : "before";
        baseX = atLeft ? boxAround.left : boxAround.right;
      } else {
        if (!ltr && (ch == end || ch == begin)) {
          ch++;
        }
        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y2 == ltr ? "after" : "before";
        var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
        baseX = coords.left;
        outside = y2 < coords.top ? -1 : y2 >= coords.bottom ? 1 : 0;
      }
      ch = skipExtendingChars(lineObj.text, ch, 1);
      return PosWithInfo(lineNo2, ch, sticky, outside, x2 - baseX);
    }
    function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2) {
      var index2 = findFirst(function(i3) {
        var part3 = order2[i3], ltr2 = part3.level != 1;
        return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part3.to : part3.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x2, y2, true);
      }, 0, order2.length - 1);
      var part2 = order2[index2];
      if (index2 > 0) {
        var ltr = part2.level != 1;
        var start2 = cursorCoords(cm, Pos(lineNo2, ltr ? part2.from : part2.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
        if (boxIsAfter(start2, x2, y2, true) && start2.top > y2) {
          part2 = order2[index2 - 1];
        }
      }
      return part2;
    }
    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order2, x2, y2) {
      var ref2 = wrappedLineExtent(cm, lineObj, preparedMeasure, y2);
      var begin = ref2.begin;
      var end = ref2.end;
      if (/\s/.test(lineObj.text.charAt(end - 1))) {
        end--;
      }
      var part2 = null, closestDist = null;
      for (var i3 = 0; i3 < order2.length; i3++) {
        var p2 = order2[i3];
        if (p2.from >= end || p2.to <= begin) {
          continue;
        }
        var ltr = p2.level != 1;
        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p2.to) - 1 : Math.max(begin, p2.from)).right;
        var dist2 = endX < x2 ? x2 - endX + 1e9 : endX - x2;
        if (!part2 || closestDist > dist2) {
          part2 = p2;
          closestDist = dist2;
        }
      }
      if (!part2) {
        part2 = order2[order2.length - 1];
      }
      if (part2.from < begin) {
        part2 = { from: begin, to: part2.to, level: part2.level };
      }
      if (part2.to > end) {
        part2 = { from: part2.from, to: end, level: part2.level };
      }
      return part2;
    }
    var measureText;
    function textHeight(display) {
      if (display.cachedTextHeight != null) {
        return display.cachedTextHeight;
      }
      if (measureText == null) {
        measureText = elt("pre", null, "CodeMirror-line-like");
        for (var i3 = 0; i3 < 49; ++i3) {
          measureText.appendChild(document.createTextNode("x"));
          measureText.appendChild(elt("br"));
        }
        measureText.appendChild(document.createTextNode("x"));
      }
      removeChildrenAndAdd(display.measure, measureText);
      var height = measureText.offsetHeight / 50;
      if (height > 3) {
        display.cachedTextHeight = height;
      }
      removeChildren(display.measure);
      return height || 1;
    }
    function charWidth(display) {
      if (display.cachedCharWidth != null) {
        return display.cachedCharWidth;
      }
      var anchor = elt("span", "xxxxxxxxxx");
      var pre2 = elt("pre", [anchor], "CodeMirror-line-like");
      removeChildrenAndAdd(display.measure, pre2);
      var rect2 = anchor.getBoundingClientRect(), width = (rect2.right - rect2.left) / 10;
      if (width > 2) {
        display.cachedCharWidth = width;
      }
      return width || 10;
    }
    function getDimensions2(cm) {
      var d2 = cm.display, left = {}, width = {};
      var gutterLeft = d2.gutters.clientLeft;
      for (var n2 = d2.gutters.firstChild, i3 = 0; n2; n2 = n2.nextSibling, ++i3) {
        var id2 = cm.display.gutterSpecs[i3].className;
        left[id2] = n2.offsetLeft + n2.clientLeft + gutterLeft;
        width[id2] = n2.clientWidth;
      }
      return {
        fixedPos: compensateForHScroll(d2),
        gutterTotalWidth: d2.gutters.offsetWidth,
        gutterLeft: left,
        gutterWidth: width,
        wrapperWidth: d2.wrapper.clientWidth
      };
    }
    function compensateForHScroll(display) {
      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
      var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
      return function(line2) {
        if (lineIsHidden(cm.doc, line2)) {
          return 0;
        }
        var widgetsHeight = 0;
        if (line2.widgets) {
          for (var i3 = 0; i3 < line2.widgets.length; i3++) {
            if (line2.widgets[i3].height) {
              widgetsHeight += line2.widgets[i3].height;
            }
          }
        }
        if (wrapping) {
          return widgetsHeight + (Math.ceil(line2.text.length / perLine) || 1) * th;
        } else {
          return widgetsHeight + th;
        }
      };
    }
    function estimateLineHeights(cm) {
      var doc2 = cm.doc, est = estimateHeight(cm);
      doc2.iter(function(line2) {
        var estHeight = est(line2);
        if (estHeight != line2.height) {
          updateLineHeight(line2, estHeight);
        }
      });
    }
    function posFromMouse(cm, e2, liberal, forRect) {
      var display = cm.display;
      if (!liberal && e_target(e2).getAttribute("cm-not-content") == "true") {
        return null;
      }
      var x2, y2, space = display.lineSpace.getBoundingClientRect();
      try {
        x2 = e2.clientX - space.left;
        y2 = e2.clientY - space.top;
      } catch (e$12) {
        return null;
      }
      var coords = coordsChar(cm, x2, y2), line2;
      if (forRect && coords.xRel > 0 && (line2 = getLine2(cm.doc, coords.line).text).length == coords.ch) {
        var colDiff = countColumn(line2, line2.length, cm.options.tabSize) - line2.length;
        coords = Pos(coords.line, Math.max(0, Math.round((x2 - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
      }
      return coords;
    }
    function findViewIndex(cm, n2) {
      if (n2 >= cm.display.viewTo) {
        return null;
      }
      n2 -= cm.display.viewFrom;
      if (n2 < 0) {
        return null;
      }
      var view = cm.display.view;
      for (var i3 = 0; i3 < view.length; i3++) {
        n2 -= view[i3].size;
        if (n2 < 0) {
          return i3;
        }
      }
    }
    function regChange(cm, from2, to2, lendiff) {
      if (from2 == null) {
        from2 = cm.doc.first;
      }
      if (to2 == null) {
        to2 = cm.doc.first + cm.doc.size;
      }
      if (!lendiff) {
        lendiff = 0;
      }
      var display = cm.display;
      if (lendiff && to2 < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from2)) {
        display.updateLineNumbers = from2;
      }
      cm.curOp.viewChanged = true;
      if (from2 >= display.viewTo) {
        if (sawCollapsedSpans && visualLineNo(cm.doc, from2) < display.viewTo) {
          resetView(cm);
        }
      } else if (to2 <= display.viewFrom) {
        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to2 + lendiff) > display.viewFrom) {
          resetView(cm);
        } else {
          display.viewFrom += lendiff;
          display.viewTo += lendiff;
        }
      } else if (from2 <= display.viewFrom && to2 >= display.viewTo) {
        resetView(cm);
      } else if (from2 <= display.viewFrom) {
        var cut = viewCuttingPoint(cm, to2, to2 + lendiff, 1);
        if (cut) {
          display.view = display.view.slice(cut.index);
          display.viewFrom = cut.lineN;
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      } else if (to2 >= display.viewTo) {
        var cut$1 = viewCuttingPoint(cm, from2, from2, -1);
        if (cut$1) {
          display.view = display.view.slice(0, cut$1.index);
          display.viewTo = cut$1.lineN;
        } else {
          resetView(cm);
        }
      } else {
        var cutTop = viewCuttingPoint(cm, from2, from2, -1);
        var cutBot = viewCuttingPoint(cm, to2, to2 + lendiff, 1);
        if (cutTop && cutBot) {
          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      }
      var ext = display.externalMeasured;
      if (ext) {
        if (to2 < ext.lineN) {
          ext.lineN += lendiff;
        } else if (from2 < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
      }
    }
    function regLineChange(cm, line2, type) {
      cm.curOp.viewChanged = true;
      var display = cm.display, ext = cm.display.externalMeasured;
      if (ext && line2 >= ext.lineN && line2 < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
      if (line2 < display.viewFrom || line2 >= display.viewTo) {
        return;
      }
      var lineView = display.view[findViewIndex(cm, line2)];
      if (lineView.node == null) {
        return;
      }
      var arr = lineView.changes || (lineView.changes = []);
      if (indexOf2(arr, type) == -1) {
        arr.push(type);
      }
    }
    function resetView(cm) {
      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
      cm.display.view = [];
      cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
      var index2 = findViewIndex(cm, oldN), diff2, view = cm.display.view;
      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
        return { index: index2, lineN: newN };
      }
      var n2 = cm.display.viewFrom;
      for (var i3 = 0; i3 < index2; i3++) {
        n2 += view[i3].size;
      }
      if (n2 != oldN) {
        if (dir > 0) {
          if (index2 == view.length - 1) {
            return null;
          }
          diff2 = n2 + view[index2].size - oldN;
          index2++;
        } else {
          diff2 = n2 - oldN;
        }
        oldN += diff2;
        newN += diff2;
      }
      while (visualLineNo(cm.doc, newN) != newN) {
        if (index2 == (dir < 0 ? 0 : view.length - 1)) {
          return null;
        }
        newN += dir * view[index2 - (dir < 0 ? 1 : 0)].size;
        index2 += dir;
      }
      return { index: index2, lineN: newN };
    }
    function adjustView(cm, from2, to2) {
      var display = cm.display, view = display.view;
      if (view.length == 0 || from2 >= display.viewTo || to2 <= display.viewFrom) {
        display.view = buildViewArray(cm, from2, to2);
        display.viewFrom = from2;
      } else {
        if (display.viewFrom > from2) {
          display.view = buildViewArray(cm, from2, display.viewFrom).concat(display.view);
        } else if (display.viewFrom < from2) {
          display.view = display.view.slice(findViewIndex(cm, from2));
        }
        display.viewFrom = from2;
        if (display.viewTo < to2) {
          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to2));
        } else if (display.viewTo > to2) {
          display.view = display.view.slice(0, findViewIndex(cm, to2));
        }
      }
      display.viewTo = to2;
    }
    function countDirtyView(cm) {
      var view = cm.display.view, dirty = 0;
      for (var i3 = 0; i3 < view.length; i3++) {
        var lineView = view[i3];
        if (!lineView.hidden && (!lineView.node || lineView.changes)) {
          ++dirty;
        }
      }
      return dirty;
    }
    function updateSelection(cm) {
      cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
      if (primary === void 0)
        primary = true;
      var doc2 = cm.doc, result = {};
      var curFragment = result.cursors = document.createDocumentFragment();
      var selFragment = result.selection = document.createDocumentFragment();
      var customCursor = cm.options.$customCursor;
      if (customCursor) {
        primary = true;
      }
      for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
        if (!primary && i3 == doc2.sel.primIndex) {
          continue;
        }
        var range3 = doc2.sel.ranges[i3];
        if (range3.from().line >= cm.display.viewTo || range3.to().line < cm.display.viewFrom) {
          continue;
        }
        var collapsed = range3.empty();
        if (customCursor) {
          var head = customCursor(cm, range3);
          if (head) {
            drawSelectionCursor(cm, head, curFragment);
          }
        } else if (collapsed || cm.options.showCursorWhenSelecting) {
          drawSelectionCursor(cm, range3.head, curFragment);
        }
        if (!collapsed) {
          drawSelectionRange(cm, range3, selFragment);
        }
      }
      return result;
    }
    function drawSelectionCursor(cm, head, output) {
      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
      var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
      cursor.style.left = pos.left + "px";
      cursor.style.top = pos.top + "px";
      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
      if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
        var charPos = charCoords(cm, head, "div", null, null);
        var width = charPos.right - charPos.left;
        cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
      }
      if (pos.other) {
        var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
        otherCursor.style.display = "";
        otherCursor.style.left = pos.other.left + "px";
        otherCursor.style.top = pos.other.top + "px";
        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
      }
    }
    function cmpCoords(a2, b2) {
      return a2.top - b2.top || a2.left - b2.left;
    }
    function drawSelectionRange(cm, range3, output) {
      var display = cm.display, doc2 = cm.doc;
      var fragment = document.createDocumentFragment();
      var padding = paddingH(cm.display), leftSide = padding.left;
      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
      var docLTR = doc2.direction == "ltr";
      function add3(left, top2, width, bottom2) {
        if (top2 < 0) {
          top2 = 0;
        }
        top2 = Math.round(top2);
        bottom2 = Math.round(bottom2);
        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top2 + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom2 - top2) + "px"));
      }
      function drawForLine(line2, fromArg, toArg) {
        var lineObj = getLine2(doc2, line2);
        var lineLen = lineObj.text.length;
        var start2, end;
        function coords(ch, bias) {
          return charCoords(cm, Pos(line2, ch), "div", lineObj, bias);
        }
        function wrapX(pos, dir, side) {
          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
          var prop3 = dir == "ltr" == (side == "after") ? "left" : "right";
          var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
          return coords(ch, prop3)[prop3];
        }
        var order2 = getOrder(lineObj, doc2.direction);
        iterateBidiSections(order2, fromArg || 0, toArg == null ? lineLen : toArg, function(from2, to2, dir, i3) {
          var ltr = dir == "ltr";
          var fromPos = coords(from2, ltr ? "left" : "right");
          var toPos = coords(to2 - 1, ltr ? "right" : "left");
          var openStart = fromArg == null && from2 == 0, openEnd = toArg == null && to2 == lineLen;
          var first = i3 == 0, last = !order2 || i3 == order2.length - 1;
          if (toPos.top - fromPos.top <= 3) {
            var openLeft = (docLTR ? openStart : openEnd) && first;
            var openRight = (docLTR ? openEnd : openStart) && last;
            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
            add3(left, fromPos.top, right - left, fromPos.bottom);
          } else {
            var topLeft, topRight, botLeft, botRight;
            if (ltr) {
              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
              topRight = docLTR ? rightSide : wrapX(from2, dir, "before");
              botLeft = docLTR ? leftSide : wrapX(to2, dir, "after");
              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
            } else {
              topLeft = !docLTR ? leftSide : wrapX(from2, dir, "before");
              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
              botRight = !docLTR ? rightSide : wrapX(to2, dir, "after");
            }
            add3(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
            if (fromPos.bottom < toPos.top) {
              add3(leftSide, fromPos.bottom, null, toPos.top);
            }
            add3(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
          }
          if (!start2 || cmpCoords(fromPos, start2) < 0) {
            start2 = fromPos;
          }
          if (cmpCoords(toPos, start2) < 0) {
            start2 = toPos;
          }
          if (!end || cmpCoords(fromPos, end) < 0) {
            end = fromPos;
          }
          if (cmpCoords(toPos, end) < 0) {
            end = toPos;
          }
        });
        return { start: start2, end };
      }
      var sFrom = range3.from(), sTo = range3.to();
      if (sFrom.line == sTo.line) {
        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
      } else {
        var fromLine = getLine2(doc2, sFrom.line), toLine = getLine2(doc2, sTo.line);
        var singleVLine = visualLine(fromLine) == visualLine(toLine);
        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
        if (singleVLine) {
          if (leftEnd.top < rightStart.top - 2) {
            add3(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
            add3(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
          } else {
            add3(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
          }
        }
        if (leftEnd.bottom < rightStart.top) {
          add3(leftSide, leftEnd.bottom, null, rightStart.top);
        }
      }
      output.appendChild(fragment);
    }
    function restartBlink(cm) {
      if (!cm.state.focused) {
        return;
      }
      var display = cm.display;
      clearInterval(display.blinker);
      var on2 = true;
      display.cursorDiv.style.visibility = "";
      if (cm.options.cursorBlinkRate > 0) {
        display.blinker = setInterval(function() {
          if (!cm.hasFocus()) {
            onBlur(cm);
          }
          display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      } else if (cm.options.cursorBlinkRate < 0) {
        display.cursorDiv.style.visibility = "hidden";
      }
    }
    function ensureFocus(cm) {
      if (!cm.hasFocus()) {
        cm.display.input.focus();
        if (!cm.state.focused) {
          onFocus(cm);
        }
      }
    }
    function delayBlurEvent(cm) {
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
          if (cm.state.focused) {
            onBlur(cm);
          }
        }
      }, 100);
    }
    function onFocus(cm, e2) {
      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
        cm.state.delayingBlurEvent = false;
      }
      if (cm.options.readOnly == "nocursor") {
        return;
      }
      if (!cm.state.focused) {
        signal(cm, "focus", cm, e2);
        cm.state.focused = true;
        addClass(cm.display.wrapper, "CodeMirror-focused");
        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
          cm.display.input.reset();
          if (webkit) {
            setTimeout(function() {
              return cm.display.input.reset(true);
            }, 20);
          }
        }
        cm.display.input.receivedFocus();
      }
      restartBlink(cm);
    }
    function onBlur(cm, e2) {
      if (cm.state.delayingBlurEvent) {
        return;
      }
      if (cm.state.focused) {
        signal(cm, "blur", cm, e2);
        cm.state.focused = false;
        rmClass(cm.display.wrapper, "CodeMirror-focused");
      }
      clearInterval(cm.display.blinker);
      setTimeout(function() {
        if (!cm.state.focused) {
          cm.display.shift = false;
        }
      }, 150);
    }
    function updateHeightsInViewport(cm) {
      var display = cm.display;
      var prevBottom = display.lineDiv.offsetTop;
      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
      var oldHeight = display.lineDiv.getBoundingClientRect().top;
      var mustScroll = 0;
      for (var i3 = 0; i3 < display.view.length; i3++) {
        var cur = display.view[i3], wrapping = cm.options.lineWrapping;
        var height = void 0, width = 0;
        if (cur.hidden) {
          continue;
        }
        oldHeight += cur.line.height;
        if (ie2 && ie_version < 8) {
          var bot2 = cur.node.offsetTop + cur.node.offsetHeight;
          height = bot2 - prevBottom;
          prevBottom = bot2;
        } else {
          var box = cur.node.getBoundingClientRect();
          height = box.bottom - box.top;
          if (!wrapping && cur.text.firstChild) {
            width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
          }
        }
        var diff2 = cur.line.height - height;
        if (diff2 > 5e-3 || diff2 < -5e-3) {
          if (oldHeight < viewTop) {
            mustScroll -= diff2;
          }
          updateLineHeight(cur.line, height);
          updateWidgetHeight(cur.line);
          if (cur.rest) {
            for (var j2 = 0; j2 < cur.rest.length; j2++) {
              updateWidgetHeight(cur.rest[j2]);
            }
          }
        }
        if (width > cm.display.sizerWidth) {
          var chWidth = Math.ceil(width / charWidth(cm.display));
          if (chWidth > cm.display.maxLineLength) {
            cm.display.maxLineLength = chWidth;
            cm.display.maxLine = cur.line;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (Math.abs(mustScroll) > 2) {
        display.scroller.scrollTop += mustScroll;
      }
    }
    function updateWidgetHeight(line2) {
      if (line2.widgets) {
        for (var i3 = 0; i3 < line2.widgets.length; ++i3) {
          var w2 = line2.widgets[i3], parent = w2.node.parentNode;
          if (parent) {
            w2.height = parent.offsetHeight;
          }
        }
      }
    }
    function visibleLines(display, doc2, viewport) {
      var top2 = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
      top2 = Math.floor(top2 - paddingTop(display));
      var bottom2 = viewport && viewport.bottom != null ? viewport.bottom : top2 + display.wrapper.clientHeight;
      var from2 = lineAtHeight(doc2, top2), to2 = lineAtHeight(doc2, bottom2);
      if (viewport && viewport.ensure) {
        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
        if (ensureFrom < from2) {
          from2 = ensureFrom;
          to2 = lineAtHeight(doc2, heightAtLine(getLine2(doc2, ensureFrom)) + display.wrapper.clientHeight);
        } else if (Math.min(ensureTo, doc2.lastLine()) >= to2) {
          from2 = lineAtHeight(doc2, heightAtLine(getLine2(doc2, ensureTo)) - display.wrapper.clientHeight);
          to2 = ensureTo;
        }
      }
      return { from: from2, to: Math.max(to2, from2 + 1) };
    }
    function maybeScrollWindow(cm, rect2) {
      if (signalDOMEvent(cm, "scrollCursorIntoView")) {
        return;
      }
      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
      if (rect2.top + box.top < 0) {
        doScroll = true;
      } else if (rect2.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
        doScroll = false;
      }
      if (doScroll != null && !phantom) {
        var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect2.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect2.bottom - rect2.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect2.left + "px; width: " + Math.max(2, rect2.right - rect2.left) + "px;");
        cm.display.lineSpace.appendChild(scrollNode);
        scrollNode.scrollIntoView(doScroll);
        cm.display.lineSpace.removeChild(scrollNode);
      }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
      if (margin == null) {
        margin = 0;
      }
      var rect2;
      if (!cm.options.lineWrapping && pos == end) {
        end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      }
      for (var limit = 0; limit < 5; limit++) {
        var changed = false;
        var coords = cursorCoords(cm, pos);
        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
        rect2 = {
          left: Math.min(coords.left, endCoords.left),
          top: Math.min(coords.top, endCoords.top) - margin,
          right: Math.max(coords.left, endCoords.left),
          bottom: Math.max(coords.bottom, endCoords.bottom) + margin
        };
        var scrollPos = calculateScrollPos(cm, rect2);
        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
            changed = true;
          }
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
            changed = true;
          }
        }
        if (!changed) {
          break;
        }
      }
      return rect2;
    }
    function scrollIntoView2(cm, rect2) {
      var scrollPos = calculateScrollPos(cm, rect2);
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
      }
    }
    function calculateScrollPos(cm, rect2) {
      var display = cm.display, snapMargin = textHeight(cm.display);
      if (rect2.top < 0) {
        rect2.top = 0;
      }
      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
      var screen2 = displayHeight(cm), result = {};
      if (rect2.bottom - rect2.top > screen2) {
        rect2.bottom = rect2.top + screen2;
      }
      var docBottom = cm.doc.height + paddingVert(display);
      var atTop = rect2.top < snapMargin, atBottom = rect2.bottom > docBottom - snapMargin;
      if (rect2.top < screentop) {
        result.scrollTop = atTop ? 0 : rect2.top;
      } else if (rect2.bottom > screentop + screen2) {
        var newTop = Math.min(rect2.top, (atBottom ? docBottom : rect2.bottom) - screen2);
        if (newTop != screentop) {
          result.scrollTop = newTop;
        }
      }
      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
      var screenw = displayWidth(cm) - display.gutters.offsetWidth;
      var tooWide = rect2.right - rect2.left > screenw;
      if (tooWide) {
        rect2.right = rect2.left + screenw;
      }
      if (rect2.left < 10) {
        result.scrollLeft = 0;
      } else if (rect2.left < screenleft) {
        result.scrollLeft = Math.max(0, rect2.left + gutterSpace - (tooWide ? 0 : 10));
      } else if (rect2.right > screenw + screenleft - 3) {
        result.scrollLeft = rect2.right + (tooWide ? 0 : 10) - screenw;
      }
      return result;
    }
    function addToScrollTop(cm, top2) {
      if (top2 == null) {
        return;
      }
      resolveScrollToPos(cm);
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
    }
    function ensureCursorVisible(cm) {
      resolveScrollToPos(cm);
      var cur = cm.getCursor();
      cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
    }
    function scrollToCoords(cm, x2, y2) {
      if (x2 != null || y2 != null) {
        resolveScrollToPos(cm);
      }
      if (x2 != null) {
        cm.curOp.scrollLeft = x2;
      }
      if (y2 != null) {
        cm.curOp.scrollTop = y2;
      }
    }
    function scrollToRange(cm, range3) {
      resolveScrollToPos(cm);
      cm.curOp.scrollToPos = range3;
    }
    function resolveScrollToPos(cm) {
      var range3 = cm.curOp.scrollToPos;
      if (range3) {
        cm.curOp.scrollToPos = null;
        var from2 = estimateCoords(cm, range3.from), to2 = estimateCoords(cm, range3.to);
        scrollToCoordsRange(cm, from2, to2, range3.margin);
      }
    }
    function scrollToCoordsRange(cm, from2, to2, margin) {
      var sPos = calculateScrollPos(cm, {
        left: Math.min(from2.left, to2.left),
        top: Math.min(from2.top, to2.top) - margin,
        right: Math.max(from2.right, to2.right),
        bottom: Math.max(from2.bottom, to2.bottom) + margin
      });
      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
    }
    function updateScrollTop(cm, val) {
      if (Math.abs(cm.doc.scrollTop - val) < 2) {
        return;
      }
      if (!gecko) {
        updateDisplaySimple(cm, { top: val });
      }
      setScrollTop(cm, val, true);
      if (gecko) {
        updateDisplaySimple(cm);
      }
      startWorker(cm, 100);
    }
    function setScrollTop(cm, val, forceScroll) {
      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
      if (cm.display.scroller.scrollTop == val && !forceScroll) {
        return;
      }
      cm.doc.scrollTop = val;
      cm.display.scrollbars.setScrollTop(val);
      if (cm.display.scroller.scrollTop != val) {
        cm.display.scroller.scrollTop = val;
      }
    }
    function setScrollLeft(cm, val, isScroller, forceScroll) {
      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
        return;
      }
      cm.doc.scrollLeft = val;
      alignHorizontally(cm);
      if (cm.display.scroller.scrollLeft != val) {
        cm.display.scroller.scrollLeft = val;
      }
      cm.display.scrollbars.setScrollLeft(val);
    }
    function measureForScrollbars(cm) {
      var d2 = cm.display, gutterW = d2.gutters.offsetWidth;
      var docH = Math.round(cm.doc.height + paddingVert(cm.display));
      return {
        clientHeight: d2.scroller.clientHeight,
        viewHeight: d2.wrapper.clientHeight,
        scrollWidth: d2.scroller.scrollWidth,
        clientWidth: d2.scroller.clientWidth,
        viewWidth: d2.wrapper.clientWidth,
        barLeft: cm.options.fixedGutter ? gutterW : 0,
        docHeight: docH,
        scrollHeight: docH + scrollGap(cm) + d2.barHeight,
        nativeBarWidth: d2.nativeBarWidth,
        gutterWidth: gutterW
      };
    }
    var NativeScrollbars = function(place, scroll, cm) {
      this.cm = cm;
      var vert2 = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      vert2.tabIndex = horiz.tabIndex = -1;
      place(vert2);
      place(horiz);
      on(vert2, "scroll", function() {
        if (vert2.clientHeight) {
          scroll(vert2.scrollTop, "vertical");
        }
      });
      on(horiz, "scroll", function() {
        if (horiz.clientWidth) {
          scroll(horiz.scrollLeft, "horizontal");
        }
      });
      this.checkedZeroWidth = false;
      if (ie2 && ie_version < 8) {
        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
      }
    };
    NativeScrollbars.prototype.update = function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;
      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.scrollTop = 0;
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }
      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }
      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) {
          this.zeroWidthHack();
        }
        this.checkedZeroWidth = true;
      }
      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
    };
    NativeScrollbars.prototype.setScrollLeft = function(pos) {
      if (this.horiz.scrollLeft != pos) {
        this.horiz.scrollLeft = pos;
      }
      if (this.disableHoriz) {
        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }
    };
    NativeScrollbars.prototype.setScrollTop = function(pos) {
      if (this.vert.scrollTop != pos) {
        this.vert.scrollTop = pos;
      }
      if (this.disableVert) {
        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }
    };
    NativeScrollbars.prototype.zeroWidthHack = function() {
      var w2 = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w2;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed();
      this.disableVert = new Delayed();
    };
    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        var box = bar.getBoundingClientRect();
        var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
        if (elt2 != bar) {
          bar.style.pointerEvents = "none";
        } else {
          delay.set(1e3, maybeDisable);
        }
      }
      delay.set(1e3, maybeDisable);
    };
    NativeScrollbars.prototype.clear = function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    };
    var NullScrollbars = function() {
    };
    NullScrollbars.prototype.update = function() {
      return { bottom: 0, right: 0 };
    };
    NullScrollbars.prototype.setScrollLeft = function() {
    };
    NullScrollbars.prototype.setScrollTop = function() {
    };
    NullScrollbars.prototype.clear = function() {
    };
    function updateScrollbars(cm, measure) {
      if (!measure) {
        measure = measureForScrollbars(cm);
      }
      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
      updateScrollbarsInner(cm, measure);
      for (var i3 = 0; i3 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i3++) {
        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
          updateHeightsInViewport(cm);
        }
        updateScrollbarsInner(cm, measureForScrollbars(cm));
        startWidth = cm.display.barWidth;
        startHeight = cm.display.barHeight;
      }
    }
    function updateScrollbarsInner(cm, measure) {
      var d2 = cm.display;
      var sizes = d2.scrollbars.update(measure);
      d2.sizer.style.paddingRight = (d2.barWidth = sizes.right) + "px";
      d2.sizer.style.paddingBottom = (d2.barHeight = sizes.bottom) + "px";
      d2.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
      if (sizes.right && sizes.bottom) {
        d2.scrollbarFiller.style.display = "block";
        d2.scrollbarFiller.style.height = sizes.bottom + "px";
        d2.scrollbarFiller.style.width = sizes.right + "px";
      } else {
        d2.scrollbarFiller.style.display = "";
      }
      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
        d2.gutterFiller.style.display = "block";
        d2.gutterFiller.style.height = sizes.bottom + "px";
        d2.gutterFiller.style.width = measure.gutterWidth + "px";
      } else {
        d2.gutterFiller.style.display = "";
      }
    }
    var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
    function initScrollbars(cm) {
      if (cm.display.scrollbars) {
        cm.display.scrollbars.clear();
        if (cm.display.scrollbars.addClass) {
          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
        on(node, "mousedown", function() {
          if (cm.state.focused) {
            setTimeout(function() {
              return cm.display.input.focus();
            }, 0);
          }
        });
        node.setAttribute("cm-not-content", "true");
      }, function(pos, axis) {
        if (axis == "horizontal") {
          setScrollLeft(cm, pos);
        } else {
          updateScrollTop(cm, pos);
        }
      }, cm);
      if (cm.display.scrollbars.addClass) {
        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    var nextOpId = 0;
    function startOperation(cm) {
      cm.curOp = {
        cm,
        viewChanged: false,
        startHeight: cm.doc.height,
        forceUpdate: false,
        updateInput: 0,
        typing: false,
        changeObjs: null,
        cursorActivityHandlers: null,
        cursorActivityCalled: 0,
        selectionChanged: false,
        updateMaxLine: false,
        scrollLeft: null,
        scrollTop: null,
        scrollToPos: null,
        focus: false,
        id: ++nextOpId,
        markArrays: null
      };
      pushOperation(cm.curOp);
    }
    function endOperation(cm) {
      var op = cm.curOp;
      if (op) {
        finishOperation(op, function(group) {
          for (var i3 = 0; i3 < group.ops.length; i3++) {
            group.ops[i3].cm.curOp = null;
          }
          endOperations(group);
        });
      }
    }
    function endOperations(group) {
      var ops = group.ops;
      for (var i3 = 0; i3 < ops.length; i3++) {
        endOperation_R1(ops[i3]);
      }
      for (var i$13 = 0; i$13 < ops.length; i$13++) {
        endOperation_W1(ops[i$13]);
      }
      for (var i$23 = 0; i$23 < ops.length; i$23++) {
        endOperation_R2(ops[i$23]);
      }
      for (var i$3 = 0; i$3 < ops.length; i$3++) {
        endOperation_W2(ops[i$3]);
      }
      for (var i$4 = 0; i$4 < ops.length; i$4++) {
        endOperation_finish(ops[i$4]);
      }
    }
    function endOperation_R1(op) {
      var cm = op.cm, display = cm.display;
      maybeClipScrollbars(cm);
      if (op.updateMaxLine) {
        findMaxLine(cm);
      }
      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
    }
    function endOperation_W1(op) {
      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
      var cm = op.cm, display = cm.display;
      if (op.updatedDisplay) {
        updateHeightsInViewport(cm);
      }
      op.barMeasure = measureForScrollbars(cm);
      if (display.maxLineChanged && !cm.options.lineWrapping) {
        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
        cm.display.sizerWidth = op.adjustWidthTo;
        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
      }
      if (op.updatedDisplay || op.selectionChanged) {
        op.preparedSelection = display.input.prepareSelection();
      }
    }
    function endOperation_W2(op) {
      var cm = op.cm;
      if (op.adjustWidthTo != null) {
        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
        if (op.maxScrollLeft < cm.doc.scrollLeft) {
          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
        }
        cm.display.maxLineChanged = false;
      }
      var takeFocus = op.focus && op.focus == activeElt();
      if (op.preparedSelection) {
        cm.display.input.showSelection(op.preparedSelection, takeFocus);
      }
      if (op.updatedDisplay || op.startHeight != cm.doc.height) {
        updateScrollbars(cm, op.barMeasure);
      }
      if (op.updatedDisplay) {
        setDocumentHeight(cm, op.barMeasure);
      }
      if (op.selectionChanged) {
        restartBlink(cm);
      }
      if (cm.state.focused && op.updateInput) {
        cm.display.input.reset(op.typing);
      }
      if (takeFocus) {
        ensureFocus(op.cm);
      }
    }
    function endOperation_finish(op) {
      var cm = op.cm, display = cm.display, doc2 = cm.doc;
      if (op.updatedDisplay) {
        postUpdateDisplay(cm, op.update);
      }
      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
        display.wheelStartX = display.wheelStartY = null;
      }
      if (op.scrollTop != null) {
        setScrollTop(cm, op.scrollTop, op.forceScroll);
      }
      if (op.scrollLeft != null) {
        setScrollLeft(cm, op.scrollLeft, true, true);
      }
      if (op.scrollToPos) {
        var rect2 = scrollPosIntoView(cm, clipPos(doc2, op.scrollToPos.from), clipPos(doc2, op.scrollToPos.to), op.scrollToPos.margin);
        maybeScrollWindow(cm, rect2);
      }
      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
      if (hidden) {
        for (var i3 = 0; i3 < hidden.length; ++i3) {
          if (!hidden[i3].lines.length) {
            signal(hidden[i3], "hide");
          }
        }
      }
      if (unhidden) {
        for (var i$13 = 0; i$13 < unhidden.length; ++i$13) {
          if (unhidden[i$13].lines.length) {
            signal(unhidden[i$13], "unhide");
          }
        }
      }
      if (display.wrapper.offsetHeight) {
        doc2.scrollTop = cm.display.scroller.scrollTop;
      }
      if (op.changeObjs) {
        signal(cm, "changes", cm, op.changeObjs);
      }
      if (op.update) {
        op.update.finish();
      }
    }
    function runInOp(cm, f2) {
      if (cm.curOp) {
        return f2();
      }
      startOperation(cm);
      try {
        return f2();
      } finally {
        endOperation(cm);
      }
    }
    function operation(cm, f2) {
      return function() {
        if (cm.curOp) {
          return f2.apply(cm, arguments);
        }
        startOperation(cm);
        try {
          return f2.apply(cm, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function methodOp(f2) {
      return function() {
        if (this.curOp) {
          return f2.apply(this, arguments);
        }
        startOperation(this);
        try {
          return f2.apply(this, arguments);
        } finally {
          endOperation(this);
        }
      };
    }
    function docMethodOp(f2) {
      return function() {
        var cm = this.cm;
        if (!cm || cm.curOp) {
          return f2.apply(this, arguments);
        }
        startOperation(cm);
        try {
          return f2.apply(this, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function startWorker(cm, time) {
      if (cm.doc.highlightFrontier < cm.display.viewTo) {
        cm.state.highlight.set(time, bind2(highlightWorker, cm));
      }
    }
    function highlightWorker(cm) {
      var doc2 = cm.doc;
      if (doc2.highlightFrontier >= cm.display.viewTo) {
        return;
      }
      var end = +new Date() + cm.options.workTime;
      var context = getContextBefore(cm, doc2.highlightFrontier);
      var changedLines = [];
      doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line2) {
        if (context.line >= cm.display.viewFrom) {
          var oldStyles = line2.styles;
          var resetState = line2.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
          var highlighted = highlightLine(cm, line2, context, true);
          if (resetState) {
            context.state = resetState;
          }
          line2.styles = highlighted.styles;
          var oldCls = line2.styleClasses, newCls = highlighted.classes;
          if (newCls) {
            line2.styleClasses = newCls;
          } else if (oldCls) {
            line2.styleClasses = null;
          }
          var ischange = !oldStyles || oldStyles.length != line2.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
          for (var i3 = 0; !ischange && i3 < oldStyles.length; ++i3) {
            ischange = oldStyles[i3] != line2.styles[i3];
          }
          if (ischange) {
            changedLines.push(context.line);
          }
          line2.stateAfter = context.save();
          context.nextLine();
        } else {
          if (line2.text.length <= cm.options.maxHighlightLength) {
            processLine(cm, line2.text, context);
          }
          line2.stateAfter = context.line % 5 == 0 ? context.save() : null;
          context.nextLine();
        }
        if (+new Date() > end) {
          startWorker(cm, cm.options.workDelay);
          return true;
        }
      });
      doc2.highlightFrontier = context.line;
      doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
      if (changedLines.length) {
        runInOp(cm, function() {
          for (var i3 = 0; i3 < changedLines.length; i3++) {
            regLineChange(cm, changedLines[i3], "text");
          }
        });
      }
    }
    var DisplayUpdate = function(cm, viewport, force) {
      var display = cm.display;
      this.viewport = viewport;
      this.visible = visibleLines(display, cm.doc, viewport);
      this.editorIsHidden = !display.wrapper.offsetWidth;
      this.wrapperHeight = display.wrapper.clientHeight;
      this.wrapperWidth = display.wrapper.clientWidth;
      this.oldDisplayWidth = displayWidth(cm);
      this.force = force;
      this.dims = getDimensions2(cm);
      this.events = [];
    };
    DisplayUpdate.prototype.signal = function(emitter, type) {
      if (hasHandler(emitter, type)) {
        this.events.push(arguments);
      }
    };
    DisplayUpdate.prototype.finish = function() {
      for (var i3 = 0; i3 < this.events.length; i3++) {
        signal.apply(null, this.events[i3]);
      }
    };
    function maybeClipScrollbars(cm) {
      var display = cm.display;
      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
        display.heightForcer.style.height = scrollGap(cm) + "px";
        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
        display.scrollbarsClipped = true;
      }
    }
    function selectionSnapshot(cm) {
      if (cm.hasFocus()) {
        return null;
      }
      var active = activeElt();
      if (!active || !contains2(cm.display.lineDiv, active)) {
        return null;
      }
      var result = { activeElt: active };
      if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
          result.anchorNode = sel.anchorNode;
          result.anchorOffset = sel.anchorOffset;
          result.focusNode = sel.focusNode;
          result.focusOffset = sel.focusOffset;
        }
      }
      return result;
    }
    function restoreSelection(snapshot) {
      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
        return;
      }
      snapshot.activeElt.focus();
      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
        var sel = window.getSelection(), range3 = document.createRange();
        range3.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
        range3.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range3);
        sel.extend(snapshot.focusNode, snapshot.focusOffset);
      }
    }
    function updateDisplayIfNeeded(cm, update3) {
      var display = cm.display, doc2 = cm.doc;
      if (update3.editorIsHidden) {
        resetView(cm);
        return false;
      }
      if (!update3.force && update3.visible.from >= display.viewFrom && update3.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
        return false;
      }
      if (maybeUpdateLineNumberWidth(cm)) {
        resetView(cm);
        update3.dims = getDimensions2(cm);
      }
      var end = doc2.first + doc2.size;
      var from2 = Math.max(update3.visible.from - cm.options.viewportMargin, doc2.first);
      var to2 = Math.min(end, update3.visible.to + cm.options.viewportMargin);
      if (display.viewFrom < from2 && from2 - display.viewFrom < 20) {
        from2 = Math.max(doc2.first, display.viewFrom);
      }
      if (display.viewTo > to2 && display.viewTo - to2 < 20) {
        to2 = Math.min(end, display.viewTo);
      }
      if (sawCollapsedSpans) {
        from2 = visualLineNo(cm.doc, from2);
        to2 = visualLineEndNo(cm.doc, to2);
      }
      var different = from2 != display.viewFrom || to2 != display.viewTo || display.lastWrapHeight != update3.wrapperHeight || display.lastWrapWidth != update3.wrapperWidth;
      adjustView(cm, from2, to2);
      display.viewOffset = heightAtLine(getLine2(cm.doc, display.viewFrom));
      cm.display.mover.style.top = display.viewOffset + "px";
      var toUpdate = countDirtyView(cm);
      if (!different && toUpdate == 0 && !update3.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
        return false;
      }
      var selSnapshot = selectionSnapshot(cm);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "none";
      }
      patchDisplay(cm, display.updateLineNumbers, update3.dims);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "";
      }
      display.renderedView = display.view;
      restoreSelection(selSnapshot);
      removeChildren(display.cursorDiv);
      removeChildren(display.selectionDiv);
      display.gutters.style.height = display.sizer.style.minHeight = 0;
      if (different) {
        display.lastWrapHeight = update3.wrapperHeight;
        display.lastWrapWidth = update3.wrapperWidth;
        startWorker(cm, 400);
      }
      display.updateLineNumbers = null;
      return true;
    }
    function postUpdateDisplay(cm, update3) {
      var viewport = update3.viewport;
      for (var first = true; ; first = false) {
        if (!first || !cm.options.lineWrapping || update3.oldDisplayWidth == displayWidth(cm)) {
          if (viewport && viewport.top != null) {
            viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
          }
          update3.visible = visibleLines(cm.display, cm.doc, viewport);
          if (update3.visible.from >= cm.display.viewFrom && update3.visible.to <= cm.display.viewTo) {
            break;
          }
        } else if (first) {
          update3.visible = visibleLines(cm.display, cm.doc, viewport);
        }
        if (!updateDisplayIfNeeded(cm, update3)) {
          break;
        }
        updateHeightsInViewport(cm);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update3.force = false;
      }
      update3.signal(cm, "update", cm);
      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
        update3.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
        cm.display.reportedViewFrom = cm.display.viewFrom;
        cm.display.reportedViewTo = cm.display.viewTo;
      }
    }
    function updateDisplaySimple(cm, viewport) {
      var update3 = new DisplayUpdate(cm, viewport);
      if (updateDisplayIfNeeded(cm, update3)) {
        updateHeightsInViewport(cm);
        postUpdateDisplay(cm, update3);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update3.finish();
      }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
      var display = cm.display, lineNumbers = cm.options.lineNumbers;
      var container = display.lineDiv, cur = container.firstChild;
      function rm(node2) {
        var next = node2.nextSibling;
        if (webkit && mac && cm.display.currentWheelTarget == node2) {
          node2.style.display = "none";
        } else {
          node2.parentNode.removeChild(node2);
        }
        return next;
      }
      var view = display.view, lineN = display.viewFrom;
      for (var i3 = 0; i3 < view.length; i3++) {
        var lineView = view[i3];
        if (lineView.hidden)
          ;
        else if (!lineView.node || lineView.node.parentNode != container) {
          var node = buildLineElement(cm, lineView, lineN, dims);
          container.insertBefore(node, cur);
        } else {
          while (cur != lineView.node) {
            cur = rm(cur);
          }
          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
          if (lineView.changes) {
            if (indexOf2(lineView.changes, "gutter") > -1) {
              updateNumber = false;
            }
            updateLineForChanges(cm, lineView, lineN, dims);
          }
          if (updateNumber) {
            removeChildren(lineView.lineNumber);
            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
          }
          cur = lineView.node.nextSibling;
        }
        lineN += lineView.size;
      }
      while (cur) {
        cur = rm(cur);
      }
    }
    function updateGutterSpace(display) {
      var width = display.gutters.offsetWidth;
      display.sizer.style.marginLeft = width + "px";
      signalLater(display, "gutterChanged", display);
    }
    function setDocumentHeight(cm, measure) {
      cm.display.sizer.style.minHeight = measure.docHeight + "px";
      cm.display.heightForcer.style.top = measure.docHeight + "px";
      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
    }
    function alignHorizontally(cm) {
      var display = cm.display, view = display.view;
      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
        return;
      }
      var comp2 = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
      var gutterW = display.gutters.offsetWidth, left = comp2 + "px";
      for (var i3 = 0; i3 < view.length; i3++) {
        if (!view[i3].hidden) {
          if (cm.options.fixedGutter) {
            if (view[i3].gutter) {
              view[i3].gutter.style.left = left;
            }
            if (view[i3].gutterBackground) {
              view[i3].gutterBackground.style.left = left;
            }
          }
          var align = view[i3].alignable;
          if (align) {
            for (var j2 = 0; j2 < align.length; j2++) {
              align[j2].style.left = left;
            }
          }
        }
      }
      if (cm.options.fixedGutter) {
        display.gutters.style.left = comp2 + gutterW + "px";
      }
    }
    function maybeUpdateLineNumberWidth(cm) {
      if (!cm.options.lineNumbers) {
        return false;
      }
      var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
      if (last.length != display.lineNumChars) {
        var test2 = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
        var innerW = test2.firstChild.offsetWidth, padding = test2.offsetWidth - innerW;
        display.lineGutter.style.width = "";
        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
        display.lineNumWidth = display.lineNumInnerWidth + padding;
        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
        display.lineGutter.style.width = display.lineNumWidth + "px";
        updateGutterSpace(cm.display);
        return true;
      }
      return false;
    }
    function getGutters(gutters, lineNumbers) {
      var result = [], sawLineNumbers = false;
      for (var i3 = 0; i3 < gutters.length; i3++) {
        var name = gutters[i3], style2 = null;
        if (typeof name != "string") {
          style2 = name.style;
          name = name.className;
        }
        if (name == "CodeMirror-linenumbers") {
          if (!lineNumbers) {
            continue;
          } else {
            sawLineNumbers = true;
          }
        }
        result.push({ className: name, style: style2 });
      }
      if (lineNumbers && !sawLineNumbers) {
        result.push({ className: "CodeMirror-linenumbers", style: null });
      }
      return result;
    }
    function renderGutters(display) {
      var gutters = display.gutters, specs = display.gutterSpecs;
      removeChildren(gutters);
      display.lineGutter = null;
      for (var i3 = 0; i3 < specs.length; ++i3) {
        var ref2 = specs[i3];
        var className = ref2.className;
        var style2 = ref2.style;
        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
        if (style2) {
          gElt.style.cssText = style2;
        }
        if (className == "CodeMirror-linenumbers") {
          display.lineGutter = gElt;
          gElt.style.width = (display.lineNumWidth || 1) + "px";
        }
      }
      gutters.style.display = specs.length ? "" : "none";
      updateGutterSpace(display);
    }
    function updateGutters(cm) {
      renderGutters(cm.display);
      regChange(cm);
      alignHorizontally(cm);
    }
    function Display(place, doc2, input, options) {
      var d2 = this;
      this.input = input;
      d2.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
      d2.scrollbarFiller.setAttribute("cm-not-content", "true");
      d2.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
      d2.gutterFiller.setAttribute("cm-not-content", "true");
      d2.lineDiv = eltP("div", null, "CodeMirror-code");
      d2.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
      d2.cursorDiv = elt("div", null, "CodeMirror-cursors");
      d2.measure = elt("div", null, "CodeMirror-measure");
      d2.lineMeasure = elt("div", null, "CodeMirror-measure");
      d2.lineSpace = eltP("div", [d2.measure, d2.lineMeasure, d2.selectionDiv, d2.cursorDiv, d2.lineDiv], null, "position: relative; outline: none");
      var lines = eltP("div", [d2.lineSpace], "CodeMirror-lines");
      d2.mover = elt("div", [lines], null, "position: relative");
      d2.sizer = elt("div", [d2.mover], "CodeMirror-sizer");
      d2.sizerWidth = null;
      d2.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
      d2.gutters = elt("div", null, "CodeMirror-gutters");
      d2.lineGutter = null;
      d2.scroller = elt("div", [d2.sizer, d2.heightForcer, d2.gutters], "CodeMirror-scroll");
      d2.scroller.setAttribute("tabIndex", "-1");
      d2.wrapper = elt("div", [d2.scrollbarFiller, d2.gutterFiller, d2.scroller], "CodeMirror");
      d2.wrapper.setAttribute("translate", "no");
      if (ie2 && ie_version < 8) {
        d2.gutters.style.zIndex = -1;
        d2.scroller.style.paddingRight = 0;
      }
      if (!webkit && !(gecko && mobile)) {
        d2.scroller.draggable = true;
      }
      if (place) {
        if (place.appendChild) {
          place.appendChild(d2.wrapper);
        } else {
          place(d2.wrapper);
        }
      }
      d2.viewFrom = d2.viewTo = doc2.first;
      d2.reportedViewFrom = d2.reportedViewTo = doc2.first;
      d2.view = [];
      d2.renderedView = null;
      d2.externalMeasured = null;
      d2.viewOffset = 0;
      d2.lastWrapHeight = d2.lastWrapWidth = 0;
      d2.updateLineNumbers = null;
      d2.nativeBarWidth = d2.barHeight = d2.barWidth = 0;
      d2.scrollbarsClipped = false;
      d2.lineNumWidth = d2.lineNumInnerWidth = d2.lineNumChars = null;
      d2.alignWidgets = false;
      d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
      d2.maxLine = null;
      d2.maxLineLength = 0;
      d2.maxLineChanged = false;
      d2.wheelDX = d2.wheelDY = d2.wheelStartX = d2.wheelStartY = null;
      d2.shift = false;
      d2.selForContextMenu = null;
      d2.activeTouch = null;
      d2.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
      renderGutters(d2);
      input.init(d2);
    }
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    if (ie2) {
      wheelPixelsPerUnit = -0.53;
    } else if (gecko) {
      wheelPixelsPerUnit = 15;
    } else if (chrome2) {
      wheelPixelsPerUnit = -0.7;
    } else if (safari) {
      wheelPixelsPerUnit = -1 / 3;
    }
    function wheelEventDelta(e2) {
      var dx = e2.wheelDeltaX, dy = e2.wheelDeltaY;
      if (dx == null && e2.detail && e2.axis == e2.HORIZONTAL_AXIS) {
        dx = e2.detail;
      }
      if (dy == null && e2.detail && e2.axis == e2.VERTICAL_AXIS) {
        dy = e2.detail;
      } else if (dy == null) {
        dy = e2.wheelDelta;
      }
      return { x: dx, y: dy };
    }
    function wheelEventPixels(e2) {
      var delta2 = wheelEventDelta(e2);
      delta2.x *= wheelPixelsPerUnit;
      delta2.y *= wheelPixelsPerUnit;
      return delta2;
    }
    function onScrollWheel(cm, e2) {
      var delta2 = wheelEventDelta(e2), dx = delta2.x, dy = delta2.y;
      var pixelsPerUnit = wheelPixelsPerUnit;
      if (e2.deltaMode === 0) {
        dx = e2.deltaX;
        dy = e2.deltaY;
        pixelsPerUnit = 1;
      }
      var display = cm.display, scroll = display.scroller;
      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
      var canScrollY = scroll.scrollHeight > scroll.clientHeight;
      if (!(dx && canScrollX || dy && canScrollY)) {
        return;
      }
      if (dy && mac && webkit) {
        outer:
          for (var cur = e2.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i3 = 0; i3 < view.length; i3++) {
              if (view[i3].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
      }
      if (dx && !gecko && !presto && pixelsPerUnit != null) {
        if (dy && canScrollY) {
          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
        }
        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
        if (!dy || dy && canScrollY) {
          e_preventDefault(e2);
        }
        display.wheelStartX = null;
        return;
      }
      if (dy && pixelsPerUnit != null) {
        var pixels = dy * pixelsPerUnit;
        var top2 = cm.doc.scrollTop, bot2 = top2 + display.wrapper.clientHeight;
        if (pixels < 0) {
          top2 = Math.max(0, top2 + pixels - 50);
        } else {
          bot2 = Math.min(cm.doc.height, bot2 + pixels + 50);
        }
        updateDisplaySimple(cm, { top: top2, bottom: bot2 });
      }
      if (wheelSamples < 20 && e2.deltaMode !== 0) {
        if (display.wheelStartX == null) {
          display.wheelStartX = scroll.scrollLeft;
          display.wheelStartY = scroll.scrollTop;
          display.wheelDX = dx;
          display.wheelDY = dy;
          setTimeout(function() {
            if (display.wheelStartX == null) {
              return;
            }
            var movedX = scroll.scrollLeft - display.wheelStartX;
            var movedY = scroll.scrollTop - display.wheelStartY;
            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
            display.wheelStartX = display.wheelStartY = null;
            if (!sample) {
              return;
            }
            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
            ++wheelSamples;
          }, 200);
        } else {
          display.wheelDX += dx;
          display.wheelDY += dy;
        }
      }
    }
    var Selection2 = function(ranges, primIndex) {
      this.ranges = ranges;
      this.primIndex = primIndex;
    };
    Selection2.prototype.primary = function() {
      return this.ranges[this.primIndex];
    };
    Selection2.prototype.equals = function(other) {
      if (other == this) {
        return true;
      }
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
        return false;
      }
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        var here = this.ranges[i3], there = other.ranges[i3];
        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
          return false;
        }
      }
      return true;
    };
    Selection2.prototype.deepCopy = function() {
      var out = [];
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        out[i3] = new Range(copyPos(this.ranges[i3].anchor), copyPos(this.ranges[i3].head));
      }
      return new Selection2(out, this.primIndex);
    };
    Selection2.prototype.somethingSelected = function() {
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        if (!this.ranges[i3].empty()) {
          return true;
        }
      }
      return false;
    };
    Selection2.prototype.contains = function(pos, end) {
      if (!end) {
        end = pos;
      }
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        var range3 = this.ranges[i3];
        if (cmp(end, range3.from()) >= 0 && cmp(pos, range3.to()) <= 0) {
          return i3;
        }
      }
      return -1;
    };
    var Range = function(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    Range.prototype.from = function() {
      return minPos(this.anchor, this.head);
    };
    Range.prototype.to = function() {
      return maxPos(this.anchor, this.head);
    };
    Range.prototype.empty = function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    };
    function normalizeSelection(cm, ranges, primIndex) {
      var mayTouch = cm && cm.options.selectionsMayTouch;
      var prim = ranges[primIndex];
      ranges.sort(function(a2, b2) {
        return cmp(a2.from(), b2.from());
      });
      primIndex = indexOf2(ranges, prim);
      for (var i3 = 1; i3 < ranges.length; i3++) {
        var cur = ranges[i3], prev = ranges[i3 - 1];
        var diff2 = cmp(prev.to(), cur.from());
        if (mayTouch && !cur.empty() ? diff2 > 0 : diff2 >= 0) {
          var from2 = minPos(prev.from(), cur.from()), to2 = maxPos(prev.to(), cur.to());
          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
          if (i3 <= primIndex) {
            --primIndex;
          }
          ranges.splice(--i3, 2, new Range(inv ? to2 : from2, inv ? from2 : to2));
        }
      }
      return new Selection2(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
      return new Selection2([new Range(anchor, head || anchor)], 0);
    }
    function changeEnd(change) {
      if (!change.text) {
        return change.to;
      }
      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    }
    function adjustForChange(pos, change) {
      if (cmp(pos, change.from) < 0) {
        return pos;
      }
      if (cmp(pos, change.to) <= 0) {
        return changeEnd(change);
      }
      var line2 = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) {
        ch += changeEnd(change).ch - change.to.ch;
      }
      return Pos(line2, ch);
    }
    function computeSelAfterChange(doc2, change) {
      var out = [];
      for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
        var range3 = doc2.sel.ranges[i3];
        out.push(new Range(adjustForChange(range3.anchor, change), adjustForChange(range3.head, change)));
      }
      return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
      if (pos.line == old.line) {
        return Pos(nw.line, pos.ch - old.ch + nw.ch);
      } else {
        return Pos(nw.line + (pos.line - old.line), pos.ch);
      }
    }
    function computeReplacedSel(doc2, changes, hint) {
      var out = [];
      var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
      for (var i3 = 0; i3 < changes.length; i3++) {
        var change = changes[i3];
        var from2 = offsetPos(change.from, oldPrev, newPrev);
        var to2 = offsetPos(changeEnd(change), oldPrev, newPrev);
        oldPrev = change.to;
        newPrev = to2;
        if (hint == "around") {
          var range3 = doc2.sel.ranges[i3], inv = cmp(range3.head, range3.anchor) < 0;
          out[i3] = new Range(inv ? to2 : from2, inv ? from2 : to2);
        } else {
          out[i3] = new Range(from2, from2);
        }
      }
      return new Selection2(out, doc2.sel.primIndex);
    }
    function loadMode(cm) {
      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
      resetModeState(cm);
    }
    function resetModeState(cm) {
      cm.doc.iter(function(line2) {
        if (line2.stateAfter) {
          line2.stateAfter = null;
        }
        if (line2.styles) {
          line2.styles = null;
        }
      });
      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
      startWorker(cm, 100);
      cm.state.modeGen++;
      if (cm.curOp) {
        regChange(cm);
      }
    }
    function isWholeLineUpdate(doc2, change) {
      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc2, change, markedSpans, estimateHeight2) {
      function spansFor(n2) {
        return markedSpans ? markedSpans[n2] : null;
      }
      function update3(line2, text4, spans) {
        updateLine(line2, text4, spans, estimateHeight2);
        signalLater(line2, "change", line2, change);
      }
      function linesFor(start2, end) {
        var result = [];
        for (var i3 = start2; i3 < end; ++i3) {
          result.push(new Line(text3[i3], spansFor(i3), estimateHeight2));
        }
        return result;
      }
      var from2 = change.from, to2 = change.to, text3 = change.text;
      var firstLine = getLine2(doc2, from2.line), lastLine = getLine2(doc2, to2.line);
      var lastText = lst(text3), lastSpans = spansFor(text3.length - 1), nlines = to2.line - from2.line;
      if (change.full) {
        doc2.insert(0, linesFor(0, text3.length));
        doc2.remove(text3.length, doc2.size - text3.length);
      } else if (isWholeLineUpdate(doc2, change)) {
        var added = linesFor(0, text3.length - 1);
        update3(lastLine, lastLine.text, lastSpans);
        if (nlines) {
          doc2.remove(from2.line, nlines);
        }
        if (added.length) {
          doc2.insert(from2.line, added);
        }
      } else if (firstLine == lastLine) {
        if (text3.length == 1) {
          update3(firstLine, firstLine.text.slice(0, from2.ch) + lastText + firstLine.text.slice(to2.ch), lastSpans);
        } else {
          var added$1 = linesFor(1, text3.length - 1);
          added$1.push(new Line(lastText + firstLine.text.slice(to2.ch), lastSpans, estimateHeight2));
          update3(firstLine, firstLine.text.slice(0, from2.ch) + text3[0], spansFor(0));
          doc2.insert(from2.line + 1, added$1);
        }
      } else if (text3.length == 1) {
        update3(firstLine, firstLine.text.slice(0, from2.ch) + text3[0] + lastLine.text.slice(to2.ch), spansFor(0));
        doc2.remove(from2.line + 1, nlines);
      } else {
        update3(firstLine, firstLine.text.slice(0, from2.ch) + text3[0], spansFor(0));
        update3(lastLine, lastText + lastLine.text.slice(to2.ch), lastSpans);
        var added$2 = linesFor(1, text3.length - 1);
        if (nlines > 1) {
          doc2.remove(from2.line + 1, nlines - 1);
        }
        doc2.insert(from2.line + 1, added$2);
      }
      signalLater(doc2, "change", doc2, change);
    }
    function linkedDocs(doc2, f2, sharedHistOnly) {
      function propagate(doc3, skip, sharedHist) {
        if (doc3.linked) {
          for (var i3 = 0; i3 < doc3.linked.length; ++i3) {
            var rel = doc3.linked[i3];
            if (rel.doc == skip) {
              continue;
            }
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) {
              continue;
            }
            f2(rel.doc, shared);
            propagate(rel.doc, doc3, shared);
          }
        }
      }
      propagate(doc2, null, true);
    }
    function attachDoc(cm, doc2) {
      if (doc2.cm) {
        throw new Error("This document is already in use.");
      }
      cm.doc = doc2;
      doc2.cm = cm;
      estimateLineHeights(cm);
      loadMode(cm);
      setDirectionClass(cm);
      cm.options.direction = doc2.direction;
      if (!cm.options.lineWrapping) {
        findMaxLine(cm);
      }
      cm.options.mode = doc2.modeOption;
      regChange(cm);
    }
    function setDirectionClass(cm) {
      (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
    }
    function directionChanged(cm) {
      runInOp(cm, function() {
        setDirectionClass(cm);
        regChange(cm);
      });
    }
    function History(prev) {
      this.done = [];
      this.undone = [];
      this.undoDepth = prev ? prev.undoDepth : Infinity;
      this.lastModTime = this.lastSelTime = 0;
      this.lastOp = this.lastSelOp = null;
      this.lastOrigin = this.lastSelOrigin = null;
      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
    }
    function historyChangeFromChange(doc2, change) {
      var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
      attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
      linkedDocs(doc2, function(doc3) {
        return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
      }, true);
      return histChange;
    }
    function clearSelectionEvents(array2) {
      while (array2.length) {
        var last = lst(array2);
        if (last.ranges) {
          array2.pop();
        } else {
          break;
        }
      }
    }
    function lastChangeEvent(hist, force) {
      if (force) {
        clearSelectionEvents(hist.done);
        return lst(hist.done);
      } else if (hist.done.length && !lst(hist.done).ranges) {
        return lst(hist.done);
      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
        hist.done.pop();
        return lst(hist.done);
      }
    }
    function addChangeToHistory(doc2, change, selAfter, opId) {
      var hist = doc2.history;
      hist.undone.length = 0;
      var time = +new Date(), cur;
      var last;
      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
        last = lst(cur.changes);
        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
          last.to = changeEnd(change);
        } else {
          cur.changes.push(historyChangeFromChange(doc2, change));
        }
      } else {
        var before = lst(hist.done);
        if (!before || !before.ranges) {
          pushSelectionToHistory(doc2.sel, hist.done);
        }
        cur = {
          changes: [historyChangeFromChange(doc2, change)],
          generation: hist.generation
        };
        hist.done.push(cur);
        while (hist.done.length > hist.undoDepth) {
          hist.done.shift();
          if (!hist.done[0].ranges) {
            hist.done.shift();
          }
        }
      }
      hist.done.push(selAfter);
      hist.generation = ++hist.maxGeneration;
      hist.lastModTime = hist.lastSelTime = time;
      hist.lastOp = hist.lastSelOp = opId;
      hist.lastOrigin = hist.lastSelOrigin = change.origin;
      if (!last) {
        signal(doc2, "historyAdded");
      }
    }
    function selectionEventCanBeMerged(doc2, origin, prev, sel) {
      var ch = origin.charAt(0);
      return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc2, sel, opId, options) {
      var hist = doc2.history, origin = options && options.origin;
      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
        hist.done[hist.done.length - 1] = sel;
      } else {
        pushSelectionToHistory(sel, hist.done);
      }
      hist.lastSelTime = +new Date();
      hist.lastSelOrigin = origin;
      hist.lastSelOp = opId;
      if (options && options.clearRedo !== false) {
        clearSelectionEvents(hist.undone);
      }
    }
    function pushSelectionToHistory(sel, dest) {
      var top2 = lst(dest);
      if (!(top2 && top2.ranges && top2.equals(sel))) {
        dest.push(sel);
      }
    }
    function attachLocalSpans(doc2, change, from2, to2) {
      var existing = change["spans_" + doc2.id], n2 = 0;
      doc2.iter(Math.max(doc2.first, from2), Math.min(doc2.first + doc2.size, to2), function(line2) {
        if (line2.markedSpans) {
          (existing || (existing = change["spans_" + doc2.id] = {}))[n2] = line2.markedSpans;
        }
        ++n2;
      });
    }
    function removeClearedSpans(spans) {
      if (!spans) {
        return null;
      }
      var out;
      for (var i3 = 0; i3 < spans.length; ++i3) {
        if (spans[i3].marker.explicitlyCleared) {
          if (!out) {
            out = spans.slice(0, i3);
          }
        } else if (out) {
          out.push(spans[i3]);
        }
      }
      return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc2, change) {
      var found = change["spans_" + doc2.id];
      if (!found) {
        return null;
      }
      var nw = [];
      for (var i3 = 0; i3 < change.text.length; ++i3) {
        nw.push(removeClearedSpans(found[i3]));
      }
      return nw;
    }
    function mergeOldSpans(doc2, change) {
      var old = getOldSpans(doc2, change);
      var stretched = stretchSpansOverChange(doc2, change);
      if (!old) {
        return stretched;
      }
      if (!stretched) {
        return old;
      }
      for (var i3 = 0; i3 < old.length; ++i3) {
        var oldCur = old[i3], stretchCur = stretched[i3];
        if (oldCur && stretchCur) {
          spans:
            for (var j2 = 0; j2 < stretchCur.length; ++j2) {
              var span = stretchCur[j2];
              for (var k2 = 0; k2 < oldCur.length; ++k2) {
                if (oldCur[k2].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
        } else if (stretchCur) {
          old[i3] = stretchCur;
        }
      }
      return old;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
      var copy2 = [];
      for (var i3 = 0; i3 < events.length; ++i3) {
        var event = events[i3];
        if (event.ranges) {
          copy2.push(instantiateSel ? Selection2.prototype.deepCopy.call(event) : event);
          continue;
        }
        var changes = event.changes, newChanges = [];
        copy2.push({ changes: newChanges });
        for (var j2 = 0; j2 < changes.length; ++j2) {
          var change = changes[j2], m2 = void 0;
          newChanges.push({ from: change.from, to: change.to, text: change.text });
          if (newGroup) {
            for (var prop3 in change) {
              if (m2 = prop3.match(/^spans_(\d+)$/)) {
                if (indexOf2(newGroup, Number(m2[1])) > -1) {
                  lst(newChanges)[prop3] = change[prop3];
                  delete change[prop3];
                }
              }
            }
          }
        }
      }
      return copy2;
    }
    function extendRange(range3, head, other, extend2) {
      if (extend2) {
        var anchor = range3.anchor;
        if (other) {
          var posBefore = cmp(head, anchor) < 0;
          if (posBefore != cmp(other, anchor) < 0) {
            anchor = head;
            head = other;
          } else if (posBefore != cmp(head, other) < 0) {
            head = other;
          }
        }
        return new Range(anchor, head);
      } else {
        return new Range(other || head, head);
      }
    }
    function extendSelection(doc2, head, other, options, extend2) {
      if (extend2 == null) {
        extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
      }
      setSelection(doc2, new Selection2([extendRange(doc2.sel.primary(), head, other, extend2)], 0), options);
    }
    function extendSelections(doc2, heads, options) {
      var out = [];
      var extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
      for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
        out[i3] = extendRange(doc2.sel.ranges[i3], heads[i3], null, extend2);
      }
      var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
      setSelection(doc2, newSel, options);
    }
    function replaceOneSelection(doc2, i3, range3, options) {
      var ranges = doc2.sel.ranges.slice(0);
      ranges[i3] = range3;
      setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options);
    }
    function setSimpleSelection(doc2, anchor, head, options) {
      setSelection(doc2, simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc2, sel, options) {
      var obj = {
        ranges: sel.ranges,
        update: function(ranges) {
          this.ranges = [];
          for (var i3 = 0; i3 < ranges.length; i3++) {
            this.ranges[i3] = new Range(clipPos(doc2, ranges[i3].anchor), clipPos(doc2, ranges[i3].head));
          }
        },
        origin: options && options.origin
      };
      signal(doc2, "beforeSelectionChange", doc2, obj);
      if (doc2.cm) {
        signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
      }
      if (obj.ranges != sel.ranges) {
        return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
      } else {
        return sel;
      }
    }
    function setSelectionReplaceHistory(doc2, sel, options) {
      var done = doc2.history.done, last = lst(done);
      if (last && last.ranges) {
        done[done.length - 1] = sel;
        setSelectionNoUndo(doc2, sel, options);
      } else {
        setSelection(doc2, sel, options);
      }
    }
    function setSelection(doc2, sel, options) {
      setSelectionNoUndo(doc2, sel, options);
      addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc2, sel, options) {
      if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
        sel = filterSelectionChange(doc2, sel, options);
      }
      var bias = options && options.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
      setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
      if (!(options && options.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
        ensureCursorVisible(doc2.cm);
      }
    }
    function setSelectionInner(doc2, sel) {
      if (sel.equals(doc2.sel)) {
        return;
      }
      doc2.sel = sel;
      if (doc2.cm) {
        doc2.cm.curOp.updateInput = 1;
        doc2.cm.curOp.selectionChanged = true;
        signalCursorActivity(doc2.cm);
      }
      signalLater(doc2, "cursorActivity", doc2);
    }
    function reCheckSelection(doc2) {
      setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
    }
    function skipAtomicInSelection(doc2, sel, bias, mayClear) {
      var out;
      for (var i3 = 0; i3 < sel.ranges.length; i3++) {
        var range3 = sel.ranges[i3];
        var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i3];
        var newAnchor = skipAtomic(doc2, range3.anchor, old && old.anchor, bias, mayClear);
        var newHead = skipAtomic(doc2, range3.head, old && old.head, bias, mayClear);
        if (out || newAnchor != range3.anchor || newHead != range3.head) {
          if (!out) {
            out = sel.ranges.slice(0, i3);
          }
          out[i3] = new Range(newAnchor, newHead);
        }
      }
      return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {
      var line2 = getLine2(doc2, pos.line);
      if (line2.markedSpans) {
        for (var i3 = 0; i3 < line2.markedSpans.length; ++i3) {
          var sp = line2.markedSpans[i3], m2 = sp.marker;
          var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;
          var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;
          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
            if (mayClear) {
              signal(m2, "beforeCursorEnter");
              if (m2.explicitlyCleared) {
                if (!line2.markedSpans) {
                  break;
                } else {
                  --i3;
                  continue;
                }
              }
            }
            if (!m2.atomic) {
              continue;
            }
            if (oldPos) {
              var near = m2.find(dir < 0 ? 1 : -1), diff2 = void 0;
              if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                near = movePos(doc2, near, -dir, near && near.line == pos.line ? line2 : null);
              }
              if (near && near.line == pos.line && (diff2 = cmp(near, oldPos)) && (dir < 0 ? diff2 < 0 : diff2 > 0)) {
                return skipAtomicInner(doc2, near, pos, dir, mayClear);
              }
            }
            var far = m2.find(dir < 0 ? -1 : 1);
            if (dir < 0 ? preventCursorLeft : preventCursorRight) {
              far = movePos(doc2, far, dir, far.line == pos.line ? line2 : null);
            }
            return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;
          }
        }
      }
      return pos;
    }
    function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
      var dir = bias || 1;
      var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);
      if (!found) {
        doc2.cantEdit = true;
        return Pos(doc2.first, 0);
      }
      return found;
    }
    function movePos(doc2, pos, dir, line2) {
      if (dir < 0 && pos.ch == 0) {
        if (pos.line > doc2.first) {
          return clipPos(doc2, Pos(pos.line - 1));
        } else {
          return null;
        }
      } else if (dir > 0 && pos.ch == (line2 || getLine2(doc2, pos.line)).text.length) {
        if (pos.line < doc2.first + doc2.size - 1) {
          return Pos(pos.line + 1, 0);
        } else {
          return null;
        }
      } else {
        return new Pos(pos.line, pos.ch + dir);
      }
    }
    function selectAll(cm) {
      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }
    function filterChange(doc2, change, update3) {
      var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function() {
          return obj.canceled = true;
        }
      };
      if (update3) {
        obj.update = function(from2, to2, text3, origin) {
          if (from2) {
            obj.from = clipPos(doc2, from2);
          }
          if (to2) {
            obj.to = clipPos(doc2, to2);
          }
          if (text3) {
            obj.text = text3;
          }
          if (origin !== void 0) {
            obj.origin = origin;
          }
        };
      }
      signal(doc2, "beforeChange", doc2, obj);
      if (doc2.cm) {
        signal(doc2.cm, "beforeChange", doc2.cm, obj);
      }
      if (obj.canceled) {
        if (doc2.cm) {
          doc2.cm.curOp.updateInput = 2;
        }
        return null;
      }
      return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
    }
    function makeChange(doc2, change, ignoreReadOnly) {
      if (doc2.cm) {
        if (!doc2.cm.curOp) {
          return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
        }
        if (doc2.cm.state.suppressEdits) {
          return;
        }
      }
      if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
        change = filterChange(doc2, change, true);
        if (!change) {
          return;
        }
      }
      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
      if (split) {
        for (var i3 = split.length - 1; i3 >= 0; --i3) {
          makeChangeInner(doc2, { from: split[i3].from, to: split[i3].to, text: i3 ? [""] : change.text, origin: change.origin });
        }
      } else {
        makeChangeInner(doc2, change);
      }
    }
    function makeChangeInner(doc2, change) {
      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
        return;
      }
      var selAfter = computeSelAfterChange(doc2, change);
      addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
      makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
      var rebased = [];
      linkedDocs(doc2, function(doc3, sharedHist) {
        if (!sharedHist && indexOf2(rebased, doc3.history) == -1) {
          rebaseHist(doc3.history, change);
          rebased.push(doc3.history);
        }
        makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
      });
    }
    function makeChangeFromHistory(doc2, type, allowSelectionOnly) {
      var suppress = doc2.cm && doc2.cm.state.suppressEdits;
      if (suppress && !allowSelectionOnly) {
        return;
      }
      var hist = doc2.history, event, selAfter = doc2.sel;
      var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
      var i3 = 0;
      for (; i3 < source.length; i3++) {
        event = source[i3];
        if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
          break;
        }
      }
      if (i3 == source.length) {
        return;
      }
      hist.lastOrigin = hist.lastSelOrigin = null;
      for (; ; ) {
        event = source.pop();
        if (event.ranges) {
          pushSelectionToHistory(event, dest);
          if (allowSelectionOnly && !event.equals(doc2.sel)) {
            setSelection(doc2, event, { clearRedo: false });
            return;
          }
          selAfter = event;
        } else if (suppress) {
          source.push(event);
          return;
        } else {
          break;
        }
      }
      var antiChanges = [];
      pushSelectionToHistory(selAfter, dest);
      dest.push({ changes: antiChanges, generation: hist.generation });
      hist.generation = event.generation || ++hist.maxGeneration;
      var filter2 = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
      var loop = function(i4) {
        var change = event.changes[i4];
        change.origin = type;
        if (filter2 && !filterChange(doc2, change, false)) {
          source.length = 0;
          return {};
        }
        antiChanges.push(historyChangeFromChange(doc2, change));
        var after = i4 ? computeSelAfterChange(doc2, change) : lst(source);
        makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
        if (!i4 && doc2.cm) {
          doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
        }
        var rebased = [];
        linkedDocs(doc2, function(doc3, sharedHist) {
          if (!sharedHist && indexOf2(rebased, doc3.history) == -1) {
            rebaseHist(doc3.history, change);
            rebased.push(doc3.history);
          }
          makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
        });
      };
      for (var i$13 = event.changes.length - 1; i$13 >= 0; --i$13) {
        var returned = loop(i$13);
        if (returned)
          return returned.v;
      }
    }
    function shiftDoc(doc2, distance) {
      if (distance == 0) {
        return;
      }
      doc2.first += distance;
      doc2.sel = new Selection2(map2(doc2.sel.ranges, function(range3) {
        return new Range(Pos(range3.anchor.line + distance, range3.anchor.ch), Pos(range3.head.line + distance, range3.head.ch));
      }), doc2.sel.primIndex);
      if (doc2.cm) {
        regChange(doc2.cm, doc2.first, doc2.first - distance, distance);
        for (var d2 = doc2.cm.display, l2 = d2.viewFrom; l2 < d2.viewTo; l2++) {
          regLineChange(doc2.cm, l2, "gutter");
        }
      }
    }
    function makeChangeSingleDoc(doc2, change, selAfter, spans) {
      if (doc2.cm && !doc2.cm.curOp) {
        return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
      }
      if (change.to.line < doc2.first) {
        shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
        return;
      }
      if (change.from.line > doc2.lastLine()) {
        return;
      }
      if (change.from.line < doc2.first) {
        var shift2 = change.text.length - 1 - (doc2.first - change.from.line);
        shiftDoc(doc2, shift2);
        change = {
          from: Pos(doc2.first, 0),
          to: Pos(change.to.line + shift2, change.to.ch),
          text: [lst(change.text)],
          origin: change.origin
        };
      }
      var last = doc2.lastLine();
      if (change.to.line > last) {
        change = {
          from: change.from,
          to: Pos(last, getLine2(doc2, last).text.length),
          text: [change.text[0]],
          origin: change.origin
        };
      }
      change.removed = getBetween(doc2, change.from, change.to);
      if (!selAfter) {
        selAfter = computeSelAfterChange(doc2, change);
      }
      if (doc2.cm) {
        makeChangeSingleDocInEditor(doc2.cm, change, spans);
      } else {
        updateDoc(doc2, change, spans);
      }
      setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
      if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
        doc2.cantEdit = false;
      }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
      var doc2 = cm.doc, display = cm.display, from2 = change.from, to2 = change.to;
      var recomputeMaxLength = false, checkWidthStart = from2.line;
      if (!cm.options.lineWrapping) {
        checkWidthStart = lineNo(visualLine(getLine2(doc2, from2.line)));
        doc2.iter(checkWidthStart, to2.line + 1, function(line2) {
          if (line2 == display.maxLine) {
            recomputeMaxLength = true;
            return true;
          }
        });
      }
      if (doc2.sel.contains(change.from, change.to) > -1) {
        signalCursorActivity(cm);
      }
      updateDoc(doc2, change, spans, estimateHeight(cm));
      if (!cm.options.lineWrapping) {
        doc2.iter(checkWidthStart, from2.line + change.text.length, function(line2) {
          var len2 = lineLength(line2);
          if (len2 > display.maxLineLength) {
            display.maxLine = line2;
            display.maxLineLength = len2;
            display.maxLineChanged = true;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) {
          cm.curOp.updateMaxLine = true;
        }
      }
      retreatFrontier(doc2, from2.line);
      startWorker(cm, 400);
      var lendiff = change.text.length - (to2.line - from2.line) - 1;
      if (change.full) {
        regChange(cm);
      } else if (from2.line == to2.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
        regLineChange(cm, from2.line, "text");
      } else {
        regChange(cm, from2.line, to2.line + 1, lendiff);
      }
      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
      if (changeHandler || changesHandler) {
        var obj = {
          from: from2,
          to: to2,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
        if (changeHandler) {
          signalLater(cm, "change", cm, obj);
        }
        if (changesHandler) {
          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
      }
      cm.display.selForContextMenu = null;
    }
    function replaceRange(doc2, code3, from2, to2, origin) {
      var assign2;
      if (!to2) {
        to2 = from2;
      }
      if (cmp(to2, from2) < 0) {
        assign2 = [to2, from2], from2 = assign2[0], to2 = assign2[1];
      }
      if (typeof code3 == "string") {
        code3 = doc2.splitLines(code3);
      }
      makeChange(doc2, { from: from2, to: to2, text: code3, origin });
    }
    function rebaseHistSelSingle(pos, from2, to2, diff2) {
      if (to2 < pos.line) {
        pos.line += diff2;
      } else if (from2 < pos.line) {
        pos.line = from2;
        pos.ch = 0;
      }
    }
    function rebaseHistArray(array2, from2, to2, diff2) {
      for (var i3 = 0; i3 < array2.length; ++i3) {
        var sub2 = array2[i3], ok = true;
        if (sub2.ranges) {
          if (!sub2.copied) {
            sub2 = array2[i3] = sub2.deepCopy();
            sub2.copied = true;
          }
          for (var j2 = 0; j2 < sub2.ranges.length; j2++) {
            rebaseHistSelSingle(sub2.ranges[j2].anchor, from2, to2, diff2);
            rebaseHistSelSingle(sub2.ranges[j2].head, from2, to2, diff2);
          }
          continue;
        }
        for (var j$12 = 0; j$12 < sub2.changes.length; ++j$12) {
          var cur = sub2.changes[j$12];
          if (to2 < cur.from.line) {
            cur.from = Pos(cur.from.line + diff2, cur.from.ch);
            cur.to = Pos(cur.to.line + diff2, cur.to.ch);
          } else if (from2 <= cur.to.line) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          array2.splice(0, i3 + 1);
          i3 = 0;
        }
      }
    }
    function rebaseHist(hist, change) {
      var from2 = change.from.line, to2 = change.to.line, diff2 = change.text.length - (to2 - from2) - 1;
      rebaseHistArray(hist.done, from2, to2, diff2);
      rebaseHistArray(hist.undone, from2, to2, diff2);
    }
    function changeLine(doc2, handle, changeType, op) {
      var no = handle, line2 = handle;
      if (typeof handle == "number") {
        line2 = getLine2(doc2, clipLine(doc2, handle));
      } else {
        no = lineNo(handle);
      }
      if (no == null) {
        return null;
      }
      if (op(line2, no) && doc2.cm) {
        regLineChange(doc2.cm, no, changeType);
      }
      return line2;
    }
    function LeafChunk(lines) {
      this.lines = lines;
      this.parent = null;
      var height = 0;
      for (var i3 = 0; i3 < lines.length; ++i3) {
        lines[i3].parent = this;
        height += lines[i3].height;
      }
      this.height = height;
    }
    LeafChunk.prototype = {
      chunkSize: function() {
        return this.lines.length;
      },
      removeInner: function(at2, n2) {
        for (var i3 = at2, e2 = at2 + n2; i3 < e2; ++i3) {
          var line2 = this.lines[i3];
          this.height -= line2.height;
          cleanUpLine(line2);
          signalLater(line2, "delete");
        }
        this.lines.splice(at2, n2);
      },
      collapse: function(lines) {
        lines.push.apply(lines, this.lines);
      },
      insertInner: function(at2, lines, height) {
        this.height += height;
        this.lines = this.lines.slice(0, at2).concat(lines).concat(this.lines.slice(at2));
        for (var i3 = 0; i3 < lines.length; ++i3) {
          lines[i3].parent = this;
        }
      },
      iterN: function(at2, n2, op) {
        for (var e2 = at2 + n2; at2 < e2; ++at2) {
          if (op(this.lines[at2])) {
            return true;
          }
        }
      }
    };
    function BranchChunk(children2) {
      this.children = children2;
      var size2 = 0, height = 0;
      for (var i3 = 0; i3 < children2.length; ++i3) {
        var ch = children2[i3];
        size2 += ch.chunkSize();
        height += ch.height;
        ch.parent = this;
      }
      this.size = size2;
      this.height = height;
      this.parent = null;
    }
    BranchChunk.prototype = {
      chunkSize: function() {
        return this.size;
      },
      removeInner: function(at2, n2) {
        this.size -= n2;
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          var child = this.children[i3], sz = child.chunkSize();
          if (at2 < sz) {
            var rm = Math.min(n2, sz - at2), oldHeight = child.height;
            child.removeInner(at2, rm);
            this.height -= oldHeight - child.height;
            if (sz == rm) {
              this.children.splice(i3--, 1);
              child.parent = null;
            }
            if ((n2 -= rm) == 0) {
              break;
            }
            at2 = 0;
          } else {
            at2 -= sz;
          }
        }
        if (this.size - n2 < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
          var lines = [];
          this.collapse(lines);
          this.children = [new LeafChunk(lines)];
          this.children[0].parent = this;
        }
      },
      collapse: function(lines) {
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          this.children[i3].collapse(lines);
        }
      },
      insertInner: function(at2, lines, height) {
        this.size += lines.length;
        this.height += height;
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          var child = this.children[i3], sz = child.chunkSize();
          if (at2 <= sz) {
            child.insertInner(at2, lines, height);
            if (child.lines && child.lines.length > 50) {
              var remaining = child.lines.length % 25 + 25;
              for (var pos = remaining; pos < child.lines.length; ) {
                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                child.height -= leaf.height;
                this.children.splice(++i3, 0, leaf);
                leaf.parent = this;
              }
              child.lines = child.lines.slice(0, remaining);
              this.maybeSpill();
            }
            break;
          }
          at2 -= sz;
        }
      },
      maybeSpill: function() {
        if (this.children.length <= 10) {
          return;
        }
        var me2 = this;
        do {
          var spilled = me2.children.splice(me2.children.length - 5, 5);
          var sibling = new BranchChunk(spilled);
          if (!me2.parent) {
            var copy2 = new BranchChunk(me2.children);
            copy2.parent = me2;
            me2.children = [copy2, sibling];
            me2 = copy2;
          } else {
            me2.size -= sibling.size;
            me2.height -= sibling.height;
            var myIndex = indexOf2(me2.parent.children, me2);
            me2.parent.children.splice(myIndex + 1, 0, sibling);
          }
          sibling.parent = me2.parent;
        } while (me2.children.length > 10);
        me2.parent.maybeSpill();
      },
      iterN: function(at2, n2, op) {
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          var child = this.children[i3], sz = child.chunkSize();
          if (at2 < sz) {
            var used = Math.min(n2, sz - at2);
            if (child.iterN(at2, used, op)) {
              return true;
            }
            if ((n2 -= used) == 0) {
              break;
            }
            at2 = 0;
          } else {
            at2 -= sz;
          }
        }
      }
    };
    var LineWidget = function(doc2, node, options) {
      if (options) {
        for (var opt in options) {
          if (options.hasOwnProperty(opt)) {
            this[opt] = options[opt];
          }
        }
      }
      this.doc = doc2;
      this.node = node;
    };
    LineWidget.prototype.clear = function() {
      var cm = this.doc.cm, ws = this.line.widgets, line2 = this.line, no = lineNo(line2);
      if (no == null || !ws) {
        return;
      }
      for (var i3 = 0; i3 < ws.length; ++i3) {
        if (ws[i3] == this) {
          ws.splice(i3--, 1);
        }
      }
      if (!ws.length) {
        line2.widgets = null;
      }
      var height = widgetHeight(this);
      updateLineHeight(line2, Math.max(0, line2.height - height));
      if (cm) {
        runInOp(cm, function() {
          adjustScrollWhenAboveVisible(cm, line2, -height);
          regLineChange(cm, no, "widget");
        });
        signalLater(cm, "lineWidgetCleared", cm, this, no);
      }
    };
    LineWidget.prototype.changed = function() {
      var this$1$1 = this;
      var oldH = this.height, cm = this.doc.cm, line2 = this.line;
      this.height = null;
      var diff2 = widgetHeight(this) - oldH;
      if (!diff2) {
        return;
      }
      if (!lineIsHidden(this.doc, line2)) {
        updateLineHeight(line2, line2.height + diff2);
      }
      if (cm) {
        runInOp(cm, function() {
          cm.curOp.forceUpdate = true;
          adjustScrollWhenAboveVisible(cm, line2, diff2);
          signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line2));
        });
      }
    };
    eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line2, diff2) {
      if (heightAtLine(line2) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
        addToScrollTop(cm, diff2);
      }
    }
    function addLineWidget(doc2, handle, node, options) {
      var widget = new LineWidget(doc2, node, options);
      var cm = doc2.cm;
      if (cm && widget.noHScroll) {
        cm.display.alignWidgets = true;
      }
      changeLine(doc2, handle, "widget", function(line2) {
        var widgets = line2.widgets || (line2.widgets = []);
        if (widget.insertAt == null) {
          widgets.push(widget);
        } else {
          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
        }
        widget.line = line2;
        if (cm && !lineIsHidden(doc2, line2)) {
          var aboveVisible = heightAtLine(line2) < doc2.scrollTop;
          updateLineHeight(line2, line2.height + widgetHeight(widget));
          if (aboveVisible) {
            addToScrollTop(cm, widget.height);
          }
          cm.curOp.forceUpdate = true;
        }
        return true;
      });
      if (cm) {
        signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
      }
      return widget;
    }
    var nextMarkerId = 0;
    var TextMarker = function(doc2, type) {
      this.lines = [];
      this.type = type;
      this.doc = doc2;
      this.id = ++nextMarkerId;
    };
    TextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      var cm = this.doc.cm, withOp = cm && !cm.curOp;
      if (withOp) {
        startOperation(cm);
      }
      if (hasHandler(this, "clear")) {
        var found = this.find();
        if (found) {
          signalLater(this, "clear", found.from, found.to);
        }
      }
      var min2 = null, max2 = null;
      for (var i3 = 0; i3 < this.lines.length; ++i3) {
        var line2 = this.lines[i3];
        var span = getMarkedSpanFor(line2.markedSpans, this);
        if (cm && !this.collapsed) {
          regLineChange(cm, lineNo(line2), "text");
        } else if (cm) {
          if (span.to != null) {
            max2 = lineNo(line2);
          }
          if (span.from != null) {
            min2 = lineNo(line2);
          }
        }
        line2.markedSpans = removeMarkedSpan(line2.markedSpans, span);
        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line2) && cm) {
          updateLineHeight(line2, textHeight(cm.display));
        }
      }
      if (cm && this.collapsed && !cm.options.lineWrapping) {
        for (var i$13 = 0; i$13 < this.lines.length; ++i$13) {
          var visual = visualLine(this.lines[i$13]), len2 = lineLength(visual);
          if (len2 > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len2;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (min2 != null && cm && this.collapsed) {
        regChange(cm, min2, max2 + 1);
      }
      this.lines.length = 0;
      this.explicitlyCleared = true;
      if (this.atomic && this.doc.cantEdit) {
        this.doc.cantEdit = false;
        if (cm) {
          reCheckSelection(cm.doc);
        }
      }
      if (cm) {
        signalLater(cm, "markerCleared", cm, this, min2, max2);
      }
      if (withOp) {
        endOperation(cm);
      }
      if (this.parent) {
        this.parent.clear();
      }
    };
    TextMarker.prototype.find = function(side, lineObj) {
      if (side == null && this.type == "bookmark") {
        side = 1;
      }
      var from2, to2;
      for (var i3 = 0; i3 < this.lines.length; ++i3) {
        var line2 = this.lines[i3];
        var span = getMarkedSpanFor(line2.markedSpans, this);
        if (span.from != null) {
          from2 = Pos(lineObj ? line2 : lineNo(line2), span.from);
          if (side == -1) {
            return from2;
          }
        }
        if (span.to != null) {
          to2 = Pos(lineObj ? line2 : lineNo(line2), span.to);
          if (side == 1) {
            return to2;
          }
        }
      }
      return from2 && { from: from2, to: to2 };
    };
    TextMarker.prototype.changed = function() {
      var this$1$1 = this;
      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
      if (!pos || !cm) {
        return;
      }
      runInOp(cm, function() {
        var line2 = pos.line, lineN = lineNo(pos.line);
        var view = findViewForLine(cm, lineN);
        if (view) {
          clearLineMeasurementCacheFor(view);
          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
        }
        cm.curOp.updateMaxLine = true;
        if (!lineIsHidden(widget.doc, line2) && widget.height != null) {
          var oldHeight = widget.height;
          widget.height = null;
          var dHeight = widgetHeight(widget) - oldHeight;
          if (dHeight) {
            updateLineHeight(line2, line2.height + dHeight);
          }
        }
        signalLater(cm, "markerChanged", cm, this$1$1);
      });
    };
    TextMarker.prototype.attachLine = function(line2) {
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        if (!op.maybeHiddenMarkers || indexOf2(op.maybeHiddenMarkers, this) == -1) {
          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
      }
      this.lines.push(line2);
    };
    TextMarker.prototype.detachLine = function(line2) {
      this.lines.splice(indexOf2(this.lines, line2), 1);
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
      }
    };
    eventMixin(TextMarker);
    function markText(doc2, from2, to2, options, type) {
      if (options && options.shared) {
        return markTextShared(doc2, from2, to2, options, type);
      }
      if (doc2.cm && !doc2.cm.curOp) {
        return operation(doc2.cm, markText)(doc2, from2, to2, options, type);
      }
      var marker2 = new TextMarker(doc2, type), diff2 = cmp(from2, to2);
      if (options) {
        copyObj(options, marker2, false);
      }
      if (diff2 > 0 || diff2 == 0 && marker2.clearWhenEmpty !== false) {
        return marker2;
      }
      if (marker2.replacedWith) {
        marker2.collapsed = true;
        marker2.widgetNode = eltP("span", [marker2.replacedWith], "CodeMirror-widget");
        if (!options.handleMouseEvents) {
          marker2.widgetNode.setAttribute("cm-ignore-events", "true");
        }
        if (options.insertLeft) {
          marker2.widgetNode.insertLeft = true;
        }
      }
      if (marker2.collapsed) {
        if (conflictingCollapsedRange(doc2, from2.line, from2, to2, marker2) || from2.line != to2.line && conflictingCollapsedRange(doc2, to2.line, from2, to2, marker2)) {
          throw new Error("Inserting collapsed marker partially overlapping an existing one");
        }
        seeCollapsedSpans();
      }
      if (marker2.addToHistory) {
        addChangeToHistory(doc2, { from: from2, to: to2, origin: "markText" }, doc2.sel, NaN);
      }
      var curLine = from2.line, cm = doc2.cm, updateMaxLine;
      doc2.iter(curLine, to2.line + 1, function(line2) {
        if (cm && marker2.collapsed && !cm.options.lineWrapping && visualLine(line2) == cm.display.maxLine) {
          updateMaxLine = true;
        }
        if (marker2.collapsed && curLine != from2.line) {
          updateLineHeight(line2, 0);
        }
        addMarkedSpan(line2, new MarkedSpan(marker2, curLine == from2.line ? from2.ch : null, curLine == to2.line ? to2.ch : null), doc2.cm && doc2.cm.curOp);
        ++curLine;
      });
      if (marker2.collapsed) {
        doc2.iter(from2.line, to2.line + 1, function(line2) {
          if (lineIsHidden(doc2, line2)) {
            updateLineHeight(line2, 0);
          }
        });
      }
      if (marker2.clearOnEnter) {
        on(marker2, "beforeCursorEnter", function() {
          return marker2.clear();
        });
      }
      if (marker2.readOnly) {
        seeReadOnlySpans();
        if (doc2.history.done.length || doc2.history.undone.length) {
          doc2.clearHistory();
        }
      }
      if (marker2.collapsed) {
        marker2.id = ++nextMarkerId;
        marker2.atomic = true;
      }
      if (cm) {
        if (updateMaxLine) {
          cm.curOp.updateMaxLine = true;
        }
        if (marker2.collapsed) {
          regChange(cm, from2.line, to2.line + 1);
        } else if (marker2.className || marker2.startStyle || marker2.endStyle || marker2.css || marker2.attributes || marker2.title) {
          for (var i3 = from2.line; i3 <= to2.line; i3++) {
            regLineChange(cm, i3, "text");
          }
        }
        if (marker2.atomic) {
          reCheckSelection(cm.doc);
        }
        signalLater(cm, "markerAdded", cm, marker2);
      }
      return marker2;
    }
    var SharedTextMarker = function(markers, primary) {
      this.markers = markers;
      this.primary = primary;
      for (var i3 = 0; i3 < markers.length; ++i3) {
        markers[i3].parent = this;
      }
    };
    SharedTextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      this.explicitlyCleared = true;
      for (var i3 = 0; i3 < this.markers.length; ++i3) {
        this.markers[i3].clear();
      }
      signalLater(this, "clear");
    };
    SharedTextMarker.prototype.find = function(side, lineObj) {
      return this.primary.find(side, lineObj);
    };
    eventMixin(SharedTextMarker);
    function markTextShared(doc2, from2, to2, options, type) {
      options = copyObj(options);
      options.shared = false;
      var markers = [markText(doc2, from2, to2, options, type)], primary = markers[0];
      var widget = options.widgetNode;
      linkedDocs(doc2, function(doc3) {
        if (widget) {
          options.widgetNode = widget.cloneNode(true);
        }
        markers.push(markText(doc3, clipPos(doc3, from2), clipPos(doc3, to2), options, type));
        for (var i3 = 0; i3 < doc3.linked.length; ++i3) {
          if (doc3.linked[i3].isParent) {
            return;
          }
        }
        primary = lst(markers);
      });
      return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc2) {
      return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m2) {
        return m2.parent;
      });
    }
    function copySharedMarkers(doc2, markers) {
      for (var i3 = 0; i3 < markers.length; i3++) {
        var marker2 = markers[i3], pos = marker2.find();
        var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
        if (cmp(mFrom, mTo)) {
          var subMark = markText(doc2, mFrom, mTo, marker2.primary, marker2.primary.type);
          marker2.markers.push(subMark);
          subMark.parent = marker2;
        }
      }
    }
    function detachSharedMarkers(markers) {
      var loop = function(i4) {
        var marker2 = markers[i4], linked = [marker2.primary.doc];
        linkedDocs(marker2.primary.doc, function(d2) {
          return linked.push(d2);
        });
        for (var j2 = 0; j2 < marker2.markers.length; j2++) {
          var subMarker = marker2.markers[j2];
          if (indexOf2(linked, subMarker.doc) == -1) {
            subMarker.parent = null;
            marker2.markers.splice(j2--, 1);
          }
        }
      };
      for (var i3 = 0; i3 < markers.length; i3++)
        loop(i3);
    }
    var nextDocId = 0;
    var Doc = function(text3, mode, firstLine, lineSep, direction) {
      if (!(this instanceof Doc)) {
        return new Doc(text3, mode, firstLine, lineSep, direction);
      }
      if (firstLine == null) {
        firstLine = 0;
      }
      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.modeFrontier = this.highlightFrontier = firstLine;
      var start2 = Pos(firstLine, 0);
      this.sel = simpleSelection(start2);
      this.history = new History(null);
      this.id = ++nextDocId;
      this.modeOption = mode;
      this.lineSep = lineSep;
      this.direction = direction == "rtl" ? "rtl" : "ltr";
      this.extend = false;
      if (typeof text3 == "string") {
        text3 = this.splitLines(text3);
      }
      updateDoc(this, { from: start2, to: start2, text: text3 });
      setSelection(this, simpleSelection(start2), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
      constructor: Doc,
      iter: function(from2, to2, op) {
        if (op) {
          this.iterN(from2 - this.first, to2 - from2, op);
        } else {
          this.iterN(this.first, this.first + this.size, from2);
        }
      },
      insert: function(at2, lines) {
        var height = 0;
        for (var i3 = 0; i3 < lines.length; ++i3) {
          height += lines[i3].height;
        }
        this.insertInner(at2 - this.first, lines, height);
      },
      remove: function(at2, n2) {
        this.removeInner(at2 - this.first, n2);
      },
      getValue: function(lineSep) {
        var lines = getLines2(this, this.first, this.first + this.size);
        if (lineSep === false) {
          return lines;
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      setValue: docMethodOp(function(code3) {
        var top2 = Pos(this.first, 0), last = this.first + this.size - 1;
        makeChange(this, {
          from: top2,
          to: Pos(last, getLine2(this, last).text.length),
          text: this.splitLines(code3),
          origin: "setValue",
          full: true
        }, true);
        if (this.cm) {
          scrollToCoords(this.cm, 0, 0);
        }
        setSelection(this, simpleSelection(top2), sel_dontScroll);
      }),
      replaceRange: function(code3, from2, to2, origin) {
        from2 = clipPos(this, from2);
        to2 = to2 ? clipPos(this, to2) : from2;
        replaceRange(this, code3, from2, to2, origin);
      },
      getRange: function(from2, to2, lineSep) {
        var lines = getBetween(this, clipPos(this, from2), clipPos(this, to2));
        if (lineSep === false) {
          return lines;
        }
        if (lineSep === "") {
          return lines.join("");
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      getLine: function(line2) {
        var l2 = this.getLineHandle(line2);
        return l2 && l2.text;
      },
      getLineHandle: function(line2) {
        if (isLine(this, line2)) {
          return getLine2(this, line2);
        }
      },
      getLineNumber: function(line2) {
        return lineNo(line2);
      },
      getLineHandleVisualStart: function(line2) {
        if (typeof line2 == "number") {
          line2 = getLine2(this, line2);
        }
        return visualLine(line2);
      },
      lineCount: function() {
        return this.size;
      },
      firstLine: function() {
        return this.first;
      },
      lastLine: function() {
        return this.first + this.size - 1;
      },
      clipPos: function(pos) {
        return clipPos(this, pos);
      },
      getCursor: function(start2) {
        var range3 = this.sel.primary(), pos;
        if (start2 == null || start2 == "head") {
          pos = range3.head;
        } else if (start2 == "anchor") {
          pos = range3.anchor;
        } else if (start2 == "end" || start2 == "to" || start2 === false) {
          pos = range3.to();
        } else {
          pos = range3.from();
        }
        return pos;
      },
      listSelections: function() {
        return this.sel.ranges;
      },
      somethingSelected: function() {
        return this.sel.somethingSelected();
      },
      setCursor: docMethodOp(function(line2, ch, options) {
        setSimpleSelection(this, clipPos(this, typeof line2 == "number" ? Pos(line2, ch || 0) : line2), null, options);
      }),
      setSelection: docMethodOp(function(anchor, head, options) {
        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
      }),
      extendSelection: docMethodOp(function(head, other, options) {
        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
      }),
      extendSelections: docMethodOp(function(heads, options) {
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      extendSelectionsBy: docMethodOp(function(f2, options) {
        var heads = map2(this.sel.ranges, f2);
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      setSelections: docMethodOp(function(ranges, primary, options) {
        if (!ranges.length) {
          return;
        }
        var out = [];
        for (var i3 = 0; i3 < ranges.length; i3++) {
          out[i3] = new Range(clipPos(this, ranges[i3].anchor), clipPos(this, ranges[i3].head || ranges[i3].anchor));
        }
        if (primary == null) {
          primary = Math.min(ranges.length - 1, this.sel.primIndex);
        }
        setSelection(this, normalizeSelection(this.cm, out, primary), options);
      }),
      addSelection: docMethodOp(function(anchor, head, options) {
        var ranges = this.sel.ranges.slice(0);
        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
      }),
      getSelection: function(lineSep) {
        var ranges = this.sel.ranges, lines;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
          lines = lines ? lines.concat(sel) : sel;
        }
        if (lineSep === false) {
          return lines;
        } else {
          return lines.join(lineSep || this.lineSeparator());
        }
      },
      getSelections: function(lineSep) {
        var parts = [], ranges = this.sel.ranges;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
          if (lineSep !== false) {
            sel = sel.join(lineSep || this.lineSeparator());
          }
          parts[i3] = sel;
        }
        return parts;
      },
      replaceSelection: function(code3, collapse, origin) {
        var dup = [];
        for (var i3 = 0; i3 < this.sel.ranges.length; i3++) {
          dup[i3] = code3;
        }
        this.replaceSelections(dup, collapse, origin || "+input");
      },
      replaceSelections: docMethodOp(function(code3, collapse, origin) {
        var changes = [], sel = this.sel;
        for (var i3 = 0; i3 < sel.ranges.length; i3++) {
          var range3 = sel.ranges[i3];
          changes[i3] = { from: range3.from(), to: range3.to(), text: this.splitLines(code3[i3]), origin };
        }
        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
        for (var i$13 = changes.length - 1; i$13 >= 0; i$13--) {
          makeChange(this, changes[i$13]);
        }
        if (newSel) {
          setSelectionReplaceHistory(this, newSel);
        } else if (this.cm) {
          ensureCursorVisible(this.cm);
        }
      }),
      undo: docMethodOp(function() {
        makeChangeFromHistory(this, "undo");
      }),
      redo: docMethodOp(function() {
        makeChangeFromHistory(this, "redo");
      }),
      undoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "undo", true);
      }),
      redoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "redo", true);
      }),
      setExtending: function(val) {
        this.extend = val;
      },
      getExtending: function() {
        return this.extend;
      },
      historySize: function() {
        var hist = this.history, done = 0, undone = 0;
        for (var i3 = 0; i3 < hist.done.length; i3++) {
          if (!hist.done[i3].ranges) {
            ++done;
          }
        }
        for (var i$13 = 0; i$13 < hist.undone.length; i$13++) {
          if (!hist.undone[i$13].ranges) {
            ++undone;
          }
        }
        return { undo: done, redo: undone };
      },
      clearHistory: function() {
        var this$1$1 = this;
        this.history = new History(this.history);
        linkedDocs(this, function(doc2) {
          return doc2.history = this$1$1.history;
        }, true);
      },
      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(forceSplit) {
        if (forceSplit) {
          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
        }
        return this.history.generation;
      },
      isClean: function(gen) {
        return this.history.generation == (gen || this.cleanGeneration);
      },
      getHistory: function() {
        return {
          done: copyHistoryArray(this.history.done),
          undone: copyHistoryArray(this.history.undone)
        };
      },
      setHistory: function(histData) {
        var hist = this.history = new History(this.history);
        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
      },
      setGutterMarker: docMethodOp(function(line2, gutterID, value) {
        return changeLine(this, line2, "gutter", function(line3) {
          var markers = line3.gutterMarkers || (line3.gutterMarkers = {});
          markers[gutterID] = value;
          if (!value && isEmpty3(markers)) {
            line3.gutterMarkers = null;
          }
          return true;
        });
      }),
      clearGutter: docMethodOp(function(gutterID) {
        var this$1$1 = this;
        this.iter(function(line2) {
          if (line2.gutterMarkers && line2.gutterMarkers[gutterID]) {
            changeLine(this$1$1, line2, "gutter", function() {
              line2.gutterMarkers[gutterID] = null;
              if (isEmpty3(line2.gutterMarkers)) {
                line2.gutterMarkers = null;
              }
              return true;
            });
          }
        });
      }),
      lineInfo: function(line2) {
        var n2;
        if (typeof line2 == "number") {
          if (!isLine(this, line2)) {
            return null;
          }
          n2 = line2;
          line2 = getLine2(this, line2);
          if (!line2) {
            return null;
          }
        } else {
          n2 = lineNo(line2);
          if (n2 == null) {
            return null;
          }
        }
        return {
          line: n2,
          handle: line2,
          text: line2.text,
          gutterMarkers: line2.gutterMarkers,
          textClass: line2.textClass,
          bgClass: line2.bgClass,
          wrapClass: line2.wrapClass,
          widgets: line2.widgets
        };
      },
      addLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line2) {
          var prop3 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          if (!line2[prop3]) {
            line2[prop3] = cls;
          } else if (classTest(cls).test(line2[prop3])) {
            return false;
          } else {
            line2[prop3] += " " + cls;
          }
          return true;
        });
      }),
      removeLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line2) {
          var prop3 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          var cur = line2[prop3];
          if (!cur) {
            return false;
          } else if (cls == null) {
            line2[prop3] = null;
          } else {
            var found = cur.match(classTest(cls));
            if (!found) {
              return false;
            }
            var end = found.index + found[0].length;
            line2[prop3] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
          }
          return true;
        });
      }),
      addLineWidget: docMethodOp(function(handle, node, options) {
        return addLineWidget(this, handle, node, options);
      }),
      removeLineWidget: function(widget) {
        widget.clear();
      },
      markText: function(from2, to2, options) {
        return markText(this, clipPos(this, from2), clipPos(this, to2), options, options && options.type || "range");
      },
      setBookmark: function(pos, options) {
        var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft,
          clearWhenEmpty: false,
          shared: options && options.shared,
          handleMouseEvents: options && options.handleMouseEvents
        };
        pos = clipPos(this, pos);
        return markText(this, pos, pos, realOpts, "bookmark");
      },
      findMarksAt: function(pos) {
        pos = clipPos(this, pos);
        var markers = [], spans = getLine2(this, pos.line).markedSpans;
        if (spans) {
          for (var i3 = 0; i3 < spans.length; ++i3) {
            var span = spans[i3];
            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
              markers.push(span.marker.parent || span.marker);
            }
          }
        }
        return markers;
      },
      findMarks: function(from2, to2, filter2) {
        from2 = clipPos(this, from2);
        to2 = clipPos(this, to2);
        var found = [], lineNo2 = from2.line;
        this.iter(from2.line, to2.line + 1, function(line2) {
          var spans = line2.markedSpans;
          if (spans) {
            for (var i3 = 0; i3 < spans.length; i3++) {
              var span = spans[i3];
              if (!(span.to != null && lineNo2 == from2.line && from2.ch >= span.to || span.from == null && lineNo2 != from2.line || span.from != null && lineNo2 == to2.line && span.from >= to2.ch) && (!filter2 || filter2(span.marker))) {
                found.push(span.marker.parent || span.marker);
              }
            }
          }
          ++lineNo2;
        });
        return found;
      },
      getAllMarks: function() {
        var markers = [];
        this.iter(function(line2) {
          var sps = line2.markedSpans;
          if (sps) {
            for (var i3 = 0; i3 < sps.length; ++i3) {
              if (sps[i3].from != null) {
                markers.push(sps[i3].marker);
              }
            }
          }
        });
        return markers;
      },
      posFromIndex: function(off2) {
        var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
        this.iter(function(line2) {
          var sz = line2.text.length + sepSize;
          if (sz > off2) {
            ch = off2;
            return true;
          }
          off2 -= sz;
          ++lineNo2;
        });
        return clipPos(this, Pos(lineNo2, ch));
      },
      indexFromPos: function(coords) {
        coords = clipPos(this, coords);
        var index2 = coords.ch;
        if (coords.line < this.first || coords.ch < 0) {
          return 0;
        }
        var sepSize = this.lineSeparator().length;
        this.iter(this.first, coords.line, function(line2) {
          index2 += line2.text.length + sepSize;
        });
        return index2;
      },
      copy: function(copyHistory) {
        var doc2 = new Doc(getLines2(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
        doc2.scrollTop = this.scrollTop;
        doc2.scrollLeft = this.scrollLeft;
        doc2.sel = this.sel;
        doc2.extend = false;
        if (copyHistory) {
          doc2.history.undoDepth = this.history.undoDepth;
          doc2.setHistory(this.getHistory());
        }
        return doc2;
      },
      linkedDoc: function(options) {
        if (!options) {
          options = {};
        }
        var from2 = this.first, to2 = this.first + this.size;
        if (options.from != null && options.from > from2) {
          from2 = options.from;
        }
        if (options.to != null && options.to < to2) {
          to2 = options.to;
        }
        var copy2 = new Doc(getLines2(this, from2, to2), options.mode || this.modeOption, from2, this.lineSep, this.direction);
        if (options.sharedHist) {
          copy2.history = this.history;
        }
        (this.linked || (this.linked = [])).push({ doc: copy2, sharedHist: options.sharedHist });
        copy2.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
        copySharedMarkers(copy2, findSharedMarkers(this));
        return copy2;
      },
      unlinkDoc: function(other) {
        if (other instanceof CodeMirror2) {
          other = other.doc;
        }
        if (this.linked) {
          for (var i3 = 0; i3 < this.linked.length; ++i3) {
            var link3 = this.linked[i3];
            if (link3.doc != other) {
              continue;
            }
            this.linked.splice(i3, 1);
            other.unlinkDoc(this);
            detachSharedMarkers(findSharedMarkers(this));
            break;
          }
        }
        if (other.history == this.history) {
          var splitIds = [other.id];
          linkedDocs(other, function(doc2) {
            return splitIds.push(doc2.id);
          }, true);
          other.history = new History(null);
          other.history.done = copyHistoryArray(this.history.done, splitIds);
          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
        }
      },
      iterLinkedDocs: function(f2) {
        linkedDocs(this, f2);
      },
      getMode: function() {
        return this.mode;
      },
      getEditor: function() {
        return this.cm;
      },
      splitLines: function(str) {
        if (this.lineSep) {
          return str.split(this.lineSep);
        }
        return splitLinesAuto(str);
      },
      lineSeparator: function() {
        return this.lineSep || "\n";
      },
      setDirection: docMethodOp(function(dir) {
        if (dir != "rtl") {
          dir = "ltr";
        }
        if (dir == this.direction) {
          return;
        }
        this.direction = dir;
        this.iter(function(line2) {
          return line2.order = null;
        });
        if (this.cm) {
          directionChanged(this.cm);
        }
      })
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    var lastDrop = 0;
    function onDrop(e2) {
      var cm = this;
      clearDragCursor(cm);
      if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
        return;
      }
      e_preventDefault(e2);
      if (ie2) {
        lastDrop = +new Date();
      }
      var pos = posFromMouse(cm, e2, true), files = e2.dataTransfer.files;
      if (!pos || cm.isReadOnly()) {
        return;
      }
      if (files && files.length && window.FileReader && window.File) {
        var n2 = files.length, text3 = Array(n2), read2 = 0;
        var markAsReadAndPasteIfAllFilesAreRead = function() {
          if (++read2 == n2) {
            operation(cm, function() {
              pos = clipPos(cm.doc, pos);
              var change = {
                from: pos,
                to: pos,
                text: cm.doc.splitLines(text3.filter(function(t2) {
                  return t2 != null;
                }).join(cm.doc.lineSeparator())),
                origin: "paste"
              };
              makeChange(cm.doc, change);
              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
            })();
          }
        };
        var readTextFromFile = function(file, i4) {
          if (cm.options.allowDropFileTypes && indexOf2(cm.options.allowDropFileTypes, file.type) == -1) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }
          var reader = new FileReader();
          reader.onerror = function() {
            return markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.onload = function() {
            var content = reader.result;
            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            text3[i4] = content;
            markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.readAsText(file);
        };
        for (var i3 = 0; i3 < files.length; i3++) {
          readTextFromFile(files[i3], i3);
        }
      } else {
        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
          cm.state.draggingText(e2);
          setTimeout(function() {
            return cm.display.input.focus();
          }, 20);
          return;
        }
        try {
          var text$1 = e2.dataTransfer.getData("Text");
          if (text$1) {
            var selected;
            if (cm.state.draggingText && !cm.state.draggingText.copy) {
              selected = cm.listSelections();
            }
            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
            if (selected) {
              for (var i$13 = 0; i$13 < selected.length; ++i$13) {
                replaceRange(cm.doc, "", selected[i$13].anchor, selected[i$13].head, "drag");
              }
            }
            cm.replaceSelection(text$1, "around", "paste");
            cm.display.input.focus();
          }
        } catch (e$12) {
        }
      }
    }
    function onDragStart(cm, e2) {
      if (ie2 && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
        e_stop(e2);
        return;
      }
      if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
        return;
      }
      e2.dataTransfer.setData("Text", cm.getSelection());
      e2.dataTransfer.effectAllowed = "copyMove";
      if (e2.dataTransfer.setDragImage && !safari) {
        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (presto) {
          img.width = img.height = 1;
          cm.display.wrapper.appendChild(img);
          img._top = img.offsetTop;
        }
        e2.dataTransfer.setDragImage(img, 0, 0);
        if (presto) {
          img.parentNode.removeChild(img);
        }
      }
    }
    function onDragOver(cm, e2) {
      var pos = posFromMouse(cm, e2);
      if (!pos) {
        return;
      }
      var frag = document.createDocumentFragment();
      drawSelectionCursor(cm, pos, frag);
      if (!cm.display.dragCursor) {
        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
      }
      removeChildrenAndAdd(cm.display.dragCursor, frag);
    }
    function clearDragCursor(cm) {
      if (cm.display.dragCursor) {
        cm.display.lineSpace.removeChild(cm.display.dragCursor);
        cm.display.dragCursor = null;
      }
    }
    function forEachCodeMirror(f2) {
      if (!document.getElementsByClassName) {
        return;
      }
      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
      for (var i3 = 0; i3 < byClass.length; i3++) {
        var cm = byClass[i3].CodeMirror;
        if (cm) {
          editors.push(cm);
        }
      }
      if (editors.length) {
        editors[0].operation(function() {
          for (var i4 = 0; i4 < editors.length; i4++) {
            f2(editors[i4]);
          }
        });
      }
    }
    var globalsRegistered = false;
    function ensureGlobalHandlers() {
      if (globalsRegistered) {
        return;
      }
      registerGlobalHandlers();
      globalsRegistered = true;
    }
    function registerGlobalHandlers() {
      var resizeTimer;
      on(window, "resize", function() {
        if (resizeTimer == null) {
          resizeTimer = setTimeout(function() {
            resizeTimer = null;
            forEachCodeMirror(onResize);
          }, 100);
        }
      });
      on(window, "blur", function() {
        return forEachCodeMirror(onBlur);
      });
    }
    function onResize(cm) {
      var d2 = cm.display;
      d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
      d2.scrollbarsClipped = false;
      cm.setSize();
    }
    var keyNames2 = {
      3: "Pause",
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Ctrl",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Esc",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      44: "PrintScrn",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Mod",
      92: "Mod",
      93: "Mod",
      106: "*",
      107: "=",
      109: "-",
      110: ".",
      111: "/",
      145: "ScrollLock",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      224: "Mod",
      63232: "Up",
      63233: "Down",
      63234: "Left",
      63235: "Right",
      63272: "Delete",
      63273: "Home",
      63275: "End",
      63276: "PageUp",
      63277: "PageDown",
      63302: "Insert"
    };
    for (var i2 = 0; i2 < 10; i2++) {
      keyNames2[i2 + 48] = keyNames2[i2 + 96] = String(i2);
    }
    for (var i$12 = 65; i$12 <= 90; i$12++) {
      keyNames2[i$12] = String.fromCharCode(i$12);
    }
    for (var i$22 = 1; i$22 <= 12; i$22++) {
      keyNames2[i$22 + 111] = keyNames2[i$22 + 63235] = "F" + i$22;
    }
    var keyMap = {};
    keyMap.basic = {
      "Left": "goCharLeft",
      "Right": "goCharRight",
      "Up": "goLineUp",
      "Down": "goLineDown",
      "End": "goLineEnd",
      "Home": "goLineStartSmart",
      "PageUp": "goPageUp",
      "PageDown": "goPageDown",
      "Delete": "delCharAfter",
      "Backspace": "delCharBefore",
      "Shift-Backspace": "delCharBefore",
      "Tab": "defaultTab",
      "Shift-Tab": "indentAuto",
      "Enter": "newlineAndIndent",
      "Insert": "toggleOverwrite",
      "Esc": "singleSelection"
    };
    keyMap.pcDefault = {
      "Ctrl-A": "selectAll",
      "Ctrl-D": "deleteLine",
      "Ctrl-Z": "undo",
      "Shift-Ctrl-Z": "redo",
      "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart",
      "Ctrl-End": "goDocEnd",
      "Ctrl-Up": "goLineUp",
      "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft",
      "Ctrl-Right": "goGroupRight",
      "Alt-Left": "goLineStart",
      "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore",
      "Ctrl-Delete": "delGroupAfter",
      "Ctrl-S": "save",
      "Ctrl-F": "find",
      "Ctrl-G": "findNext",
      "Shift-Ctrl-G": "findPrev",
      "Shift-Ctrl-F": "replace",
      "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess",
      "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection",
      "Shift-Ctrl-U": "redoSelection",
      "Alt-U": "redoSelection",
      "fallthrough": "basic"
    };
    keyMap.emacsy = {
      "Ctrl-F": "goCharRight",
      "Ctrl-B": "goCharLeft",
      "Ctrl-P": "goLineUp",
      "Ctrl-N": "goLineDown",
      "Ctrl-A": "goLineStart",
      "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown",
      "Shift-Ctrl-V": "goPageUp",
      "Ctrl-D": "delCharAfter",
      "Ctrl-H": "delCharBefore",
      "Alt-Backspace": "delWordBefore",
      "Ctrl-K": "killLine",
      "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    };
    keyMap.macDefault = {
      "Cmd-A": "selectAll",
      "Cmd-D": "deleteLine",
      "Cmd-Z": "undo",
      "Shift-Cmd-Z": "redo",
      "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart",
      "Cmd-Up": "goDocStart",
      "Cmd-End": "goDocEnd",
      "Cmd-Down": "goDocEnd",
      "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight",
      "Cmd-Left": "goLineLeft",
      "Cmd-Right": "goLineRight",
      "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter",
      "Alt-Delete": "delGroupAfter",
      "Cmd-S": "save",
      "Cmd-F": "find",
      "Cmd-G": "findNext",
      "Shift-Cmd-G": "findPrev",
      "Cmd-Alt-F": "replace",
      "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess",
      "Cmd-]": "indentMore",
      "Cmd-Backspace": "delWrappedLineLeft",
      "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection",
      "Shift-Cmd-U": "redoSelection",
      "Ctrl-Up": "goDocStart",
      "Ctrl-Down": "goDocEnd",
      "fallthrough": ["basic", "emacsy"]
    };
    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
    function normalizeKeyName(name) {
      var parts = name.split(/-(?!$)/);
      name = parts[parts.length - 1];
      var alt, ctrl, shift2, cmd;
      for (var i3 = 0; i3 < parts.length - 1; i3++) {
        var mod2 = parts[i3];
        if (/^(cmd|meta|m)$/i.test(mod2)) {
          cmd = true;
        } else if (/^a(lt)?$/i.test(mod2)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod2)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod2)) {
          shift2 = true;
        } else {
          throw new Error("Unrecognized modifier name: " + mod2);
        }
      }
      if (alt) {
        name = "Alt-" + name;
      }
      if (ctrl) {
        name = "Ctrl-" + name;
      }
      if (cmd) {
        name = "Cmd-" + name;
      }
      if (shift2) {
        name = "Shift-" + name;
      }
      return name;
    }
    function normalizeKeyMap(keymap) {
      var copy2 = {};
      for (var keyname in keymap) {
        if (keymap.hasOwnProperty(keyname)) {
          var value = keymap[keyname];
          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
            continue;
          }
          if (value == "...") {
            delete keymap[keyname];
            continue;
          }
          var keys2 = map2(keyname.split(" "), normalizeKeyName);
          for (var i3 = 0; i3 < keys2.length; i3++) {
            var val = void 0, name = void 0;
            if (i3 == keys2.length - 1) {
              name = keys2.join(" ");
              val = value;
            } else {
              name = keys2.slice(0, i3 + 1).join(" ");
              val = "...";
            }
            var prev = copy2[name];
            if (!prev) {
              copy2[name] = val;
            } else if (prev != val) {
              throw new Error("Inconsistent bindings for " + name);
            }
          }
          delete keymap[keyname];
        }
      }
      for (var prop3 in copy2) {
        keymap[prop3] = copy2[prop3];
      }
      return keymap;
    }
    function lookupKey(key, map3, handle, context) {
      map3 = getKeyMap(map3);
      var found = map3.call ? map3.call(key, context) : map3[key];
      if (found === false) {
        return "nothing";
      }
      if (found === "...") {
        return "multi";
      }
      if (found != null && handle(found)) {
        return "handled";
      }
      if (map3.fallthrough) {
        if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
          return lookupKey(key, map3.fallthrough, handle, context);
        }
        for (var i3 = 0; i3 < map3.fallthrough.length; i3++) {
          var result = lookupKey(key, map3.fallthrough[i3], handle, context);
          if (result) {
            return result;
          }
        }
      }
    }
    function isModifierKey(value) {
      var name = typeof value == "string" ? value : keyNames2[value.keyCode];
      return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
    }
    function addModifierNames(name, event, noShift) {
      var base2 = name;
      if (event.altKey && base2 != "Alt") {
        name = "Alt-" + name;
      }
      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base2 != "Ctrl") {
        name = "Ctrl-" + name;
      }
      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base2 != "Mod") {
        name = "Cmd-" + name;
      }
      if (!noShift && event.shiftKey && base2 != "Shift") {
        name = "Shift-" + name;
      }
      return name;
    }
    function keyName(event, noShift) {
      if (presto && event.keyCode == 34 && event["char"]) {
        return false;
      }
      var name = keyNames2[event.keyCode];
      if (name == null || event.altGraphKey) {
        return false;
      }
      if (event.keyCode == 3 && event.code) {
        name = event.code;
      }
      return addModifierNames(name, event, noShift);
    }
    function getKeyMap(val) {
      return typeof val == "string" ? keyMap[val] : val;
    }
    function deleteNearSelection(cm, compute2) {
      var ranges = cm.doc.sel.ranges, kill = [];
      for (var i3 = 0; i3 < ranges.length; i3++) {
        var toKill = compute2(ranges[i3]);
        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
          var replaced = kill.pop();
          if (cmp(replaced.from, toKill.from) < 0) {
            toKill.from = replaced.from;
            break;
          }
        }
        kill.push(toKill);
      }
      runInOp(cm, function() {
        for (var i4 = kill.length - 1; i4 >= 0; i4--) {
          replaceRange(cm.doc, "", kill[i4].from, kill[i4].to, "+delete");
        }
        ensureCursorVisible(cm);
      });
    }
    function moveCharLogically(line2, ch, dir) {
      var target2 = skipExtendingChars(line2.text, ch + dir, dir);
      return target2 < 0 || target2 > line2.text.length ? null : target2;
    }
    function moveLogically(line2, start2, dir) {
      var ch = moveCharLogically(line2, start2.ch, dir);
      return ch == null ? null : new Pos(start2.line, ch, dir < 0 ? "after" : "before");
    }
    function endOfLine(visually, cm, lineObj, lineNo2, dir) {
      if (visually) {
        if (cm.doc.direction == "rtl") {
          dir = -dir;
        }
        var order2 = getOrder(lineObj, cm.doc.direction);
        if (order2) {
          var part2 = dir < 0 ? lst(order2) : order2[0];
          var moveInStorageOrder = dir < 0 == (part2.level == 1);
          var sticky = moveInStorageOrder ? "after" : "before";
          var ch;
          if (part2.level > 0 || cm.doc.direction == "rtl") {
            var prep = prepareMeasureForLine(cm, lineObj);
            ch = dir < 0 ? lineObj.text.length - 1 : 0;
            var targetTop = measureCharPrepared(cm, prep, ch).top;
            ch = findFirst(function(ch2) {
              return measureCharPrepared(cm, prep, ch2).top == targetTop;
            }, dir < 0 == (part2.level == 1) ? part2.from : part2.to - 1, ch);
            if (sticky == "before") {
              ch = moveCharLogically(lineObj, ch, 1);
            }
          } else {
            ch = dir < 0 ? part2.to : part2.from;
          }
          return new Pos(lineNo2, ch, sticky);
        }
      }
      return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
    }
    function moveVisually(cm, line2, start2, dir) {
      var bidi = getOrder(line2, cm.doc.direction);
      if (!bidi) {
        return moveLogically(line2, start2, dir);
      }
      if (start2.ch >= line2.text.length) {
        start2.ch = line2.text.length;
        start2.sticky = "before";
      } else if (start2.ch <= 0) {
        start2.ch = 0;
        start2.sticky = "after";
      }
      var partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part2 = bidi[partPos];
      if (cm.doc.direction == "ltr" && part2.level % 2 == 0 && (dir > 0 ? part2.to > start2.ch : part2.from < start2.ch)) {
        return moveLogically(line2, start2, dir);
      }
      var mv = function(pos, dir2) {
        return moveCharLogically(line2, pos instanceof Pos ? pos.ch : pos, dir2);
      };
      var prep;
      var getWrappedLineExtent = function(ch2) {
        if (!cm.options.lineWrapping) {
          return { begin: 0, end: line2.text.length };
        }
        prep = prep || prepareMeasureForLine(cm, line2);
        return wrappedLineExtentChar(cm, line2, prep, ch2);
      };
      var wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
      if (cm.doc.direction == "rtl" || part2.level == 1) {
        var moveInStorageOrder = part2.level == 1 == dir < 0;
        var ch = mv(start2, moveInStorageOrder ? 1 : -1);
        if (ch != null && (!moveInStorageOrder ? ch >= part2.from && ch >= wrappedLineExtent2.begin : ch <= part2.to && ch <= wrappedLineExtent2.end)) {
          var sticky = moveInStorageOrder ? "before" : "after";
          return new Pos(start2.line, ch, sticky);
        }
      }
      var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
        var getRes = function(ch3, moveInStorageOrder3) {
          return moveInStorageOrder3 ? new Pos(start2.line, mv(ch3, 1), "before") : new Pos(start2.line, ch3, "after");
        };
        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
          var part3 = bidi[partPos2];
          var moveInStorageOrder2 = dir2 > 0 == (part3.level != 1);
          var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
          if (part3.from <= ch2 && ch2 < part3.to) {
            return getRes(ch2, moveInStorageOrder2);
          }
          ch2 = moveInStorageOrder2 ? part3.from : mv(part3.to, -1);
          if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
            return getRes(ch2, moveInStorageOrder2);
          }
        }
      };
      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
      if (res) {
        return res;
      }
      var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
      if (nextCh != null && !(dir > 0 && nextCh == line2.text.length)) {
        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
        if (res) {
          return res;
        }
      }
      return null;
    }
    var commands = {
      selectAll,
      singleSelection: function(cm) {
        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
      },
      killLine: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          if (range3.empty()) {
            var len2 = getLine2(cm.doc, range3.head.line).text.length;
            if (range3.head.ch == len2 && range3.head.line < cm.lastLine()) {
              return { from: range3.head, to: Pos(range3.head.line + 1, 0) };
            } else {
              return { from: range3.head, to: Pos(range3.head.line, len2) };
            }
          } else {
            return { from: range3.from(), to: range3.to() };
          }
        });
      },
      deleteLine: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          return {
            from: Pos(range3.from().line, 0),
            to: clipPos(cm.doc, Pos(range3.to().line + 1, 0))
          };
        });
      },
      delLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          return {
            from: Pos(range3.from().line, 0),
            to: range3.from()
          };
        });
      },
      delWrappedLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          var top2 = cm.charCoords(range3.head, "div").top + 5;
          var leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
          return { from: leftPos, to: range3.from() };
        });
      },
      delWrappedLineRight: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          var top2 = cm.charCoords(range3.head, "div").top + 5;
          var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
          return { from: range3.from(), to: rightPos };
        });
      },
      undo: function(cm) {
        return cm.undo();
      },
      redo: function(cm) {
        return cm.redo();
      },
      undoSelection: function(cm) {
        return cm.undoSelection();
      },
      redoSelection: function(cm) {
        return cm.redoSelection();
      },
      goDocStart: function(cm) {
        return cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function(cm) {
        return cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineStart(cm, range3.head.line);
        }, { origin: "+move", bias: 1 });
      },
      goLineStartSmart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineStartSmart(cm, range3.head);
        }, { origin: "+move", bias: 1 });
      },
      goLineEnd: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineEnd(cm, range3.head.line);
        }, { origin: "+move", bias: -1 });
      },
      goLineRight: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
        }, sel_move);
      },
      goLineLeft: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          return cm.coordsChar({ left: 0, top: top2 }, "div");
        }, sel_move);
      },
      goLineLeftSmart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          var pos = cm.coordsChar({ left: 0, top: top2 }, "div");
          if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
            return lineStartSmart(cm, range3.head);
          }
          return pos;
        }, sel_move);
      },
      goLineUp: function(cm) {
        return cm.moveV(-1, "line");
      },
      goLineDown: function(cm) {
        return cm.moveV(1, "line");
      },
      goPageUp: function(cm) {
        return cm.moveV(-1, "page");
      },
      goPageDown: function(cm) {
        return cm.moveV(1, "page");
      },
      goCharLeft: function(cm) {
        return cm.moveH(-1, "char");
      },
      goCharRight: function(cm) {
        return cm.moveH(1, "char");
      },
      goColumnLeft: function(cm) {
        return cm.moveH(-1, "column");
      },
      goColumnRight: function(cm) {
        return cm.moveH(1, "column");
      },
      goWordLeft: function(cm) {
        return cm.moveH(-1, "word");
      },
      goGroupRight: function(cm) {
        return cm.moveH(1, "group");
      },
      goGroupLeft: function(cm) {
        return cm.moveH(-1, "group");
      },
      goWordRight: function(cm) {
        return cm.moveH(1, "word");
      },
      delCharBefore: function(cm) {
        return cm.deleteH(-1, "codepoint");
      },
      delCharAfter: function(cm) {
        return cm.deleteH(1, "char");
      },
      delWordBefore: function(cm) {
        return cm.deleteH(-1, "word");
      },
      delWordAfter: function(cm) {
        return cm.deleteH(1, "word");
      },
      delGroupBefore: function(cm) {
        return cm.deleteH(-1, "group");
      },
      delGroupAfter: function(cm) {
        return cm.deleteH(1, "group");
      },
      indentAuto: function(cm) {
        return cm.indentSelection("smart");
      },
      indentMore: function(cm) {
        return cm.indentSelection("add");
      },
      indentLess: function(cm) {
        return cm.indentSelection("subtract");
      },
      insertTab: function(cm) {
        return cm.replaceSelection("	");
      },
      insertSoftTab: function(cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          var pos = ranges[i3].from();
          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(spaceStr(tabSize - col % tabSize));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function(cm) {
        if (cm.somethingSelected()) {
          cm.indentSelection("add");
        } else {
          cm.execCommand("insertTab");
        }
      },
      transposeChars: function(cm) {
        return runInOp(cm, function() {
          var ranges = cm.listSelections(), newSel = [];
          for (var i3 = 0; i3 < ranges.length; i3++) {
            if (!ranges[i3].empty()) {
              continue;
            }
            var cur = ranges[i3].head, line2 = getLine2(cm.doc, cur.line).text;
            if (line2) {
              if (cur.ch == line2.length) {
                cur = new Pos(cur.line, cur.ch - 1);
              }
              if (cur.ch > 0) {
                cur = new Pos(cur.line, cur.ch + 1);
                cm.replaceRange(line2.charAt(cur.ch - 1) + line2.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
              } else if (cur.line > cm.doc.first) {
                var prev = getLine2(cm.doc, cur.line - 1).text;
                if (prev) {
                  cur = new Pos(cur.line, 1);
                  cm.replaceRange(line2.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                }
              }
            }
            newSel.push(new Range(cur, cur));
          }
          cm.setSelections(newSel);
        });
      },
      newlineAndIndent: function(cm) {
        return runInOp(cm, function() {
          var sels = cm.listSelections();
          for (var i3 = sels.length - 1; i3 >= 0; i3--) {
            cm.replaceRange(cm.doc.lineSeparator(), sels[i3].anchor, sels[i3].head, "+input");
          }
          sels = cm.listSelections();
          for (var i$13 = 0; i$13 < sels.length; i$13++) {
            cm.indentLine(sels[i$13].from().line, null, true);
          }
          ensureCursorVisible(cm);
        });
      },
      openLine: function(cm) {
        return cm.replaceSelection("\n", "start");
      },
      toggleOverwrite: function(cm) {
        return cm.toggleOverwrite();
      }
    };
    function lineStart(cm, lineN) {
      var line2 = getLine2(cm.doc, lineN);
      var visual = visualLine(line2);
      if (visual != line2) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, visual, lineN, 1);
    }
    function lineEnd(cm, lineN) {
      var line2 = getLine2(cm.doc, lineN);
      var visual = visualLineEnd(line2);
      if (visual != line2) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, line2, lineN, -1);
    }
    function lineStartSmart(cm, pos) {
      var start2 = lineStart(cm, pos.line);
      var line2 = getLine2(cm.doc, start2.line);
      var order2 = getOrder(line2, cm.doc.direction);
      if (!order2 || order2[0].level == 0) {
        var firstNonWS = Math.max(start2.ch, line2.text.search(/\S/));
        var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
        return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
      }
      return start2;
    }
    function doHandleBinding(cm, bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands[bound];
        if (!bound) {
          return false;
        }
      }
      cm.display.input.ensurePolled();
      var prevShift = cm.display.shift, done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        if (dropShift) {
          cm.display.shift = false;
        }
        done = bound(cm) != Pass;
      } finally {
        cm.display.shift = prevShift;
        cm.state.suppressEdits = false;
      }
      return done;
    }
    function lookupKeyForEditor(cm, name, handle) {
      for (var i3 = 0; i3 < cm.state.keyMaps.length; i3++) {
        var result = lookupKey(name, cm.state.keyMaps[i3], handle, cm);
        if (result) {
          return result;
        }
      }
      return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
    }
    var stopSeq = new Delayed();
    function dispatchKey(cm, name, e2, handle) {
      var seq2 = cm.state.keySeq;
      if (seq2) {
        if (isModifierKey(name)) {
          return "handled";
        }
        if (/\'$/.test(name)) {
          cm.state.keySeq = null;
        } else {
          stopSeq.set(50, function() {
            if (cm.state.keySeq == seq2) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
        }
        if (dispatchKeyInner(cm, seq2 + " " + name, e2, handle)) {
          return true;
        }
      }
      return dispatchKeyInner(cm, name, e2, handle);
    }
    function dispatchKeyInner(cm, name, e2, handle) {
      var result = lookupKeyForEditor(cm, name, handle);
      if (result == "multi") {
        cm.state.keySeq = name;
      }
      if (result == "handled") {
        signalLater(cm, "keyHandled", cm, name, e2);
      }
      if (result == "handled" || result == "multi") {
        e_preventDefault(e2);
        restartBlink(cm);
      }
      return !!result;
    }
    function handleKeyBinding(cm, e2) {
      var name = keyName(e2, true);
      if (!name) {
        return false;
      }
      if (e2.shiftKey && !cm.state.keySeq) {
        return dispatchKey(cm, "Shift-" + name, e2, function(b2) {
          return doHandleBinding(cm, b2, true);
        }) || dispatchKey(cm, name, e2, function(b2) {
          if (typeof b2 == "string" ? /^go[A-Z]/.test(b2) : b2.motion) {
            return doHandleBinding(cm, b2);
          }
        });
      } else {
        return dispatchKey(cm, name, e2, function(b2) {
          return doHandleBinding(cm, b2);
        });
      }
    }
    function handleCharBinding(cm, e2, ch) {
      return dispatchKey(cm, "'" + ch + "'", e2, function(b2) {
        return doHandleBinding(cm, b2, true);
      });
    }
    var lastStoppedKey = null;
    function onKeyDown(e2) {
      var cm = this;
      if (e2.target && e2.target != cm.display.input.getField()) {
        return;
      }
      cm.curOp.focus = activeElt();
      if (signalDOMEvent(cm, e2)) {
        return;
      }
      if (ie2 && ie_version < 11 && e2.keyCode == 27) {
        e2.returnValue = false;
      }
      var code3 = e2.keyCode;
      cm.display.shift = code3 == 16 || e2.shiftKey;
      var handled = handleKeyBinding(cm, e2);
      if (presto) {
        lastStoppedKey = handled ? code3 : null;
        if (!handled && code3 == 88 && !hasCopyEvent && (mac ? e2.metaKey : e2.ctrlKey)) {
          cm.replaceSelection("", null, "cut");
        }
      }
      if (gecko && !mac && !handled && code3 == 46 && e2.shiftKey && !e2.ctrlKey && document.execCommand) {
        document.execCommand("cut");
      }
      if (code3 == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
        showCrossHair(cm);
      }
    }
    function showCrossHair(cm) {
      var lineDiv = cm.display.lineDiv;
      addClass(lineDiv, "CodeMirror-crosshair");
      function up(e2) {
        if (e2.keyCode == 18 || !e2.altKey) {
          rmClass(lineDiv, "CodeMirror-crosshair");
          off(document, "keyup", up);
          off(document, "mouseover", up);
        }
      }
      on(document, "keyup", up);
      on(document, "mouseover", up);
    }
    function onKeyUp(e2) {
      if (e2.keyCode == 16) {
        this.doc.sel.shift = false;
      }
      signalDOMEvent(this, e2);
    }
    function onKeyPress(e2) {
      var cm = this;
      if (e2.target && e2.target != cm.display.input.getField()) {
        return;
      }
      if (eventInWidget(cm.display, e2) || signalDOMEvent(cm, e2) || e2.ctrlKey && !e2.altKey || mac && e2.metaKey) {
        return;
      }
      var keyCode = e2.keyCode, charCode = e2.charCode;
      if (presto && keyCode == lastStoppedKey) {
        lastStoppedKey = null;
        e_preventDefault(e2);
        return;
      }
      if (presto && (!e2.which || e2.which < 10) && handleKeyBinding(cm, e2)) {
        return;
      }
      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
      if (ch == "\b") {
        return;
      }
      if (handleCharBinding(cm, e2, ch)) {
        return;
      }
      cm.display.input.onKeyPress(e2);
    }
    var DOUBLECLICK_DELAY = 400;
    var PastClick = function(time, pos, button) {
      this.time = time;
      this.pos = pos;
      this.button = button;
    };
    PastClick.prototype.compare = function(time, pos, button) {
      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
    };
    var lastClick, lastDoubleClick;
    function clickRepeat(pos, button) {
      var now2 = +new Date();
      if (lastDoubleClick && lastDoubleClick.compare(now2, pos, button)) {
        lastClick = lastDoubleClick = null;
        return "triple";
      } else if (lastClick && lastClick.compare(now2, pos, button)) {
        lastDoubleClick = new PastClick(now2, pos, button);
        lastClick = null;
        return "double";
      } else {
        lastClick = new PastClick(now2, pos, button);
        lastDoubleClick = null;
        return "single";
      }
    }
    function onMouseDown(e2) {
      var cm = this, display = cm.display;
      if (signalDOMEvent(cm, e2) || display.activeTouch && display.input.supportsTouch()) {
        return;
      }
      display.input.ensurePolled();
      display.shift = e2.shiftKey;
      if (eventInWidget(display, e2)) {
        if (!webkit) {
          display.scroller.draggable = false;
          setTimeout(function() {
            return display.scroller.draggable = true;
          }, 100);
        }
        return;
      }
      if (clickInGutter(cm, e2)) {
        return;
      }
      var pos = posFromMouse(cm, e2), button = e_button(e2), repeat = pos ? clickRepeat(pos, button) : "single";
      window.focus();
      if (button == 1 && cm.state.selectingText) {
        cm.state.selectingText(e2);
      }
      if (pos && handleMappedButton(cm, button, pos, repeat, e2)) {
        return;
      }
      if (button == 1) {
        if (pos) {
          leftButtonDown(cm, pos, repeat, e2);
        } else if (e_target(e2) == display.scroller) {
          e_preventDefault(e2);
        }
      } else if (button == 2) {
        if (pos) {
          extendSelection(cm.doc, pos);
        }
        setTimeout(function() {
          return display.input.focus();
        }, 20);
      } else if (button == 3) {
        if (captureRightClick) {
          cm.display.input.onContextMenu(e2);
        } else {
          delayBlurEvent(cm);
        }
      }
    }
    function handleMappedButton(cm, button, pos, repeat, event) {
      var name = "Click";
      if (repeat == "double") {
        name = "Double" + name;
      } else if (repeat == "triple") {
        name = "Triple" + name;
      }
      name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
      return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
        if (typeof bound == "string") {
          bound = commands[bound];
        }
        if (!bound) {
          return false;
        }
        var done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          done = bound(cm, pos) != Pass;
        } finally {
          cm.state.suppressEdits = false;
        }
        return done;
      });
    }
    function configureMouse(cm, repeat, event) {
      var option = cm.getOption("configureMouse");
      var value = option ? option(cm, repeat, event) : {};
      if (value.unit == null) {
        var rect2 = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
        value.unit = rect2 ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
      }
      if (value.extend == null || cm.doc.extend) {
        value.extend = cm.doc.extend || event.shiftKey;
      }
      if (value.addNew == null) {
        value.addNew = mac ? event.metaKey : event.ctrlKey;
      }
      if (value.moveOnDrag == null) {
        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
      }
      return value;
    }
    function leftButtonDown(cm, pos, repeat, event) {
      if (ie2) {
        setTimeout(bind2(ensureFocus, cm), 0);
      } else {
        cm.curOp.focus = activeElt();
      }
      var behavior = configureMouse(cm, repeat, event);
      var sel = cm.doc.sel, contained;
      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
        leftButtonStartDrag(cm, event, pos, behavior);
      } else {
        leftButtonSelect(cm, event, pos, behavior);
      }
    }
    function leftButtonStartDrag(cm, event, pos, behavior) {
      var display = cm.display, moved = false;
      var dragEnd = operation(cm, function(e2) {
        if (webkit) {
          display.scroller.draggable = false;
        }
        cm.state.draggingText = false;
        if (cm.state.delayingBlurEvent) {
          if (cm.hasFocus()) {
            cm.state.delayingBlurEvent = false;
          } else {
            delayBlurEvent(cm);
          }
        }
        off(display.wrapper.ownerDocument, "mouseup", dragEnd);
        off(display.wrapper.ownerDocument, "mousemove", mouseMove);
        off(display.scroller, "dragstart", dragStart);
        off(display.scroller, "drop", dragEnd);
        if (!moved) {
          e_preventDefault(e2);
          if (!behavior.addNew) {
            extendSelection(cm.doc, pos, null, null, behavior.extend);
          }
          if (webkit && !safari || ie2 && ie_version == 9) {
            setTimeout(function() {
              display.wrapper.ownerDocument.body.focus({ preventScroll: true });
              display.input.focus();
            }, 20);
          } else {
            display.input.focus();
          }
        }
      });
      var mouseMove = function(e2) {
        moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
      };
      var dragStart = function() {
        return moved = true;
      };
      if (webkit) {
        display.scroller.draggable = true;
      }
      cm.state.draggingText = dragEnd;
      dragEnd.copy = !behavior.moveOnDrag;
      on(display.wrapper.ownerDocument, "mouseup", dragEnd);
      on(display.wrapper.ownerDocument, "mousemove", mouseMove);
      on(display.scroller, "dragstart", dragStart);
      on(display.scroller, "drop", dragEnd);
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        return display.input.focus();
      }, 20);
      if (display.scroller.dragDrop) {
        display.scroller.dragDrop();
      }
    }
    function rangeForUnit(cm, pos, unit) {
      if (unit == "char") {
        return new Range(pos, pos);
      }
      if (unit == "word") {
        return cm.findWordAt(pos);
      }
      if (unit == "line") {
        return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
      }
      var result = unit(cm, pos);
      return new Range(result.from, result.to);
    }
    function leftButtonSelect(cm, event, start2, behavior) {
      if (ie2) {
        delayBlurEvent(cm);
      }
      var display = cm.display, doc2 = cm.doc;
      e_preventDefault(event);
      var ourRange, ourIndex, startSel = doc2.sel, ranges = startSel.ranges;
      if (behavior.addNew && !behavior.extend) {
        ourIndex = doc2.sel.contains(start2);
        if (ourIndex > -1) {
          ourRange = ranges[ourIndex];
        } else {
          ourRange = new Range(start2, start2);
        }
      } else {
        ourRange = doc2.sel.primary();
        ourIndex = doc2.sel.primIndex;
      }
      if (behavior.unit == "rectangle") {
        if (!behavior.addNew) {
          ourRange = new Range(start2, start2);
        }
        start2 = posFromMouse(cm, event, true, true);
        ourIndex = -1;
      } else {
        var range3 = rangeForUnit(cm, start2, behavior.unit);
        if (behavior.extend) {
          ourRange = extendRange(ourRange, range3.anchor, range3.head, behavior.extend);
        } else {
          ourRange = range3;
        }
      }
      if (!behavior.addNew) {
        ourIndex = 0;
        setSelection(doc2, new Selection2([ourRange], 0), sel_mouse);
        startSel = doc2.sel;
      } else if (ourIndex == -1) {
        ourIndex = ranges.length;
        setSelection(doc2, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
        setSelection(doc2, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
        startSel = doc2.sel;
      } else {
        replaceOneSelection(doc2, ourIndex, ourRange, sel_mouse);
      }
      var lastPos = start2;
      function extendTo(pos) {
        if (cmp(lastPos, pos) == 0) {
          return;
        }
        lastPos = pos;
        if (behavior.unit == "rectangle") {
          var ranges2 = [], tabSize = cm.options.tabSize;
          var startCol = countColumn(getLine2(doc2, start2.line).text, start2.ch, tabSize);
          var posCol = countColumn(getLine2(doc2, pos.line).text, pos.ch, tabSize);
          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
          for (var line2 = Math.min(start2.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line2 <= end; line2++) {
            var text3 = getLine2(doc2, line2).text, leftPos = findColumn(text3, left, tabSize);
            if (left == right) {
              ranges2.push(new Range(Pos(line2, leftPos), Pos(line2, leftPos)));
            } else if (text3.length > leftPos) {
              ranges2.push(new Range(Pos(line2, leftPos), Pos(line2, findColumn(text3, right, tabSize))));
            }
          }
          if (!ranges2.length) {
            ranges2.push(new Range(start2, start2));
          }
          setSelection(doc2, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
          cm.scrollIntoView(pos);
        } else {
          var oldRange = ourRange;
          var range4 = rangeForUnit(cm, pos, behavior.unit);
          var anchor = oldRange.anchor, head;
          if (cmp(range4.anchor, anchor) > 0) {
            head = range4.head;
            anchor = minPos(oldRange.from(), range4.anchor);
          } else {
            head = range4.anchor;
            anchor = maxPos(oldRange.to(), range4.head);
          }
          var ranges$1 = startSel.ranges.slice(0);
          ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc2, anchor), head));
          setSelection(doc2, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
        }
      }
      var editorSize = display.wrapper.getBoundingClientRect();
      var counter2 = 0;
      function extend2(e2) {
        var curCount = ++counter2;
        var cur = posFromMouse(cm, e2, true, behavior.unit == "rectangle");
        if (!cur) {
          return;
        }
        if (cmp(cur, lastPos) != 0) {
          cm.curOp.focus = activeElt();
          extendTo(cur);
          var visible = visibleLines(display, doc2);
          if (cur.line >= visible.to || cur.line < visible.from) {
            setTimeout(operation(cm, function() {
              if (counter2 == curCount) {
                extend2(e2);
              }
            }), 150);
          }
        } else {
          var outside = e2.clientY < editorSize.top ? -20 : e2.clientY > editorSize.bottom ? 20 : 0;
          if (outside) {
            setTimeout(operation(cm, function() {
              if (counter2 != curCount) {
                return;
              }
              display.scroller.scrollTop += outside;
              extend2(e2);
            }), 50);
          }
        }
      }
      function done(e2) {
        cm.state.selectingText = false;
        counter2 = Infinity;
        if (e2) {
          e_preventDefault(e2);
          display.input.focus();
        }
        off(display.wrapper.ownerDocument, "mousemove", move);
        off(display.wrapper.ownerDocument, "mouseup", up);
        doc2.history.lastSelOrigin = null;
      }
      var move = operation(cm, function(e2) {
        if (e2.buttons === 0 || !e_button(e2)) {
          done(e2);
        } else {
          extend2(e2);
        }
      });
      var up = operation(cm, done);
      cm.state.selectingText = up;
      on(display.wrapper.ownerDocument, "mousemove", move);
      on(display.wrapper.ownerDocument, "mouseup", up);
    }
    function bidiSimplify(cm, range3) {
      var anchor = range3.anchor;
      var head = range3.head;
      var anchorLine = getLine2(cm.doc, anchor.line);
      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
        return range3;
      }
      var order2 = getOrder(anchorLine);
      if (!order2) {
        return range3;
      }
      var index2 = getBidiPartAt(order2, anchor.ch, anchor.sticky), part2 = order2[index2];
      if (part2.from != anchor.ch && part2.to != anchor.ch) {
        return range3;
      }
      var boundary = index2 + (part2.from == anchor.ch == (part2.level != 1) ? 0 : 1);
      if (boundary == 0 || boundary == order2.length) {
        return range3;
      }
      var leftSide;
      if (head.line != anchor.line) {
        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
      } else {
        var headIndex = getBidiPartAt(order2, head.ch, head.sticky);
        var dir = headIndex - index2 || (head.ch - anchor.ch) * (part2.level == 1 ? -1 : 1);
        if (headIndex == boundary - 1 || headIndex == boundary) {
          leftSide = dir < 0;
        } else {
          leftSide = dir > 0;
        }
      }
      var usePart = order2[boundary + (leftSide ? -1 : 0)];
      var from2 = leftSide == (usePart.level == 1);
      var ch = from2 ? usePart.from : usePart.to, sticky = from2 ? "after" : "before";
      return anchor.ch == ch && anchor.sticky == sticky ? range3 : new Range(new Pos(anchor.line, ch, sticky), head);
    }
    function gutterEvent(cm, e2, type, prevent) {
      var mX, mY;
      if (e2.touches) {
        mX = e2.touches[0].clientX;
        mY = e2.touches[0].clientY;
      } else {
        try {
          mX = e2.clientX;
          mY = e2.clientY;
        } catch (e$12) {
          return false;
        }
      }
      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
        return false;
      }
      if (prevent) {
        e_preventDefault(e2);
      }
      var display = cm.display;
      var lineBox = display.lineDiv.getBoundingClientRect();
      if (mY > lineBox.bottom || !hasHandler(cm, type)) {
        return e_defaultPrevented(e2);
      }
      mY -= lineBox.top - display.viewOffset;
      for (var i3 = 0; i3 < cm.display.gutterSpecs.length; ++i3) {
        var g2 = display.gutters.childNodes[i3];
        if (g2 && g2.getBoundingClientRect().right >= mX) {
          var line2 = lineAtHeight(cm.doc, mY);
          var gutter = cm.display.gutterSpecs[i3];
          signal(cm, type, cm, line2, gutter.className, e2);
          return e_defaultPrevented(e2);
        }
      }
    }
    function clickInGutter(cm, e2) {
      return gutterEvent(cm, e2, "gutterClick", true);
    }
    function onContextMenu(cm, e2) {
      if (eventInWidget(cm.display, e2) || contextMenuInGutter(cm, e2)) {
        return;
      }
      if (signalDOMEvent(cm, e2, "contextmenu")) {
        return;
      }
      if (!captureRightClick) {
        cm.display.input.onContextMenu(e2);
      }
    }
    function contextMenuInGutter(cm, e2) {
      if (!hasHandler(cm, "gutterContextMenu")) {
        return false;
      }
      return gutterEvent(cm, e2, "gutterContextMenu", false);
    }
    function themeChanged(cm) {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      clearCaches(cm);
    }
    var Init = { toString: function() {
      return "CodeMirror.Init";
    } };
    var defaults2 = {};
    var optionHandlers = {};
    function defineOptions(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      function option(name, deflt, handle, notOnInit) {
        CodeMirror3.defaults[name] = deflt;
        if (handle) {
          optionHandlers2[name] = notOnInit ? function(cm, val, old) {
            if (old != Init) {
              handle(cm, val, old);
            }
          } : handle;
        }
      }
      CodeMirror3.defineOption = option;
      CodeMirror3.Init = Init;
      option("value", "", function(cm, val) {
        return cm.setValue(val);
      }, true);
      option("mode", null, function(cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);
      option("indentUnit", 2, loadMode, true);
      option("indentWithTabs", false);
      option("smartIndent", true);
      option("tabSize", 4, function(cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option("lineSeparator", null, function(cm, val) {
        cm.doc.lineSep = val;
        if (!val) {
          return;
        }
        var newBreaks = [], lineNo2 = cm.doc.first;
        cm.doc.iter(function(line2) {
          for (var pos = 0; ; ) {
            var found = line2.text.indexOf(val, pos);
            if (found == -1) {
              break;
            }
            pos = found + val.length;
            newBreaks.push(Pos(lineNo2, found));
          }
          lineNo2++;
        });
        for (var i3 = newBreaks.length - 1; i3 >= 0; i3--) {
          replaceRange(cm.doc, val, newBreaks[i3], Pos(newBreaks[i3].line, newBreaks[i3].ch + val.length));
        }
      });
      option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
        if (old != Init) {
          cm.refresh();
        }
      });
      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
        return cm.refresh();
      }, true);
      option("electricChars", true);
      option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
        throw new Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      option("spellcheck", false, function(cm, val) {
        return cm.getInputField().spellcheck = val;
      }, true);
      option("autocorrect", false, function(cm, val) {
        return cm.getInputField().autocorrect = val;
      }, true);
      option("autocapitalize", false, function(cm, val) {
        return cm.getInputField().autocapitalize = val;
      }, true);
      option("rtlMoveVisually", !windows);
      option("wholeLineUpdateBefore", true);
      option("theme", "default", function(cm) {
        themeChanged(cm);
        updateGutters(cm);
      }, true);
      option("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != Init && getKeyMap(old);
        if (prev && prev.detach) {
          prev.detach(cm, next);
        }
        if (next.attach) {
          next.attach(cm, prev || null);
        }
      });
      option("extraKeys", null);
      option("configureMouse", null);
      option("lineWrapping", false, wrappingChanged, true);
      option("gutters", [], function(cm, val) {
        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
        updateGutters(cm);
      }, true);
      option("fixedGutter", true, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option("coverGutterNextToScrollbar", false, function(cm) {
        return updateScrollbars(cm);
      }, true);
      option("scrollbarStyle", "native", function(cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option("lineNumbers", false, function(cm, val) {
        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
        updateGutters(cm);
      }, true);
      option("firstLineNumber", 1, updateGutters, true);
      option("lineNumberFormatter", function(integer) {
        return integer;
      }, updateGutters, true);
      option("showCursorWhenSelecting", false, updateSelection, true);
      option("resetSelectionOnContextMenu", true);
      option("lineWiseCopyCut", true);
      option("pasteLinesPerSelection", true);
      option("selectionsMayTouch", false);
      option("readOnly", false, function(cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
        }
        cm.display.input.readOnlyChanged(val);
      });
      option("screenReaderLabel", null, function(cm, val) {
        val = val === "" ? null : val;
        cm.display.input.screenReaderLabelChanged(val);
      });
      option("disableInput", false, function(cm, val) {
        if (!val) {
          cm.display.input.reset();
        }
      }, true);
      option("dragDrop", true, dragDropChanged);
      option("allowDropFileTypes", null);
      option("cursorBlinkRate", 530);
      option("cursorScrollMargin", 0);
      option("cursorHeight", 1, updateSelection, true);
      option("singleCursorHeightPerLine", true, updateSelection, true);
      option("workTime", 100);
      option("workDelay", 100);
      option("flattenSpans", true, resetModeState, true);
      option("addModeClass", false, resetModeState, true);
      option("pollInterval", 100);
      option("undoDepth", 200, function(cm, val) {
        return cm.doc.history.undoDepth = val;
      });
      option("historyEventDelay", 1250);
      option("viewportMargin", 10, function(cm) {
        return cm.refresh();
      }, true);
      option("maxHighlightLength", 1e4, resetModeState, true);
      option("moveInputWithCursor", true, function(cm, val) {
        if (!val) {
          cm.display.input.resetPosition();
        }
      });
      option("tabindex", null, function(cm, val) {
        return cm.display.input.getField().tabIndex = val || "";
      });
      option("autofocus", null);
      option("direction", "ltr", function(cm, val) {
        return cm.doc.setDirection(val);
      }, true);
      option("phrases", null);
    }
    function dragDropChanged(cm, value, old) {
      var wasOn = old && old != Init;
      if (!value != !wasOn) {
        var funcs = cm.display.dragFunctions;
        var toggle = value ? on : off;
        toggle(cm.display.scroller, "dragstart", funcs.start);
        toggle(cm.display.scroller, "dragenter", funcs.enter);
        toggle(cm.display.scroller, "dragover", funcs.over);
        toggle(cm.display.scroller, "dragleave", funcs.leave);
        toggle(cm.display.scroller, "drop", funcs.drop);
      }
    }
    function wrappingChanged(cm) {
      if (cm.options.lineWrapping) {
        addClass(cm.display.wrapper, "CodeMirror-wrap");
        cm.display.sizer.style.minWidth = "";
        cm.display.sizerWidth = null;
      } else {
        rmClass(cm.display.wrapper, "CodeMirror-wrap");
        findMaxLine(cm);
      }
      estimateLineHeights(cm);
      regChange(cm);
      clearCaches(cm);
      setTimeout(function() {
        return updateScrollbars(cm);
      }, 100);
    }
    function CodeMirror2(place, options) {
      var this$1$1 = this;
      if (!(this instanceof CodeMirror2)) {
        return new CodeMirror2(place, options);
      }
      this.options = options = options ? copyObj(options) : {};
      copyObj(defaults2, options, false);
      var doc2 = options.value;
      if (typeof doc2 == "string") {
        doc2 = new Doc(doc2, options.mode, null, options.lineSeparator, options.direction);
      } else if (options.mode) {
        doc2.modeOption = options.mode;
      }
      this.doc = doc2;
      var input = new CodeMirror2.inputStyles[options.inputStyle](this);
      var display = this.display = new Display(place, doc2, input, options);
      display.wrapper.CodeMirror = this;
      themeChanged(this);
      if (options.lineWrapping) {
        this.display.wrapper.className += " CodeMirror-wrap";
      }
      initScrollbars(this);
      this.state = {
        keyMaps: [],
        overlays: [],
        modeGen: 0,
        overwrite: false,
        delayingBlurEvent: false,
        focused: false,
        suppressEdits: false,
        pasteIncoming: -1,
        cutIncoming: -1,
        selectingText: false,
        draggingText: false,
        highlight: new Delayed(),
        keySeq: null,
        specialChars: null
      };
      if (options.autofocus && !mobile) {
        display.input.focus();
      }
      if (ie2 && ie_version < 11) {
        setTimeout(function() {
          return this$1$1.display.input.reset(true);
        }, 20);
      }
      registerEventHandlers(this);
      ensureGlobalHandlers();
      startOperation(this);
      this.curOp.forceUpdate = true;
      attachDoc(this, doc2);
      if (options.autofocus && !mobile || this.hasFocus()) {
        setTimeout(function() {
          if (this$1$1.hasFocus() && !this$1$1.state.focused) {
            onFocus(this$1$1);
          }
        }, 20);
      } else {
        onBlur(this);
      }
      for (var opt in optionHandlers) {
        if (optionHandlers.hasOwnProperty(opt)) {
          optionHandlers[opt](this, options[opt], Init);
        }
      }
      maybeUpdateLineNumberWidth(this);
      if (options.finishInit) {
        options.finishInit(this);
      }
      for (var i3 = 0; i3 < initHooks.length; ++i3) {
        initHooks[i3](this);
      }
      endOperation(this);
      if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
        display.lineDiv.style.textRendering = "auto";
      }
    }
    CodeMirror2.defaults = defaults2;
    CodeMirror2.optionHandlers = optionHandlers;
    function registerEventHandlers(cm) {
      var d2 = cm.display;
      on(d2.scroller, "mousedown", operation(cm, onMouseDown));
      if (ie2 && ie_version < 11) {
        on(d2.scroller, "dblclick", operation(cm, function(e2) {
          if (signalDOMEvent(cm, e2)) {
            return;
          }
          var pos = posFromMouse(cm, e2);
          if (!pos || clickInGutter(cm, e2) || eventInWidget(cm.display, e2)) {
            return;
          }
          e_preventDefault(e2);
          var word2 = cm.findWordAt(pos);
          extendSelection(cm.doc, word2.anchor, word2.head);
        }));
      } else {
        on(d2.scroller, "dblclick", function(e2) {
          return signalDOMEvent(cm, e2) || e_preventDefault(e2);
        });
      }
      on(d2.scroller, "contextmenu", function(e2) {
        return onContextMenu(cm, e2);
      });
      on(d2.input.getField(), "contextmenu", function(e2) {
        if (!d2.scroller.contains(e2.target)) {
          onContextMenu(cm, e2);
        }
      });
      var touchFinished, prevTouch = { end: 0 };
      function finishTouch() {
        if (d2.activeTouch) {
          touchFinished = setTimeout(function() {
            return d2.activeTouch = null;
          }, 1e3);
          prevTouch = d2.activeTouch;
          prevTouch.end = +new Date();
        }
      }
      function isMouseLikeTouchEvent(e2) {
        if (e2.touches.length != 1) {
          return false;
        }
        var touch = e2.touches[0];
        return touch.radiusX <= 1 && touch.radiusY <= 1;
      }
      function farAway(touch, other) {
        if (other.left == null) {
          return true;
        }
        var dx = other.left - touch.left, dy = other.top - touch.top;
        return dx * dx + dy * dy > 20 * 20;
      }
      on(d2.scroller, "touchstart", function(e2) {
        if (!signalDOMEvent(cm, e2) && !isMouseLikeTouchEvent(e2) && !clickInGutter(cm, e2)) {
          d2.input.ensurePolled();
          clearTimeout(touchFinished);
          var now2 = +new Date();
          d2.activeTouch = {
            start: now2,
            moved: false,
            prev: now2 - prevTouch.end <= 300 ? prevTouch : null
          };
          if (e2.touches.length == 1) {
            d2.activeTouch.left = e2.touches[0].pageX;
            d2.activeTouch.top = e2.touches[0].pageY;
          }
        }
      });
      on(d2.scroller, "touchmove", function() {
        if (d2.activeTouch) {
          d2.activeTouch.moved = true;
        }
      });
      on(d2.scroller, "touchend", function(e2) {
        var touch = d2.activeTouch;
        if (touch && !eventInWidget(d2, e2) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
          var pos = cm.coordsChar(d2.activeTouch, "page"), range3;
          if (!touch.prev || farAway(touch, touch.prev)) {
            range3 = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
            range3 = cm.findWordAt(pos);
          } else {
            range3 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          cm.setSelection(range3.anchor, range3.head);
          cm.focus();
          e_preventDefault(e2);
        }
        finishTouch();
      });
      on(d2.scroller, "touchcancel", finishTouch);
      on(d2.scroller, "scroll", function() {
        if (d2.scroller.clientHeight) {
          updateScrollTop(cm, d2.scroller.scrollTop);
          setScrollLeft(cm, d2.scroller.scrollLeft, true);
          signal(cm, "scroll", cm);
        }
      });
      on(d2.scroller, "mousewheel", function(e2) {
        return onScrollWheel(cm, e2);
      });
      on(d2.scroller, "DOMMouseScroll", function(e2) {
        return onScrollWheel(cm, e2);
      });
      on(d2.wrapper, "scroll", function() {
        return d2.wrapper.scrollTop = d2.wrapper.scrollLeft = 0;
      });
      d2.dragFunctions = {
        enter: function(e2) {
          if (!signalDOMEvent(cm, e2)) {
            e_stop(e2);
          }
        },
        over: function(e2) {
          if (!signalDOMEvent(cm, e2)) {
            onDragOver(cm, e2);
            e_stop(e2);
          }
        },
        start: function(e2) {
          return onDragStart(cm, e2);
        },
        drop: operation(cm, onDrop),
        leave: function(e2) {
          if (!signalDOMEvent(cm, e2)) {
            clearDragCursor(cm);
          }
        }
      };
      var inp = d2.input.getField();
      on(inp, "keyup", function(e2) {
        return onKeyUp.call(cm, e2);
      });
      on(inp, "keydown", operation(cm, onKeyDown));
      on(inp, "keypress", operation(cm, onKeyPress));
      on(inp, "focus", function(e2) {
        return onFocus(cm, e2);
      });
      on(inp, "blur", function(e2) {
        return onBlur(cm, e2);
      });
    }
    var initHooks = [];
    CodeMirror2.defineInitHook = function(f2) {
      return initHooks.push(f2);
    };
    function indentLine(cm, n2, how, aggressive) {
      var doc2 = cm.doc, state;
      if (how == null) {
        how = "add";
      }
      if (how == "smart") {
        if (!doc2.mode.indent) {
          how = "prev";
        } else {
          state = getContextBefore(cm, n2).state;
        }
      }
      var tabSize = cm.options.tabSize;
      var line2 = getLine2(doc2, n2), curSpace = countColumn(line2.text, null, tabSize);
      if (line2.stateAfter) {
        line2.stateAfter = null;
      }
      var curSpaceString = line2.text.match(/^\s*/)[0], indentation;
      if (!aggressive && !/\S/.test(line2.text)) {
        indentation = 0;
        how = "not";
      } else if (how == "smart") {
        indentation = doc2.mode.indent(state, line2.text.slice(curSpaceString.length), line2.text);
        if (indentation == Pass || indentation > 150) {
          if (!aggressive) {
            return;
          }
          how = "prev";
        }
      }
      if (how == "prev") {
        if (n2 > doc2.first) {
          indentation = countColumn(getLine2(doc2, n2 - 1).text, null, tabSize);
        } else {
          indentation = 0;
        }
      } else if (how == "add") {
        indentation = curSpace + cm.options.indentUnit;
      } else if (how == "subtract") {
        indentation = curSpace - cm.options.indentUnit;
      } else if (typeof how == "number") {
        indentation = curSpace + how;
      }
      indentation = Math.max(0, indentation);
      var indentString = "", pos = 0;
      if (cm.options.indentWithTabs) {
        for (var i3 = Math.floor(indentation / tabSize); i3; --i3) {
          pos += tabSize;
          indentString += "	";
        }
      }
      if (pos < indentation) {
        indentString += spaceStr(indentation - pos);
      }
      if (indentString != curSpaceString) {
        replaceRange(doc2, indentString, Pos(n2, 0), Pos(n2, curSpaceString.length), "+input");
        line2.stateAfter = null;
        return true;
      } else {
        for (var i$13 = 0; i$13 < doc2.sel.ranges.length; i$13++) {
          var range3 = doc2.sel.ranges[i$13];
          if (range3.head.line == n2 && range3.head.ch < curSpaceString.length) {
            var pos$1 = Pos(n2, curSpaceString.length);
            replaceOneSelection(doc2, i$13, new Range(pos$1, pos$1));
            break;
          }
        }
      }
    }
    var lastCopied = null;
    function setLastCopied(newLastCopied) {
      lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
      var doc2 = cm.doc;
      cm.display.shift = false;
      if (!sel) {
        sel = doc2.sel;
      }
      var recent = +new Date() - 200;
      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
      var textLines = splitLinesAuto(inserted), multiPaste = null;
      if (paste && sel.ranges.length > 1) {
        if (lastCopied && lastCopied.text.join("\n") == inserted) {
          if (sel.ranges.length % lastCopied.text.length == 0) {
            multiPaste = [];
            for (var i3 = 0; i3 < lastCopied.text.length; i3++) {
              multiPaste.push(doc2.splitLines(lastCopied.text[i3]));
            }
          }
        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
          multiPaste = map2(textLines, function(l2) {
            return [l2];
          });
        }
      }
      var updateInput = cm.curOp.updateInput;
      for (var i$13 = sel.ranges.length - 1; i$13 >= 0; i$13--) {
        var range3 = sel.ranges[i$13];
        var from2 = range3.from(), to2 = range3.to();
        if (range3.empty()) {
          if (deleted && deleted > 0) {
            from2 = Pos(from2.line, from2.ch - deleted);
          } else if (cm.state.overwrite && !paste) {
            to2 = Pos(to2.line, Math.min(getLine2(doc2, to2.line).text.length, to2.ch + lst(textLines).length));
          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
            from2 = to2 = Pos(from2.line, 0);
          }
        }
        var changeEvent = {
          from: from2,
          to: to2,
          text: multiPaste ? multiPaste[i$13 % multiPaste.length] : textLines,
          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
        };
        makeChange(cm.doc, changeEvent);
        signalLater(cm, "inputRead", cm, changeEvent);
      }
      if (inserted && !paste) {
        triggerElectric(cm, inserted);
      }
      ensureCursorVisible(cm);
      if (cm.curOp.updateInput < 2) {
        cm.curOp.updateInput = updateInput;
      }
      cm.curOp.typing = true;
      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }
    function handlePaste(e2, cm) {
      var pasted = e2.clipboardData && e2.clipboardData.getData("Text");
      if (pasted) {
        e2.preventDefault();
        if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
          runInOp(cm, function() {
            return applyTextInput(cm, pasted, 0, null, "paste");
          });
        }
        return true;
      }
    }
    function triggerElectric(cm, inserted) {
      if (!cm.options.electricChars || !cm.options.smartIndent) {
        return;
      }
      var sel = cm.doc.sel;
      for (var i3 = sel.ranges.length - 1; i3 >= 0; i3--) {
        var range3 = sel.ranges[i3];
        if (range3.head.ch > 100 || i3 && sel.ranges[i3 - 1].head.line == range3.head.line) {
          continue;
        }
        var mode = cm.getModeAt(range3.head);
        var indented = false;
        if (mode.electricChars) {
          for (var j2 = 0; j2 < mode.electricChars.length; j2++) {
            if (inserted.indexOf(mode.electricChars.charAt(j2)) > -1) {
              indented = indentLine(cm, range3.head.line, "smart");
              break;
            }
          }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine2(cm.doc, range3.head.line).text.slice(0, range3.head.ch))) {
            indented = indentLine(cm, range3.head.line, "smart");
          }
        }
        if (indented) {
          signalLater(cm, "electricInput", cm, range3.head.line);
        }
      }
    }
    function copyableRanges(cm) {
      var text3 = [], ranges = [];
      for (var i3 = 0; i3 < cm.doc.sel.ranges.length; i3++) {
        var line2 = cm.doc.sel.ranges[i3].head.line;
        var lineRange = { anchor: Pos(line2, 0), head: Pos(line2 + 1, 0) };
        ranges.push(lineRange);
        text3.push(cm.getRange(lineRange.anchor, lineRange.head));
      }
      return { text: text3, ranges };
    }
    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
      field.setAttribute("autocorrect", autocorrect ? "" : "off");
      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
      field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea() {
      var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
      var div2 = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      if (webkit) {
        te.style.width = "1000px";
      } else {
        te.setAttribute("wrap", "off");
      }
      if (ios) {
        te.style.border = "1px solid black";
      }
      disableBrowserMagic(te);
      return div2;
    }
    function addEditorMethods(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      var helpers2 = CodeMirror3.helpers = {};
      CodeMirror3.prototype = {
        constructor: CodeMirror3,
        focus: function() {
          window.focus();
          this.display.input.focus();
        },
        setOption: function(option, value) {
          var options = this.options, old = options[option];
          if (options[option] == value && option != "mode") {
            return;
          }
          options[option] = value;
          if (optionHandlers2.hasOwnProperty(option)) {
            operation(this, optionHandlers2[option])(this, value, old);
          }
          signal(this, "optionChange", this, option);
        },
        getOption: function(option) {
          return this.options[option];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(map3, bottom2) {
          this.state.keyMaps[bottom2 ? "push" : "unshift"](getKeyMap(map3));
        },
        removeKeyMap: function(map3) {
          var maps = this.state.keyMaps;
          for (var i3 = 0; i3 < maps.length; ++i3) {
            if (maps[i3] == map3 || maps[i3].name == map3) {
              maps.splice(i3, 1);
              return true;
            }
          }
        },
        addOverlay: methodOp(function(spec, options) {
          var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
          if (mode.startState) {
            throw new Error("Overlays may not be stateful.");
          }
          insertSorted(this.state.overlays, {
            mode,
            modeSpec: spec,
            opaque: options && options.opaque,
            priority: options && options.priority || 0
          }, function(overlay2) {
            return overlay2.priority;
          });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: methodOp(function(spec) {
          var overlays = this.state.overlays;
          for (var i3 = 0; i3 < overlays.length; ++i3) {
            var cur = overlays[i3].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i3, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),
        indentLine: methodOp(function(n2, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) {
              dir = this.options.smartIndent ? "smart" : "prev";
            } else {
              dir = dir ? "add" : "subtract";
            }
          }
          if (isLine(this.doc, n2)) {
            indentLine(this, n2, dir, aggressive);
          }
        }),
        indentSelection: methodOp(function(how) {
          var ranges = this.doc.sel.ranges, end = -1;
          for (var i3 = 0; i3 < ranges.length; i3++) {
            var range3 = ranges[i3];
            if (!range3.empty()) {
              var from2 = range3.from(), to2 = range3.to();
              var start2 = Math.max(end, from2.line);
              end = Math.min(this.lastLine(), to2.line - (to2.ch ? 0 : 1)) + 1;
              for (var j2 = start2; j2 < end; ++j2) {
                indentLine(this, j2, how);
              }
              var newRanges = this.doc.sel.ranges;
              if (from2.ch == 0 && ranges.length == newRanges.length && newRanges[i3].from().ch > 0) {
                replaceOneSelection(this.doc, i3, new Range(from2, newRanges[i3].to()), sel_dontScroll);
              }
            } else if (range3.head.line > end) {
              indentLine(this, range3.head.line, how, true);
              end = range3.head.line;
              if (i3 == this.doc.sel.primIndex) {
                ensureCursorVisible(this);
              }
            }
          }
        }),
        getTokenAt: function(pos, precise) {
          return takeToken(this, pos, precise);
        },
        getLineTokens: function(line2, precise) {
          return takeToken(this, Pos(line2), precise, true);
        },
        getTokenTypeAt: function(pos) {
          pos = clipPos(this.doc, pos);
          var styles = getLineStyles(this, getLine2(this.doc, pos.line));
          var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
          var type;
          if (ch == 0) {
            type = styles[2];
          } else {
            for (; ; ) {
              var mid2 = before + after >> 1;
              if ((mid2 ? styles[mid2 * 2 - 1] : 0) >= ch) {
                after = mid2;
              } else if (styles[mid2 * 2 + 1] < ch) {
                before = mid2 + 1;
              } else {
                type = styles[mid2 * 2 + 2];
                break;
              }
            }
          }
          var cut = type ? type.indexOf("overlay ") : -1;
          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
        },
        getModeAt: function(pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode) {
            return mode;
          }
          return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function(pos, type) {
          return this.getHelpers(pos, type)[0];
        },
        getHelpers: function(pos, type) {
          var found = [];
          if (!helpers2.hasOwnProperty(type)) {
            return found;
          }
          var help = helpers2[type], mode = this.getModeAt(pos);
          if (typeof mode[type] == "string") {
            if (help[mode[type]]) {
              found.push(help[mode[type]]);
            }
          } else if (mode[type]) {
            for (var i3 = 0; i3 < mode[type].length; i3++) {
              var val = help[mode[type][i3]];
              if (val) {
                found.push(val);
              }
            }
          } else if (mode.helperType && help[mode.helperType]) {
            found.push(help[mode.helperType]);
          } else if (help[mode.name]) {
            found.push(help[mode.name]);
          }
          for (var i$13 = 0; i$13 < help._global.length; i$13++) {
            var cur = help._global[i$13];
            if (cur.pred(mode, this) && indexOf2(found, cur.val) == -1) {
              found.push(cur.val);
            }
          }
          return found;
        },
        getStateAfter: function(line2, precise) {
          var doc2 = this.doc;
          line2 = clipLine(doc2, line2 == null ? doc2.first + doc2.size - 1 : line2);
          return getContextBefore(this, line2 + 1, precise).state;
        },
        cursorCoords: function(start2, mode) {
          var pos, range3 = this.doc.sel.primary();
          if (start2 == null) {
            pos = range3.head;
          } else if (typeof start2 == "object") {
            pos = clipPos(this.doc, start2);
          } else {
            pos = start2 ? range3.from() : range3.to();
          }
          return cursorCoords(this, pos, mode || "page");
        },
        charCoords: function(pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page");
        },
        coordsChar: function(coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function(height, mode) {
          height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function(line2, mode, includeWidgets) {
          var end = false, lineObj;
          if (typeof line2 == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line2 < this.doc.first) {
              line2 = this.doc.first;
            } else if (line2 > last) {
              line2 = last;
              end = true;
            }
            lineObj = getLine2(this.doc, line2);
          } else {
            lineObj = line2;
          }
          return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function() {
          return textHeight(this.display);
        },
        defaultCharWidth: function() {
          return charWidth(this.display);
        },
        getViewport: function() {
          return { from: this.display.viewFrom, to: this.display.viewTo };
        },
        addWidget: function(pos, node, scroll, vert2, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top2 = pos.bottom, left = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert2 == "over") {
            top2 = pos.top;
          } else if (vert2 == "above" || vert2 == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            if ((vert2 == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
              top2 = pos.top - node.offsetHeight;
            } else if (pos.bottom + node.offsetHeight <= vspace) {
              top2 = pos.bottom;
            }
            if (left + node.offsetWidth > hspace) {
              left = hspace - node.offsetWidth;
            }
          }
          node.style.top = top2 + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") {
              left = 0;
            } else if (horiz == "middle") {
              left = (display.sizer.clientWidth - node.offsetWidth) / 2;
            }
            node.style.left = left + "px";
          }
          if (scroll) {
            scrollIntoView2(this, { left, top: top2, right: left + node.offsetWidth, bottom: top2 + node.offsetHeight });
          }
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        triggerOnMouseDown: methodOp(onMouseDown),
        execCommand: function(cmd) {
          if (commands.hasOwnProperty(cmd)) {
            return commands[cmd].call(null, this);
          }
        },
        triggerElectric: methodOp(function(text3) {
          triggerElectric(this, text3);
        }),
        findPosH: function(from2, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from2);
          for (var i3 = 0; i3 < amount; ++i3) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveH: methodOp(function(dir, unit) {
          var this$1$1 = this;
          this.extendSelectionsBy(function(range3) {
            if (this$1$1.display.shift || this$1$1.doc.extend || range3.empty()) {
              return findPosH(this$1$1.doc, range3.head, dir, unit, this$1$1.options.rtlMoveVisually);
            } else {
              return dir < 0 ? range3.from() : range3.to();
            }
          }, sel_move);
        }),
        deleteH: methodOp(function(dir, unit) {
          var sel = this.doc.sel, doc2 = this.doc;
          if (sel.somethingSelected()) {
            doc2.replaceSelection("", null, "+delete");
          } else {
            deleteNearSelection(this, function(range3) {
              var other = findPosH(doc2, range3.head, dir, unit, false);
              return dir < 0 ? { from: other, to: range3.head } : { from: range3.head, to: other };
            });
          }
        }),
        findPosV: function(from2, amount, unit, goalColumn) {
          var dir = 1, x2 = goalColumn;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from2);
          for (var i3 = 0; i3 < amount; ++i3) {
            var coords = cursorCoords(this, cur, "div");
            if (x2 == null) {
              x2 = coords.left;
            } else {
              coords.left = x2;
            }
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveV: methodOp(function(dir, unit) {
          var this$1$1 = this;
          var doc2 = this.doc, goals = [];
          var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
          doc2.extendSelectionsBy(function(range3) {
            if (collapse) {
              return dir < 0 ? range3.from() : range3.to();
            }
            var headPos = cursorCoords(this$1$1, range3.head, "div");
            if (range3.goalColumn != null) {
              headPos.left = range3.goalColumn;
            }
            goals.push(headPos.left);
            var pos = findPosV(this$1$1, headPos, dir, unit);
            if (unit == "page" && range3 == doc2.sel.primary()) {
              addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top);
            }
            return pos;
          }, sel_move);
          if (goals.length) {
            for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
              doc2.sel.ranges[i3].goalColumn = goals[i3];
            }
          }
        }),
        findWordAt: function(pos) {
          var doc2 = this.doc, line2 = getLine2(doc2, pos.line).text;
          var start2 = pos.ch, end = pos.ch;
          if (line2) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.sticky == "before" || end == line2.length) && start2) {
              --start2;
            } else {
              ++end;
            }
            var startChar = line2.charAt(start2);
            var check2 = isWordChar(startChar, helper) ? function(ch) {
              return isWordChar(ch, helper);
            } : /\s/.test(startChar) ? function(ch) {
              return /\s/.test(ch);
            } : function(ch) {
              return !/\s/.test(ch) && !isWordChar(ch);
            };
            while (start2 > 0 && check2(line2.charAt(start2 - 1))) {
              --start2;
            }
            while (end < line2.length && check2(line2.charAt(end))) {
              ++end;
            }
          }
          return new Range(Pos(pos.line, start2), Pos(pos.line, end));
        },
        toggleOverwrite: function(value) {
          if (value != null && value == this.state.overwrite) {
            return;
          }
          if (this.state.overwrite = !this.state.overwrite) {
            addClass(this.display.cursorDiv, "CodeMirror-overwrite");
          } else {
            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
          }
          signal(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() {
          return this.display.input.getField() == activeElt();
        },
        isReadOnly: function() {
          return !!(this.options.readOnly || this.doc.cantEdit);
        },
        scrollTo: methodOp(function(x2, y2) {
          scrollToCoords(this, x2, y2);
        }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {
            left: scroller.scrollLeft,
            top: scroller.scrollTop,
            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
            clientHeight: displayHeight(this),
            clientWidth: displayWidth(this)
          };
        },
        scrollIntoView: methodOp(function(range3, margin) {
          if (range3 == null) {
            range3 = { from: this.doc.sel.primary().head, to: null };
            if (margin == null) {
              margin = this.options.cursorScrollMargin;
            }
          } else if (typeof range3 == "number") {
            range3 = { from: Pos(range3, 0), to: null };
          } else if (range3.from == null) {
            range3 = { from: range3, to: null };
          }
          if (!range3.to) {
            range3.to = range3.from;
          }
          range3.margin = margin || 0;
          if (range3.from.line != null) {
            scrollToRange(this, range3);
          } else {
            scrollToCoordsRange(this, range3.from, range3.to, range3.margin);
          }
        }),
        setSize: methodOp(function(width, height) {
          var this$1$1 = this;
          var interpret = function(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          };
          if (width != null) {
            this.display.wrapper.style.width = interpret(width);
          }
          if (height != null) {
            this.display.wrapper.style.height = interpret(height);
          }
          if (this.options.lineWrapping) {
            clearLineMeasurementCache(this);
          }
          var lineNo2 = this.display.viewFrom;
          this.doc.iter(lineNo2, this.display.viewTo, function(line2) {
            if (line2.widgets) {
              for (var i3 = 0; i3 < line2.widgets.length; i3++) {
                if (line2.widgets[i3].noHScroll) {
                  regLineChange(this$1$1, lineNo2, "widget");
                  break;
                }
              }
            }
            ++lineNo2;
          });
          this.curOp.forceUpdate = true;
          signal(this, "refresh", this);
        }),
        operation: function(f2) {
          return runInOp(this, f2);
        },
        startOperation: function() {
          return startOperation(this);
        },
        endOperation: function() {
          return endOperation(this);
        },
        refresh: methodOp(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange(this);
          this.curOp.forceUpdate = true;
          clearCaches(this);
          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace(this.display);
          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
            estimateLineHeights(this);
          }
          signal(this, "refresh", this);
        }),
        swapDoc: methodOp(function(doc2) {
          var old = this.doc;
          old.cm = null;
          if (this.state.selectingText) {
            this.state.selectingText();
          }
          attachDoc(this, doc2);
          clearCaches(this);
          this.display.input.reset();
          scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
          this.curOp.forceScroll = true;
          signalLater(this, "swapDoc", this, old);
          return old;
        }),
        phrase: function(phraseText) {
          var phrases = this.options.phrases;
          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
        },
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror3);
      CodeMirror3.registerHelper = function(type, name, value) {
        if (!helpers2.hasOwnProperty(type)) {
          helpers2[type] = CodeMirror3[type] = { _global: [] };
        }
        helpers2[type][name] = value;
      };
      CodeMirror3.registerGlobalHelper = function(type, name, predicate, value) {
        CodeMirror3.registerHelper(type, name, value);
        helpers2[type]._global.push({ pred: predicate, val: value });
      };
    }
    function findPosH(doc2, pos, dir, unit, visually) {
      var oldPos = pos;
      var origDir = dir;
      var lineObj = getLine2(doc2, pos.line);
      var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;
      function findNextLine() {
        var l2 = pos.line + lineDir;
        if (l2 < doc2.first || l2 >= doc2.first + doc2.size) {
          return false;
        }
        pos = new Pos(l2, pos.ch, pos.sticky);
        return lineObj = getLine2(doc2, l2);
      }
      function moveOnce(boundToLine) {
        var next;
        if (unit == "codepoint") {
          var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
          if (isNaN(ch)) {
            next = null;
          } else {
            var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
            next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
          }
        } else if (visually) {
          next = moveVisually(doc2.cm, lineObj, pos, dir);
        } else {
          next = moveLogically(lineObj, pos, dir);
        }
        if (next == null) {
          if (!boundToLine && findNextLine()) {
            pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
          } else {
            return false;
          }
        } else {
          pos = next;
        }
        return true;
      }
      if (unit == "char" || unit == "codepoint") {
        moveOnce();
      } else if (unit == "column") {
        moveOnce(true);
      } else if (unit == "word" || unit == "group") {
        var sawType = null, group = unit == "group";
        var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
        for (var first = true; ; first = false) {
          if (dir < 0 && !moveOnce(!first)) {
            break;
          }
          var cur = lineObj.text.charAt(pos.ch) || "\n";
          var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
          if (group && !first && !type) {
            type = "s";
          }
          if (sawType && sawType != type) {
            if (dir < 0) {
              dir = 1;
              moveOnce();
              pos.sticky = "after";
            }
            break;
          }
          if (type) {
            sawType = type;
          }
          if (dir > 0 && !moveOnce(!first)) {
            break;
          }
        }
      }
      var result = skipAtomic(doc2, pos, oldPos, origDir, true);
      if (equalCursorPos(oldPos, result)) {
        result.hitSide = true;
      }
      return result;
    }
    function findPosV(cm, pos, dir, unit) {
      var doc2 = cm.doc, x2 = pos.left, y2;
      if (unit == "page") {
        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
        y2 = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
      } else if (unit == "line") {
        y2 = dir > 0 ? pos.bottom + 3 : pos.top - 3;
      }
      var target2;
      for (; ; ) {
        target2 = coordsChar(cm, x2, y2);
        if (!target2.outside) {
          break;
        }
        if (dir < 0 ? y2 <= 0 : y2 >= doc2.height) {
          target2.hitSide = true;
          break;
        }
        y2 += dir * 5;
      }
      return target2;
    }
    var ContentEditableInput = function(cm) {
      this.cm = cm;
      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
      this.polling = new Delayed();
      this.composing = null;
      this.gracePeriod = false;
      this.readDOMTimeout = null;
    };
    ContentEditableInput.prototype.init = function(display) {
      var this$1$1 = this;
      var input = this, cm = input.cm;
      var div2 = input.div = display.lineDiv;
      div2.contentEditable = true;
      disableBrowserMagic(div2, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
      function belongsToInput(e2) {
        for (var t2 = e2.target; t2; t2 = t2.parentNode) {
          if (t2 == div2) {
            return true;
          }
          if (/\bCodeMirror-(?:line)?widget\b/.test(t2.className)) {
            break;
          }
        }
        return false;
      }
      on(div2, "paste", function(e2) {
        if (!belongsToInput(e2) || signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
          return;
        }
        if (ie_version <= 11) {
          setTimeout(operation(cm, function() {
            return this$1$1.updateFromDOM();
          }), 20);
        }
      });
      on(div2, "compositionstart", function(e2) {
        this$1$1.composing = { data: e2.data, done: false };
      });
      on(div2, "compositionupdate", function(e2) {
        if (!this$1$1.composing) {
          this$1$1.composing = { data: e2.data, done: false };
        }
      });
      on(div2, "compositionend", function(e2) {
        if (this$1$1.composing) {
          if (e2.data != this$1$1.composing.data) {
            this$1$1.readFromDOMSoon();
          }
          this$1$1.composing.done = true;
        }
      });
      on(div2, "touchstart", function() {
        return input.forceCompositionEnd();
      });
      on(div2, "input", function() {
        if (!this$1$1.composing) {
          this$1$1.readFromDOMSoon();
        }
      });
      function onCopyCut(e2) {
        if (!belongsToInput(e2) || signalDOMEvent(cm, e2)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
          if (e2.type == "cut") {
            cm.replaceSelection("", null, "cut");
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e2.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e2.clipboardData) {
          e2.clipboardData.clearData();
          var content = lastCopied.text.join("\n");
          e2.clipboardData.setData("Text", content);
          if (e2.clipboardData.getData("Text") == content) {
            e2.preventDefault();
            return;
          }
        }
        var kludge = hiddenTextarea(), te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = lastCopied.text.join("\n");
        var hadFocus = activeElt();
        selectInput(te);
        setTimeout(function() {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div2) {
            input.showPrimarySelection();
          }
        }, 50);
      }
      on(div2, "copy", onCopyCut);
      on(div2, "cut", onCopyCut);
    };
    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.div.setAttribute("aria-label", label);
      } else {
        this.div.removeAttribute("aria-label");
      }
    };
    ContentEditableInput.prototype.prepareSelection = function() {
      var result = prepareSelection(this.cm, false);
      result.focus = activeElt() == this.div;
      return result;
    };
    ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
      if (!info || !this.cm.display.view.length) {
        return;
      }
      if (info.focus || takeFocus) {
        this.showPrimarySelection();
      }
      this.showMultipleSelections(info);
    };
    ContentEditableInput.prototype.getSelection = function() {
      return this.cm.display.wrapper.ownerDocument.getSelection();
    };
    ContentEditableInput.prototype.showPrimarySelection = function() {
      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
      var from2 = prim.from(), to2 = prim.to();
      if (cm.display.viewTo == cm.display.viewFrom || from2.line >= cm.display.viewTo || to2.line < cm.display.viewFrom) {
        sel.removeAllRanges();
        return;
      }
      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from2) == 0 && cmp(maxPos(curAnchor, curFocus), to2) == 0) {
        return;
      }
      var view = cm.display.view;
      var start2 = from2.line >= cm.display.viewFrom && posToDOM(cm, from2) || { node: view[0].measure.map[2], offset: 0 };
      var end = to2.line < cm.display.viewTo && posToDOM(cm, to2);
      if (!end) {
        var measure = view[view.length - 1].measure;
        var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };
      }
      if (!start2 || !end) {
        sel.removeAllRanges();
        return;
      }
      var old = sel.rangeCount && sel.getRangeAt(0), rng;
      try {
        rng = range2(start2.node, start2.offset, end.offset, end.node);
      } catch (e2) {
      }
      if (rng) {
        if (!gecko && cm.state.focused) {
          sel.collapse(start2.node, start2.offset);
          if (!rng.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) {
          sel.addRange(old);
        } else if (gecko) {
          this.startGracePeriod();
        }
      }
      this.rememberSelection();
    };
    ContentEditableInput.prototype.startGracePeriod = function() {
      var this$1$1 = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        this$1$1.gracePeriod = false;
        if (this$1$1.selectionChanged()) {
          this$1$1.cm.operation(function() {
            return this$1$1.cm.curOp.selectionChanged = true;
          });
        }
      }, 20);
    };
    ContentEditableInput.prototype.showMultipleSelections = function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    };
    ContentEditableInput.prototype.rememberSelection = function() {
      var sel = this.getSelection();
      this.lastAnchorNode = sel.anchorNode;
      this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode;
      this.lastFocusOffset = sel.focusOffset;
    };
    ContentEditableInput.prototype.selectionInEditor = function() {
      var sel = this.getSelection();
      if (!sel.rangeCount) {
        return false;
      }
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains2(this.div, node);
    };
    ContentEditableInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor() || activeElt() != this.div) {
          this.showSelection(this.prepareSelection(), true);
        }
        this.div.focus();
      }
    };
    ContentEditableInput.prototype.blur = function() {
      this.div.blur();
    };
    ContentEditableInput.prototype.getField = function() {
      return this.div;
    };
    ContentEditableInput.prototype.supportsTouch = function() {
      return true;
    };
    ContentEditableInput.prototype.receivedFocus = function() {
      var this$1$1 = this;
      var input = this;
      if (this.selectionInEditor()) {
        setTimeout(function() {
          return this$1$1.pollSelection();
        }, 20);
      } else {
        runInOp(this.cm, function() {
          return input.cm.curOp.selectionChanged = true;
        });
      }
      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    };
    ContentEditableInput.prototype.selectionChanged = function() {
      var sel = this.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    };
    ContentEditableInput.prototype.pollSelection = function() {
      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
        return;
      }
      var sel = this.getSelection(), cm = this.cm;
      if (android && chrome2 && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
        this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
        this.blur();
        this.focus();
        return;
      }
      if (this.composing) {
        return;
      }
      this.rememberSelection();
      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var head = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (anchor && head) {
        runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) {
            cm.curOp.selectionChanged = true;
          }
        });
      }
    };
    ContentEditableInput.prototype.pollContent = function() {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from2 = sel.from(), to2 = sel.to();
      if (from2.ch == 0 && from2.line > cm.firstLine()) {
        from2 = Pos(from2.line - 1, getLine2(cm.doc, from2.line - 1).length);
      }
      if (to2.ch == getLine2(cm.doc, to2.line).text.length && to2.line < cm.lastLine()) {
        to2 = Pos(to2.line + 1, 0);
      }
      if (from2.line < display.viewFrom || to2.line > display.viewTo - 1) {
        return false;
      }
      var fromIndex, fromLine, fromNode;
      if (from2.line == display.viewFrom || (fromIndex = findViewIndex(cm, from2.line)) == 0) {
        fromLine = lineNo(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = lineNo(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to2.line);
      var toLine, toNode;
      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = lineNo(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }
      if (!fromNode) {
        return false;
      }
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine2(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) {
          newText.pop();
          oldText.pop();
          toLine--;
        } else if (newText[0] == oldText[0]) {
          newText.shift();
          oldText.shift();
          fromLine++;
        } else {
          break;
        }
      }
      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
        ++cutFront;
      }
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        ++cutEnd;
      }
      if (newText.length == 1 && oldText.length == 1 && fromLine == from2.line) {
        while (cutFront && cutFront > from2.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          cutFront--;
          cutEnd++;
        }
      }
      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    };
    ContentEditableInput.prototype.ensurePolled = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.reset = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.forceCompositionEnd = function() {
      if (!this.composing) {
        return;
      }
      clearTimeout(this.readDOMTimeout);
      this.composing = null;
      this.updateFromDOM();
      this.div.blur();
      this.div.focus();
    };
    ContentEditableInput.prototype.readFromDOMSoon = function() {
      var this$1$1 = this;
      if (this.readDOMTimeout != null) {
        return;
      }
      this.readDOMTimeout = setTimeout(function() {
        this$1$1.readDOMTimeout = null;
        if (this$1$1.composing) {
          if (this$1$1.composing.done) {
            this$1$1.composing = null;
          } else {
            return;
          }
        }
        this$1$1.updateFromDOM();
      }, 80);
    };
    ContentEditableInput.prototype.updateFromDOM = function() {
      var this$1$1 = this;
      if (this.cm.isReadOnly() || !this.pollContent()) {
        runInOp(this.cm, function() {
          return regChange(this$1$1.cm);
        });
      }
    };
    ContentEditableInput.prototype.setUneditable = function(node) {
      node.contentEditable = "false";
    };
    ContentEditableInput.prototype.onKeyPress = function(e2) {
      if (e2.charCode == 0 || this.composing) {
        return;
      }
      e2.preventDefault();
      if (!this.cm.isReadOnly()) {
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e2.charCode == null ? e2.keyCode : e2.charCode), 0);
      }
    };
    ContentEditableInput.prototype.readOnlyChanged = function(val) {
      this.div.contentEditable = String(val != "nocursor");
    };
    ContentEditableInput.prototype.onContextMenu = function() {
    };
    ContentEditableInput.prototype.resetPosition = function() {
    };
    ContentEditableInput.prototype.needsContentAttribute = true;
    function posToDOM(cm, pos) {
      var view = findViewForLine(cm, pos.line);
      if (!view || view.hidden) {
        return null;
      }
      var line2 = getLine2(cm.doc, pos.line);
      var info = mapFromLineView(view, line2, pos.line);
      var order2 = getOrder(line2, cm.doc.direction), side = "left";
      if (order2) {
        var partPos = getBidiPartAt(order2, pos.ch);
        side = partPos % 2 ? "right" : "left";
      }
      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
      result.offset = result.collapse == "right" ? result.end : result.start;
      return result;
    }
    function isInGutter(node) {
      for (var scan = node; scan; scan = scan.parentNode) {
        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
          return true;
        }
      }
      return false;
    }
    function badPos(pos, bad) {
      if (bad) {
        pos.bad = true;
      }
      return pos;
    }
    function domTextBetween(cm, from2, to2, fromLine, toLine) {
      var text3 = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
      function recognizeMarker(id2) {
        return function(marker2) {
          return marker2.id == id2;
        };
      }
      function close() {
        if (closing) {
          text3 += lineSep;
          if (extraLinebreak) {
            text3 += lineSep;
          }
          closing = extraLinebreak = false;
        }
      }
      function addText(str) {
        if (str) {
          close();
          text3 += str;
        }
      }
      function walk(node) {
        if (node.nodeType == 1) {
          var cmText = node.getAttribute("cm-text");
          if (cmText) {
            addText(cmText);
            return;
          }
          var markerID = node.getAttribute("cm-marker"), range3;
          if (markerID) {
            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
            if (found.length && (range3 = found[0].find(0))) {
              addText(getBetween(cm.doc, range3.from, range3.to).join(lineSep));
            }
            return;
          }
          if (node.getAttribute("contenteditable") == "false") {
            return;
          }
          var isBlock2 = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
            return;
          }
          if (isBlock2) {
            close();
          }
          for (var i3 = 0; i3 < node.childNodes.length; i3++) {
            walk(node.childNodes[i3]);
          }
          if (/^(pre|p)$/i.test(node.nodeName)) {
            extraLinebreak = true;
          }
          if (isBlock2) {
            closing = true;
          }
        } else if (node.nodeType == 3) {
          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
      }
      for (; ; ) {
        walk(from2);
        if (from2 == to2) {
          break;
        }
        from2 = from2.nextSibling;
        extraLinebreak = false;
      }
      return text3;
    }
    function domToPos(cm, node, offset2) {
      var lineNode;
      if (node == cm.display.lineDiv) {
        lineNode = cm.display.lineDiv.childNodes[offset2];
        if (!lineNode) {
          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
        }
        node = null;
        offset2 = 0;
      } else {
        for (lineNode = node; ; lineNode = lineNode.parentNode) {
          if (!lineNode || lineNode == cm.display.lineDiv) {
            return null;
          }
          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
            break;
          }
        }
      }
      for (var i3 = 0; i3 < cm.display.view.length; i3++) {
        var lineView = cm.display.view[i3];
        if (lineView.node == lineNode) {
          return locateNodeInLineView(lineView, node, offset2);
        }
      }
    }
    function locateNodeInLineView(lineView, node, offset2) {
      var wrapper = lineView.text.firstChild, bad = false;
      if (!node || !contains2(wrapper, node)) {
        return badPos(Pos(lineNo(lineView.line), 0), true);
      }
      if (node == wrapper) {
        bad = true;
        node = wrapper.childNodes[offset2];
        offset2 = 0;
        if (!node) {
          var line2 = lineView.rest ? lst(lineView.rest) : lineView.line;
          return badPos(Pos(lineNo(line2), line2.text.length), bad);
        }
      }
      var textNode = node.nodeType == 3 ? node : null, topNode = node;
      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
        textNode = node.firstChild;
        if (offset2) {
          offset2 = textNode.nodeValue.length;
        }
      }
      while (topNode.parentNode != wrapper) {
        topNode = topNode.parentNode;
      }
      var measure = lineView.measure, maps = measure.maps;
      function find2(textNode2, topNode2, offset3) {
        for (var i3 = -1; i3 < (maps ? maps.length : 0); i3++) {
          var map3 = i3 < 0 ? measure.map : maps[i3];
          for (var j2 = 0; j2 < map3.length; j2 += 3) {
            var curNode = map3[j2 + 2];
            if (curNode == textNode2 || curNode == topNode2) {
              var line3 = lineNo(i3 < 0 ? lineView.line : lineView.rest[i3]);
              var ch = map3[j2] + offset3;
              if (offset3 < 0 || curNode != textNode2) {
                ch = map3[j2 + (offset3 ? 1 : 0)];
              }
              return Pos(line3, ch);
            }
          }
        }
      }
      var found = find2(textNode, topNode, offset2);
      if (found) {
        return badPos(found, bad);
      }
      for (var after = topNode.nextSibling, dist2 = textNode ? textNode.nodeValue.length - offset2 : 0; after; after = after.nextSibling) {
        found = find2(after, after.firstChild, 0);
        if (found) {
          return badPos(Pos(found.line, found.ch - dist2), bad);
        } else {
          dist2 += after.textContent.length;
        }
      }
      for (var before = topNode.previousSibling, dist$1 = offset2; before; before = before.previousSibling) {
        found = find2(before, before.firstChild, -1);
        if (found) {
          return badPos(Pos(found.line, found.ch + dist$1), bad);
        } else {
          dist$1 += before.textContent.length;
        }
      }
    }
    var TextareaInput = function(cm) {
      this.cm = cm;
      this.prevInput = "";
      this.pollingFast = false;
      this.polling = new Delayed();
      this.hasSelection = false;
      this.composing = null;
    };
    TextareaInput.prototype.init = function(display) {
      var this$1$1 = this;
      var input = this, cm = this.cm;
      this.createField(display);
      var te = this.textarea;
      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
      if (ios) {
        te.style.width = "0px";
      }
      on(te, "input", function() {
        if (ie2 && ie_version >= 9 && this$1$1.hasSelection) {
          this$1$1.hasSelection = null;
        }
        input.poll();
      });
      on(te, "paste", function(e2) {
        if (signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
          return;
        }
        cm.state.pasteIncoming = +new Date();
        input.fastPoll();
      });
      function prepareCopyCut(e2) {
        if (signalDOMEvent(cm, e2)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e2.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e2.type == "cut") {
          cm.state.cutIncoming = +new Date();
        }
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);
      on(display.scroller, "paste", function(e2) {
        if (eventInWidget(display, e2) || signalDOMEvent(cm, e2)) {
          return;
        }
        if (!te.dispatchEvent) {
          cm.state.pasteIncoming = +new Date();
          input.focus();
          return;
        }
        var event = new Event("paste");
        event.clipboardData = e2.clipboardData;
        te.dispatchEvent(event);
      });
      on(display.lineSpace, "selectstart", function(e2) {
        if (!eventInWidget(display, e2)) {
          e_preventDefault(e2);
        }
      });
      on(te, "compositionstart", function() {
        var start2 = cm.getCursor("from");
        if (input.composing) {
          input.composing.range.clear();
        }
        input.composing = {
          start: start2,
          range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
        };
      });
      on(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    };
    TextareaInput.prototype.createField = function(_display) {
      this.wrapper = hiddenTextarea();
      this.textarea = this.wrapper.firstChild;
    };
    TextareaInput.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.textarea.setAttribute("aria-label", label);
      } else {
        this.textarea.removeAttribute("aria-label");
      }
    };
    TextareaInput.prototype.prepareSelection = function() {
      var cm = this.cm, display = cm.display, doc2 = cm.doc;
      var result = prepareSelection(cm);
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
      }
      return result;
    };
    TextareaInput.prototype.showSelection = function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    };
    TextareaInput.prototype.reset = function(typing) {
      if (this.contextMenuPending || this.composing) {
        return;
      }
      var cm = this.cm;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var content = cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) {
          selectInput(this.textarea);
        }
        if (ie2 && ie_version >= 9) {
          this.hasSelection = content;
        }
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie2 && ie_version >= 9) {
          this.hasSelection = null;
        }
      }
    };
    TextareaInput.prototype.getField = function() {
      return this.textarea;
    };
    TextareaInput.prototype.supportsTouch = function() {
      return false;
    };
    TextareaInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try {
          this.textarea.focus();
        } catch (e2) {
        }
      }
    };
    TextareaInput.prototype.blur = function() {
      this.textarea.blur();
    };
    TextareaInput.prototype.resetPosition = function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    };
    TextareaInput.prototype.receivedFocus = function() {
      this.slowPoll();
    };
    TextareaInput.prototype.slowPoll = function() {
      var this$1$1 = this;
      if (this.pollingFast) {
        return;
      }
      this.polling.set(this.cm.options.pollInterval, function() {
        this$1$1.poll();
        if (this$1$1.cm.state.focused) {
          this$1$1.slowPoll();
        }
      });
    };
    TextareaInput.prototype.fastPoll = function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p2() {
        var changed = input.poll();
        if (!changed && !missed) {
          missed = true;
          input.polling.set(60, p2);
        } else {
          input.pollingFast = false;
          input.slowPoll();
        }
      }
      input.polling.set(20, p2);
    };
    TextareaInput.prototype.poll = function() {
      var this$1$1 = this;
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
        return false;
      }
      var text3 = input.value;
      if (text3 == prevInput && !cm.somethingSelected()) {
        return false;
      }
      if (ie2 && ie_version >= 9 && this.hasSelection === text3 || mac && /[\uf700-\uf7ff]/.test(text3)) {
        cm.display.input.reset();
        return false;
      }
      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text3.charCodeAt(0);
        if (first == 8203 && !prevInput) {
          prevInput = "\u200B";
        }
        if (first == 8666) {
          this.reset();
          return this.cm.execCommand("undo");
        }
      }
      var same = 0, l2 = Math.min(prevInput.length, text3.length);
      while (same < l2 && prevInput.charCodeAt(same) == text3.charCodeAt(same)) {
        ++same;
      }
      runInOp(cm, function() {
        applyTextInput(cm, text3.slice(same), prevInput.length - same, null, this$1$1.composing ? "*compose" : null);
        if (text3.length > 1e3 || text3.indexOf("\n") > -1) {
          input.value = this$1$1.prevInput = "";
        } else {
          this$1$1.prevInput = text3;
        }
        if (this$1$1.composing) {
          this$1$1.composing.range.clear();
          this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
        }
      });
      return true;
    };
    TextareaInput.prototype.ensurePolled = function() {
      if (this.pollingFast && this.poll()) {
        this.pollingFast = false;
      }
    };
    TextareaInput.prototype.onKeyPress = function() {
      if (ie2 && ie_version >= 9) {
        this.hasSelection = null;
      }
      this.fastPoll();
    };
    TextareaInput.prototype.onContextMenu = function(e2) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      if (input.contextMenuPending) {
        input.contextMenuPending();
      }
      var pos = posFromMouse(cm, e2), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) {
        return;
      }
      var reset2 = cm.options.resetSelectionOnContextMenu;
      if (reset2 && cm.doc.sel.contains(pos) == -1) {
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
      }
      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
      input.wrapper.style.cssText = "position: static";
      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e2.clientY - wrapperBox.top - 5) + "px; left: " + (e2.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie2 ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      var oldScrollY;
      if (webkit) {
        oldScrollY = window.scrollY;
      }
      display.input.focus();
      if (webkit) {
        window.scrollTo(null, oldScrollY);
      }
      display.input.reset();
      if (!cm.somethingSelected()) {
        te.value = input.prevInput = " ";
      }
      input.contextMenuPending = rehide;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200B" + (selected ? te.value : "");
          te.value = "\u21DA";
          te.value = extval;
          input.prevInput = selected ? "" : "\u200B";
          te.selectionStart = 1;
          te.selectionEnd = extval.length;
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        if (input.contextMenuPending != rehide) {
          return;
        }
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS;
        te.style.cssText = oldCSS;
        if (ie2 && ie_version < 9) {
          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
        }
        if (te.selectionStart != null) {
          if (!ie2 || ie2 && ie_version < 9) {
            prepareSelectAllHack();
          }
          var i3 = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
              operation(cm, selectAll)(cm);
            } else if (i3++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }
      if (ie2 && ie_version >= 9) {
        prepareSelectAllHack();
      }
      if (captureRightClick) {
        e_stop(e2);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    };
    TextareaInput.prototype.readOnlyChanged = function(val) {
      if (!val) {
        this.reset();
      }
      this.textarea.disabled = val == "nocursor";
      this.textarea.readOnly = !!val;
    };
    TextareaInput.prototype.setUneditable = function() {
    };
    TextareaInput.prototype.needsContentAttribute = false;
    function fromTextArea(textarea, options) {
      options = options ? copyObj(options) : {};
      options.value = textarea.value;
      if (!options.tabindex && textarea.tabIndex) {
        options.tabindex = textarea.tabIndex;
      }
      if (!options.placeholder && textarea.placeholder) {
        options.placeholder = textarea.placeholder;
      }
      if (options.autofocus == null) {
        var hasFocus = activeElt();
        options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
      }
      function save() {
        textarea.value = cm.getValue();
      }
      var realSubmit;
      if (textarea.form) {
        on(textarea.form, "submit", save);
        if (!options.leaveSubmitMethodAlone) {
          var form = textarea.form;
          realSubmit = form.submit;
          try {
            var wrappedSubmit = form.submit = function() {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
          } catch (e2) {
          }
        }
      }
      options.finishInit = function(cm2) {
        cm2.save = save;
        cm2.getTextArea = function() {
          return textarea;
        };
        cm2.toTextArea = function() {
          cm2.toTextArea = isNaN;
          save();
          textarea.parentNode.removeChild(cm2.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off(textarea.form, "submit", save);
            if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
              textarea.form.submit = realSubmit;
            }
          }
        };
      };
      textarea.style.display = "none";
      var cm = CodeMirror2(function(node) {
        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
      return cm;
    }
    function addLegacyProps(CodeMirror3) {
      CodeMirror3.off = off;
      CodeMirror3.on = on;
      CodeMirror3.wheelEventPixels = wheelEventPixels;
      CodeMirror3.Doc = Doc;
      CodeMirror3.splitLines = splitLinesAuto;
      CodeMirror3.countColumn = countColumn;
      CodeMirror3.findColumn = findColumn;
      CodeMirror3.isWordChar = isWordCharBasic;
      CodeMirror3.Pass = Pass;
      CodeMirror3.signal = signal;
      CodeMirror3.Line = Line;
      CodeMirror3.changeEnd = changeEnd;
      CodeMirror3.scrollbarModel = scrollbarModel;
      CodeMirror3.Pos = Pos;
      CodeMirror3.cmpPos = cmp;
      CodeMirror3.modes = modes;
      CodeMirror3.mimeModes = mimeModes;
      CodeMirror3.resolveMode = resolveMode;
      CodeMirror3.getMode = getMode;
      CodeMirror3.modeExtensions = modeExtensions;
      CodeMirror3.extendMode = extendMode;
      CodeMirror3.copyState = copyState;
      CodeMirror3.startState = startState;
      CodeMirror3.innerMode = innerMode;
      CodeMirror3.commands = commands;
      CodeMirror3.keyMap = keyMap;
      CodeMirror3.keyName = keyName;
      CodeMirror3.isModifierKey = isModifierKey;
      CodeMirror3.lookupKey = lookupKey;
      CodeMirror3.normalizeKeyMap = normalizeKeyMap;
      CodeMirror3.StringStream = StringStream;
      CodeMirror3.SharedTextMarker = SharedTextMarker;
      CodeMirror3.TextMarker = TextMarker;
      CodeMirror3.LineWidget = LineWidget;
      CodeMirror3.e_preventDefault = e_preventDefault;
      CodeMirror3.e_stopPropagation = e_stopPropagation;
      CodeMirror3.e_stop = e_stop;
      CodeMirror3.addClass = addClass;
      CodeMirror3.contains = contains2;
      CodeMirror3.rmClass = rmClass;
      CodeMirror3.keyNames = keyNames2;
    }
    defineOptions(CodeMirror2);
    addEditorMethods(CodeMirror2);
    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for (var prop2 in Doc.prototype) {
      if (Doc.prototype.hasOwnProperty(prop2) && indexOf2(dontDelegate, prop2) < 0) {
        CodeMirror2.prototype[prop2] = function(method) {
          return function() {
            return method.apply(this.doc, arguments);
          };
        }(Doc.prototype[prop2]);
      }
    }
    eventMixin(Doc);
    CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
    CodeMirror2.defineMode = function(name) {
      if (!CodeMirror2.defaults.mode && name != "null") {
        CodeMirror2.defaults.mode = name;
      }
      defineMode.apply(this, arguments);
    };
    CodeMirror2.defineMIME = defineMIME;
    CodeMirror2.defineMode("null", function() {
      return { token: function(stream) {
        return stream.skipToEnd();
      } };
    });
    CodeMirror2.defineMIME("text/plain", "null");
    CodeMirror2.defineExtension = function(name, func) {
      CodeMirror2.prototype[name] = func;
    };
    CodeMirror2.defineDocExtension = function(name, func) {
      Doc.prototype[name] = func;
    };
    CodeMirror2.fromTextArea = fromTextArea;
    addLegacyProps(CodeMirror2);
    CodeMirror2.version = "5.65.4";
    return CodeMirror2;
  });
})(codemirror);
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports);
  })(function(CodeMirror2) {
    var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/, emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/, unorderedListRE = /[*+-]\s/;
    CodeMirror2.commands.newlineAndIndentContinueMarkdownList = function(cm) {
      if (cm.getOption("disableInput"))
        return CodeMirror2.Pass;
      var ranges = cm.listSelections(), replacements2 = [];
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var pos = ranges[i2].head;
        var eolState = cm.getStateAfter(pos.line);
        var inner = CodeMirror2.innerMode(cm.getMode(), eolState);
        if (inner.mode.name !== "markdown" && inner.mode.helperType !== "markdown") {
          cm.execCommand("newlineAndIndent");
          return;
        } else {
          eolState = inner.state;
        }
        var inList = eolState.list !== false;
        var inQuote = eolState.quote !== 0;
        var line2 = cm.getLine(pos.line), match5 = listRE.exec(line2);
        var cursorBeforeBullet = /^\s*$/.test(line2.slice(0, pos.ch));
        if (!ranges[i2].empty() || !inList && !inQuote || !match5 || cursorBeforeBullet) {
          cm.execCommand("newlineAndIndent");
          return;
        }
        if (emptyListRE.test(line2)) {
          var endOfQuote = inQuote && />\s*$/.test(line2);
          var endOfList = !/>\s*$/.test(line2);
          if (endOfQuote || endOfList)
            cm.replaceRange("", {
              line: pos.line,
              ch: 0
            }, {
              line: pos.line,
              ch: pos.ch + 1
            });
          replacements2[i2] = "\n";
        } else {
          var indent2 = match5[1], after = match5[5];
          var numbered = !(unorderedListRE.test(match5[2]) || match5[2].indexOf(">") >= 0);
          var bullet2 = numbered ? parseInt(match5[3], 10) + 1 + match5[4] : match5[2].replace("x", " ");
          replacements2[i2] = "\n" + indent2 + bullet2 + after;
          if (numbered)
            incrementRemainingMarkdownListNumbers(cm, pos);
        }
      }
      cm.replaceSelections(replacements2);
    };
    function incrementRemainingMarkdownListNumbers(cm, pos) {
      var startLine = pos.line, lookAhead = 0, skipCount = 0;
      var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];
      do {
        lookAhead += 1;
        var nextLineNumber = startLine + lookAhead;
        var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);
        if (nextItem) {
          var nextIndent = nextItem[1];
          var newNumber = parseInt(startItem[3], 10) + lookAhead - skipCount;
          var nextNumber = parseInt(nextItem[3], 10), itemNumber = nextNumber;
          if (startIndent === nextIndent && !isNaN(nextNumber)) {
            if (newNumber === nextNumber)
              itemNumber = nextNumber + 1;
            if (newNumber > nextNumber)
              itemNumber = newNumber + 1;
            cm.replaceRange(nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]), {
              line: nextLineNumber,
              ch: 0
            }, {
              line: nextLineNumber,
              ch: nextLine.length
            });
          } else {
            if (startIndent.length > nextIndent.length)
              return;
            if (startIndent.length < nextIndent.length && lookAhead === 1)
              return;
            skipCount += 1;
          }
        }
      } while (nextItem);
    }
  });
})();
var CodeMirror$1 = codemirror.exports;
CodeMirror$1.commands.tabAndIndentMarkdownList = function(cm) {
  var ranges = cm.listSelections();
  var pos = ranges[0].head;
  var eolState = cm.getStateAfter(pos.line);
  var inList = eolState.list !== false;
  if (inList) {
    cm.execCommand("indentMore");
    return;
  }
  if (cm.options.indentWithTabs) {
    cm.execCommand("insertTab");
  } else {
    var spaces = Array(cm.options.tabSize + 1).join(" ");
    cm.replaceSelection(spaces);
  }
};
CodeMirror$1.commands.shiftTabAndUnindentMarkdownList = function(cm) {
  var ranges = cm.listSelections();
  var pos = ranges[0].head;
  var eolState = cm.getStateAfter(pos.line);
  var inList = eolState.list !== false;
  if (inList) {
    cm.execCommand("indentLess");
    return;
  }
  if (cm.options.indentWithTabs) {
    cm.execCommand("insertTab");
  } else {
    var spaces = Array(cm.options.tabSize + 1).join(" ");
    cm.replaceSelection(spaces);
  }
};
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("fullScreen", false, function(cm, val, old) {
      if (old == CodeMirror2.Init)
        old = false;
      if (!old == !val)
        return;
      if (val)
        setFullscreen(cm);
      else
        setNormal(cm);
    });
    function setFullscreen(cm) {
      var wrap2 = cm.getWrapperElement();
      cm.state.fullScreenRestore = {
        scrollTop: window.pageYOffset,
        scrollLeft: window.pageXOffset,
        width: wrap2.style.width,
        height: wrap2.style.height
      };
      wrap2.style.width = "";
      wrap2.style.height = "auto";
      wrap2.className += " CodeMirror-fullscreen";
      document.documentElement.style.overflow = "hidden";
      cm.refresh();
    }
    function setNormal(cm) {
      var wrap2 = cm.getWrapperElement();
      wrap2.className = wrap2.className.replace(/\s*CodeMirror-fullscreen\b/, "");
      document.documentElement.style.overflow = "";
      var info = cm.state.fullScreenRestore;
      wrap2.style.width = info.width;
      wrap2.style.height = info.height;
      window.scrollTo(info.scrollLeft, info.scrollTop);
      cm.refresh();
    }
  });
})();
var markdown = { exports: {} };
var xml = { exports: {} };
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports);
  })(function(CodeMirror2) {
    var htmlConfig = {
      autoSelfClosers: {
        "area": true,
        "base": true,
        "br": true,
        "col": true,
        "command": true,
        "embed": true,
        "frame": true,
        "hr": true,
        "img": true,
        "input": true,
        "keygen": true,
        "link": true,
        "meta": true,
        "param": true,
        "source": true,
        "track": true,
        "wbr": true,
        "menuitem": true
      },
      implicitlyClosed: {
        "dd": true,
        "li": true,
        "optgroup": true,
        "option": true,
        "p": true,
        "rp": true,
        "rt": true,
        "tbody": true,
        "td": true,
        "tfoot": true,
        "th": true,
        "tr": true
      },
      contextGrabbers: {
        "dd": { "dd": true, "dt": true },
        "dt": { "dd": true, "dt": true },
        "li": { "li": true },
        "option": { "option": true, "optgroup": true },
        "optgroup": { "optgroup": true },
        "p": {
          "address": true,
          "article": true,
          "aside": true,
          "blockquote": true,
          "dir": true,
          "div": true,
          "dl": true,
          "fieldset": true,
          "footer": true,
          "form": true,
          "h1": true,
          "h2": true,
          "h3": true,
          "h4": true,
          "h5": true,
          "h6": true,
          "header": true,
          "hgroup": true,
          "hr": true,
          "menu": true,
          "nav": true,
          "ol": true,
          "p": true,
          "pre": true,
          "section": true,
          "table": true,
          "ul": true
        },
        "rp": { "rp": true, "rt": true },
        "rt": { "rp": true, "rt": true },
        "tbody": { "tbody": true, "tfoot": true },
        "td": { "td": true, "th": true },
        "tfoot": { "tbody": true },
        "th": { "td": true, "th": true },
        "thead": { "tbody": true, "tfoot": true },
        "tr": { "tr": true }
      },
      doNotIndent: { "pre": true },
      allowUnquoted: true,
      allowMissing: true,
      caseFold: true
    };
    var xmlConfig = {
      autoSelfClosers: {},
      implicitlyClosed: {},
      contextGrabbers: {},
      doNotIndent: {},
      allowUnquoted: false,
      allowMissing: false,
      allowMissingTagName: false,
      caseFold: false
    };
    CodeMirror2.defineMode("xml", function(editorConf, config_) {
      var indentUnit = editorConf.indentUnit;
      var config2 = {};
      var defaults2 = config_.htmlMode ? htmlConfig : xmlConfig;
      for (var prop2 in defaults2)
        config2[prop2] = defaults2[prop2];
      for (var prop2 in config_)
        config2[prop2] = config_[prop2];
      var type, setStyle2;
      function inText(stream, state) {
        function chain(parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }
        var ch = stream.next();
        if (ch == "<") {
          if (stream.eat("!")) {
            if (stream.eat("[")) {
              if (stream.match("CDATA["))
                return chain(inBlock("atom", "]]>"));
              else
                return null;
            } else if (stream.match("--")) {
              return chain(inBlock("comment", "-->"));
            } else if (stream.match("DOCTYPE", true, true)) {
              stream.eatWhile(/[\w\._\-]/);
              return chain(doctype(1));
            } else {
              return null;
            }
          } else if (stream.eat("?")) {
            stream.eatWhile(/[\w\._\-]/);
            state.tokenize = inBlock("meta", "?>");
            return "meta";
          } else {
            type = stream.eat("/") ? "closeTag" : "openTag";
            state.tokenize = inTag;
            return "tag bracket";
          }
        } else if (ch == "&") {
          var ok;
          if (stream.eat("#")) {
            if (stream.eat("x")) {
              ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
            } else {
              ok = stream.eatWhile(/[\d]/) && stream.eat(";");
            }
          } else {
            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
          }
          return ok ? "atom" : "error";
        } else {
          stream.eatWhile(/[^&<]/);
          return null;
        }
      }
      inText.isInText = true;
      function inTag(stream, state) {
        var ch = stream.next();
        if (ch == ">" || ch == "/" && stream.eat(">")) {
          state.tokenize = inText;
          type = ch == ">" ? "endTag" : "selfcloseTag";
          return "tag bracket";
        } else if (ch == "=") {
          type = "equals";
          return null;
        } else if (ch == "<") {
          state.tokenize = inText;
          state.state = baseState;
          state.tagName = state.tagStart = null;
          var next = state.tokenize(stream, state);
          return next ? next + " tag error" : "tag error";
        } else if (/[\'\"]/.test(ch)) {
          state.tokenize = inAttribute(ch);
          state.stringStartCol = stream.column();
          return state.tokenize(stream, state);
        } else {
          stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
          return "word";
        }
      }
      function inAttribute(quote) {
        var closure = function(stream, state) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state.tokenize = inTag;
              break;
            }
          }
          return "string";
        };
        closure.isInAttribute = true;
        return closure;
      }
      function inBlock(style2, terminator) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = inText;
              break;
            }
            stream.next();
          }
          return style2;
        };
      }
      function doctype(depth) {
        return function(stream, state) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == "<") {
              state.tokenize = doctype(depth + 1);
              return state.tokenize(stream, state);
            } else if (ch == ">") {
              if (depth == 1) {
                state.tokenize = inText;
                break;
              } else {
                state.tokenize = doctype(depth - 1);
                return state.tokenize(stream, state);
              }
            }
          }
          return "meta";
        };
      }
      function lower2(tagName) {
        return tagName && tagName.toLowerCase();
      }
      function Context(state, tagName, startOfLine) {
        this.prev = state.context;
        this.tagName = tagName || "";
        this.indent = state.indented;
        this.startOfLine = startOfLine;
        if (config2.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)
          this.noIndent = true;
      }
      function popContext(state) {
        if (state.context)
          state.context = state.context.prev;
      }
      function maybePopContext(state, nextTagName) {
        var parentTagName;
        while (true) {
          if (!state.context) {
            return;
          }
          parentTagName = state.context.tagName;
          if (!config2.contextGrabbers.hasOwnProperty(lower2(parentTagName)) || !config2.contextGrabbers[lower2(parentTagName)].hasOwnProperty(lower2(nextTagName))) {
            return;
          }
          popContext(state);
        }
      }
      function baseState(type2, stream, state) {
        if (type2 == "openTag") {
          state.tagStart = stream.column();
          return tagNameState;
        } else if (type2 == "closeTag") {
          return closeTagNameState;
        } else {
          return baseState;
        }
      }
      function tagNameState(type2, stream, state) {
        if (type2 == "word") {
          state.tagName = stream.current();
          setStyle2 = "tag";
          return attrState;
        } else if (config2.allowMissingTagName && type2 == "endTag") {
          setStyle2 = "tag bracket";
          return attrState(type2, stream, state);
        } else {
          setStyle2 = "error";
          return tagNameState;
        }
      }
      function closeTagNameState(type2, stream, state) {
        if (type2 == "word") {
          var tagName = stream.current();
          if (state.context && state.context.tagName != tagName && config2.implicitlyClosed.hasOwnProperty(lower2(state.context.tagName)))
            popContext(state);
          if (state.context && state.context.tagName == tagName || config2.matchClosing === false) {
            setStyle2 = "tag";
            return closeState;
          } else {
            setStyle2 = "tag error";
            return closeStateErr;
          }
        } else if (config2.allowMissingTagName && type2 == "endTag") {
          setStyle2 = "tag bracket";
          return closeState(type2, stream, state);
        } else {
          setStyle2 = "error";
          return closeStateErr;
        }
      }
      function closeState(type2, _stream, state) {
        if (type2 != "endTag") {
          setStyle2 = "error";
          return closeState;
        }
        popContext(state);
        return baseState;
      }
      function closeStateErr(type2, stream, state) {
        setStyle2 = "error";
        return closeState(type2, stream, state);
      }
      function attrState(type2, _stream, state) {
        if (type2 == "word") {
          setStyle2 = "attribute";
          return attrEqState;
        } else if (type2 == "endTag" || type2 == "selfcloseTag") {
          var tagName = state.tagName, tagStart = state.tagStart;
          state.tagName = state.tagStart = null;
          if (type2 == "selfcloseTag" || config2.autoSelfClosers.hasOwnProperty(lower2(tagName))) {
            maybePopContext(state, tagName);
          } else {
            maybePopContext(state, tagName);
            state.context = new Context(state, tagName, tagStart == state.indented);
          }
          return baseState;
        }
        setStyle2 = "error";
        return attrState;
      }
      function attrEqState(type2, stream, state) {
        if (type2 == "equals")
          return attrValueState;
        if (!config2.allowMissing)
          setStyle2 = "error";
        return attrState(type2, stream, state);
      }
      function attrValueState(type2, stream, state) {
        if (type2 == "string")
          return attrContinuedState;
        if (type2 == "word" && config2.allowUnquoted) {
          setStyle2 = "string";
          return attrState;
        }
        setStyle2 = "error";
        return attrState(type2, stream, state);
      }
      function attrContinuedState(type2, stream, state) {
        if (type2 == "string")
          return attrContinuedState;
        return attrState(type2, stream, state);
      }
      return {
        startState: function(baseIndent) {
          var state = {
            tokenize: inText,
            state: baseState,
            indented: baseIndent || 0,
            tagName: null,
            tagStart: null,
            context: null
          };
          if (baseIndent != null)
            state.baseIndent = baseIndent;
          return state;
        },
        token: function(stream, state) {
          if (!state.tagName && stream.sol())
            state.indented = stream.indentation();
          if (stream.eatSpace())
            return null;
          type = null;
          var style2 = state.tokenize(stream, state);
          if ((style2 || type) && style2 != "comment") {
            setStyle2 = null;
            state.state = state.state(type || style2, stream, state);
            if (setStyle2)
              style2 = setStyle2 == "error" ? style2 + " error" : setStyle2;
          }
          return style2;
        },
        indent: function(state, textAfter, fullLine) {
          var context = state.context;
          if (state.tokenize.isInAttribute) {
            if (state.tagStart == state.indented)
              return state.stringStartCol + 1;
            else
              return state.indented + indentUnit;
          }
          if (context && context.noIndent)
            return CodeMirror2.Pass;
          if (state.tokenize != inTag && state.tokenize != inText)
            return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
          if (state.tagName) {
            if (config2.multilineTagIndentPastTag !== false)
              return state.tagStart + state.tagName.length + 2;
            else
              return state.tagStart + indentUnit * (config2.multilineTagIndentFactor || 1);
          }
          if (config2.alignCDATA && /<!\[CDATA\[/.test(textAfter))
            return 0;
          var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
          if (tagAfter && tagAfter[1]) {
            while (context) {
              if (context.tagName == tagAfter[2]) {
                context = context.prev;
                break;
              } else if (config2.implicitlyClosed.hasOwnProperty(lower2(context.tagName))) {
                context = context.prev;
              } else {
                break;
              }
            }
          } else if (tagAfter) {
            while (context) {
              var grabbers = config2.contextGrabbers[lower2(context.tagName)];
              if (grabbers && grabbers.hasOwnProperty(lower2(tagAfter[2])))
                context = context.prev;
              else
                break;
            }
          }
          while (context && context.prev && !context.startOfLine)
            context = context.prev;
          if (context)
            return context.indent + indentUnit;
          else
            return state.baseIndent || 0;
        },
        electricInput: /<\/[\s\w:]+>$/,
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",
        configuration: config2.htmlMode ? "html" : "xml",
        helperType: config2.htmlMode ? "html" : "xml",
        skipAttribute: function(state) {
          if (state.state == attrValueState)
            state.state = attrState;
        },
        xmlCurrentTag: function(state) {
          return state.tagName ? { name: state.tagName, close: state.type == "closeTag" } : null;
        },
        xmlCurrentContext: function(state) {
          var context = [];
          for (var cx = state.context; cx; cx = cx.prev)
            context.push(cx.tagName);
          return context.reverse();
        }
      };
    });
    CodeMirror2.defineMIME("text/xml", "xml");
    CodeMirror2.defineMIME("application/xml", "xml");
    if (!CodeMirror2.mimeModes.hasOwnProperty("text/html"))
      CodeMirror2.defineMIME("text/html", { name: "xml", htmlMode: true });
  });
})();
var meta = { exports: {} };
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports);
  })(function(CodeMirror2) {
    CodeMirror2.modeInfo = [
      { name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] },
      { name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"] },
      { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] },
      { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i },
      { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] },
      { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"] },
      { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] },
      { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy", "cbl"] },
      { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"] },
      { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] },
      { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] },
      { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] },
      { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/ },
      { name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] },
      { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] },
      { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] },
      { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] },
      { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] },
      { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] },
      { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] },
      { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] },
      { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] },
      { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] },
      { name: "Django", mime: "text/x-django", mode: "django" },
      { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ },
      { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] },
      { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] },
      { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" },
      { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] },
      { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] },
      { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] },
      { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] },
      { name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] },
      { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] },
      { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] },
      { name: "Esper", mime: "text/x-esper", mode: "sql" },
      { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] },
      { name: "FCL", mime: "text/x-fcl", mode: "fcl" },
      { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] },
      { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"] },
      { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] },
      { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] },
      { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] },
      { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i },
      { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] },
      { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/ },
      { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] },
      { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] },
      { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] },
      { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] },
      { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] },
      { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] },
      { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"] },
      { name: "HTTP", mime: "message/http", mode: "http" },
      { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] },
      { name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"] },
      { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] },
      { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] },
      {
        name: "JavaScript",
        mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
        mode: "javascript",
        ext: ["js"],
        alias: ["ecmascript", "js", "node"]
      },
      { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] },
      { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] },
      { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] },
      { name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"] },
      { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"], alias: ["jl"] },
      { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] },
      { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] },
      { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] },
      { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] },
      { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] },
      { name: "mIRC", mime: "text/mirc", mode: "mirc" },
      { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" },
      { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"] },
      { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] },
      { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] },
      { name: "MS SQL", mime: "text/x-mssql", mode: "sql" },
      { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] },
      { name: "MySQL", mime: "text/x-mysql", mode: "sql" },
      { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i },
      { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] },
      {
        name: "NTriples",
        mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
        mode: "ntriples",
        ext: ["nt", "nq"]
      },
      { name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"] },
      { name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"] },
      { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] },
      { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] },
      { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] },
      { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] },
      { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] },
      { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] },
      { name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"] },
      { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] },
      { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] },
      { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] },
      { name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql" },
      { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] },
      { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] },
      { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] },
      { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ },
      { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] },
      { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] },
      { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"] },
      { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] },
      { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" },
      { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] },
      { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] },
      { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] },
      { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] },
      { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] },
      { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] },
      { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] },
      { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] },
      { name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ },
      { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] },
      { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] },
      { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] },
      { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] },
      { name: "Solr", mime: "text/x-solr", mode: "solr" },
      { name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"] },
      { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] },
      { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] },
      { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] },
      { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] },
      { name: "SQLite", mime: "text/x-sqlite", mode: "sql" },
      { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] },
      { name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"] },
      { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] },
      { name: "sTeX", mime: "text/x-stex", mode: "stex" },
      { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"] },
      { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"] },
      { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] },
      { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] },
      { name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki" },
      { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" },
      { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] },
      { name: "Tornado", mime: "text/x-tornado", mode: "tornado" },
      { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] },
      { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] },
      { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] },
      { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] },
      { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] },
      { name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"] },
      { name: "Twig", mime: "text/x-twig", mode: "twig" },
      { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] },
      { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] },
      { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] },
      { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] },
      { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] },
      { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] },
      { name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"] },
      { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"] },
      { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] },
      { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] },
      { name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] },
      { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] },
      { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] },
      { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] },
      { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] },
      { name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"] }
    ];
    for (var i2 = 0; i2 < CodeMirror2.modeInfo.length; i2++) {
      var info = CodeMirror2.modeInfo[i2];
      if (info.mimes)
        info.mime = info.mimes[0];
    }
    CodeMirror2.findModeByMIME = function(mime) {
      mime = mime.toLowerCase();
      for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
        var info2 = CodeMirror2.modeInfo[i3];
        if (info2.mime == mime)
          return info2;
        if (info2.mimes) {
          for (var j2 = 0; j2 < info2.mimes.length; j2++)
            if (info2.mimes[j2] == mime)
              return info2;
        }
      }
      if (/\+xml$/.test(mime))
        return CodeMirror2.findModeByMIME("application/xml");
      if (/\+json$/.test(mime))
        return CodeMirror2.findModeByMIME("application/json");
    };
    CodeMirror2.findModeByExtension = function(ext) {
      ext = ext.toLowerCase();
      for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
        var info2 = CodeMirror2.modeInfo[i3];
        if (info2.ext) {
          for (var j2 = 0; j2 < info2.ext.length; j2++)
            if (info2.ext[j2] == ext)
              return info2;
        }
      }
    };
    CodeMirror2.findModeByFileName = function(filename) {
      for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
        var info2 = CodeMirror2.modeInfo[i3];
        if (info2.file && info2.file.test(filename))
          return info2;
      }
      var dot2 = filename.lastIndexOf(".");
      var ext = dot2 > -1 && filename.substring(dot2 + 1, filename.length);
      if (ext)
        return CodeMirror2.findModeByExtension(ext);
    };
    CodeMirror2.findModeByName = function(name) {
      name = name.toLowerCase();
      for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
        var info2 = CodeMirror2.modeInfo[i3];
        if (info2.name.toLowerCase() == name)
          return info2;
        if (info2.alias) {
          for (var j2 = 0; j2 < info2.alias.length; j2++)
            if (info2.alias[j2].toLowerCase() == name)
              return info2;
        }
      }
    };
  });
})();
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports, xml.exports, meta.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineMode("markdown", function(cmCfg, modeCfg) {
      var htmlMode = CodeMirror2.getMode(cmCfg, "text/html");
      var htmlModeMissing = htmlMode.name == "null";
      function getMode(name) {
        if (CodeMirror2.findModeByName) {
          var found = CodeMirror2.findModeByName(name);
          if (found)
            name = found.mime || found.mimes[0];
        }
        var mode2 = CodeMirror2.getMode(cmCfg, name);
        return mode2.name == "null" ? null : mode2;
      }
      if (modeCfg.highlightFormatting === void 0)
        modeCfg.highlightFormatting = false;
      if (modeCfg.maxBlockquoteDepth === void 0)
        modeCfg.maxBlockquoteDepth = 0;
      if (modeCfg.taskLists === void 0)
        modeCfg.taskLists = false;
      if (modeCfg.strikethrough === void 0)
        modeCfg.strikethrough = false;
      if (modeCfg.emoji === void 0)
        modeCfg.emoji = false;
      if (modeCfg.fencedCodeBlockHighlighting === void 0)
        modeCfg.fencedCodeBlockHighlighting = true;
      if (modeCfg.fencedCodeBlockDefaultMode === void 0)
        modeCfg.fencedCodeBlockDefaultMode = "text/plain";
      if (modeCfg.xml === void 0)
        modeCfg.xml = true;
      if (modeCfg.tokenTypeOverrides === void 0)
        modeCfg.tokenTypeOverrides = {};
      var tokenTypes = {
        header: "header",
        code: "comment",
        quote: "quote",
        list1: "variable-2",
        list2: "variable-3",
        list3: "keyword",
        hr: "hr",
        image: "image",
        imageAltText: "image-alt-text",
        imageMarker: "image-marker",
        formatting: "formatting",
        linkInline: "link",
        linkEmail: "link",
        linkText: "link",
        linkHref: "string",
        em: "em",
        strong: "strong",
        strikethrough: "strikethrough",
        emoji: "builtin"
      };
      for (var tokenType2 in tokenTypes) {
        if (tokenTypes.hasOwnProperty(tokenType2) && modeCfg.tokenTypeOverrides[tokenType2]) {
          tokenTypes[tokenType2] = modeCfg.tokenTypeOverrides[tokenType2];
        }
      }
      var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/, listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, taskListRE = /^\[(x| )\](?=\s)/i, atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/, textRE = /^[^#!\[\]*_\\<>` "'(~:]+/, fencedCodeRE = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, linkDefRE = /^\s*\[[^\]]+?\]:.*$/, punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/, expandedTab = "    ";
      function switchInline(stream, state, f2) {
        state.f = state.inline = f2;
        return f2(stream, state);
      }
      function switchBlock(stream, state, f2) {
        state.f = state.block = f2;
        return f2(stream, state);
      }
      function lineIsEmpty(line2) {
        return !line2 || !/\S/.test(line2.string);
      }
      function blankLine(state) {
        state.linkTitle = false;
        state.linkHref = false;
        state.linkText = false;
        state.em = false;
        state.strong = false;
        state.strikethrough = false;
        state.quote = 0;
        state.indentedCode = false;
        if (state.f == htmlBlock) {
          var exit = htmlModeMissing;
          if (!exit) {
            var inner = CodeMirror2.innerMode(htmlMode, state.htmlState);
            exit = inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText);
          }
          if (exit) {
            state.f = inlineNormal;
            state.block = blockNormal;
            state.htmlState = null;
          }
        }
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;
        state.prevLine = state.thisLine;
        state.thisLine = { stream: null };
        return null;
      }
      function blockNormal(stream, state) {
        var firstTokenOnLine = stream.column() === state.indentation;
        var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
        var prevLineIsIndentedCode = state.indentedCode;
        var prevLineIsHr = state.prevLine.hr;
        var prevLineIsList = state.list !== false;
        var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;
        state.indentedCode = false;
        var lineIndentation = state.indentation;
        if (state.indentationDiff === null) {
          state.indentationDiff = state.indentation;
          if (prevLineIsList) {
            state.list = null;
            while (lineIndentation < state.listStack[state.listStack.length - 1]) {
              state.listStack.pop();
              if (state.listStack.length) {
                state.indentation = state.listStack[state.listStack.length - 1];
              } else {
                state.list = false;
              }
            }
            if (state.list !== false) {
              state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];
            }
          }
        }
        var allowsInlineContinuation = !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header && (!prevLineIsList || !prevLineIsIndentedCode) && !state.prevLine.fencedCodeEnd;
        var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) && state.indentation <= maxNonCodeIndentation && stream.match(hrRE);
        var match5 = null;
        if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd || state.prevLine.header || prevLineLineIsEmpty)) {
          stream.skipToEnd();
          state.indentedCode = true;
          return tokenTypes.code;
        } else if (stream.eatSpace()) {
          return null;
        } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match5 = stream.match(atxHeaderRE)) && match5[1].length <= 6) {
          state.quote = 0;
          state.header = match5[1].length;
          state.thisLine.header = true;
          if (modeCfg.highlightFormatting)
            state.formatting = "header";
          state.f = state.inline;
          return getType2(state);
        } else if (state.indentation <= maxNonCodeIndentation && stream.eat(">")) {
          state.quote = firstTokenOnLine ? 1 : state.quote + 1;
          if (modeCfg.highlightFormatting)
            state.formatting = "quote";
          stream.eatSpace();
          return getType2(state);
        } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match5 = stream.match(listRE))) {
          var listType = match5[1] ? "ol" : "ul";
          state.indentation = lineIndentation + stream.current().length;
          state.list = true;
          state.quote = 0;
          state.listStack.push(state.indentation);
          state.em = false;
          state.strong = false;
          state.code = false;
          state.strikethrough = false;
          if (modeCfg.taskLists && stream.match(taskListRE, false)) {
            state.taskList = true;
          }
          state.f = state.inline;
          if (modeCfg.highlightFormatting)
            state.formatting = ["list", "list-" + listType];
          return getType2(state);
        } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match5 = stream.match(fencedCodeRE, true))) {
          state.quote = 0;
          state.fencedEndRE = new RegExp(match5[1] + "+ *$");
          state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match5[2] || modeCfg.fencedCodeBlockDefaultMode);
          if (state.localMode)
            state.localState = CodeMirror2.startState(state.localMode);
          state.f = state.block = local;
          if (modeCfg.highlightFormatting)
            state.formatting = "code-block";
          state.code = -1;
          return getType2(state);
        } else if (state.setext || (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false && !state.code && !isHr && !linkDefRE.test(stream.string) && (match5 = stream.lookAhead(1)) && (match5 = match5.match(setextHeaderRE))) {
          if (!state.setext) {
            state.header = match5[0].charAt(0) == "=" ? 1 : 2;
            state.setext = state.header;
          } else {
            state.header = state.setext;
            state.setext = 0;
            stream.skipToEnd();
            if (modeCfg.highlightFormatting)
              state.formatting = "header";
          }
          state.thisLine.header = true;
          state.f = state.inline;
          return getType2(state);
        } else if (isHr) {
          stream.skipToEnd();
          state.hr = true;
          state.thisLine.hr = true;
          return tokenTypes.hr;
        } else if (stream.peek() === "[") {
          return switchInline(stream, state, footnoteLink);
        }
        return switchInline(stream, state, state.inline);
      }
      function htmlBlock(stream, state) {
        var style2 = htmlMode.token(stream, state.htmlState);
        if (!htmlModeMissing) {
          var inner = CodeMirror2.innerMode(htmlMode, state.htmlState);
          if (inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText) || state.md_inside && stream.current().indexOf(">") > -1) {
            state.f = inlineNormal;
            state.block = blockNormal;
            state.htmlState = null;
          }
        }
        return style2;
      }
      function local(stream, state) {
        var currListInd = state.listStack[state.listStack.length - 1] || 0;
        var hasExitedList = state.indentation < currListInd;
        var maxFencedEndInd = currListInd + 3;
        if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
          if (modeCfg.highlightFormatting)
            state.formatting = "code-block";
          var returnType;
          if (!hasExitedList)
            returnType = getType2(state);
          state.localMode = state.localState = null;
          state.block = blockNormal;
          state.f = inlineNormal;
          state.fencedEndRE = null;
          state.code = 0;
          state.thisLine.fencedCodeEnd = true;
          if (hasExitedList)
            return switchBlock(stream, state, state.block);
          return returnType;
        } else if (state.localMode) {
          return state.localMode.token(stream, state.localState);
        } else {
          stream.skipToEnd();
          return tokenTypes.code;
        }
      }
      function getType2(state) {
        var styles = [];
        if (state.formatting) {
          styles.push(tokenTypes.formatting);
          if (typeof state.formatting === "string")
            state.formatting = [state.formatting];
          for (var i2 = 0; i2 < state.formatting.length; i2++) {
            styles.push(tokenTypes.formatting + "-" + state.formatting[i2]);
            if (state.formatting[i2] === "header") {
              styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.header);
            }
            if (state.formatting[i2] === "quote") {
              if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.quote);
              } else {
                styles.push("error");
              }
            }
          }
        }
        if (state.taskOpen) {
          styles.push("meta");
          return styles.length ? styles.join(" ") : null;
        }
        if (state.taskClosed) {
          styles.push("property");
          return styles.length ? styles.join(" ") : null;
        }
        if (state.linkHref) {
          styles.push(tokenTypes.linkHref, "url");
        } else {
          if (state.strong) {
            styles.push(tokenTypes.strong);
          }
          if (state.em) {
            styles.push(tokenTypes.em);
          }
          if (state.strikethrough) {
            styles.push(tokenTypes.strikethrough);
          }
          if (state.emoji) {
            styles.push(tokenTypes.emoji);
          }
          if (state.linkText) {
            styles.push(tokenTypes.linkText);
          }
          if (state.code) {
            styles.push(tokenTypes.code);
          }
          if (state.image) {
            styles.push(tokenTypes.image);
          }
          if (state.imageAltText) {
            styles.push(tokenTypes.imageAltText, "link");
          }
          if (state.imageMarker) {
            styles.push(tokenTypes.imageMarker);
          }
        }
        if (state.header) {
          styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header);
        }
        if (state.quote) {
          styles.push(tokenTypes.quote);
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
            styles.push(tokenTypes.quote + "-" + state.quote);
          } else {
            styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
          }
        }
        if (state.list !== false) {
          var listMod = (state.listStack.length - 1) % 3;
          if (!listMod) {
            styles.push(tokenTypes.list1);
          } else if (listMod === 1) {
            styles.push(tokenTypes.list2);
          } else {
            styles.push(tokenTypes.list3);
          }
        }
        if (state.trailingSpaceNewLine) {
          styles.push("trailing-space-new-line");
        } else if (state.trailingSpace) {
          styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
        }
        return styles.length ? styles.join(" ") : null;
      }
      function handleText(stream, state) {
        if (stream.match(textRE, true)) {
          return getType2(state);
        }
        return void 0;
      }
      function inlineNormal(stream, state) {
        var style2 = state.text(stream, state);
        if (typeof style2 !== "undefined")
          return style2;
        if (state.list) {
          state.list = null;
          return getType2(state);
        }
        if (state.taskList) {
          var taskOpen = stream.match(taskListRE, true)[1] === " ";
          if (taskOpen)
            state.taskOpen = true;
          else
            state.taskClosed = true;
          if (modeCfg.highlightFormatting)
            state.formatting = "task";
          state.taskList = false;
          return getType2(state);
        }
        state.taskOpen = false;
        state.taskClosed = false;
        if (state.header && stream.match(/^#+$/, true)) {
          if (modeCfg.highlightFormatting)
            state.formatting = "header";
          return getType2(state);
        }
        var ch = stream.next();
        if (state.linkTitle) {
          state.linkTitle = false;
          var matchCh = ch;
          if (ch === "(") {
            matchCh = ")";
          }
          matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
          var regex2 = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
          if (stream.match(new RegExp(regex2), true)) {
            return tokenTypes.linkHref;
          }
        }
        if (ch === "`") {
          var previousFormatting = state.formatting;
          if (modeCfg.highlightFormatting)
            state.formatting = "code";
          stream.eatWhile("`");
          var count2 = stream.current().length;
          if (state.code == 0 && (!state.quote || count2 == 1)) {
            state.code = count2;
            return getType2(state);
          } else if (count2 == state.code) {
            var t2 = getType2(state);
            state.code = 0;
            return t2;
          } else {
            state.formatting = previousFormatting;
            return getType2(state);
          }
        } else if (state.code) {
          return getType2(state);
        }
        if (ch === "\\") {
          stream.next();
          if (modeCfg.highlightFormatting) {
            var type = getType2(state);
            var formattingEscape = tokenTypes.formatting + "-escape";
            return type ? type + " " + formattingEscape : formattingEscape;
          }
        }
        if (ch === "!" && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
          state.imageMarker = true;
          state.image = true;
          if (modeCfg.highlightFormatting)
            state.formatting = "image";
          return getType2(state);
        }
        if (ch === "[" && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
          state.imageMarker = false;
          state.imageAltText = true;
          if (modeCfg.highlightFormatting)
            state.formatting = "image";
          return getType2(state);
        }
        if (ch === "]" && state.imageAltText) {
          if (modeCfg.highlightFormatting)
            state.formatting = "image";
          var type = getType2(state);
          state.imageAltText = false;
          state.image = false;
          state.inline = state.f = linkHref;
          return type;
        }
        if (ch === "[" && !state.image) {
          if (state.linkText && stream.match(/^.*?\]/))
            return getType2(state);
          state.linkText = true;
          if (modeCfg.highlightFormatting)
            state.formatting = "link";
          return getType2(state);
        }
        if (ch === "]" && state.linkText) {
          if (modeCfg.highlightFormatting)
            state.formatting = "link";
          var type = getType2(state);
          state.linkText = false;
          state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal;
          return type;
        }
        if (ch === "<" && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
          state.f = state.inline = linkInline;
          if (modeCfg.highlightFormatting)
            state.formatting = "link";
          var type = getType2(state);
          if (type) {
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkInline;
        }
        if (ch === "<" && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
          state.f = state.inline = linkInline;
          if (modeCfg.highlightFormatting)
            state.formatting = "link";
          var type = getType2(state);
          if (type) {
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkEmail;
        }
        if (modeCfg.xml && ch === "<" && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
          var end = stream.string.indexOf(">", stream.pos);
          if (end != -1) {
            var atts = stream.string.substring(stream.start, end);
            if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts))
              state.md_inside = true;
          }
          stream.backUp(1);
          state.htmlState = CodeMirror2.startState(htmlMode);
          return switchBlock(stream, state, htmlBlock);
        }
        if (modeCfg.xml && ch === "<" && stream.match(/^\/\w*?>/)) {
          state.md_inside = false;
          return "tag";
        } else if (ch === "*" || ch === "_") {
          var len2 = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);
          while (len2 < 3 && stream.eat(ch))
            len2++;
          var after = stream.peek() || " ";
          var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before));
          var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after));
          var setEm = null, setStrong = null;
          if (len2 % 2) {
            if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
              setEm = true;
            else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
              setEm = false;
          }
          if (len2 > 1) {
            if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
              setStrong = true;
            else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
              setStrong = false;
          }
          if (setStrong != null || setEm != null) {
            if (modeCfg.highlightFormatting)
              state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
            if (setEm === true)
              state.em = ch;
            if (setStrong === true)
              state.strong = ch;
            var t2 = getType2(state);
            if (setEm === false)
              state.em = false;
            if (setStrong === false)
              state.strong = false;
            return t2;
          }
        } else if (ch === " ") {
          if (stream.eat("*") || stream.eat("_")) {
            if (stream.peek() === " ") {
              return getType2(state);
            } else {
              stream.backUp(1);
            }
          }
        }
        if (modeCfg.strikethrough) {
          if (ch === "~" && stream.eatWhile(ch)) {
            if (state.strikethrough) {
              if (modeCfg.highlightFormatting)
                state.formatting = "strikethrough";
              var t2 = getType2(state);
              state.strikethrough = false;
              return t2;
            } else if (stream.match(/^[^\s]/, false)) {
              state.strikethrough = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "strikethrough";
              return getType2(state);
            }
          } else if (ch === " ") {
            if (stream.match("~~", true)) {
              if (stream.peek() === " ") {
                return getType2(state);
              } else {
                stream.backUp(2);
              }
            }
          }
        }
        if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
          state.emoji = true;
          if (modeCfg.highlightFormatting)
            state.formatting = "emoji";
          var retType = getType2(state);
          state.emoji = false;
          return retType;
        }
        if (ch === " ") {
          if (stream.match(/^ +$/, false)) {
            state.trailingSpace++;
          } else if (state.trailingSpace) {
            state.trailingSpaceNewLine = true;
          }
        }
        return getType2(state);
      }
      function linkInline(stream, state) {
        var ch = stream.next();
        if (ch === ">") {
          state.f = state.inline = inlineNormal;
          if (modeCfg.highlightFormatting)
            state.formatting = "link";
          var type = getType2(state);
          if (type) {
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkInline;
        }
        stream.match(/^[^>]+/, true);
        return tokenTypes.linkInline;
      }
      function linkHref(stream, state) {
        if (stream.eatSpace()) {
          return null;
        }
        var ch = stream.next();
        if (ch === "(" || ch === "[") {
          state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
          if (modeCfg.highlightFormatting)
            state.formatting = "link-string";
          state.linkHref = true;
          return getType2(state);
        }
        return "error";
      }
      var linkRE = {
        ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
        "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
      };
      function getLinkHrefInside(endChar) {
        return function(stream, state) {
          var ch = stream.next();
          if (ch === endChar) {
            state.f = state.inline = inlineNormal;
            if (modeCfg.highlightFormatting)
              state.formatting = "link-string";
            var returnState = getType2(state);
            state.linkHref = false;
            return returnState;
          }
          stream.match(linkRE[endChar]);
          state.linkHref = true;
          return getType2(state);
        };
      }
      function footnoteLink(stream, state) {
        if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
          state.f = footnoteLinkInside;
          stream.next();
          if (modeCfg.highlightFormatting)
            state.formatting = "link";
          state.linkText = true;
          return getType2(state);
        }
        return switchInline(stream, state, inlineNormal);
      }
      function footnoteLinkInside(stream, state) {
        if (stream.match("]:", true)) {
          state.f = state.inline = footnoteUrl;
          if (modeCfg.highlightFormatting)
            state.formatting = "link";
          var returnType = getType2(state);
          state.linkText = false;
          return returnType;
        }
        stream.match(/^([^\]\\]|\\.)+/, true);
        return tokenTypes.linkText;
      }
      function footnoteUrl(stream, state) {
        if (stream.eatSpace()) {
          return null;
        }
        stream.match(/^[^\s]+/, true);
        if (stream.peek() === void 0) {
          state.linkTitle = true;
        } else {
          stream.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, true);
        }
        state.f = state.inline = inlineNormal;
        return tokenTypes.linkHref + " url";
      }
      var mode = {
        startState: function() {
          return {
            f: blockNormal,
            prevLine: { stream: null },
            thisLine: { stream: null },
            block: blockNormal,
            htmlState: null,
            indentation: 0,
            inline: inlineNormal,
            text: handleText,
            formatting: false,
            linkText: false,
            linkHref: false,
            linkTitle: false,
            code: 0,
            em: false,
            strong: false,
            header: 0,
            setext: 0,
            hr: false,
            taskList: false,
            list: false,
            listStack: [],
            quote: 0,
            trailingSpace: 0,
            trailingSpaceNewLine: false,
            strikethrough: false,
            emoji: false,
            fencedEndRE: null
          };
        },
        copyState: function(s2) {
          return {
            f: s2.f,
            prevLine: s2.prevLine,
            thisLine: s2.thisLine,
            block: s2.block,
            htmlState: s2.htmlState && CodeMirror2.copyState(htmlMode, s2.htmlState),
            indentation: s2.indentation,
            localMode: s2.localMode,
            localState: s2.localMode ? CodeMirror2.copyState(s2.localMode, s2.localState) : null,
            inline: s2.inline,
            text: s2.text,
            formatting: false,
            linkText: s2.linkText,
            linkTitle: s2.linkTitle,
            linkHref: s2.linkHref,
            code: s2.code,
            em: s2.em,
            strong: s2.strong,
            strikethrough: s2.strikethrough,
            emoji: s2.emoji,
            header: s2.header,
            setext: s2.setext,
            hr: s2.hr,
            taskList: s2.taskList,
            list: s2.list,
            listStack: s2.listStack.slice(0),
            quote: s2.quote,
            indentedCode: s2.indentedCode,
            trailingSpace: s2.trailingSpace,
            trailingSpaceNewLine: s2.trailingSpaceNewLine,
            md_inside: s2.md_inside,
            fencedEndRE: s2.fencedEndRE
          };
        },
        token: function(stream, state) {
          state.formatting = false;
          if (stream != state.thisLine.stream) {
            state.header = 0;
            state.hr = false;
            if (stream.match(/^\s*$/, true)) {
              blankLine(state);
              return null;
            }
            state.prevLine = state.thisLine;
            state.thisLine = { stream };
            state.taskList = false;
            state.trailingSpace = 0;
            state.trailingSpaceNewLine = false;
            if (!state.localState) {
              state.f = state.block;
              if (state.f != htmlBlock) {
                var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                state.indentation = indentation;
                state.indentationDiff = null;
                if (indentation > 0)
                  return null;
              }
            }
          }
          return state.f(stream, state);
        },
        innerMode: function(state) {
          if (state.block == htmlBlock)
            return { state: state.htmlState, mode: htmlMode };
          if (state.localState)
            return { state: state.localState, mode: state.localMode };
          return { state, mode };
        },
        indent: function(state, textAfter, line2) {
          if (state.block == htmlBlock && htmlMode.indent)
            return htmlMode.indent(state.htmlState, textAfter, line2);
          if (state.localState && state.localMode.indent)
            return state.localMode.indent(state.localState, textAfter, line2);
          return CodeMirror2.Pass;
        },
        blankLine,
        getType: getType2,
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",
        closeBrackets: "()[]{}''\"\"``",
        fold: "markdown"
      };
      return mode;
    }, "xml");
    CodeMirror2.defineMIME("text/markdown", "markdown");
    CodeMirror2.defineMIME("text/x-markdown", "markdown");
  });
})();
var overlay = { exports: {} };
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports);
  })(function(CodeMirror2) {
    CodeMirror2.overlayMode = function(base2, overlay2, combine) {
      return {
        startState: function() {
          return {
            base: CodeMirror2.startState(base2),
            overlay: CodeMirror2.startState(overlay2),
            basePos: 0,
            baseCur: null,
            overlayPos: 0,
            overlayCur: null,
            streamSeen: null
          };
        },
        copyState: function(state) {
          return {
            base: CodeMirror2.copyState(base2, state.base),
            overlay: CodeMirror2.copyState(overlay2, state.overlay),
            basePos: state.basePos,
            baseCur: null,
            overlayPos: state.overlayPos,
            overlayCur: null
          };
        },
        token: function(stream, state) {
          if (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) {
            state.streamSeen = stream;
            state.basePos = state.overlayPos = stream.start;
          }
          if (stream.start == state.basePos) {
            state.baseCur = base2.token(stream, state.base);
            state.basePos = stream.pos;
          }
          if (stream.start == state.overlayPos) {
            stream.pos = stream.start;
            state.overlayCur = overlay2.token(stream, state.overlay);
            state.overlayPos = stream.pos;
          }
          stream.pos = Math.min(state.basePos, state.overlayPos);
          if (state.overlayCur == null)
            return state.baseCur;
          else if (state.baseCur != null && state.overlay.combineTokens || combine && state.overlay.combineTokens == null)
            return state.baseCur + " " + state.overlayCur;
          else
            return state.overlayCur;
        },
        indent: base2.indent && function(state, textAfter, line2) {
          return base2.indent(state.base, textAfter, line2);
        },
        electricChars: base2.electricChars,
        innerMode: function(state) {
          return { state: state.base, mode: base2 };
        },
        blankLine: function(state) {
          var baseToken, overlayToken;
          if (base2.blankLine)
            baseToken = base2.blankLine(state.base);
          if (overlay2.blankLine)
            overlayToken = overlay2.blankLine(state.overlay);
          return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken;
        }
      };
    };
  });
})();
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("placeholder", "", function(cm, val, old) {
      var prev = old && old != CodeMirror2.Init;
      if (val && !prev) {
        cm.on("blur", onBlur);
        cm.on("change", onChange15);
        cm.on("swapDoc", onChange15);
        CodeMirror2.on(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose = function() {
          onComposition(cm);
        });
        onChange15(cm);
      } else if (!val && prev) {
        cm.off("blur", onBlur);
        cm.off("change", onChange15);
        cm.off("swapDoc", onChange15);
        CodeMirror2.off(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose);
        clearPlaceholder(cm);
        var wrapper = cm.getWrapperElement();
        wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
      }
      if (val && !cm.hasFocus())
        onBlur(cm);
    });
    function clearPlaceholder(cm) {
      if (cm.state.placeholder) {
        cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
        cm.state.placeholder = null;
      }
    }
    function setPlaceholder(cm) {
      clearPlaceholder(cm);
      var elt = cm.state.placeholder = document.createElement("pre");
      elt.style.cssText = "height: 0; overflow: visible";
      elt.style.direction = cm.getOption("direction");
      elt.className = "CodeMirror-placeholder CodeMirror-line-like";
      var placeHolder = cm.getOption("placeholder");
      if (typeof placeHolder == "string")
        placeHolder = document.createTextNode(placeHolder);
      elt.appendChild(placeHolder);
      cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
    }
    function onComposition(cm) {
      setTimeout(function() {
        var empty2 = false;
        if (cm.lineCount() == 1) {
          var input = cm.getInputField();
          empty2 = input.nodeName == "TEXTAREA" ? !cm.getLine(0).length : !/[^\u200b]/.test(input.querySelector(".CodeMirror-line").textContent);
        }
        if (empty2)
          setPlaceholder(cm);
        else
          clearPlaceholder(cm);
      }, 20);
    }
    function onBlur(cm) {
      if (isEmpty3(cm))
        setPlaceholder(cm);
    }
    function onChange15(cm) {
      var wrapper = cm.getWrapperElement(), empty2 = isEmpty3(cm);
      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty2 ? " CodeMirror-empty" : "");
      if (empty2)
        setPlaceholder(cm);
      else
        clearPlaceholder(cm);
    }
    function isEmpty3(cm) {
      return cm.lineCount() === 1 && cm.getLine(0) === "";
    }
  });
})();
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("styleSelectedText", false, function(cm, val, old) {
      var prev = old && old != CodeMirror2.Init;
      if (val && !prev) {
        cm.state.markedSelection = [];
        cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
        reset2(cm);
        cm.on("cursorActivity", onCursorActivity);
        cm.on("change", onChange15);
      } else if (!val && prev) {
        cm.off("cursorActivity", onCursorActivity);
        cm.off("change", onChange15);
        clear2(cm);
        cm.state.markedSelection = cm.state.markedSelectionStyle = null;
      }
    });
    function onCursorActivity(cm) {
      if (cm.state.markedSelection)
        cm.operation(function() {
          update3(cm);
        });
    }
    function onChange15(cm) {
      if (cm.state.markedSelection && cm.state.markedSelection.length)
        cm.operation(function() {
          clear2(cm);
        });
    }
    var CHUNK_SIZE = 8;
    var Pos = CodeMirror2.Pos;
    var cmp = CodeMirror2.cmpPos;
    function coverRange(cm, from2, to2, addAt) {
      if (cmp(from2, to2) == 0)
        return;
      var array2 = cm.state.markedSelection;
      var cls = cm.state.markedSelectionStyle;
      for (var line2 = from2.line; ; ) {
        var start2 = line2 == from2.line ? from2 : Pos(line2, 0);
        var endLine = line2 + CHUNK_SIZE, atEnd = endLine >= to2.line;
        var end = atEnd ? to2 : Pos(endLine, 0);
        var mark = cm.markText(start2, end, { className: cls });
        if (addAt == null)
          array2.push(mark);
        else
          array2.splice(addAt++, 0, mark);
        if (atEnd)
          break;
        line2 = endLine;
      }
    }
    function clear2(cm) {
      var array2 = cm.state.markedSelection;
      for (var i2 = 0; i2 < array2.length; ++i2)
        array2[i2].clear();
      array2.length = 0;
    }
    function reset2(cm) {
      clear2(cm);
      var ranges = cm.listSelections();
      for (var i2 = 0; i2 < ranges.length; i2++)
        coverRange(cm, ranges[i2].from(), ranges[i2].to());
    }
    function update3(cm) {
      if (!cm.somethingSelected())
        return clear2(cm);
      if (cm.listSelections().length > 1)
        return reset2(cm);
      var from2 = cm.getCursor("start"), to2 = cm.getCursor("end");
      var array2 = cm.state.markedSelection;
      if (!array2.length)
        return coverRange(cm, from2, to2);
      var coverStart = array2[0].find(), coverEnd = array2[array2.length - 1].find();
      if (!coverStart || !coverEnd || to2.line - from2.line <= CHUNK_SIZE || cmp(from2, coverEnd.to) >= 0 || cmp(to2, coverStart.from) <= 0)
        return reset2(cm);
      while (cmp(from2, coverStart.from) > 0) {
        array2.shift().clear();
        coverStart = array2[0].find();
      }
      if (cmp(from2, coverStart.from) < 0) {
        if (coverStart.to.line - from2.line < CHUNK_SIZE) {
          array2.shift().clear();
          coverRange(cm, from2, coverStart.to, 0);
        } else {
          coverRange(cm, from2, coverStart.from, 0);
        }
      }
      while (cmp(to2, coverEnd.to) < 0) {
        array2.pop().clear();
        coverEnd = array2[array2.length - 1].find();
      }
      if (cmp(to2, coverEnd.to) > 0) {
        if (to2.line - coverEnd.from.line < CHUNK_SIZE) {
          array2.pop().clear();
          coverRange(cm, coverEnd.from, to2);
        } else {
          coverRange(cm, coverEnd.to, to2);
        }
      }
    }
  });
})();
(function(module2, exports2) {
  (function(mod2) {
    mod2(codemirror.exports, markdown.exports, overlay.exports);
  })(function(CodeMirror2) {
    var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i;
    CodeMirror2.defineMode("gfm", function(config2, modeConfig) {
      var codeDepth = 0;
      function blankLine(state) {
        state.code = false;
        return null;
      }
      var gfmOverlay = {
        startState: function() {
          return {
            code: false,
            codeBlock: false,
            ateSpace: false
          };
        },
        copyState: function(s2) {
          return {
            code: s2.code,
            codeBlock: s2.codeBlock,
            ateSpace: s2.ateSpace
          };
        },
        token: function(stream, state) {
          state.combineTokens = null;
          if (state.codeBlock) {
            if (stream.match(/^```+/)) {
              state.codeBlock = false;
              return null;
            }
            stream.skipToEnd();
            return null;
          }
          if (stream.sol()) {
            state.code = false;
          }
          if (stream.sol() && stream.match(/^```+/)) {
            stream.skipToEnd();
            state.codeBlock = true;
            return null;
          }
          if (stream.peek() === "`") {
            stream.next();
            var before = stream.pos;
            stream.eatWhile("`");
            var difference = 1 + stream.pos - before;
            if (!state.code) {
              codeDepth = difference;
              state.code = true;
            } else {
              if (difference === codeDepth) {
                state.code = false;
              }
            }
            return null;
          } else if (state.code) {
            stream.next();
            return null;
          }
          if (stream.eatSpace()) {
            state.ateSpace = true;
            return null;
          }
          if (stream.sol() || state.ateSpace) {
            state.ateSpace = false;
            if (modeConfig.gitHubSpice !== false) {
              if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
                state.combineTokens = true;
                return "link";
              } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
                state.combineTokens = true;
                return "link";
              }
            }
          }
          if (stream.match(urlRE) && stream.string.slice(stream.start - 2, stream.start) != "](" && (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
            state.combineTokens = true;
            return "link";
          }
          stream.next();
          return null;
        },
        blankLine
      };
      var markdownConfig = {
        taskLists: true,
        strikethrough: true,
        emoji: true
      };
      for (var attr in modeConfig) {
        markdownConfig[attr] = modeConfig[attr];
      }
      markdownConfig.name = "markdown";
      return CodeMirror2.overlayMode(CodeMirror2.getMode(config2, markdownConfig), gfmOverlay);
    }, "markdown");
    CodeMirror2.defineMIME("text/x-gfm", "gfm");
  });
})();
var typo = { exports: {} };
var __viteBrowserExternal = new Proxy({}, {
  get() {
    throw new Error('Module "" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module2) {
  var Typo2;
  (function() {
    Typo2 = function(dictionary, affData, wordsData, settings) {
      settings = settings || {};
      this.dictionary = null;
      this.rules = {};
      this.dictionaryTable = {};
      this.compoundRules = [];
      this.compoundRuleCodes = {};
      this.replacementTable = [];
      this.flags = settings.flags || {};
      this.memoized = {};
      this.loaded = false;
      var self2 = this;
      var path2;
      var i2, j2, _len, _jlen;
      if (dictionary) {
        self2.dictionary = dictionary;
        if (affData && wordsData) {
          setup2();
        } else if (typeof window !== "undefined" && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension) {
          if (settings.dictionaryPath) {
            path2 = settings.dictionaryPath;
          } else {
            path2 = "typo/dictionaries";
          }
          if (!affData)
            readDataFile(chrome.extension.getURL(path2 + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
          if (!wordsData)
            readDataFile(chrome.extension.getURL(path2 + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
        } else {
          if (settings.dictionaryPath) {
            path2 = settings.dictionaryPath;
          } else if (typeof __dirname !== "undefined") {
            path2 = __dirname + "/dictionaries";
          } else {
            path2 = "./dictionaries";
          }
          if (!affData)
            readDataFile(path2 + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
          if (!wordsData)
            readDataFile(path2 + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
        }
      }
      function readDataFile(url, setFunc) {
        var response = self2._readFile(url, null, settings.asyncLoad);
        if (settings.asyncLoad) {
          response.then(function(data2) {
            setFunc(data2);
          });
        } else {
          setFunc(response);
        }
      }
      function setAffData(data2) {
        affData = data2;
        if (wordsData) {
          setup2();
        }
      }
      function setWordsData(data2) {
        wordsData = data2;
        if (affData) {
          setup2();
        }
      }
      function setup2() {
        self2.rules = self2._parseAFF(affData);
        self2.compoundRuleCodes = {};
        for (i2 = 0, _len = self2.compoundRules.length; i2 < _len; i2++) {
          var rule = self2.compoundRules[i2];
          for (j2 = 0, _jlen = rule.length; j2 < _jlen; j2++) {
            self2.compoundRuleCodes[rule[j2]] = [];
          }
        }
        if ("ONLYINCOMPOUND" in self2.flags) {
          self2.compoundRuleCodes[self2.flags.ONLYINCOMPOUND] = [];
        }
        self2.dictionaryTable = self2._parseDIC(wordsData);
        for (i2 in self2.compoundRuleCodes) {
          if (self2.compoundRuleCodes[i2].length === 0) {
            delete self2.compoundRuleCodes[i2];
          }
        }
        for (i2 = 0, _len = self2.compoundRules.length; i2 < _len; i2++) {
          var ruleText = self2.compoundRules[i2];
          var expressionText = "";
          for (j2 = 0, _jlen = ruleText.length; j2 < _jlen; j2++) {
            var character = ruleText[j2];
            if (character in self2.compoundRuleCodes) {
              expressionText += "(" + self2.compoundRuleCodes[character].join("|") + ")";
            } else {
              expressionText += character;
            }
          }
          self2.compoundRules[i2] = new RegExp(expressionText, "i");
        }
        self2.loaded = true;
        if (settings.asyncLoad && settings.loadedCallback) {
          settings.loadedCallback(self2);
        }
      }
      return this;
    };
    Typo2.prototype = {
      load: function(obj) {
        for (var i2 in obj) {
          if (obj.hasOwnProperty(i2)) {
            this[i2] = obj[i2];
          }
        }
        return this;
      },
      _readFile: function(path2, charset, async) {
        charset = charset || "utf8";
        if (typeof XMLHttpRequest !== "undefined") {
          var promise;
          var req = new XMLHttpRequest();
          req.open("GET", path2, async);
          if (async) {
            promise = new Promise(function(resolve2, reject) {
              req.onload = function() {
                if (req.status === 200) {
                  resolve2(req.responseText);
                } else {
                  reject(req.statusText);
                }
              };
              req.onerror = function() {
                reject(req.statusText);
              };
            });
          }
          if (req.overrideMimeType)
            req.overrideMimeType("text/plain; charset=" + charset);
          req.send(null);
          return async ? promise : req.responseText;
        } else if (typeof commonjsRequire !== "undefined") {
          var fs = require$$0;
          try {
            if (fs.existsSync(path2)) {
              return fs.readFileSync(path2, charset);
            } else {
              console.log("Path " + path2 + " does not exist.");
            }
          } catch (e2) {
            console.log(e2);
            return "";
          }
        }
      },
      _parseAFF: function(data2) {
        var rules = {};
        var line2, subline, numEntries, lineParts;
        var i2, j2, _len, _jlen;
        var lines = data2.split(/\r?\n/);
        for (i2 = 0, _len = lines.length; i2 < _len; i2++) {
          line2 = this._removeAffixComments(lines[i2]);
          line2 = line2.trim();
          if (!line2) {
            continue;
          }
          var definitionParts = line2.split(/\s+/);
          var ruleType = definitionParts[0];
          if (ruleType == "PFX" || ruleType == "SFX") {
            var ruleCode = definitionParts[1];
            var combineable = definitionParts[2];
            numEntries = parseInt(definitionParts[3], 10);
            var entries = [];
            for (j2 = i2 + 1, _jlen = i2 + 1 + numEntries; j2 < _jlen; j2++) {
              subline = lines[j2];
              lineParts = subline.split(/\s+/);
              var charactersToRemove = lineParts[2];
              var additionParts = lineParts[3].split("/");
              var charactersToAdd = additionParts[0];
              if (charactersToAdd === "0")
                charactersToAdd = "";
              var continuationClasses = this.parseRuleCodes(additionParts[1]);
              var regexToMatch = lineParts[4];
              var entry = {};
              entry.add = charactersToAdd;
              if (continuationClasses.length > 0)
                entry.continuationClasses = continuationClasses;
              if (regexToMatch !== ".") {
                if (ruleType === "SFX") {
                  entry.match = new RegExp(regexToMatch + "$");
                } else {
                  entry.match = new RegExp("^" + regexToMatch);
                }
              }
              if (charactersToRemove != "0") {
                if (ruleType === "SFX") {
                  entry.remove = new RegExp(charactersToRemove + "$");
                } else {
                  entry.remove = charactersToRemove;
                }
              }
              entries.push(entry);
            }
            rules[ruleCode] = { "type": ruleType, "combineable": combineable == "Y", "entries": entries };
            i2 += numEntries;
          } else if (ruleType === "COMPOUNDRULE") {
            numEntries = parseInt(definitionParts[1], 10);
            for (j2 = i2 + 1, _jlen = i2 + 1 + numEntries; j2 < _jlen; j2++) {
              line2 = lines[j2];
              lineParts = line2.split(/\s+/);
              this.compoundRules.push(lineParts[1]);
            }
            i2 += numEntries;
          } else if (ruleType === "REP") {
            lineParts = line2.split(/\s+/);
            if (lineParts.length === 3) {
              this.replacementTable.push([lineParts[1], lineParts[2]]);
            }
          } else {
            this.flags[ruleType] = definitionParts[1];
          }
        }
        return rules;
      },
      _removeAffixComments: function(line2) {
        if (line2.match(/^\s*#/, "")) {
          return "";
        }
        return line2;
      },
      _parseDIC: function(data2) {
        data2 = this._removeDicComments(data2);
        var lines = data2.split(/\r?\n/);
        var dictionaryTable = {};
        function addWord(word3, rules) {
          if (!dictionaryTable.hasOwnProperty(word3)) {
            dictionaryTable[word3] = null;
          }
          if (rules.length > 0) {
            if (dictionaryTable[word3] === null) {
              dictionaryTable[word3] = [];
            }
            dictionaryTable[word3].push(rules);
          }
        }
        for (var i2 = 1, _len = lines.length; i2 < _len; i2++) {
          var line2 = lines[i2];
          if (!line2) {
            continue;
          }
          var parts = line2.split("/", 2);
          var word2 = parts[0];
          if (parts.length > 1) {
            var ruleCodesArray = this.parseRuleCodes(parts[1]);
            if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {
              addWord(word2, ruleCodesArray);
            }
            for (var j2 = 0, _jlen = ruleCodesArray.length; j2 < _jlen; j2++) {
              var code3 = ruleCodesArray[j2];
              var rule = this.rules[code3];
              if (rule) {
                var newWords = this._applyRule(word2, rule);
                for (var ii2 = 0, _iilen = newWords.length; ii2 < _iilen; ii2++) {
                  var newWord = newWords[ii2];
                  addWord(newWord, []);
                  if (rule.combineable) {
                    for (var k2 = j2 + 1; k2 < _jlen; k2++) {
                      var combineCode = ruleCodesArray[k2];
                      var combineRule = this.rules[combineCode];
                      if (combineRule) {
                        if (combineRule.combineable && rule.type != combineRule.type) {
                          var otherNewWords = this._applyRule(newWord, combineRule);
                          for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                            var otherNewWord = otherNewWords[iii];
                            addWord(otherNewWord, []);
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (code3 in this.compoundRuleCodes) {
                this.compoundRuleCodes[code3].push(word2);
              }
            }
          } else {
            addWord(word2.trim(), []);
          }
        }
        return dictionaryTable;
      },
      _removeDicComments: function(data2) {
        data2 = data2.replace(/^\t.*$/mg, "");
        return data2;
      },
      parseRuleCodes: function(textCodes) {
        if (!textCodes) {
          return [];
        } else if (!("FLAG" in this.flags)) {
          return textCodes.split("");
        } else if (this.flags.FLAG === "long") {
          var flags = [];
          for (var i2 = 0, _len = textCodes.length; i2 < _len; i2 += 2) {
            flags.push(textCodes.substr(i2, 2));
          }
          return flags;
        } else if (this.flags.FLAG === "num") {
          return textCodes.split(",");
        }
      },
      _applyRule: function(word2, rule) {
        var entries = rule.entries;
        var newWords = [];
        for (var i2 = 0, _len = entries.length; i2 < _len; i2++) {
          var entry = entries[i2];
          if (!entry.match || word2.match(entry.match)) {
            var newWord = word2;
            if (entry.remove) {
              newWord = newWord.replace(entry.remove, "");
            }
            if (rule.type === "SFX") {
              newWord = newWord + entry.add;
            } else {
              newWord = entry.add + newWord;
            }
            newWords.push(newWord);
            if ("continuationClasses" in entry) {
              for (var j2 = 0, _jlen = entry.continuationClasses.length; j2 < _jlen; j2++) {
                var continuationRule = this.rules[entry.continuationClasses[j2]];
                if (continuationRule) {
                  newWords = newWords.concat(this._applyRule(newWord, continuationRule));
                }
              }
            }
          }
        }
        return newWords;
      },
      check: function(aWord) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        var trimmedWord = aWord.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        if (this.checkExact(trimmedWord)) {
          return true;
        }
        if (trimmedWord.toUpperCase() === trimmedWord) {
          var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
          if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
            return false;
          }
          if (this.checkExact(capitalizedWord)) {
            return true;
          }
          if (this.checkExact(trimmedWord.toLowerCase())) {
            return true;
          }
        }
        var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);
        if (uncapitalizedWord !== trimmedWord) {
          if (this.hasFlag(uncapitalizedWord, "KEEPCASE")) {
            return false;
          }
          if (this.checkExact(uncapitalizedWord)) {
            return true;
          }
        }
        return false;
      },
      checkExact: function(word2) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        var ruleCodes = this.dictionaryTable[word2];
        var i2, _len;
        if (typeof ruleCodes === "undefined") {
          if ("COMPOUNDMIN" in this.flags && word2.length >= this.flags.COMPOUNDMIN) {
            for (i2 = 0, _len = this.compoundRules.length; i2 < _len; i2++) {
              if (word2.match(this.compoundRules[i2])) {
                return true;
              }
            }
          }
        } else if (ruleCodes === null) {
          return true;
        } else if (typeof ruleCodes === "object") {
          for (i2 = 0, _len = ruleCodes.length; i2 < _len; i2++) {
            if (!this.hasFlag(word2, "ONLYINCOMPOUND", ruleCodes[i2])) {
              return true;
            }
          }
        }
        return false;
      },
      hasFlag: function(word2, flag, wordFlags) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        if (flag in this.flags) {
          if (typeof wordFlags === "undefined") {
            wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word2]);
          }
          if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
            return true;
          }
        }
        return false;
      },
      alphabet: "",
      suggest: function(word2, limit) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        limit = limit || 5;
        if (this.memoized.hasOwnProperty(word2)) {
          var memoizedLimit = this.memoized[word2]["limit"];
          if (limit <= memoizedLimit || this.memoized[word2]["suggestions"].length < memoizedLimit) {
            return this.memoized[word2]["suggestions"].slice(0, limit);
          }
        }
        if (this.check(word2))
          return [];
        for (var i2 = 0, _len = this.replacementTable.length; i2 < _len; i2++) {
          var replacementEntry = this.replacementTable[i2];
          if (word2.indexOf(replacementEntry[0]) !== -1) {
            var correctedWord = word2.replace(replacementEntry[0], replacementEntry[1]);
            if (this.check(correctedWord)) {
              return [correctedWord];
            }
          }
        }
        var self2 = this;
        self2.alphabet = "abcdefghijklmnopqrstuvwxyz";
        function edits1(words, known_only) {
          var rv = {};
          var i3, j2, _len2, _edit;
          var alphabetLength = self2.alphabet.length;
          if (typeof words == "string") {
            var word3 = words;
            words = {};
            words[word3] = true;
          }
          for (var word3 in words) {
            for (i3 = 0, _len2 = word3.length + 1; i3 < _len2; i3++) {
              var s2 = [word3.substring(0, i3), word3.substring(i3)];
              if (s2[1]) {
                _edit = s2[0] + s2[1].substring(1);
                if (!known_only || self2.check(_edit)) {
                  if (!(_edit in rv)) {
                    rv[_edit] = 1;
                  } else {
                    rv[_edit] += 1;
                  }
                }
              }
              if (s2[1].length > 1 && s2[1][1] !== s2[1][0]) {
                _edit = s2[0] + s2[1][1] + s2[1][0] + s2[1].substring(2);
                if (!known_only || self2.check(_edit)) {
                  if (!(_edit in rv)) {
                    rv[_edit] = 1;
                  } else {
                    rv[_edit] += 1;
                  }
                }
              }
              if (s2[1]) {
                var lettercase = s2[1].substring(0, 1).toUpperCase() === s2[1].substring(0, 1) ? "uppercase" : "lowercase";
                for (j2 = 0; j2 < alphabetLength; j2++) {
                  var replacementLetter = self2.alphabet[j2];
                  if ("uppercase" === lettercase) {
                    replacementLetter = replacementLetter.toUpperCase();
                  }
                  if (replacementLetter != s2[1].substring(0, 1)) {
                    _edit = s2[0] + replacementLetter + s2[1].substring(1);
                    if (!known_only || self2.check(_edit)) {
                      if (!(_edit in rv)) {
                        rv[_edit] = 1;
                      } else {
                        rv[_edit] += 1;
                      }
                    }
                  }
                }
              }
              if (s2[1]) {
                for (j2 = 0; j2 < alphabetLength; j2++) {
                  var lettercase = s2[0].substring(-1).toUpperCase() === s2[0].substring(-1) && s2[1].substring(0, 1).toUpperCase() === s2[1].substring(0, 1) ? "uppercase" : "lowercase";
                  var replacementLetter = self2.alphabet[j2];
                  if ("uppercase" === lettercase) {
                    replacementLetter = replacementLetter.toUpperCase();
                  }
                  _edit = s2[0] + replacementLetter + s2[1];
                  if (!known_only || self2.check(_edit)) {
                    if (!(_edit in rv)) {
                      rv[_edit] = 1;
                    } else {
                      rv[_edit] += 1;
                    }
                  }
                }
              }
            }
          }
          return rv;
        }
        function correct(word3) {
          var ed1 = edits1(word3);
          var ed2 = edits1(ed1, true);
          var weighted_corrections = ed2;
          for (var ed1word in ed1) {
            if (!self2.check(ed1word)) {
              continue;
            }
            if (ed1word in weighted_corrections) {
              weighted_corrections[ed1word] += ed1[ed1word];
            } else {
              weighted_corrections[ed1word] = ed1[ed1word];
            }
          }
          var i3;
          var sorted_corrections = [];
          for (i3 in weighted_corrections) {
            if (weighted_corrections.hasOwnProperty(i3)) {
              sorted_corrections.push([i3, weighted_corrections[i3]]);
            }
          }
          function sorter(a2, b2) {
            var a_val = a2[1];
            var b_val = b2[1];
            if (a_val < b_val) {
              return -1;
            } else if (a_val > b_val) {
              return 1;
            }
            return b2[0].localeCompare(a2[0]);
          }
          sorted_corrections.sort(sorter).reverse();
          var rv = [];
          var capitalization_scheme = "lowercase";
          if (word3.toUpperCase() === word3) {
            capitalization_scheme = "uppercase";
          } else if (word3.substr(0, 1).toUpperCase() + word3.substr(1).toLowerCase() === word3) {
            capitalization_scheme = "capitalized";
          }
          var working_limit = limit;
          for (i3 = 0; i3 < Math.min(working_limit, sorted_corrections.length); i3++) {
            if ("uppercase" === capitalization_scheme) {
              sorted_corrections[i3][0] = sorted_corrections[i3][0].toUpperCase();
            } else if ("capitalized" === capitalization_scheme) {
              sorted_corrections[i3][0] = sorted_corrections[i3][0].substr(0, 1).toUpperCase() + sorted_corrections[i3][0].substr(1);
            }
            if (!self2.hasFlag(sorted_corrections[i3][0], "NOSUGGEST") && rv.indexOf(sorted_corrections[i3][0]) == -1) {
              rv.push(sorted_corrections[i3][0]);
            } else {
              working_limit++;
            }
          }
          return rv;
        }
        this.memoized[word2] = {
          "suggestions": correct(word2),
          "limit": limit
        };
        return this.memoized[word2]["suggestions"];
      }
    };
  })();
  {
    module2.exports = Typo2;
  }
})(typo);
var Typo = typo.exports;
function CodeMirrorSpellChecker$1(options) {
  options = options || {};
  if (typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
    console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
    return;
  }
  if (!String.prototype.includes) {
    String.prototype.includes = function() {
      return String.prototype.indexOf.apply(this, arguments) !== -1;
    };
  }
  options.codeMirrorInstance.defineMode("spell-checker", function(config2) {
    if (!CodeMirrorSpellChecker$1.aff_loading) {
      CodeMirrorSpellChecker$1.aff_loading = true;
      var xhr_aff = new XMLHttpRequest();
      xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
      xhr_aff.onload = function() {
        if (xhr_aff.readyState === 4 && xhr_aff.status === 200) {
          CodeMirrorSpellChecker$1.aff_data = xhr_aff.responseText;
          CodeMirrorSpellChecker$1.num_loaded++;
          if (CodeMirrorSpellChecker$1.num_loaded == 2) {
            CodeMirrorSpellChecker$1.typo = new Typo("en_US", CodeMirrorSpellChecker$1.aff_data, CodeMirrorSpellChecker$1.dic_data, {
              platform: "any"
            });
          }
        }
      };
      xhr_aff.send(null);
    }
    if (!CodeMirrorSpellChecker$1.dic_loading) {
      CodeMirrorSpellChecker$1.dic_loading = true;
      var xhr_dic = new XMLHttpRequest();
      xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
      xhr_dic.onload = function() {
        if (xhr_dic.readyState === 4 && xhr_dic.status === 200) {
          CodeMirrorSpellChecker$1.dic_data = xhr_dic.responseText;
          CodeMirrorSpellChecker$1.num_loaded++;
          if (CodeMirrorSpellChecker$1.num_loaded == 2) {
            CodeMirrorSpellChecker$1.typo = new Typo("en_US", CodeMirrorSpellChecker$1.aff_data, CodeMirrorSpellChecker$1.dic_data, {
              platform: "any"
            });
          }
        }
      };
      xhr_dic.send(null);
    }
    var rx_word = '!"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ';
    var overlay2 = {
      token: function(stream) {
        var ch = stream.peek();
        var word2 = "";
        if (rx_word.includes(ch)) {
          stream.next();
          return null;
        }
        while ((ch = stream.peek()) != null && !rx_word.includes(ch)) {
          word2 += ch;
          stream.next();
        }
        if (CodeMirrorSpellChecker$1.typo && !CodeMirrorSpellChecker$1.typo.check(word2))
          return "spell-error";
        return null;
      }
    };
    var mode = options.codeMirrorInstance.getMode(config2, config2.backdrop || "text/plain");
    return options.codeMirrorInstance.overlayMode(mode, overlay2, true);
  });
}
CodeMirrorSpellChecker$1.num_loaded = 0;
CodeMirrorSpellChecker$1.aff_loading = false;
CodeMirrorSpellChecker$1.dic_loading = false;
CodeMirrorSpellChecker$1.aff_data = "";
CodeMirrorSpellChecker$1.dic_data = "";
var spellChecker = CodeMirrorSpellChecker$1;
var marked$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  function _defineProperties2(target2, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target2, descriptor.key, descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties2(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _unsupportedIterableToArray2(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray2(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o2, minLen);
  }
  function _arrayLikeToArray2(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
    var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
    if (it2)
      return (it2 = it2.call(o2)).next.bind(it2);
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i2 = 0;
      return function() {
        if (i2 >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i2++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function getDefaults() {
    return {
      baseUrl: null,
      breaks: false,
      extensions: null,
      gfm: true,
      headerIds: true,
      headerPrefix: "",
      highlight: null,
      langPrefix: "language-",
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }
  exports2.defaults = getDefaults();
  function changeDefaults(newDefaults) {
    exports2.defaults = newDefaults;
  }
  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = function getEscapeReplacement2(ch) {
    return escapeReplacements[ch];
  };
  function escape2(html, encode2) {
    if (encode2) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html;
  }
  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  function unescape2(html) {
    return html.replace(unescapeTest, function(_2, n2) {
      n2 = n2.toLowerCase();
      if (n2 === "colon")
        return ":";
      if (n2.charAt(0) === "#") {
        return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
      }
      return "";
    });
  }
  var caret2 = /(^|[^\[])\^/g;
  function edit(regex2, opt) {
    regex2 = typeof regex2 === "string" ? regex2 : regex2.source;
    opt = opt || "";
    var obj = {
      replace: function replace2(name, val) {
        val = val.source || val;
        val = val.replace(caret2, "$1");
        regex2 = regex2.replace(name, val);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex2, opt);
      }
    };
    return obj;
  }
  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
  function cleanUrl(sanitize, base2, href) {
    if (sanitize) {
      var prot;
      try {
        prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
      } catch (e2) {
        return null;
      }
      if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
        return null;
      }
    }
    if (base2 && !originIndependentUrl.test(href)) {
      href = resolveUrl(base2, href);
    }
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch (e2) {
      return null;
    }
    return href;
  }
  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
  function resolveUrl(base2, href) {
    if (!baseUrls[" " + base2]) {
      if (justDomain.test(base2)) {
        baseUrls[" " + base2] = base2 + "/";
      } else {
        baseUrls[" " + base2] = rtrim(base2, "/", true);
      }
    }
    base2 = baseUrls[" " + base2];
    var relativeBase = base2.indexOf(":") === -1;
    if (href.substring(0, 2) === "//") {
      if (relativeBase) {
        return href;
      }
      return base2.replace(protocol, "$1") + href;
    } else if (href.charAt(0) === "/") {
      if (relativeBase) {
        return href;
      }
      return base2.replace(domain, "$1") + href;
    } else {
      return base2 + href;
    }
  }
  var noopTest = {
    exec: function noopTest2() {
    }
  };
  function merge(obj) {
    var i2 = 1, target2, key;
    for (; i2 < arguments.length; i2++) {
      target2 = arguments[i2];
      for (key in target2) {
        if (Object.prototype.hasOwnProperty.call(target2, key)) {
          obj[key] = target2[key];
        }
      }
    }
    return obj;
  }
  function splitCells(tableRow, count2) {
    var row = tableRow.replace(/\|/g, function(match5, offset2, str) {
      var escaped = false, curr = offset2;
      while (--curr >= 0 && str[curr] === "\\") {
        escaped = !escaped;
      }
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    var i2 = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (cells.length > count2) {
      cells.splice(count2);
    } else {
      while (cells.length < count2) {
        cells.push("");
      }
    }
    for (; i2 < cells.length; i2++) {
      cells[i2] = cells[i2].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str, c2, invert) {
    var l2 = str.length;
    if (l2 === 0) {
      return "";
    }
    var suffLen = 0;
    while (suffLen < l2) {
      var currChar = str.charAt(l2 - suffLen - 1);
      if (currChar === c2 && !invert) {
        suffLen++;
      } else if (currChar !== c2 && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l2 - suffLen);
  }
  function findClosingBracket(str, b2) {
    if (str.indexOf(b2[1]) === -1) {
      return -1;
    }
    var l2 = str.length;
    var level = 0, i2 = 0;
    for (; i2 < l2; i2++) {
      if (str[i2] === "\\") {
        i2++;
      } else if (str[i2] === b2[0]) {
        level++;
      } else if (str[i2] === b2[1]) {
        level--;
        if (level < 0) {
          return i2;
        }
      }
    }
    return -1;
  }
  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
    }
  }
  function repeatString(pattern, count2) {
    if (count2 < 1) {
      return "";
    }
    var result = "";
    while (count2 > 1) {
      if (count2 & 1) {
        result += pattern;
      }
      count2 >>= 1;
      pattern += pattern;
    }
    return result + pattern;
  }
  function outputLink(cap2, link3, raw, lexer2) {
    var href = link3.href;
    var title = link3.title ? escape2(link3.title) : null;
    var text3 = cap2[1].replace(/\\([\[\]])/g, "$1");
    if (cap2[0].charAt(0) !== "!") {
      lexer2.state.inLink = true;
      var token2 = {
        type: "link",
        raw,
        href,
        title,
        text: text3,
        tokens: lexer2.inlineTokens(text3, [])
      };
      lexer2.state.inLink = false;
      return token2;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape2(text3)
    };
  }
  function indentCodeCompensation(raw, text3) {
    var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text3;
    }
    var indentToCode = matchIndentToCode[1];
    return text3.split("\n").map(function(node) {
      var matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      var indentInNode = matchIndentInNode[0];
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  var Tokenizer = /* @__PURE__ */ function() {
    function Tokenizer2(options2) {
      this.options = options2 || exports2.defaults;
    }
    var _proto = Tokenizer2.prototype;
    _proto.space = function space(src) {
      var cap2 = this.rules.block.newline.exec(src);
      if (cap2 && cap2[0].length > 0) {
        return {
          type: "space",
          raw: cap2[0]
        };
      }
    };
    _proto.code = function code3(src) {
      var cap2 = this.rules.block.code.exec(src);
      if (cap2) {
        var text3 = cap2[0].replace(/^ {1,4}/gm, "");
        return {
          type: "code",
          raw: cap2[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text3, "\n") : text3
        };
      }
    };
    _proto.fences = function fences(src) {
      var cap2 = this.rules.block.fences.exec(src);
      if (cap2) {
        var raw = cap2[0];
        var text3 = indentCodeCompensation(raw, cap2[3] || "");
        return {
          type: "code",
          raw,
          lang: cap2[2] ? cap2[2].trim() : cap2[2],
          text: text3
        };
      }
    };
    _proto.heading = function heading3(src) {
      var cap2 = this.rules.block.heading.exec(src);
      if (cap2) {
        var text3 = cap2[2].trim();
        if (/#$/.test(text3)) {
          var trimmed = rtrim(text3, "#");
          if (this.options.pedantic) {
            text3 = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text3 = trimmed.trim();
          }
        }
        var token2 = {
          type: "heading",
          raw: cap2[0],
          depth: cap2[1].length,
          text: text3,
          tokens: []
        };
        this.lexer.inline(token2.text, token2.tokens);
        return token2;
      }
    };
    _proto.hr = function hr3(src) {
      var cap2 = this.rules.block.hr.exec(src);
      if (cap2) {
        return {
          type: "hr",
          raw: cap2[0]
        };
      }
    };
    _proto.blockquote = function blockquote3(src) {
      var cap2 = this.rules.block.blockquote.exec(src);
      if (cap2) {
        var text3 = cap2[0].replace(/^ *>[ \t]?/gm, "");
        return {
          type: "blockquote",
          raw: cap2[0],
          tokens: this.lexer.blockTokens(text3, []),
          text: text3
        };
      }
    };
    _proto.list = function list3(src) {
      var cap2 = this.rules.block.list.exec(src);
      if (cap2) {
        var raw, istask, ischecked, indent2, i2, blankLine, endsWithBlankLine, line2, nextLine, rawLine, itemContents, endEarly;
        var bull2 = cap2[1].trim();
        var isordered = bull2.length > 1;
        var list4 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull2.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull2 = isordered ? "\\d{1,9}\\" + bull2.slice(-1) : "\\" + bull2;
        if (this.options.pedantic) {
          bull2 = isordered ? bull2 : "[*+-]";
        }
        var itemRegex = new RegExp("^( {0,3}" + bull2 + ")((?:[	 ][^\\n]*)?(?:\\n|$))");
        while (src) {
          endEarly = false;
          if (!(cap2 = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap2[0];
          src = src.substring(raw.length);
          line2 = cap2[2].split("\n", 1)[0];
          nextLine = src.split("\n", 1)[0];
          if (this.options.pedantic) {
            indent2 = 2;
            itemContents = line2.trimLeft();
          } else {
            indent2 = cap2[2].search(/[^ ]/);
            indent2 = indent2 > 4 ? 1 : indent2;
            itemContents = line2.slice(indent2);
            indent2 += cap2[1].length;
          }
          blankLine = false;
          if (!line2 && /^ *$/.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent2 - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))");
            var hrRegex = new RegExp("^ {0," + Math.min(3, indent2 - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
            while (src) {
              rawLine = src.split("\n", 1)[0];
              line2 = rawLine;
              if (this.options.pedantic) {
                line2 = line2.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
              }
              if (nextBulletRegex.test(line2)) {
                break;
              }
              if (hrRegex.test(src)) {
                break;
              }
              if (line2.search(/[^ ]/) >= indent2 || !line2.trim()) {
                itemContents += "\n" + line2.slice(indent2);
              } else if (!blankLine) {
                itemContents += "\n" + line2;
              } else {
                break;
              }
              if (!blankLine && !line2.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
            }
          }
          if (!list4.loose) {
            if (endsWithBlankLine) {
              list4.loose = true;
            } else if (/\n *\n *$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list4.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents
          });
          list4.raw += raw;
        }
        list4.items[list4.items.length - 1].raw = raw.trimRight();
        list4.items[list4.items.length - 1].text = itemContents.trimRight();
        list4.raw = list4.raw.trimRight();
        var l2 = list4.items.length;
        for (i2 = 0; i2 < l2; i2++) {
          this.lexer.state.top = false;
          list4.items[i2].tokens = this.lexer.blockTokens(list4.items[i2].text, []);
          var spacers = list4.items[i2].tokens.filter(function(t2) {
            return t2.type === "space";
          });
          var hasMultipleLineBreaks = spacers.every(function(t2) {
            var chars = t2.raw.split("");
            var lineBreaks = 0;
            for (var _iterator = _createForOfIteratorHelperLoose(chars), _step; !(_step = _iterator()).done; ) {
              var _char = _step.value;
              if (_char === "\n") {
                lineBreaks += 1;
              }
              if (lineBreaks > 1) {
                return true;
              }
            }
            return false;
          });
          if (!list4.loose && spacers.length && hasMultipleLineBreaks) {
            list4.loose = true;
            list4.items[i2].loose = true;
          }
        }
        return list4;
      }
    };
    _proto.html = function html(src) {
      var cap2 = this.rules.block.html.exec(src);
      if (cap2) {
        var token2 = {
          type: "html",
          raw: cap2[0],
          pre: !this.options.sanitizer && (cap2[1] === "pre" || cap2[1] === "script" || cap2[1] === "style"),
          text: cap2[0]
        };
        if (this.options.sanitize) {
          token2.type = "paragraph";
          token2.text = this.options.sanitizer ? this.options.sanitizer(cap2[0]) : escape2(cap2[0]);
          token2.tokens = [];
          this.lexer.inline(token2.text, token2.tokens);
        }
        return token2;
      }
    };
    _proto.def = function def2(src) {
      var cap2 = this.rules.block.def.exec(src);
      if (cap2) {
        if (cap2[3])
          cap2[3] = cap2[3].substring(1, cap2[3].length - 1);
        var tag = cap2[1].toLowerCase().replace(/\s+/g, " ");
        return {
          type: "def",
          tag,
          raw: cap2[0],
          href: cap2[2],
          title: cap2[3]
        };
      }
    };
    _proto.table = function table3(src) {
      var cap2 = this.rules.block.table.exec(src);
      if (cap2) {
        var item = {
          type: "table",
          header: splitCells(cap2[1]).map(function(c2) {
            return {
              text: c2
            };
          }),
          align: cap2[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
          rows: cap2[3] && cap2[3].trim() ? cap2[3].replace(/\n[ \t]*$/, "").split("\n") : []
        };
        if (item.header.length === item.align.length) {
          item.raw = cap2[0];
          var l2 = item.align.length;
          var i2, j2, k2, row;
          for (i2 = 0; i2 < l2; i2++) {
            if (/^ *-+: *$/.test(item.align[i2])) {
              item.align[i2] = "right";
            } else if (/^ *:-+: *$/.test(item.align[i2])) {
              item.align[i2] = "center";
            } else if (/^ *:-+ *$/.test(item.align[i2])) {
              item.align[i2] = "left";
            } else {
              item.align[i2] = null;
            }
          }
          l2 = item.rows.length;
          for (i2 = 0; i2 < l2; i2++) {
            item.rows[i2] = splitCells(item.rows[i2], item.header.length).map(function(c2) {
              return {
                text: c2
              };
            });
          }
          l2 = item.header.length;
          for (j2 = 0; j2 < l2; j2++) {
            item.header[j2].tokens = [];
            this.lexer.inline(item.header[j2].text, item.header[j2].tokens);
          }
          l2 = item.rows.length;
          for (j2 = 0; j2 < l2; j2++) {
            row = item.rows[j2];
            for (k2 = 0; k2 < row.length; k2++) {
              row[k2].tokens = [];
              this.lexer.inline(row[k2].text, row[k2].tokens);
            }
          }
          return item;
        }
      }
    };
    _proto.lheading = function lheading3(src) {
      var cap2 = this.rules.block.lheading.exec(src);
      if (cap2) {
        var token2 = {
          type: "heading",
          raw: cap2[0],
          depth: cap2[2].charAt(0) === "=" ? 1 : 2,
          text: cap2[1],
          tokens: []
        };
        this.lexer.inline(token2.text, token2.tokens);
        return token2;
      }
    };
    _proto.paragraph = function paragraph3(src) {
      var cap2 = this.rules.block.paragraph.exec(src);
      if (cap2) {
        var token2 = {
          type: "paragraph",
          raw: cap2[0],
          text: cap2[1].charAt(cap2[1].length - 1) === "\n" ? cap2[1].slice(0, -1) : cap2[1],
          tokens: []
        };
        this.lexer.inline(token2.text, token2.tokens);
        return token2;
      }
    };
    _proto.text = function text3(src) {
      var cap2 = this.rules.block.text.exec(src);
      if (cap2) {
        var token2 = {
          type: "text",
          raw: cap2[0],
          text: cap2[0],
          tokens: []
        };
        this.lexer.inline(token2.text, token2.tokens);
        return token2;
      }
    };
    _proto.escape = function escape$1(src) {
      var cap2 = this.rules.inline.escape.exec(src);
      if (cap2) {
        return {
          type: "escape",
          raw: cap2[0],
          text: escape2(cap2[1])
        };
      }
    };
    _proto.tag = function tag(src) {
      var cap2 = this.rules.inline.tag.exec(src);
      if (cap2) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap2[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap2[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap2[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap2[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: this.options.sanitize ? "text" : "html",
          raw: cap2[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap2[0]) : escape2(cap2[0]) : cap2[0]
        };
      }
    };
    _proto.link = function link3(src) {
      var cap2 = this.rules.inline.link.exec(src);
      if (cap2) {
        var trimmedUrl = cap2[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          var lastParenIndex = findClosingBracket(cap2[2], "()");
          if (lastParenIndex > -1) {
            var start2 = cap2[0].indexOf("!") === 0 ? 5 : 4;
            var linkLen = start2 + cap2[1].length + lastParenIndex;
            cap2[2] = cap2[2].substring(0, lastParenIndex);
            cap2[0] = cap2[0].substring(0, linkLen).trim();
            cap2[3] = "";
          }
        }
        var href = cap2[2];
        var title = "";
        if (this.options.pedantic) {
          var link4 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link4) {
            href = link4[1];
            title = link4[3];
          }
        } else {
          title = cap2[3] ? cap2[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap2, {
          href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
          title: title ? title.replace(this.rules.inline._escapes, "$1") : title
        }, cap2[0], this.lexer);
      }
    };
    _proto.reflink = function reflink(src, links) {
      var cap2;
      if ((cap2 = this.rules.inline.reflink.exec(src)) || (cap2 = this.rules.inline.nolink.exec(src))) {
        var link3 = (cap2[2] || cap2[1]).replace(/\s+/g, " ");
        link3 = links[link3.toLowerCase()];
        if (!link3 || !link3.href) {
          var text3 = cap2[0].charAt(0);
          return {
            type: "text",
            raw: text3,
            text: text3
          };
        }
        return outputLink(cap2, link3, cap2[0], this.lexer);
      }
    };
    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
      if (prevChar === void 0) {
        prevChar = "";
      }
      var match5 = this.rules.inline.emStrong.lDelim.exec(src);
      if (!match5)
        return;
      if (match5[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))
        return;
      var nextChar = match5[1] || match5[2] || "";
      if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
        var lLength = match5[0].length - 1;
        var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        var endReg = match5[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match5 = endReg.exec(maskedSrc)) != null) {
          rDelim = match5[1] || match5[2] || match5[3] || match5[4] || match5[5] || match5[6];
          if (!rDelim)
            continue;
          rLength = rDelim.length;
          if (match5[3] || match5[4]) {
            delimTotal += rLength;
            continue;
          } else if (match5[5] || match5[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          if (Math.min(lLength, rLength) % 2) {
            var _text = src.slice(1, lLength + match5.index + rLength);
            return {
              type: "em",
              raw: src.slice(0, lLength + match5.index + rLength + 1),
              text: _text,
              tokens: this.lexer.inlineTokens(_text, [])
            };
          }
          var text3 = src.slice(2, lLength + match5.index + rLength - 1);
          return {
            type: "strong",
            raw: src.slice(0, lLength + match5.index + rLength + 1),
            text: text3,
            tokens: this.lexer.inlineTokens(text3, [])
          };
        }
      }
    };
    _proto.codespan = function codespan(src) {
      var cap2 = this.rules.inline.code.exec(src);
      if (cap2) {
        var text3 = cap2[2].replace(/\n/g, " ");
        var hasNonSpaceChars = /[^ ]/.test(text3);
        var hasSpaceCharsOnBothEnds = /^ /.test(text3) && / $/.test(text3);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text3 = text3.substring(1, text3.length - 1);
        }
        text3 = escape2(text3, true);
        return {
          type: "codespan",
          raw: cap2[0],
          text: text3
        };
      }
    };
    _proto.br = function br(src) {
      var cap2 = this.rules.inline.br.exec(src);
      if (cap2) {
        return {
          type: "br",
          raw: cap2[0]
        };
      }
    };
    _proto.del = function del2(src) {
      var cap2 = this.rules.inline.del.exec(src);
      if (cap2) {
        return {
          type: "del",
          raw: cap2[0],
          text: cap2[2],
          tokens: this.lexer.inlineTokens(cap2[2], [])
        };
      }
    };
    _proto.autolink = function autolink3(src, mangle2) {
      var cap2 = this.rules.inline.autolink.exec(src);
      if (cap2) {
        var text3, href;
        if (cap2[2] === "@") {
          text3 = escape2(this.options.mangle ? mangle2(cap2[1]) : cap2[1]);
          href = "mailto:" + text3;
        } else {
          text3 = escape2(cap2[1]);
          href = text3;
        }
        return {
          type: "link",
          raw: cap2[0],
          text: text3,
          href,
          tokens: [{
            type: "text",
            raw: text3,
            text: text3
          }]
        };
      }
    };
    _proto.url = function url(src, mangle2) {
      var cap2;
      if (cap2 = this.rules.inline.url.exec(src)) {
        var text3, href;
        if (cap2[2] === "@") {
          text3 = escape2(this.options.mangle ? mangle2(cap2[0]) : cap2[0]);
          href = "mailto:" + text3;
        } else {
          var prevCapZero;
          do {
            prevCapZero = cap2[0];
            cap2[0] = this.rules.inline._backpedal.exec(cap2[0])[0];
          } while (prevCapZero !== cap2[0]);
          text3 = escape2(cap2[0]);
          if (cap2[1] === "www.") {
            href = "http://" + text3;
          } else {
            href = text3;
          }
        }
        return {
          type: "link",
          raw: cap2[0],
          text: text3,
          href,
          tokens: [{
            type: "text",
            raw: text3,
            text: text3
          }]
        };
      }
    };
    _proto.inlineText = function inlineText(src, smartypants2) {
      var cap2 = this.rules.inline.text.exec(src);
      if (cap2) {
        var text3;
        if (this.lexer.state.inRawBlock) {
          text3 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap2[0]) : escape2(cap2[0]) : cap2[0];
        } else {
          text3 = escape2(this.options.smartypants ? smartypants2(cap2[0]) : cap2[0]);
        }
        return {
          type: "text",
          raw: cap2[0],
          text: text3
        };
      }
    };
    return Tokenizer2;
  }();
  var block3 = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
    def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block3._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  block3._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block3.def = edit(block3.def).replace("label", block3._label).replace("title", block3._title).getRegex();
  block3.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block3.listItemStart = edit(/^( *)(bull) */).replace("bull", block3.bullet).getRegex();
  block3.list = edit(block3.list).replace(/bull/g, block3.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block3.def.source + ")").getRegex();
  block3._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  block3._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block3.html = edit(block3.html, "i").replace("comment", block3._comment).replace("tag", block3._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block3.paragraph = edit(block3._paragraph).replace("hr", block3.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block3._tag).getRegex();
  block3.blockquote = edit(block3.blockquote).replace("paragraph", block3.paragraph).getRegex();
  block3.normal = merge({}, block3);
  block3.gfm = merge({}, block3.normal, {
    table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  });
  block3.gfm.table = edit(block3.gfm.table).replace("hr", block3.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block3._tag).getRegex();
  block3.gfm.paragraph = edit(block3._paragraph).replace("hr", block3.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block3.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block3._tag).getRegex();
  block3.pedantic = merge({}, block3.normal, {
    html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block3._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    paragraph: edit(block3.normal._paragraph).replace("hr", block3.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block3.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
  });
  var inline3 = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: "reflink|nolink(?!\\()",
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
      rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  };
  inline3._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
  inline3.punctuation = edit(inline3.punctuation).replace(/punctuation/g, inline3._punctuation).getRegex();
  inline3.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  inline3.escapedEmSt = /\\\*|\\_/g;
  inline3._comment = edit(block3._comment).replace("(?:-->|$)", "-->").getRegex();
  inline3.emStrong.lDelim = edit(inline3.emStrong.lDelim).replace(/punct/g, inline3._punctuation).getRegex();
  inline3.emStrong.rDelimAst = edit(inline3.emStrong.rDelimAst, "g").replace(/punct/g, inline3._punctuation).getRegex();
  inline3.emStrong.rDelimUnd = edit(inline3.emStrong.rDelimUnd, "g").replace(/punct/g, inline3._punctuation).getRegex();
  inline3._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline3._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline3._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline3.autolink = edit(inline3.autolink).replace("scheme", inline3._scheme).replace("email", inline3._email).getRegex();
  inline3._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline3.tag = edit(inline3.tag).replace("comment", inline3._comment).replace("attribute", inline3._attribute).getRegex();
  inline3._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline3._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline3._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline3.link = edit(inline3.link).replace("label", inline3._label).replace("href", inline3._href).replace("title", inline3._title).getRegex();
  inline3.reflink = edit(inline3.reflink).replace("label", inline3._label).replace("ref", block3._label).getRegex();
  inline3.nolink = edit(inline3.nolink).replace("ref", block3._label).getRegex();
  inline3.reflinkSearch = edit(inline3.reflinkSearch, "g").replace("reflink", inline3.reflink).replace("nolink", inline3.nolink).getRegex();
  inline3.normal = merge({}, inline3);
  inline3.pedantic = merge({}, inline3.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline3._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline3._label).getRegex()
  });
  inline3.gfm = merge({}, inline3.normal, {
    escape: edit(inline3.escape).replace("])", "~|])").getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  });
  inline3.gfm.url = edit(inline3.gfm.url, "i").replace("email", inline3.gfm._extended_email).getRegex();
  inline3.breaks = merge({}, inline3.gfm, {
    br: edit(inline3.br).replace("{2,}", "*").getRegex(),
    text: edit(inline3.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  });
  function smartypants(text3) {
    return text3.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
  }
  function mangle(text3) {
    var out = "", i2, ch;
    var l2 = text3.length;
    for (i2 = 0; i2 < l2; i2++) {
      ch = text3.charCodeAt(i2);
      if (Math.random() > 0.5) {
        ch = "x" + ch.toString(16);
      }
      out += "&#" + ch + ";";
    }
    return out;
  }
  var Lexer2 = /* @__PURE__ */ function() {
    function Lexer3(options2) {
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options2 || exports2.defaults;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      var rules = {
        block: block3.normal,
        inline: inline3.normal
      };
      if (this.options.pedantic) {
        rules.block = block3.pedantic;
        rules.inline = inline3.pedantic;
      } else if (this.options.gfm) {
        rules.block = block3.gfm;
        if (this.options.breaks) {
          rules.inline = inline3.breaks;
        } else {
          rules.inline = inline3.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    Lexer3.lex = function lex(src, options2) {
      var lexer2 = new Lexer3(options2);
      return lexer2.lex(src);
    };
    Lexer3.lexInline = function lexInline(src, options2) {
      var lexer2 = new Lexer3(options2);
      return lexer2.inlineTokens(src);
    };
    var _proto = Lexer3.prototype;
    _proto.lex = function lex(src) {
      src = src.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src, this.tokens);
      var next;
      while (next = this.inlineQueue.shift()) {
        this.inlineTokens(next.src, next.tokens);
      }
      return this.tokens;
    };
    _proto.blockTokens = function blockTokens(src, tokens2) {
      var _this = this;
      if (tokens2 === void 0) {
        tokens2 = [];
      }
      if (this.options.pedantic) {
        src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      } else {
        src = src.replace(/^( *)(\t+)/gm, function(_2, leading, tabs) {
          return leading + "    ".repeat(tabs.length);
        });
      }
      var token2, lastToken, cutSrc, lastParagraphClipped;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
          if (token2 = extTokenizer.call({
            lexer: _this
          }, src, tokens2)) {
            src = src.substring(token2.raw.length);
            tokens2.push(token2);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token2 = this.tokenizer.space(src)) {
          src = src.substring(token2.raw.length);
          if (token2.raw.length === 1 && tokens2.length > 0) {
            tokens2[tokens2.length - 1].raw += "\n";
          } else {
            tokens2.push(token2);
          }
          continue;
        }
        if (token2 = this.tokenizer.code(src)) {
          src = src.substring(token2.raw.length);
          lastToken = tokens2[tokens2.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token2.raw;
            lastToken.text += "\n" + token2.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens2.push(token2);
          }
          continue;
        }
        if (token2 = this.tokenizer.fences(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.heading(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.hr(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.blockquote(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.list(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.html(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.def(src)) {
          src = src.substring(token2.raw.length);
          lastToken = tokens2[tokens2.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token2.raw;
            lastToken.text += "\n" + token2.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token2.tag]) {
            this.tokens.links[token2.tag] = {
              href: token2.href,
              title: token2.title
            };
          }
          continue;
        }
        if (token2 = this.tokenizer.table(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.lheading(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          (function() {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;
            _this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }
        if (this.state.top && (token2 = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens2[tokens2.length - 1];
          if (lastParagraphClipped && lastToken.type === "paragraph") {
            lastToken.raw += "\n" + token2.raw;
            lastToken.text += "\n" + token2.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens2.push(token2);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token2.raw.length);
          continue;
        }
        if (token2 = this.tokenizer.text(src)) {
          src = src.substring(token2.raw.length);
          lastToken = tokens2[tokens2.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token2.raw;
            lastToken.text += "\n" + token2.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens2.push(token2);
          }
          continue;
        }
        if (src) {
          var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens2;
    };
    _proto.inline = function inline4(src, tokens2) {
      this.inlineQueue.push({
        src,
        tokens: tokens2
      });
    };
    _proto.inlineTokens = function inlineTokens(src, tokens2) {
      var _this2 = this;
      if (tokens2 === void 0) {
        tokens2 = [];
      }
      var token2, lastToken, cutSrc;
      var maskedSrc = src;
      var match5;
      var keepPrevChar, prevChar;
      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match5 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match5[0].slice(match5[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match5.index) + "[" + repeatString("a", match5[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match5 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match5.index) + "[" + repeatString("a", match5[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match5 = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match5.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
          if (token2 = extTokenizer.call({
            lexer: _this2
          }, src, tokens2)) {
            src = src.substring(token2.raw.length);
            tokens2.push(token2);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token2 = this.tokenizer.escape(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.tag(src)) {
          src = src.substring(token2.raw.length);
          lastToken = tokens2[tokens2.length - 1];
          if (lastToken && token2.type === "text" && lastToken.type === "text") {
            lastToken.raw += token2.raw;
            lastToken.text += token2.text;
          } else {
            tokens2.push(token2);
          }
          continue;
        }
        if (token2 = this.tokenizer.link(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token2.raw.length);
          lastToken = tokens2[tokens2.length - 1];
          if (lastToken && token2.type === "text" && lastToken.type === "text") {
            lastToken.raw += token2.raw;
            lastToken.text += token2.text;
          } else {
            tokens2.push(token2);
          }
          continue;
        }
        if (token2 = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.codespan(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.br(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.del(src)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (token2 = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        if (!this.state.inLink && (token2 = this.tokenizer.url(src, mangle))) {
          src = src.substring(token2.raw.length);
          tokens2.push(token2);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          (function() {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;
            _this2.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }
        if (token2 = this.tokenizer.inlineText(cutSrc, smartypants)) {
          src = src.substring(token2.raw.length);
          if (token2.raw.slice(-1) !== "_") {
            prevChar = token2.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens2[tokens2.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token2.raw;
            lastToken.text += token2.text;
          } else {
            tokens2.push(token2);
          }
          continue;
        }
        if (src) {
          var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens2;
    };
    _createClass2(Lexer3, null, [{
      key: "rules",
      get: function get2() {
        return {
          block: block3,
          inline: inline3
        };
      }
    }]);
    return Lexer3;
  }();
  var Renderer2 = /* @__PURE__ */ function() {
    function Renderer3(options2) {
      this.options = options2 || exports2.defaults;
    }
    var _proto = Renderer3.prototype;
    _proto.code = function code3(_code, infostring, escaped) {
      var lang2 = (infostring || "").match(/\S*/)[0];
      if (this.options.highlight) {
        var out = this.options.highlight(_code, lang2);
        if (out != null && out !== _code) {
          escaped = true;
          _code = out;
        }
      }
      _code = _code.replace(/\n$/, "") + "\n";
      if (!lang2) {
        return "<pre><code>" + (escaped ? _code : escape2(_code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="' + this.options.langPrefix + escape2(lang2, true) + '">' + (escaped ? _code : escape2(_code, true)) + "</code></pre>\n";
    };
    _proto.blockquote = function blockquote3(quote) {
      return "<blockquote>\n" + quote + "</blockquote>\n";
    };
    _proto.html = function html(_html) {
      return _html;
    };
    _proto.heading = function heading3(text3, level, raw, slugger) {
      if (this.options.headerIds) {
        var id2 = this.options.headerPrefix + slugger.slug(raw);
        return "<h" + level + ' id="' + id2 + '">' + text3 + "</h" + level + ">\n";
      }
      return "<h" + level + ">" + text3 + "</h" + level + ">\n";
    };
    _proto.hr = function hr3() {
      return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
    };
    _proto.list = function list3(body, ordered, start2) {
      var type = ordered ? "ol" : "ul", startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
      return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
    };
    _proto.listitem = function listitem(text3) {
      return "<li>" + text3 + "</li>\n";
    };
    _proto.checkbox = function checkbox(checked) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
    };
    _proto.paragraph = function paragraph3(text3) {
      return "<p>" + text3 + "</p>\n";
    };
    _proto.table = function table3(header, body) {
      if (body)
        body = "<tbody>" + body + "</tbody>";
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    };
    _proto.tablerow = function tablerow(content) {
      return "<tr>\n" + content + "</tr>\n";
    };
    _proto.tablecell = function tablecell(content, flags) {
      var type = flags.header ? "th" : "td";
      var tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
      return tag + content + ("</" + type + ">\n");
    };
    _proto.strong = function strong(text3) {
      return "<strong>" + text3 + "</strong>";
    };
    _proto.em = function em(text3) {
      return "<em>" + text3 + "</em>";
    };
    _proto.codespan = function codespan(text3) {
      return "<code>" + text3 + "</code>";
    };
    _proto.br = function br() {
      return this.options.xhtml ? "<br/>" : "<br>";
    };
    _proto.del = function del2(text3) {
      return "<del>" + text3 + "</del>";
    };
    _proto.link = function link3(href, title, text3) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text3;
      }
      var out = '<a href="' + escape2(href) + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text3 + "</a>";
      return out;
    };
    _proto.image = function image3(href, title, text3) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text3;
      }
      var out = '<img src="' + href + '" alt="' + text3 + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += this.options.xhtml ? "/>" : ">";
      return out;
    };
    _proto.text = function text3(_text) {
      return _text;
    };
    return Renderer3;
  }();
  var TextRenderer = /* @__PURE__ */ function() {
    function TextRenderer2() {
    }
    var _proto = TextRenderer2.prototype;
    _proto.strong = function strong(text3) {
      return text3;
    };
    _proto.em = function em(text3) {
      return text3;
    };
    _proto.codespan = function codespan(text3) {
      return text3;
    };
    _proto.del = function del2(text3) {
      return text3;
    };
    _proto.html = function html(text3) {
      return text3;
    };
    _proto.text = function text3(_text) {
      return _text;
    };
    _proto.link = function link3(href, title, text3) {
      return "" + text3;
    };
    _proto.image = function image3(href, title, text3) {
      return "" + text3;
    };
    _proto.br = function br() {
      return "";
    };
    return TextRenderer2;
  }();
  var Slugger = /* @__PURE__ */ function() {
    function Slugger2() {
      this.seen = {};
    }
    var _proto = Slugger2.prototype;
    _proto.serialize = function serialize(value) {
      return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
    };
    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
      var slug = originalSlug;
      var occurenceAccumulator = 0;
      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];
        do {
          occurenceAccumulator++;
          slug = originalSlug + "-" + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }
      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }
      return slug;
    };
    _proto.slug = function slug(value, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var slug2 = this.serialize(value);
      return this.getNextSafeSlug(slug2, options2.dryrun);
    };
    return Slugger2;
  }();
  var Parser2 = /* @__PURE__ */ function() {
    function Parser3(options2) {
      this.options = options2 || exports2.defaults;
      this.options.renderer = this.options.renderer || new Renderer2();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }
    Parser3.parse = function parse3(tokens2, options2) {
      var parser2 = new Parser3(options2);
      return parser2.parse(tokens2);
    };
    Parser3.parseInline = function parseInline2(tokens2, options2) {
      var parser2 = new Parser3(options2);
      return parser2.parseInline(tokens2);
    };
    var _proto = Parser3.prototype;
    _proto.parse = function parse3(tokens2, top2) {
      if (top2 === void 0) {
        top2 = true;
      }
      var out = "", i2, j2, k2, l2, l3, row, cell, header, body, token2, ordered, start2, loose, itemBody, item, checked, task, checkbox, ret;
      var l4 = tokens2.length;
      for (i2 = 0; i2 < l4; i2++) {
        token2 = tokens2[i2];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
          ret = this.options.extensions.renderers[token2.type].call({
            parser: this
          }, token2);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token2.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token2.type) {
          case "space": {
            continue;
          }
          case "hr": {
            out += this.renderer.hr();
            continue;
          }
          case "heading": {
            out += this.renderer.heading(this.parseInline(token2.tokens), token2.depth, unescape2(this.parseInline(token2.tokens, this.textRenderer)), this.slugger);
            continue;
          }
          case "code": {
            out += this.renderer.code(token2.text, token2.lang, token2.escaped);
            continue;
          }
          case "table": {
            header = "";
            cell = "";
            l2 = token2.header.length;
            for (j2 = 0; j2 < l2; j2++) {
              cell += this.renderer.tablecell(this.parseInline(token2.header[j2].tokens), {
                header: true,
                align: token2.align[j2]
              });
            }
            header += this.renderer.tablerow(cell);
            body = "";
            l2 = token2.rows.length;
            for (j2 = 0; j2 < l2; j2++) {
              row = token2.rows[j2];
              cell = "";
              l3 = row.length;
              for (k2 = 0; k2 < l3; k2++) {
                cell += this.renderer.tablecell(this.parseInline(row[k2].tokens), {
                  header: false,
                  align: token2.align[k2]
                });
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
          case "blockquote": {
            body = this.parse(token2.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
          case "list": {
            ordered = token2.ordered;
            start2 = token2.start;
            loose = token2.loose;
            l2 = token2.items.length;
            body = "";
            for (j2 = 0; j2 < l2; j2++) {
              item = token2.items[j2];
              checked = item.checked;
              task = item.task;
              itemBody = "";
              if (item.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                    item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                      item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: "text",
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task, checked);
            }
            out += this.renderer.list(body, ordered, start2);
            continue;
          }
          case "html": {
            out += this.renderer.html(token2.text);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(this.parseInline(token2.tokens));
            continue;
          }
          case "text": {
            body = token2.tokens ? this.parseInline(token2.tokens) : token2.text;
            while (i2 + 1 < l4 && tokens2[i2 + 1].type === "text") {
              token2 = tokens2[++i2];
              body += "\n" + (token2.tokens ? this.parseInline(token2.tokens) : token2.text);
            }
            out += top2 ? this.renderer.paragraph(body) : body;
            continue;
          }
          default: {
            var errMsg = 'Token with "' + token2.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    };
    _proto.parseInline = function parseInline2(tokens2, renderer2) {
      renderer2 = renderer2 || this.renderer;
      var out = "", i2, token2, ret;
      var l2 = tokens2.length;
      for (i2 = 0; i2 < l2; i2++) {
        token2 = tokens2[i2];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
          ret = this.options.extensions.renderers[token2.type].call({
            parser: this
          }, token2);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token2.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token2.type) {
          case "escape": {
            out += renderer2.text(token2.text);
            break;
          }
          case "html": {
            out += renderer2.html(token2.text);
            break;
          }
          case "link": {
            out += renderer2.link(token2.href, token2.title, this.parseInline(token2.tokens, renderer2));
            break;
          }
          case "image": {
            out += renderer2.image(token2.href, token2.title, token2.text);
            break;
          }
          case "strong": {
            out += renderer2.strong(this.parseInline(token2.tokens, renderer2));
            break;
          }
          case "em": {
            out += renderer2.em(this.parseInline(token2.tokens, renderer2));
            break;
          }
          case "codespan": {
            out += renderer2.codespan(token2.text);
            break;
          }
          case "br": {
            out += renderer2.br();
            break;
          }
          case "del": {
            out += renderer2.del(this.parseInline(token2.tokens, renderer2));
            break;
          }
          case "text": {
            out += renderer2.text(token2.text);
            break;
          }
          default: {
            var errMsg = 'Token with "' + token2.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    };
    return Parser3;
  }();
  function marked2(src, opt, callback) {
    if (typeof src === "undefined" || src === null) {
      throw new Error("marked(): input parameter is undefined or null");
    }
    if (typeof src !== "string") {
      throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
    }
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    opt = merge({}, marked2.defaults, opt || {});
    checkSanitizeDeprecation(opt);
    if (callback) {
      var highlight = opt.highlight;
      var tokens2;
      try {
        tokens2 = Lexer2.lex(src, opt);
      } catch (e2) {
        return callback(e2);
      }
      var done = function done2(err) {
        var out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              marked2.walkTokens(tokens2, opt.walkTokens);
            }
            out = Parser2.parse(tokens2, opt);
          } catch (e2) {
            err = e2;
          }
        }
        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens2.length)
        return done();
      var pending = 0;
      marked2.walkTokens(tokens2, function(token2) {
        if (token2.type === "code") {
          pending++;
          setTimeout(function() {
            highlight(token2.text, token2.lang, function(err, code3) {
              if (err) {
                return done(err);
              }
              if (code3 != null && code3 !== token2.text) {
                token2.text = code3;
                token2.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    try {
      var _tokens = Lexer2.lex(src, opt);
      if (opt.walkTokens) {
        marked2.walkTokens(_tokens, opt.walkTokens);
      }
      return Parser2.parse(_tokens, opt);
    } catch (e2) {
      e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (opt.silent) {
        return "<p>An error occurred:</p><pre>" + escape2(e2.message + "", true) + "</pre>";
      }
      throw e2;
    }
  }
  marked2.options = marked2.setOptions = function(opt) {
    merge(marked2.defaults, opt);
    changeDefaults(marked2.defaults);
    return marked2;
  };
  marked2.getDefaults = getDefaults;
  marked2.defaults = exports2.defaults;
  marked2.use = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var opts = merge.apply(void 0, [{}].concat(args));
    var extensions = marked2.defaults.extensions || {
      renderers: {},
      childTokens: {}
    };
    var hasExtensions;
    args.forEach(function(pack) {
      if (pack.extensions) {
        hasExtensions = true;
        pack.extensions.forEach(function(ext) {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if (ext.renderer) {
            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
            if (prevRenderer) {
              extensions.renderers[ext.name] = function() {
                for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args2[_key2] = arguments[_key2];
                }
                var ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if (ext.tokenizer) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            if (extensions[ext.level]) {
              extensions[ext.level].unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if (ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
      }
      if (pack.renderer) {
        (function() {
          var renderer2 = marked2.defaults.renderer || new Renderer2();
          var _loop = function _loop2(prop3) {
            var prevRenderer = renderer2[prop3];
            renderer2[prop3] = function() {
              for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args2[_key3] = arguments[_key3];
              }
              var ret = pack.renderer[prop3].apply(renderer2, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer2, args2);
              }
              return ret;
            };
          };
          for (var prop2 in pack.renderer) {
            _loop(prop2);
          }
          opts.renderer = renderer2;
        })();
      }
      if (pack.tokenizer) {
        (function() {
          var tokenizer = marked2.defaults.tokenizer || new Tokenizer();
          var _loop2 = function _loop22(prop3) {
            var prevTokenizer = tokenizer[prop3];
            tokenizer[prop3] = function() {
              for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args2[_key4] = arguments[_key4];
              }
              var ret = pack.tokenizer[prop3].apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          };
          for (var prop2 in pack.tokenizer) {
            _loop2(prop2);
          }
          opts.tokenizer = tokenizer;
        })();
      }
      if (pack.walkTokens) {
        var _walkTokens = marked2.defaults.walkTokens;
        opts.walkTokens = function(token2) {
          pack.walkTokens.call(this, token2);
          if (_walkTokens) {
            _walkTokens.call(this, token2);
          }
        };
      }
      if (hasExtensions) {
        opts.extensions = extensions;
      }
      marked2.setOptions(opts);
    });
  };
  marked2.walkTokens = function(tokens2, callback) {
    var _loop3 = function _loop32() {
      var token2 = _step.value;
      callback.call(marked2, token2);
      switch (token2.type) {
        case "table": {
          for (var _iterator2 = _createForOfIteratorHelperLoose(token2.header), _step2; !(_step2 = _iterator2()).done; ) {
            var cell = _step2.value;
            marked2.walkTokens(cell.tokens, callback);
          }
          for (var _iterator3 = _createForOfIteratorHelperLoose(token2.rows), _step3; !(_step3 = _iterator3()).done; ) {
            var row = _step3.value;
            for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
              var _cell = _step4.value;
              marked2.walkTokens(_cell.tokens, callback);
            }
          }
          break;
        }
        case "list": {
          marked2.walkTokens(token2.items, callback);
          break;
        }
        default: {
          if (marked2.defaults.extensions && marked2.defaults.extensions.childTokens && marked2.defaults.extensions.childTokens[token2.type]) {
            marked2.defaults.extensions.childTokens[token2.type].forEach(function(childTokens) {
              marked2.walkTokens(token2[childTokens], callback);
            });
          } else if (token2.tokens) {
            marked2.walkTokens(token2.tokens, callback);
          }
        }
      }
    };
    for (var _iterator = _createForOfIteratorHelperLoose(tokens2), _step; !(_step = _iterator()).done; ) {
      _loop3();
    }
  };
  marked2.parseInline = function(src, opt) {
    if (typeof src === "undefined" || src === null) {
      throw new Error("marked.parseInline(): input parameter is undefined or null");
    }
    if (typeof src !== "string") {
      throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
    }
    opt = merge({}, marked2.defaults, opt || {});
    checkSanitizeDeprecation(opt);
    try {
      var tokens2 = Lexer2.lexInline(src, opt);
      if (opt.walkTokens) {
        marked2.walkTokens(tokens2, opt.walkTokens);
      }
      return Parser2.parseInline(tokens2, opt);
    } catch (e2) {
      e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (opt.silent) {
        return "<p>An error occurred:</p><pre>" + escape2(e2.message + "", true) + "</pre>";
      }
      throw e2;
    }
  };
  marked2.Parser = Parser2;
  marked2.parser = Parser2.parse;
  marked2.Renderer = Renderer2;
  marked2.TextRenderer = TextRenderer;
  marked2.Lexer = Lexer2;
  marked2.lexer = Lexer2.lex;
  marked2.Tokenizer = Tokenizer;
  marked2.Slugger = Slugger;
  marked2.parse = marked2;
  var options = marked2.options;
  var setOptions = marked2.setOptions;
  var use = marked2.use;
  var walkTokens = marked2.walkTokens;
  var parseInline = marked2.parseInline;
  var parse2 = marked2;
  var parser = Parser2.parse;
  var lexer = Lexer2.lex;
  exports2.Lexer = Lexer2;
  exports2.Parser = Parser2;
  exports2.Renderer = Renderer2;
  exports2.Slugger = Slugger;
  exports2.TextRenderer = TextRenderer;
  exports2.Tokenizer = Tokenizer;
  exports2.getDefaults = getDefaults;
  exports2.lexer = lexer;
  exports2.marked = marked2;
  exports2.options = options;
  exports2.parse = parse2;
  exports2.parseInline = parseInline;
  exports2.parser = parser;
  exports2.setOptions = setOptions;
  exports2.use = use;
  exports2.walkTokens = walkTokens;
})(marked$1);
var CodeMirror = codemirror.exports;
var CodeMirrorSpellChecker = spellChecker;
var marked = marked$1;
var isMac = /Mac/.test(navigator.platform);
var bindings = {
  "toggleBold": toggleBold,
  "toggleItalic": toggleItalic,
  "drawLink": drawLink,
  "toggleHeadingSmaller": toggleHeadingSmaller,
  "toggleHeadingBigger": toggleHeadingBigger,
  "drawImage": drawImage,
  "toggleBlockquote": toggleBlockquote,
  "toggleOrderedList": toggleOrderedList,
  "toggleUnorderedList": toggleUnorderedList,
  "toggleCodeBlock": toggleCodeBlock,
  "togglePreview": togglePreview,
  "toggleStrikethrough": toggleStrikethrough,
  "toggleHeading1": toggleHeading1,
  "toggleHeading2": toggleHeading2,
  "toggleHeading3": toggleHeading3,
  "cleanBlock": cleanBlock,
  "drawTable": drawTable,
  "drawHorizontalRule": drawHorizontalRule,
  "undo": undo,
  "redo": redo,
  "toggleSideBySide": toggleSideBySide,
  "toggleFullScreen": toggleFullScreen
};
var shortcuts = {
  "toggleBold": "Cmd-B",
  "toggleItalic": "Cmd-I",
  "drawLink": "Cmd-K",
  "toggleHeadingSmaller": "Cmd-H",
  "toggleHeadingBigger": "Shift-Cmd-H",
  "cleanBlock": "Cmd-E",
  "drawImage": "Cmd-Alt-I",
  "toggleBlockquote": "Cmd-'",
  "toggleOrderedList": "Cmd-Alt-L",
  "toggleUnorderedList": "Cmd-L",
  "toggleCodeBlock": "Cmd-Alt-C",
  "togglePreview": "Cmd-P",
  "toggleSideBySide": "F9",
  "toggleFullScreen": "F11"
};
var getBindingName = function(f2) {
  for (var key in bindings) {
    if (bindings[key] === f2) {
      return key;
    }
  }
  return null;
};
var isMobile = function() {
  var check2 = false;
  (function(a2) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a2.substr(0, 4)))
      check2 = true;
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check2;
};
function fixShortcut(name) {
  if (isMac) {
    name = name.replace("Ctrl", "Cmd");
  } else {
    name = name.replace("Cmd", "Ctrl");
  }
  return name;
}
function createIcon(options, enableTooltips, shortcuts2) {
  options = options || {};
  var el2 = document.createElement("a");
  enableTooltips = enableTooltips == void 0 ? true : enableTooltips;
  if (options.title && enableTooltips) {
    el2.title = createTootlip(options.title, options.action, shortcuts2);
    if (isMac) {
      el2.title = el2.title.replace("Ctrl", "\u2318");
      el2.title = el2.title.replace("Alt", "\u2325");
    }
  }
  el2.tabIndex = -1;
  el2.className = options.className;
  return el2;
}
function createSep() {
  var el2 = document.createElement("i");
  el2.className = "separator";
  el2.innerHTML = "|";
  return el2;
}
function createTootlip(title, action, shortcuts2) {
  var actionName;
  var tooltip = title;
  if (action) {
    actionName = getBindingName(action);
    if (shortcuts2[actionName]) {
      tooltip += " (" + fixShortcut(shortcuts2[actionName]) + ")";
    }
  }
  return tooltip;
}
function getState(cm, pos) {
  pos = pos || cm.getCursor("start");
  var stat = cm.getTokenAt(pos);
  if (!stat.type)
    return {};
  var types = stat.type.split(" ");
  var ret = {}, data2, text3;
  for (var i2 = 0; i2 < types.length; i2++) {
    data2 = types[i2];
    if (data2 === "strong") {
      ret.bold = true;
    } else if (data2 === "variable-2") {
      text3 = cm.getLine(pos.line);
      if (/^\s*\d+\.\s/.test(text3)) {
        ret["ordered-list"] = true;
      } else {
        ret["unordered-list"] = true;
      }
    } else if (data2 === "atom") {
      ret.quote = true;
    } else if (data2 === "em") {
      ret.italic = true;
    } else if (data2 === "quote") {
      ret.quote = true;
    } else if (data2 === "strikethrough") {
      ret.strikethrough = true;
    } else if (data2 === "comment") {
      ret.code = true;
    } else if (data2 === "link") {
      ret.link = true;
    } else if (data2 === "tag") {
      ret.image = true;
    } else if (data2.match(/^header(\-[1-6])?$/)) {
      ret[data2.replace("header", "heading")] = true;
    }
  }
  return ret;
}
var saved_overflow = "";
function toggleFullScreen(editor) {
  var cm = editor.codemirror;
  cm.setOption("fullScreen", !cm.getOption("fullScreen"));
  if (cm.getOption("fullScreen")) {
    saved_overflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";
  } else {
    document.body.style.overflow = saved_overflow;
  }
  var wrap2 = cm.getWrapperElement();
  if (!/fullscreen/.test(wrap2.previousSibling.className)) {
    wrap2.previousSibling.className += " fullscreen";
  } else {
    wrap2.previousSibling.className = wrap2.previousSibling.className.replace(/\s*fullscreen\b/, "");
  }
  var toolbarButton = editor.toolbarElements.fullscreen;
  if (!/active/.test(toolbarButton.className)) {
    toolbarButton.className += " active";
  } else {
    toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
  }
  var sidebyside = cm.getWrapperElement().nextSibling;
  if (/editor-preview-active-side/.test(sidebyside.className))
    toggleSideBySide(editor);
}
function toggleBold(editor) {
  _toggleBlock(editor, "bold", editor.options.blockStyles.bold);
}
function toggleItalic(editor) {
  _toggleBlock(editor, "italic", editor.options.blockStyles.italic);
}
function toggleStrikethrough(editor) {
  _toggleBlock(editor, "strikethrough", "~~");
}
function toggleCodeBlock(editor) {
  var fenceCharsToInsert = editor.options.blockStyles.code;
  function fencing_line(line3) {
    if (typeof line3 !== "object") {
      throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line3 + ": " + line3;
    }
    return line3.styles && line3.styles[2] && line3.styles[2].indexOf("formatting-code-block") !== -1;
  }
  function token_state(token2) {
    return token2.state.base.base || token2.state.base;
  }
  function code_type(cm2, line_num, line3, firstTok, lastTok) {
    line3 = line3 || cm2.getLineHandle(line_num);
    firstTok = firstTok || cm2.getTokenAt({
      line: line_num,
      ch: 1
    });
    lastTok = lastTok || !!line3.text && cm2.getTokenAt({
      line: line_num,
      ch: line3.text.length - 1
    });
    var types = firstTok.type ? firstTok.type.split(" ") : [];
    if (lastTok && token_state(lastTok).indentedCode) {
      return "indented";
    } else if (types.indexOf("comment") === -1) {
      return false;
    } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line3)) {
      return "fenced";
    } else {
      return "single";
    }
  }
  function insertFencingAtSelection(cm2, cur_start2, cur_end2, fenceCharsToInsert2) {
    var start_line_sel = cur_start2.line + 1, end_line_sel = cur_end2.line + 1, sel_multi2 = cur_start2.line !== cur_end2.line, repl_start = fenceCharsToInsert2 + "\n", repl_end = "\n" + fenceCharsToInsert2;
    if (sel_multi2) {
      end_line_sel++;
    }
    if (sel_multi2 && cur_end2.ch === 0) {
      repl_end = fenceCharsToInsert2 + "\n";
      end_line_sel--;
    }
    _replaceSelection(cm2, false, [repl_start, repl_end]);
    cm2.setSelection({
      line: start_line_sel,
      ch: 0
    }, {
      line: end_line_sel,
      ch: 0
    });
  }
  var cm = editor.codemirror, cur_start = cm.getCursor("start"), cur_end = cm.getCursor("end"), tok = cm.getTokenAt({
    line: cur_start.line,
    ch: cur_start.ch || 1
  }), line2 = cm.getLineHandle(cur_start.line), is_code = code_type(cm, cur_start.line, line2, tok);
  var block_start, block_end, lineCount;
  if (is_code === "single") {
    var start2 = line2.text.slice(0, cur_start.ch).replace("`", ""), end = line2.text.slice(cur_start.ch).replace("`", "");
    cm.replaceRange(start2 + end, {
      line: cur_start.line,
      ch: 0
    }, {
      line: cur_start.line,
      ch: 99999999999999
    });
    cur_start.ch--;
    if (cur_start !== cur_end) {
      cur_end.ch--;
    }
    cm.setSelection(cur_start, cur_end);
    cm.focus();
  } else if (is_code === "fenced") {
    if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
      for (block_start = cur_start.line; block_start >= 0; block_start--) {
        line2 = cm.getLineHandle(block_start);
        if (fencing_line(line2)) {
          break;
        }
      }
      var fencedTok = cm.getTokenAt({
        line: block_start,
        ch: 1
      });
      var fence_chars = token_state(fencedTok).fencedChars;
      var start_text, start_line;
      var end_text, end_line;
      if (fencing_line(cm.getLineHandle(cur_start.line))) {
        start_text = "";
        start_line = cur_start.line;
      } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {
        start_text = "";
        start_line = cur_start.line - 1;
      } else {
        start_text = fence_chars + "\n";
        start_line = cur_start.line;
      }
      if (fencing_line(cm.getLineHandle(cur_end.line))) {
        end_text = "";
        end_line = cur_end.line;
        if (cur_end.ch === 0) {
          end_line += 1;
        }
      } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
        end_text = "";
        end_line = cur_end.line + 1;
      } else {
        end_text = fence_chars + "\n";
        end_line = cur_end.line + 1;
      }
      if (cur_end.ch === 0) {
        end_line -= 1;
      }
      cm.operation(function() {
        cm.replaceRange(end_text, {
          line: end_line,
          ch: 0
        }, {
          line: end_line + (end_text ? 0 : 1),
          ch: 0
        });
        cm.replaceRange(start_text, {
          line: start_line,
          ch: 0
        }, {
          line: start_line + (start_text ? 0 : 1),
          ch: 0
        });
      });
      cm.setSelection({
        line: start_line + (start_text ? 1 : 0),
        ch: 0
      }, {
        line: end_line + (start_text ? 1 : -1),
        ch: 0
      });
      cm.focus();
    } else {
      var search_from = cur_start.line;
      if (fencing_line(cm.getLineHandle(cur_start.line))) {
        if (code_type(cm, cur_start.line + 1) === "fenced") {
          block_start = cur_start.line;
          search_from = cur_start.line + 1;
        } else {
          block_end = cur_start.line;
          search_from = cur_start.line - 1;
        }
      }
      if (block_start === void 0) {
        for (block_start = search_from; block_start >= 0; block_start--) {
          line2 = cm.getLineHandle(block_start);
          if (fencing_line(line2)) {
            break;
          }
        }
      }
      if (block_end === void 0) {
        lineCount = cm.lineCount();
        for (block_end = search_from; block_end < lineCount; block_end++) {
          line2 = cm.getLineHandle(block_end);
          if (fencing_line(line2)) {
            break;
          }
        }
      }
      cm.operation(function() {
        cm.replaceRange("", {
          line: block_start,
          ch: 0
        }, {
          line: block_start + 1,
          ch: 0
        });
        cm.replaceRange("", {
          line: block_end - 1,
          ch: 0
        }, {
          line: block_end,
          ch: 0
        });
      });
      cm.focus();
    }
  } else if (is_code === "indented") {
    if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
      block_start = cur_start.line;
      block_end = cur_end.line;
      if (cur_end.ch === 0) {
        block_end--;
      }
    } else {
      for (block_start = cur_start.line; block_start >= 0; block_start--) {
        line2 = cm.getLineHandle(block_start);
        if (line2.text.match(/^\s*$/)) {
          continue;
        } else {
          if (code_type(cm, block_start, line2) !== "indented") {
            block_start += 1;
            break;
          }
        }
      }
      lineCount = cm.lineCount();
      for (block_end = cur_start.line; block_end < lineCount; block_end++) {
        line2 = cm.getLineHandle(block_end);
        if (line2.text.match(/^\s*$/)) {
          continue;
        } else {
          if (code_type(cm, block_end, line2) !== "indented") {
            block_end -= 1;
            break;
          }
        }
      }
    }
    var next_line = cm.getLineHandle(block_end + 1), next_line_last_tok = next_line && cm.getTokenAt({
      line: block_end + 1,
      ch: next_line.text.length - 1
    }), next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
    if (next_line_indented) {
      cm.replaceRange("\n", {
        line: block_end + 1,
        ch: 0
      });
    }
    for (var i2 = block_start; i2 <= block_end; i2++) {
      cm.indentLine(i2, "subtract");
    }
    cm.focus();
  } else {
    var no_sel_and_starting_of_line = cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0;
    var sel_multi = cur_start.line !== cur_end.line;
    if (no_sel_and_starting_of_line || sel_multi) {
      insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
    } else {
      _replaceSelection(cm, false, ["`", "`"]);
    }
  }
}
function toggleBlockquote(editor) {
  var cm = editor.codemirror;
  _toggleLine(cm, "quote");
}
function toggleHeadingSmaller(editor) {
  var cm = editor.codemirror;
  _toggleHeading(cm, "smaller");
}
function toggleHeadingBigger(editor) {
  var cm = editor.codemirror;
  _toggleHeading(cm, "bigger");
}
function toggleHeading1(editor) {
  var cm = editor.codemirror;
  _toggleHeading(cm, void 0, 1);
}
function toggleHeading2(editor) {
  var cm = editor.codemirror;
  _toggleHeading(cm, void 0, 2);
}
function toggleHeading3(editor) {
  var cm = editor.codemirror;
  _toggleHeading(cm, void 0, 3);
}
function toggleUnorderedList(editor) {
  var cm = editor.codemirror;
  _toggleLine(cm, "unordered-list");
}
function toggleOrderedList(editor) {
  var cm = editor.codemirror;
  _toggleLine(cm, "ordered-list");
}
function cleanBlock(editor) {
  var cm = editor.codemirror;
  _cleanBlock(cm);
}
function drawLink(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);
  var options = editor.options;
  var url = "http://";
  if (options.promptURLs) {
    url = prompt(options.promptTexts.link);
    if (!url) {
      return false;
    }
  }
  _replaceSelection(cm, stat.link, options.insertTexts.link, url);
}
function drawImage(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);
  var options = editor.options;
  var url = "http://";
  if (options.promptURLs) {
    url = prompt(options.promptTexts.image);
    if (!url) {
      return false;
    }
  }
  _replaceSelection(cm, stat.image, options.insertTexts.image, url);
}
function drawTable(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);
  var options = editor.options;
  _replaceSelection(cm, stat.table, options.insertTexts.table);
}
function drawHorizontalRule(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);
  var options = editor.options;
  _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
}
function undo(editor) {
  var cm = editor.codemirror;
  cm.undo();
  cm.focus();
}
function redo(editor) {
  var cm = editor.codemirror;
  cm.redo();
  cm.focus();
}
function toggleSideBySide(editor) {
  var cm = editor.codemirror;
  var wrapper = cm.getWrapperElement();
  var preview = wrapper.nextSibling;
  var toolbarButton = editor.toolbarElements["side-by-side"];
  var useSideBySideListener = false;
  if (/editor-preview-active-side/.test(preview.className)) {
    preview.className = preview.className.replace(/\s*editor-preview-active-side\s*/g, "");
    toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
    wrapper.className = wrapper.className.replace(/\s*CodeMirror-sided\s*/g, " ");
  } else {
    setTimeout(function() {
      if (!cm.getOption("fullScreen"))
        toggleFullScreen(editor);
      preview.className += " editor-preview-active-side";
    }, 1);
    toolbarButton.className += " active";
    wrapper.className += " CodeMirror-sided";
    useSideBySideListener = true;
  }
  var previewNormal = wrapper.lastChild;
  if (/editor-preview-active/.test(previewNormal.className)) {
    previewNormal.className = previewNormal.className.replace(/\s*editor-preview-active\s*/g, "");
    var toolbar = editor.toolbarElements.preview;
    var toolbar_div = wrapper.previousSibling;
    toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
    toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
  }
  var sideBySideRenderingFunction = function() {
    preview.innerHTML = editor.options.previewRender(editor.value(), preview);
  };
  if (!cm.sideBySideRenderingFunction) {
    cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
  }
  if (useSideBySideListener) {
    preview.innerHTML = editor.options.previewRender(editor.value(), preview);
    cm.on("update", cm.sideBySideRenderingFunction);
  } else {
    cm.off("update", cm.sideBySideRenderingFunction);
  }
  cm.refresh();
}
function togglePreview(editor) {
  var cm = editor.codemirror;
  var wrapper = cm.getWrapperElement();
  var toolbar_div = wrapper.previousSibling;
  var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
  var preview = wrapper.lastChild;
  if (!preview || !/editor-preview/.test(preview.className)) {
    preview = document.createElement("div");
    preview.className = "editor-preview";
    wrapper.appendChild(preview);
  }
  if (/editor-preview-active/.test(preview.className)) {
    preview.className = preview.className.replace(/\s*editor-preview-active\s*/g, "");
    if (toolbar) {
      toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
      toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
    }
  } else {
    setTimeout(function() {
      preview.className += " editor-preview-active";
    }, 1);
    if (toolbar) {
      toolbar.className += " active";
      toolbar_div.className += " disabled-for-preview";
    }
  }
  preview.innerHTML = editor.options.previewRender(editor.value(), preview);
  var sidebyside = cm.getWrapperElement().nextSibling;
  if (/editor-preview-active-side/.test(sidebyside.className))
    toggleSideBySide(editor);
}
function _replaceSelection(cm, active, startEnd, url) {
  if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
    return;
  var text3;
  var start2 = startEnd[0];
  var end = startEnd[1];
  var startPoint = cm.getCursor("start");
  var endPoint = cm.getCursor("end");
  if (url) {
    end = end.replace("#url#", url);
  }
  if (active) {
    text3 = cm.getLine(startPoint.line);
    start2 = text3.slice(0, startPoint.ch);
    end = text3.slice(startPoint.ch);
    cm.replaceRange(start2 + end, {
      line: startPoint.line,
      ch: 0
    });
  } else {
    text3 = cm.getSelection();
    cm.replaceSelection(start2 + text3 + end);
    startPoint.ch += start2.length;
    if (startPoint !== endPoint) {
      endPoint.ch += start2.length;
    }
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}
function _toggleHeading(cm, direction, size2) {
  if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
    return;
  var startPoint = cm.getCursor("start");
  var endPoint = cm.getCursor("end");
  for (var i2 = startPoint.line; i2 <= endPoint.line; i2++) {
    (function(i3) {
      var text3 = cm.getLine(i3);
      var currHeadingLevel = text3.search(/[^#]/);
      if (direction !== void 0) {
        if (currHeadingLevel <= 0) {
          if (direction == "bigger") {
            text3 = "###### " + text3;
          } else {
            text3 = "# " + text3;
          }
        } else if (currHeadingLevel == 6 && direction == "smaller") {
          text3 = text3.substr(7);
        } else if (currHeadingLevel == 1 && direction == "bigger") {
          text3 = text3.substr(2);
        } else {
          if (direction == "bigger") {
            text3 = text3.substr(1);
          } else {
            text3 = "#" + text3;
          }
        }
      } else {
        if (size2 == 1) {
          if (currHeadingLevel <= 0) {
            text3 = "# " + text3;
          } else if (currHeadingLevel == size2) {
            text3 = text3.substr(currHeadingLevel + 1);
          } else {
            text3 = "# " + text3.substr(currHeadingLevel + 1);
          }
        } else if (size2 == 2) {
          if (currHeadingLevel <= 0) {
            text3 = "## " + text3;
          } else if (currHeadingLevel == size2) {
            text3 = text3.substr(currHeadingLevel + 1);
          } else {
            text3 = "## " + text3.substr(currHeadingLevel + 1);
          }
        } else {
          if (currHeadingLevel <= 0) {
            text3 = "### " + text3;
          } else if (currHeadingLevel == size2) {
            text3 = text3.substr(currHeadingLevel + 1);
          } else {
            text3 = "### " + text3.substr(currHeadingLevel + 1);
          }
        }
      }
      cm.replaceRange(text3, {
        line: i3,
        ch: 0
      }, {
        line: i3,
        ch: 99999999999999
      });
    })(i2);
  }
  cm.focus();
}
function _toggleLine(cm, name) {
  if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
    return;
  var stat = getState(cm);
  var startPoint = cm.getCursor("start");
  var endPoint = cm.getCursor("end");
  var repl = {
    "quote": /^(\s*)\>\s+/,
    "unordered-list": /^(\s*)(\*|\-|\+)\s+/,
    "ordered-list": /^(\s*)\d+\.\s+/
  };
  var map2 = {
    "quote": "> ",
    "unordered-list": "* ",
    "ordered-list": "1. "
  };
  for (var i2 = startPoint.line; i2 <= endPoint.line; i2++) {
    (function(i3) {
      var text3 = cm.getLine(i3);
      if (stat[name]) {
        text3 = text3.replace(repl[name], "$1");
      } else {
        text3 = map2[name] + text3;
      }
      cm.replaceRange(text3, {
        line: i3,
        ch: 0
      }, {
        line: i3,
        ch: 99999999999999
      });
    })(i2);
  }
  cm.focus();
}
function _toggleBlock(editor, type, start_chars, end_chars) {
  if (/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))
    return;
  end_chars = typeof end_chars === "undefined" ? start_chars : end_chars;
  var cm = editor.codemirror;
  var stat = getState(cm);
  var text3;
  var start2 = start_chars;
  var end = end_chars;
  var startPoint = cm.getCursor("start");
  var endPoint = cm.getCursor("end");
  if (stat[type]) {
    text3 = cm.getLine(startPoint.line);
    start2 = text3.slice(0, startPoint.ch);
    end = text3.slice(startPoint.ch);
    if (type == "bold") {
      start2 = start2.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
      end = end.replace(/(\*\*|__)/, "");
    } else if (type == "italic") {
      start2 = start2.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
      end = end.replace(/(\*|_)/, "");
    } else if (type == "strikethrough") {
      start2 = start2.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
      end = end.replace(/(\*\*|~~)/, "");
    }
    cm.replaceRange(start2 + end, {
      line: startPoint.line,
      ch: 0
    }, {
      line: startPoint.line,
      ch: 99999999999999
    });
    if (type == "bold" || type == "strikethrough") {
      startPoint.ch -= 2;
      if (startPoint !== endPoint) {
        endPoint.ch -= 2;
      }
    } else if (type == "italic") {
      startPoint.ch -= 1;
      if (startPoint !== endPoint) {
        endPoint.ch -= 1;
      }
    }
  } else {
    text3 = cm.getSelection();
    if (type == "bold") {
      text3 = text3.split("**").join("");
      text3 = text3.split("__").join("");
    } else if (type == "italic") {
      text3 = text3.split("*").join("");
      text3 = text3.split("_").join("");
    } else if (type == "strikethrough") {
      text3 = text3.split("~~").join("");
    }
    cm.replaceSelection(start2 + text3 + end);
    startPoint.ch += start_chars.length;
    endPoint.ch = startPoint.ch + text3.length;
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}
function _cleanBlock(cm) {
  if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
    return;
  var startPoint = cm.getCursor("start");
  var endPoint = cm.getCursor("end");
  var text3;
  for (var line2 = startPoint.line; line2 <= endPoint.line; line2++) {
    text3 = cm.getLine(line2);
    text3 = text3.replace(/^[ ]*([# ]+|\*|\-|[> ]+|[0-9]+(.|\)))[ ]*/, "");
    cm.replaceRange(text3, {
      line: line2,
      ch: 0
    }, {
      line: line2,
      ch: 99999999999999
    });
  }
}
function _mergeProperties(target2, source) {
  for (var property in source) {
    if (source.hasOwnProperty(property)) {
      if (source[property] instanceof Array) {
        target2[property] = source[property].concat(target2[property] instanceof Array ? target2[property] : []);
      } else if (source[property] !== null && typeof source[property] === "object" && source[property].constructor === Object) {
        target2[property] = _mergeProperties(target2[property] || {}, source[property]);
      } else {
        target2[property] = source[property];
      }
    }
  }
  return target2;
}
function extend$1(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    target2 = _mergeProperties(target2, arguments[i2]);
  }
  return target2;
}
function wordCount(data2) {
  var pattern = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
  var m2 = data2.match(pattern);
  var count2 = 0;
  if (m2 === null)
    return count2;
  for (var i2 = 0; i2 < m2.length; i2++) {
    if (m2[i2].charCodeAt(0) >= 19968) {
      count2 += m2[i2].length;
    } else {
      count2 += 1;
    }
  }
  return count2;
}
var toolbarBuiltInButtons = {
  "bold": {
    name: "bold",
    action: toggleBold,
    className: "fa fa-bold",
    title: "Bold",
    default: true
  },
  "italic": {
    name: "italic",
    action: toggleItalic,
    className: "fa fa-italic",
    title: "Italic",
    default: true
  },
  "strikethrough": {
    name: "strikethrough",
    action: toggleStrikethrough,
    className: "fa fa-strikethrough",
    title: "Strikethrough"
  },
  "heading": {
    name: "heading",
    action: toggleHeadingSmaller,
    className: "fa fa-header",
    title: "Heading",
    default: true
  },
  "heading-smaller": {
    name: "heading-smaller",
    action: toggleHeadingSmaller,
    className: "fa fa-header fa-header-x fa-header-smaller",
    title: "Smaller Heading"
  },
  "heading-bigger": {
    name: "heading-bigger",
    action: toggleHeadingBigger,
    className: "fa fa-header fa-header-x fa-header-bigger",
    title: "Bigger Heading"
  },
  "heading-1": {
    name: "heading-1",
    action: toggleHeading1,
    className: "fa fa-header fa-header-x fa-header-1",
    title: "Big Heading"
  },
  "heading-2": {
    name: "heading-2",
    action: toggleHeading2,
    className: "fa fa-header fa-header-x fa-header-2",
    title: "Medium Heading"
  },
  "heading-3": {
    name: "heading-3",
    action: toggleHeading3,
    className: "fa fa-header fa-header-x fa-header-3",
    title: "Small Heading"
  },
  "separator-1": {
    name: "separator-1"
  },
  "code": {
    name: "code",
    action: toggleCodeBlock,
    className: "fa fa-code",
    title: "Code"
  },
  "quote": {
    name: "quote",
    action: toggleBlockquote,
    className: "fa fa-quote-left",
    title: "Quote",
    default: true
  },
  "unordered-list": {
    name: "unordered-list",
    action: toggleUnorderedList,
    className: "fa fa-list-ul",
    title: "Generic List",
    default: true
  },
  "ordered-list": {
    name: "ordered-list",
    action: toggleOrderedList,
    className: "fa fa-list-ol",
    title: "Numbered List",
    default: true
  },
  "clean-block": {
    name: "clean-block",
    action: cleanBlock,
    className: "fa fa-eraser fa-clean-block",
    title: "Clean block"
  },
  "separator-2": {
    name: "separator-2"
  },
  "link": {
    name: "link",
    action: drawLink,
    className: "fa fa-link",
    title: "Create Link",
    default: true
  },
  "image": {
    name: "image",
    action: drawImage,
    className: "fa fa-picture-o",
    title: "Insert Image",
    default: true
  },
  "table": {
    name: "table",
    action: drawTable,
    className: "fa fa-table",
    title: "Insert Table"
  },
  "horizontal-rule": {
    name: "horizontal-rule",
    action: drawHorizontalRule,
    className: "fa fa-minus",
    title: "Insert Horizontal Line"
  },
  "separator-3": {
    name: "separator-3"
  },
  "preview": {
    name: "preview",
    action: togglePreview,
    className: "fa fa-eye no-disable",
    title: "Toggle Preview",
    default: true
  },
  "side-by-side": {
    name: "side-by-side",
    action: toggleSideBySide,
    className: "fa fa-columns no-disable no-mobile",
    title: "Toggle Side by Side",
    default: true
  },
  "fullscreen": {
    name: "fullscreen",
    action: toggleFullScreen,
    className: "fa fa-arrows-alt no-disable no-mobile",
    title: "Toggle Fullscreen",
    default: true
  },
  "separator-4": {
    name: "separator-4"
  },
  "guide": {
    name: "guide",
    action: "https://simplemde.com/markdown-guide",
    className: "fa fa-question-circle",
    title: "Markdown Guide",
    default: true
  },
  "separator-5": {
    name: "separator-5"
  },
  "undo": {
    name: "undo",
    action: undo,
    className: "fa fa-undo no-disable",
    title: "Undo"
  },
  "redo": {
    name: "redo",
    action: redo,
    className: "fa fa-repeat no-disable",
    title: "Redo"
  }
};
var insertTexts = {
  link: ["[", "](#url#)"],
  image: ["![](", "#url#)"],
  table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
  horizontalRule: ["", "\n\n-----\n\n"]
};
var promptTexts = {
  link: "URL for the link:",
  image: "URL of the image:"
};
var blockStyles = {
  "bold": "**",
  "code": "```",
  "italic": "*"
};
function SimpleMDE(options) {
  options = options || {};
  options.parent = this;
  var autoDownloadFA = true;
  if (options.autoDownloadFontAwesome === false) {
    autoDownloadFA = false;
  }
  if (options.autoDownloadFontAwesome !== true) {
    var styleSheets = document.styleSheets;
    for (var i2 = 0; i2 < styleSheets.length; i2++) {
      if (!styleSheets[i2].href)
        continue;
      if (styleSheets[i2].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1) {
        autoDownloadFA = false;
      }
    }
  }
  if (autoDownloadFA) {
    var link3 = document.createElement("link");
    link3.rel = "stylesheet";
    link3.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css";
    document.getElementsByTagName("head")[0].appendChild(link3);
  }
  if (options.element) {
    this.element = options.element;
  } else if (options.element === null) {
    console.log("SimpleMDE: Error. No element was found.");
    return;
  }
  if (options.toolbar === void 0) {
    options.toolbar = [];
    for (var key in toolbarBuiltInButtons) {
      if (toolbarBuiltInButtons.hasOwnProperty(key)) {
        if (key.indexOf("separator-") != -1) {
          options.toolbar.push("|");
        }
        if (toolbarBuiltInButtons[key].default === true || options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1) {
          options.toolbar.push(key);
        }
      }
    }
  }
  if (!options.hasOwnProperty("status")) {
    options.status = ["autosave", "lines", "words", "cursor"];
  }
  if (!options.previewRender) {
    options.previewRender = function(plainText) {
      return this.parent.markdown(plainText);
    };
  }
  options.parsingConfig = extend$1({
    highlightFormatting: true
  }, options.parsingConfig || {});
  options.insertTexts = extend$1({}, insertTexts, options.insertTexts || {});
  options.promptTexts = promptTexts;
  options.blockStyles = extend$1({}, blockStyles, options.blockStyles || {});
  options.shortcuts = extend$1({}, shortcuts, options.shortcuts || {});
  if (options.autosave != void 0 && options.autosave.unique_id != void 0 && options.autosave.unique_id != "")
    options.autosave.uniqueId = options.autosave.unique_id;
  this.options = options;
  this.render();
  if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
    this.value(options.initialValue);
  }
}
SimpleMDE.prototype.markdown = function(text3) {
  if (marked) {
    var markedOptions = {};
    if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
      markedOptions.breaks = false;
    } else {
      markedOptions.breaks = true;
    }
    if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true && window.hljs) {
      markedOptions.highlight = function(code3) {
        return window.hljs.highlightAuto(code3).value;
      };
    }
    marked.setOptions(markedOptions);
    return marked(text3);
  }
};
SimpleMDE.prototype.render = function(el2) {
  if (!el2) {
    el2 = this.element || document.getElementsByTagName("textarea")[0];
  }
  if (this._rendered && this._rendered === el2) {
    return;
  }
  this.element = el2;
  var options = this.options;
  var self2 = this;
  var keyMaps = {};
  for (var key in options.shortcuts) {
    if (options.shortcuts[key] !== null && bindings[key] !== null) {
      (function(key2) {
        keyMaps[fixShortcut(options.shortcuts[key2])] = function() {
          bindings[key2](self2);
        };
      })(key);
    }
  }
  keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";
  keyMaps["Tab"] = "tabAndIndentMarkdownList";
  keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";
  keyMaps["Esc"] = function(cm2) {
    if (cm2.getOption("fullScreen"))
      toggleFullScreen(self2);
  };
  document.addEventListener("keydown", function(e2) {
    e2 = e2 || window.event;
    if (e2.keyCode == 27) {
      if (self2.codemirror.getOption("fullScreen"))
        toggleFullScreen(self2);
    }
  }, false);
  var mode, backdrop;
  if (options.spellChecker !== false) {
    mode = "spell-checker";
    backdrop = options.parsingConfig;
    backdrop.name = "gfm";
    backdrop.gitHubSpice = false;
    CodeMirrorSpellChecker({
      codeMirrorInstance: CodeMirror
    });
  } else {
    mode = options.parsingConfig;
    mode.name = "gfm";
    mode.gitHubSpice = false;
  }
  this.codemirror = CodeMirror.fromTextArea(el2, {
    mode,
    backdrop,
    theme: "paper",
    tabSize: options.tabSize != void 0 ? options.tabSize : 2,
    indentUnit: options.tabSize != void 0 ? options.tabSize : 2,
    indentWithTabs: options.indentWithTabs === false ? false : true,
    lineNumbers: false,
    autofocus: options.autofocus === true ? true : false,
    extraKeys: keyMaps,
    lineWrapping: options.lineWrapping === false ? false : true,
    allowDropFileTypes: ["text/plain"],
    placeholder: options.placeholder || el2.getAttribute("placeholder") || "",
    styleSelectedText: options.styleSelectedText != void 0 ? options.styleSelectedText : true
  });
  if (options.forceSync === true) {
    var cm = this.codemirror;
    cm.on("change", function() {
      cm.save();
    });
  }
  this.gui = {};
  if (options.toolbar !== false) {
    this.gui.toolbar = this.createToolbar();
  }
  if (options.status !== false) {
    this.gui.statusbar = this.createStatusbar();
  }
  if (options.autosave != void 0 && options.autosave.enabled === true) {
    this.autosave();
  }
  this.gui.sideBySide = this.createSideBySide();
  this._rendered = this.element;
  var temp_cm = this.codemirror;
  setTimeout(function() {
    temp_cm.refresh();
  }.bind(temp_cm), 0);
};
function isLocalStorageAvailable() {
  if (typeof localStorage === "object") {
    try {
      localStorage.setItem("smde_localStorage", 1);
      localStorage.removeItem("smde_localStorage");
    } catch (e2) {
      return false;
    }
  } else {
    return false;
  }
  return true;
}
SimpleMDE.prototype.autosave = function() {
  if (isLocalStorageAvailable()) {
    var simplemde2 = this;
    if (this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
      console.log("SimpleMDE: You must set a uniqueId to use the autosave feature");
      return;
    }
    if (simplemde2.element.form != null && simplemde2.element.form != void 0) {
      simplemde2.element.form.addEventListener("submit", function() {
        localStorage.removeItem("smde_" + simplemde2.options.autosave.uniqueId);
      });
    }
    if (this.options.autosave.loaded !== true) {
      if (typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" && localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {
        this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));
        this.options.autosave.foundSavedValue = true;
      }
      this.options.autosave.loaded = true;
    }
    localStorage.setItem("smde_" + this.options.autosave.uniqueId, simplemde2.value());
    var el2 = document.getElementById("autosaved");
    if (el2 != null && el2 != void 0 && el2 != "") {
      var d2 = new Date();
      var hh = d2.getHours();
      var m2 = d2.getMinutes();
      var dd2 = "am";
      var h2 = hh;
      if (h2 >= 12) {
        h2 = hh - 12;
        dd2 = "pm";
      }
      if (h2 == 0) {
        h2 = 12;
      }
      m2 = m2 < 10 ? "0" + m2 : m2;
      el2.innerHTML = "Autosaved: " + h2 + ":" + m2 + " " + dd2;
    }
    this.autosaveTimeoutId = setTimeout(function() {
      simplemde2.autosave();
    }, this.options.autosave.delay || 1e4);
  } else {
    console.log("SimpleMDE: localStorage not available, cannot autosave");
  }
};
SimpleMDE.prototype.clearAutosavedValue = function() {
  if (isLocalStorageAvailable()) {
    if (this.options.autosave == void 0 || this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
      console.log("SimpleMDE: You must set a uniqueId to clear the autosave value");
      return;
    }
    localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
  } else {
    console.log("SimpleMDE: localStorage not available, cannot autosave");
  }
};
SimpleMDE.prototype.createSideBySide = function() {
  var cm = this.codemirror;
  var wrapper = cm.getWrapperElement();
  var preview = wrapper.nextSibling;
  if (!preview || !/editor-preview-side/.test(preview.className)) {
    preview = document.createElement("div");
    preview.className = "editor-preview-side";
    wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);
  }
  var cScroll = false;
  var pScroll = false;
  cm.on("scroll", function(v2) {
    if (cScroll) {
      cScroll = false;
      return;
    }
    pScroll = true;
    var height = v2.getScrollInfo().height - v2.getScrollInfo().clientHeight;
    var ratio2 = parseFloat(v2.getScrollInfo().top) / height;
    var move = (preview.scrollHeight - preview.clientHeight) * ratio2;
    preview.scrollTop = move;
  });
  preview.onscroll = function() {
    if (pScroll) {
      pScroll = false;
      return;
    }
    cScroll = true;
    var height = preview.scrollHeight - preview.clientHeight;
    var ratio2 = parseFloat(preview.scrollTop) / height;
    var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio2;
    cm.scrollTo(0, move);
  };
  return preview;
};
SimpleMDE.prototype.createToolbar = function(items) {
  items = items || this.options.toolbar;
  if (!items || items.length === 0) {
    return;
  }
  var i2;
  for (i2 = 0; i2 < items.length; i2++) {
    if (toolbarBuiltInButtons[items[i2]] != void 0) {
      items[i2] = toolbarBuiltInButtons[items[i2]];
    }
  }
  var bar = document.createElement("div");
  bar.className = "editor-toolbar";
  var self2 = this;
  var toolbarData = {};
  self2.toolbar = items;
  for (i2 = 0; i2 < items.length; i2++) {
    if (items[i2].name == "guide" && self2.options.toolbarGuideIcon === false)
      continue;
    if (self2.options.hideIcons && self2.options.hideIcons.indexOf(items[i2].name) != -1)
      continue;
    if ((items[i2].name == "fullscreen" || items[i2].name == "side-by-side") && isMobile())
      continue;
    if (items[i2] === "|") {
      var nonSeparatorIconsFollow = false;
      for (var x2 = i2 + 1; x2 < items.length; x2++) {
        if (items[x2] !== "|" && (!self2.options.hideIcons || self2.options.hideIcons.indexOf(items[x2].name) == -1)) {
          nonSeparatorIconsFollow = true;
        }
      }
      if (!nonSeparatorIconsFollow)
        continue;
    }
    (function(item) {
      var el2;
      if (item === "|") {
        el2 = createSep();
      } else {
        el2 = createIcon(item, self2.options.toolbarTips, self2.options.shortcuts);
      }
      if (item.action) {
        if (typeof item.action === "function") {
          el2.onclick = function(e2) {
            e2.preventDefault();
            item.action(self2);
          };
        } else if (typeof item.action === "string") {
          el2.href = item.action;
          el2.target = "_blank";
        }
      }
      toolbarData[item.name || item] = el2;
      bar.appendChild(el2);
    })(items[i2]);
  }
  self2.toolbarElements = toolbarData;
  var cm = this.codemirror;
  cm.on("cursorActivity", function() {
    var stat = getState(cm);
    for (var key in toolbarData) {
      (function(key2) {
        var el2 = toolbarData[key2];
        if (stat[key2]) {
          el2.className += " active";
        } else if (key2 != "fullscreen" && key2 != "side-by-side") {
          el2.className = el2.className.replace(/\s*active\s*/g, "");
        }
      })(key);
    }
  });
  var cmWrapper = cm.getWrapperElement();
  cmWrapper.parentNode.insertBefore(bar, cmWrapper);
  return bar;
};
SimpleMDE.prototype.createStatusbar = function(status) {
  status = status || this.options.status;
  var options = this.options;
  var cm = this.codemirror;
  if (!status || status.length === 0)
    return;
  var items = [];
  var i2, onUpdate, defaultValue;
  for (i2 = 0; i2 < status.length; i2++) {
    onUpdate = void 0;
    defaultValue = void 0;
    if (typeof status[i2] === "object") {
      items.push({
        className: status[i2].className,
        defaultValue: status[i2].defaultValue,
        onUpdate: status[i2].onUpdate
      });
    } else {
      var name = status[i2];
      if (name === "words") {
        defaultValue = function(el3) {
          el3.innerHTML = wordCount(cm.getValue());
        };
        onUpdate = function(el3) {
          el3.innerHTML = wordCount(cm.getValue());
        };
      } else if (name === "lines") {
        defaultValue = function(el3) {
          el3.innerHTML = cm.lineCount();
        };
        onUpdate = function(el3) {
          el3.innerHTML = cm.lineCount();
        };
      } else if (name === "cursor") {
        defaultValue = function(el3) {
          el3.innerHTML = "0:0";
        };
        onUpdate = function(el3) {
          var pos = cm.getCursor();
          el3.innerHTML = pos.line + ":" + pos.ch;
        };
      } else if (name === "autosave") {
        defaultValue = function(el3) {
          if (options.autosave != void 0 && options.autosave.enabled === true) {
            el3.setAttribute("id", "autosaved");
          }
        };
      }
      items.push({
        className: name,
        defaultValue,
        onUpdate
      });
    }
  }
  var bar = document.createElement("div");
  bar.className = "editor-statusbar";
  for (i2 = 0; i2 < items.length; i2++) {
    var item = items[i2];
    var el2 = document.createElement("span");
    el2.className = item.className;
    if (typeof item.defaultValue === "function") {
      item.defaultValue(el2);
    }
    if (typeof item.onUpdate === "function") {
      this.codemirror.on("update", function(el3, item2) {
        return function() {
          item2.onUpdate(el3);
        };
      }(el2, item));
    }
    bar.appendChild(el2);
  }
  var cmWrapper = this.codemirror.getWrapperElement();
  cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
  return bar;
};
SimpleMDE.prototype.value = function(val) {
  if (val === void 0) {
    return this.codemirror.getValue();
  } else {
    this.codemirror.getDoc().setValue(val);
    return this;
  }
};
SimpleMDE.toggleBold = toggleBold;
SimpleMDE.toggleItalic = toggleItalic;
SimpleMDE.toggleStrikethrough = toggleStrikethrough;
SimpleMDE.toggleBlockquote = toggleBlockquote;
SimpleMDE.toggleHeadingSmaller = toggleHeadingSmaller;
SimpleMDE.toggleHeadingBigger = toggleHeadingBigger;
SimpleMDE.toggleHeading1 = toggleHeading1;
SimpleMDE.toggleHeading2 = toggleHeading2;
SimpleMDE.toggleHeading3 = toggleHeading3;
SimpleMDE.toggleCodeBlock = toggleCodeBlock;
SimpleMDE.toggleUnorderedList = toggleUnorderedList;
SimpleMDE.toggleOrderedList = toggleOrderedList;
SimpleMDE.cleanBlock = cleanBlock;
SimpleMDE.drawLink = drawLink;
SimpleMDE.drawImage = drawImage;
SimpleMDE.drawTable = drawTable;
SimpleMDE.drawHorizontalRule = drawHorizontalRule;
SimpleMDE.undo = undo;
SimpleMDE.redo = redo;
SimpleMDE.togglePreview = togglePreview;
SimpleMDE.toggleSideBySide = toggleSideBySide;
SimpleMDE.toggleFullScreen = toggleFullScreen;
SimpleMDE.prototype.toggleBold = function() {
  toggleBold(this);
};
SimpleMDE.prototype.toggleItalic = function() {
  toggleItalic(this);
};
SimpleMDE.prototype.toggleStrikethrough = function() {
  toggleStrikethrough(this);
};
SimpleMDE.prototype.toggleBlockquote = function() {
  toggleBlockquote(this);
};
SimpleMDE.prototype.toggleHeadingSmaller = function() {
  toggleHeadingSmaller(this);
};
SimpleMDE.prototype.toggleHeadingBigger = function() {
  toggleHeadingBigger(this);
};
SimpleMDE.prototype.toggleHeading1 = function() {
  toggleHeading1(this);
};
SimpleMDE.prototype.toggleHeading2 = function() {
  toggleHeading2(this);
};
SimpleMDE.prototype.toggleHeading3 = function() {
  toggleHeading3(this);
};
SimpleMDE.prototype.toggleCodeBlock = function() {
  toggleCodeBlock(this);
};
SimpleMDE.prototype.toggleUnorderedList = function() {
  toggleUnorderedList(this);
};
SimpleMDE.prototype.toggleOrderedList = function() {
  toggleOrderedList(this);
};
SimpleMDE.prototype.cleanBlock = function() {
  cleanBlock(this);
};
SimpleMDE.prototype.drawLink = function() {
  drawLink(this);
};
SimpleMDE.prototype.drawImage = function() {
  drawImage(this);
};
SimpleMDE.prototype.drawTable = function() {
  drawTable(this);
};
SimpleMDE.prototype.drawHorizontalRule = function() {
  drawHorizontalRule(this);
};
SimpleMDE.prototype.undo = function() {
  undo(this);
};
SimpleMDE.prototype.redo = function() {
  redo(this);
};
SimpleMDE.prototype.togglePreview = function() {
  togglePreview(this);
};
SimpleMDE.prototype.toggleSideBySide = function() {
  toggleSideBySide(this);
};
SimpleMDE.prototype.toggleFullScreen = function() {
  toggleFullScreen(this);
};
SimpleMDE.prototype.isPreviewActive = function() {
  var cm = this.codemirror;
  var wrapper = cm.getWrapperElement();
  var preview = wrapper.lastChild;
  return /editor-preview-active/.test(preview.className);
};
SimpleMDE.prototype.isSideBySideActive = function() {
  var cm = this.codemirror;
  var wrapper = cm.getWrapperElement();
  var preview = wrapper.nextSibling;
  return /editor-preview-active-side/.test(preview.className);
};
SimpleMDE.prototype.isFullscreenActive = function() {
  var cm = this.codemirror;
  return cm.getOption("fullScreen");
};
SimpleMDE.prototype.getState = function() {
  var cm = this.codemirror;
  return getState(cm);
};
SimpleMDE.prototype.toTextArea = function() {
  var cm = this.codemirror;
  var wrapper = cm.getWrapperElement();
  if (wrapper.parentNode) {
    if (this.gui.toolbar) {
      wrapper.parentNode.removeChild(this.gui.toolbar);
    }
    if (this.gui.statusbar) {
      wrapper.parentNode.removeChild(this.gui.statusbar);
    }
    if (this.gui.sideBySide) {
      wrapper.parentNode.removeChild(this.gui.sideBySide);
    }
  }
  cm.toTextArea();
  if (this.autosaveTimeoutId) {
    clearTimeout(this.autosaveTimeoutId);
    this.autosaveTimeoutId = void 0;
    this.clearAutosavedValue();
  }
};
var simplemde = SimpleMDE;
var simplemde_min = "";
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns")
    name = name.slice(i2 + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
      if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group[i2]) {
        subgroups.push(select2.call(node, node.__data__, i2, group));
        parents.push(node);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find$1 = Array.prototype.find;
function childFind(match5) {
  return function() {
    return find$1.call(this.children, match5);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match5) {
  return this.select(match5 == null ? childFirst : childFind(typeof match5 === "function" ? match5 : childMatcher(match5)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match5) {
  return function() {
    return filter.call(this.children, match5);
  };
}
function selection_selectChildren(match5) {
  return this.selectAll(match5 == null ? children : childrenFilter(typeof match5 === "function" ? match5 : childMatcher(match5)));
}
function selection_filter(match5) {
  if (typeof match5 !== "function")
    match5 = matcher(match5);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node, i2 = 0; i2 < n2; ++i2) {
      if ((node = group[i2]) && match5.call(node, node.__data__, i2, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update3) {
  return new Array(update3.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$4(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update3, exit, data2) {
  var i2 = 0, node, groupLength = group.length, dataLength = data2.length;
  for (; i2 < dataLength; ++i2) {
    if (node = group[i2]) {
      node.__data__ = data2[i2];
      update3[i2] = node;
    } else {
      enter[i2] = new EnterNode(parent, data2[i2]);
    }
  }
  for (; i2 < groupLength; ++i2) {
    if (node = group[i2]) {
      exit[i2] = node;
    }
  }
}
function bindKey(parent, group, enter, update3, exit, data2, key) {
  var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2) {
    if (node = group[i2]) {
      keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i2] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i2 = 0; i2 < dataLength; ++i2) {
    keyValue = key.call(parent, data2[i2], i2, data2) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update3[i2] = node;
      node.__data__ = data2[i2];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i2] = new EnterNode(parent, data2[i2]);
    }
  }
  for (i2 = 0; i2 < groupLength; ++i2) {
    if ((node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
      exit[i2] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$4(value);
  for (var m2 = groups.length, update3 = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    var parent = parents[j2], group = groups[j2], groupLength = group.length, data2 = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data2.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update3[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind2(parent, group, enterGroup, updateGroup, exitGroup, data2, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update3 = new Selection$1(update3, parents);
  update3._enter = enter;
  update3._exit = exit;
  return update3;
}
function arraylike(data2) {
  return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update3 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update3 = onupdate(update3);
    if (update3)
      update3 = update3.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update3 ? enter.merge(update3).order() : update3;
}
function selection_merge(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge = merges[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge[i2] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; ) {
    for (var group = groups[j2], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; ) {
      if (node = group[i2]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a2, b2) {
    return a2 && b2 ? compare(a2.__data__, b2.__data__) : !a2 - !b2;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, sortgroup = sortgroups[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group[i2]) {
        sortgroup[i2] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
    for (var group = groups[j2], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
      var node = group[i2];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size() {
  let size2 = 0;
  for (const node of this)
    ++size2;
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
    for (var group = groups[j2], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
      if (node = group[i2])
        callback.call(node, node.__data__, i2, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v2);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v2, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      delete this[name];
    else
      this[name] = v2;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 >= 0) {
      this._names.splice(i2, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list3 = classList(node), i2 = -1, n2 = names.length;
  while (++i2 < n2)
    list3.add(names[i2]);
}
function classedRemove(node, names) {
  var list3 = classList(node), i2 = -1, n2 = names.length;
  while (++i2 < n2)
    list3.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list3 = classList(this.node()), i2 = -1, n2 = names.length;
    while (++i2 < n2)
      if (!list3.contains(names[i2]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove$1() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove$1);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$1(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0)
      name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    return { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j2 = 0, i2 = -1, m2 = on.length, o2; j2 < m2; ++j2) {
      if (o2 = on[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on[++i2] = o2;
      }
    }
    if (++i2)
      on.length = i2;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o2, listener = contextListener(value);
    if (on)
      for (var j2 = 0, m2 = on.length; j2 < m2; ++j2) {
        if ((o2 = on[j2]).type === typename.type && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
          this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
          o2.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o2 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o2];
    else
      on.push(o2);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames$1(typename + ""), i2, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j2 = 0, m2 = on.length, o2; j2 < m2; ++j2) {
        for (i2 = 0, o2 = on[j2]; i2 < n2; ++i2) {
          if ((t2 = typenames[i2]).type === o2.type && t2.name === o2.name) {
            return o2.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i2 = 0; i2 < n2; ++i2)
    this.each(on(typenames[i2], value, options));
  return this;
}
function dispatchEvent(node, type, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
    for (var group = groups[j2], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
      if (node = group[i2])
        yield node;
    }
  }
}
var root$1 = [null];
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$1);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$1);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer(event, node) {
  event = sourceEvent(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg2 = node.ownerSVGElement || node;
    if (svg2.createSVGPoint) {
      var point = svg2.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect2 = node.getBoundingClientRect();
      return [event.clientX - rect2.left - node.clientLeft, event.clientY - rect2.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
var noop = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _2 || /[\s.]/.test(t2))
      throw new Error("illegal type: " + t2);
    _2[t2] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0)
      name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    if (t2 && !types.hasOwnProperty(t2))
      throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T2 = parseTypenames(typename + "", _2), t2, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      while (++i2 < n2)
        if ((t2 = (typename = T2[i2]).type) && (t2 = get$1(_2[t2], typename.name)))
          return t2;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i2 < n2) {
      if (t2 = (typename = T2[i2]).type)
        _2[t2] = set$1(_2[t2], typename.name, callback);
      else if (callback == null)
        for (t2 in _2)
          _2[t2] = set$1(_2[t2], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _2 = this._;
    for (var t2 in _2)
      copy2[t2] = _2[t2].slice();
    return new Dispatch(copy2);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0)
      for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2)
        args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2)
      t2[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2)
      t2[i2].value.apply(that, args);
  }
};
function get$1(type, name) {
  for (var i2 = 0, n2 = type.length, c2; i2 < n2; ++i2) {
    if ((c2 = type[i2]).name === name) {
      return c2.value;
    }
  }
}
function set$1(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
const nonpassive = { passive: false };
const nonpassivecapture = { capture: true, passive: false };
function nopropagation$1(event) {
  event.stopImmediatePropagation();
}
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
var constant$3 = (x2) => () => x2;
function DragEvent(type, {
  sourceEvent: sourceEvent2,
  subject,
  target: target2,
  identifier,
  active,
  x: x2,
  y: y2,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target2, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x2, enumerable: true, configurable: true },
    y: { value: y2, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$1(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d2) {
  return d2 == null ? { x: event.x, y: event.y } : d2;
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag() {
  var filter2 = defaultFilter$1, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d2) {
    if (touchending || !filter2.call(this, event, d2))
      return;
    var gesture = beforestart(this, container.call(this, event, d2), event, d2, "mouse");
    if (!gesture)
      return;
    select(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    dragDisable(event.view);
    nopropagation$1(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent$1(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent$1(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d2) {
    if (!filter2.call(this, event, d2))
      return;
    var touches = event.changedTouches, c2 = container.call(this, event, d2), n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = beforestart(this, c2, event, d2, touches[i2].identifier, touches[i2])) {
        nopropagation$1(event);
        gesture("start", event, touches[i2]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        noevent$1(event);
        gesture("drag", event, touches[i2]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        nopropagation$1(event);
        gesture("end", event, touches[i2]);
      }
    }
  }
  function beforestart(that, container2, event, d2, identifier, touch) {
    var dispatch2 = listeners.copy(), p2 = pointer(touch || event, container2), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p2[0],
      y: p2[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d2)) == null)
      return;
    dx = s2.x - p2[0] || 0;
    dy = s2.y - p2[1] || 0;
    return function gesture(type, event2, touch2) {
      var p0 = p2, n2;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n2 = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p2 = pointer(touch2 || event2, container2), n2 = active;
          break;
      }
      dispatch2.call(type, that, new DragEvent(type, {
        sourceEvent: event2,
        subject: s2,
        target: drag2,
        identifier,
        active: n2,
        x: p2[0] + dx,
        y: p2[1] + dy,
        dx: p2[0] - p0[0],
        dy: p2[1] - p0[1],
        dispatch: dispatch2
      }), d2);
    };
  }
  drag2.filter = function(_2) {
    return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant$3(!!_2), drag2) : filter2;
  };
  drag2.container = function(_2) {
    return arguments.length ? (container = typeof _2 === "function" ? _2 : constant$3(_2), drag2) : container;
  };
  drag2.subject = function(_2) {
    return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant$3(_2), drag2) : subject;
  };
  drag2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$3(!!_2), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m2, l2;
  format3 = (format3 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format3)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format3)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format3)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format3)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format3)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format3)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format3)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b2, a2) {
  if (a2 <= 0)
    r2 = g2 = b2 = NaN;
  return new Rgb(r2, g2, b2, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color))
    o2 = color(o2);
  if (!o2)
    return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b2, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0)
    h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl)
    return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color))
    o2 = color(o2);
  if (!o2)
    return new Hsl();
  if (o2 instanceof Hsl)
    return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r2 === max2)
      h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
    else if (g2 === max2)
      h2 = (b2 - r2) / s2 + 2;
    else
      h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb(h2, m1, m2), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
var constant$2 = (x2) => () => x2;
function linear(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant$2(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear(a2, d2) : constant$2(isNaN(a2) ? b2 : a2);
}
var interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end) {
    var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      start2.r = r2(t2);
      start2.g = g2(t2);
      start2.b = b2(t2);
      start2.opacity = opacity(t2);
      return start2 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function interpolateString(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s2[i2])
        s2[i2] += bs;
      else
        s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2])
        s2[i2] += bm;
      else
        s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s2[i2])
      s2[i2] += bs;
    else
      s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (var i3 = 0, o2; i3 < b2; ++i3)
      s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}
var degrees = 180 / Math.PI;
var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b2, c2, d2, e2, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b2 * b2))
    a2 /= scaleX, b2 /= scaleX;
  if (skewX = a2 * c2 + b2 * d2)
    c2 -= a2 * skewX, d2 -= b2 * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d2 * d2))
    c2 /= scaleY, d2 /= scaleY, skewX /= scaleY;
  if (a2 * d2 < b2 * c2)
    a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e2,
    translateY: f2,
    rotate: Math.atan2(b2, a2) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity$1 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  if (value == null)
    return identity$1;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa2, ya2, xb, yb, s2, q2) {
    if (xa2 !== xb || ya2 !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i2 - 4, x: interpolateNumber(xa2, xb) }, { i: i2 - 2, x: interpolateNumber(ya2, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b2, s2, q2) {
    if (a2 !== b2) {
      if (a2 - b2 > 180)
        b2 += 360;
      else if (b2 - a2 > 180)
        a2 += 360;
      q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b2) });
    } else if (b2) {
      s2.push(pop(s2) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a2, b2, s2, q2) {
    if (a2 !== b2) {
      q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b2) });
    } else if (b2) {
      s2.push(pop(s2) + "skewX(" + b2 + degParen);
    }
  }
  function scale(xa2, ya2, xb, yb, s2, q2) {
    if (xa2 !== xb || ya2 !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q2.push({ i: i2 - 4, x: interpolateNumber(xa2, xb) }, { i: i2 - 2, x: interpolateNumber(ya2, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b2) {
    var s2 = [], q2 = [];
    a2 = parse2(a2), b2 = parse2(b2);
    translate(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s2, q2);
    rotate(a2.rotate, b2.rotate, s2, q2);
    skewX(a2.skewX, b2.skewX, s2, q2);
    scale(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s2, q2);
    a2 = b2 = null;
    return function(t2) {
      var i2 = -1, n2 = q2.length, o2;
      while (++i2 < n2)
        s2[(o2 = q2[i2]).i] = o2.x(t2);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
var interpolateZoom = function zoomRho(rho2, rho22, rho4) {
  function zoom3(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
    if (d2 < epsilon2) {
      S2 = Math.log(w1 / w0) / rho2;
      i2 = function(t2) {
        return [
          ux0 + t2 * dx,
          uy0 + t2 * dy,
          w0 * Math.exp(rho2 * t2 * S2)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho22 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho22 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S2 = (r1 - r0) / rho2;
      i2 = function(t2) {
        var s2 = t2 * S2, coshr0 = cosh(r0), u2 = w0 / (rho22 * d1) * (coshr0 * tanh(rho2 * s2 + r0) - sinh(r0));
        return [
          ux0 + u2 * dx,
          uy0 + u2 * dy,
          w0 * coshr0 / cosh(rho2 * s2 + r0)
        ];
      };
    }
    i2.duration = S2 * 1e3 * rho2 / Math.SQRT2;
    return i2;
  }
  zoom3.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom3;
}(Math.SQRT2, 2, 4);
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now$3() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now$3() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t2 = new Timer();
  t2.restart(callback, delay, time);
  return t2;
}
function timerFlush() {
  now$3();
  ++frame;
  var t2 = taskHead, e2;
  while (t2) {
    if ((e2 = clockNow - t2._time) >= 0)
      t2._call.call(void 0, e2);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time) {
  var t2 = new Timer();
  delay = delay == null ? 0 : +delay;
  t2.restart((elapsed) => {
    t2.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t2;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    group,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get(node, id2) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j2, n2, o2;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i2 in schedules) {
      o2 = schedules[i2];
      if (o2.name !== self2.name)
        continue;
      if (o2.state === STARTED)
        return timeout(start2);
      if (o2.state === RUNNING) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("interrupt", node, node.__data__, o2.index, o2.group);
        delete schedules[i2];
      } else if (+i2 < id2) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("cancel", node, node.__data__, o2.index, o2.group);
        delete schedules[i2];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n2 = self2.tween.length);
    for (i2 = 0, j2 = -1; i2 < n2; ++i2) {
      if (o2 = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j2] = o2;
      }
    }
    tween.length = j2 + 1;
  }
  function tick(elapsed) {
    var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length;
    while (++i2 < n2) {
      tween[i2].call(node, t2);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i2 in schedules)
      return;
    delete node.__transition;
  }
}
function interrupt(node, name) {
  var schedules = node.__transition, schedule2, active, empty2 = true, i2;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i2 in schedules) {
    if ((schedule2 = schedules[i2]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
    delete schedules[i2];
  }
  if (empty2)
    delete node.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
        if (tween1[i2].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i2, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
        if (tween1[i2].name === name) {
          tween1[i2] = t2;
          break;
        }
      }
      if (i2 === n2)
        tween1.push(t2);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2) {
      if ((t2 = tween[i2]).name === name) {
        return t2.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get(node, id2).value[name];
  };
}
function interpolate(a2, b2) {
  var c2;
  return (typeof b2 === "number" ? interpolateNumber : b2 instanceof color ? interpolateRgb : (c2 = color(b2)) ? (b2 = c2, interpolateRgb) : interpolateString)(a2, b2);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value));
}
function attrInterpolate(name, i2) {
  return function(t2) {
    this.setAttribute(name, i2.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t0 = (i0 = i2) && attrInterpolateNS(fullname, i2);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t0 = (i0 = i2) && attrInterpolate(name, i2);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function")
      throw new Error();
    set(this, id2).ease = v2;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match5) {
  if (typeof match5 !== "function")
    match5 = matcher(match5);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node, i2 = 0; i2 < n2; ++i2) {
      if ((node = group[i2]) && match5.call(node, node.__data__, i2, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge = merges[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge[i2] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i2 = t2.indexOf(".");
    if (i2 >= 0)
      t2 = t2.slice(0, i2);
    return !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i2 in this.__transition)
      if (+i2 !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
      if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
        schedule(subgroup[i2], name, id2, i2, subgroup, get(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group[i2]) {
        for (var children2 = select2.call(node, node.__data__, i2, group), child, inherit2 = get(node, id2), k2 = 0, l2 = children2.length; k2 < l2; ++k2) {
          if (child = children2[k2]) {
            schedule(child, name, id2, k2, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i2, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i2, priority) {
  return function(t2) {
    this.style.setProperty(name, i2.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t2 = (i0 = i2) && styleInterpolate(name, i2, priority);
    return t2;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i2) {
  return function(t2) {
    this.textContent = i2.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0)
      t0 = (i0 = i2) && textInterpolate(i2);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group[i2]) {
        var inherit2 = get(node, id0);
        schedule(node, name, id1, i2, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve2, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size2 === 0)
        resolve2();
    } };
    that.each(function() {
      var schedule2 = set(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size2 === 0)
      resolve2();
  });
}
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
var defaultTiming = {
  time: null,
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now$3(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group[i2]) {
        schedule(node, name, id2, i2, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
var constant$1 = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target: target2,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target2, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function Transform(k2, x2, y2) {
  this.k = k2;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity;
  return node.__zoom;
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e2 = this;
  if (e2 instanceof SVGElement) {
    e2 = e2.ownerSVGElement || e2;
    if (e2.hasAttribute("viewBox")) {
      e2 = e2.viewBox.baseVal;
      return [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]];
    }
    return [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]];
  }
  return [[0, 0], [e2.clientWidth, e2.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
function zoom() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom3(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom3.transform = function(collection, transform2, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule2(collection, transform2, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom3.scaleBy = function(selection2, k2, p2, event) {
    zoom3.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p2, event);
  };
  zoom3.scaleTo = function(selection2, k2, p2, event) {
    zoom3.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale(t0, k1), p0, p1), e2, translateExtent);
    }, p2, event);
  };
  zoom3.translateBy = function(selection2, x2, y2, event) {
    zoom3.transform(selection2, function() {
      return constrain(this.__zoom.translate(typeof x2 === "function" ? x2.apply(this, arguments) : x2, typeof y2 === "function" ? y2.apply(this, arguments) : y2), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom3.translateTo = function(selection2, x2, y2, p2, event) {
    zoom3.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
      return constrain(identity.translate(p0[0], p0[1]).scale(t2.k).translate(typeof x2 === "function" ? -x2.apply(this, arguments) : -x2, typeof y2 === "function" ? -y2.apply(this, arguments) : -y2), e2, translateExtent);
    }, p2, event);
  };
  function scale(transform2, k2) {
    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform2, point, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g2 = gesture(that, args).event(event), e2 = extent.apply(that, args), p2 = point == null ? centroid(e2) : typeof point === "function" ? point.apply(that, args) : point, w2 = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a2 = that.__zoom, b2 = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i2 = interpolate2(a2.invert(p2).concat(w2 / a2.k), b2.invert(p2).concat(w2 / b2.k));
      return function(t2) {
        if (t2 === 1)
          t2 = b2;
        else {
          var l2 = i2(t2), k2 = w2 / l2[2];
          t2 = new Transform(k2, p2[0] - l2[0] * k2, p2[1] - l2[1] * k2);
        }
        g2.zoom(null, t2);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d2 = select(this.that).datum();
      listeners.call(type, this.that, new ZoomEvent(type, {
        sourceEvent: this.sourceEvent,
        target: zoom3,
        type,
        transform: this.that.__zoom,
        dispatch: listeners
      }), d2);
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var g2 = gesture(this, args).event(event), t2 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = pointer(event);
    if (g2.wheel) {
      if (g2.mouse[0][0] !== p2[0] || g2.mouse[0][1] !== p2[1]) {
        g2.mouse[1] = t2.invert(g2.mouse[0] = p2);
      }
      clearTimeout(g2.wheel);
    } else if (t2.k === k2)
      return;
    else {
      g2.mouse = [p2, t2.invert(p2)];
      interrupt(this);
      g2.start();
    }
    noevent(event);
    g2.wheel = setTimeout(wheelidled, wheelDelay);
    g2.zoom("mouse", constrain(translate(scale(t2, k2), g2.mouse[0], g2.mouse[1]), g2.extent, translateExtent));
    function wheelidled() {
      g2.wheel = null;
      g2.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g2 = gesture(this, args, true).event(event), v2 = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view);
    nopropagation(event);
    g2.mouse = [p2, this.__zoom.invert(p2)];
    interrupt(this);
    g2.start();
    function mousemoved(event2) {
      noevent(event2);
      if (!g2.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g2.moved = dx * dx + dy * dy > clickDistance2;
      }
      g2.event(event2).zoom("mouse", constrain(translate(g2.that.__zoom, g2.mouse[0] = pointer(event2, currentTarget), g2.mouse[1]), g2.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g2.moved);
      noevent(event2);
      g2.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent(event);
    if (duration > 0)
      select(this).transition().duration(duration).call(schedule2, t1, p0, event);
    else
      select(this).call(zoom3.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var touches = event.touches, n2 = touches.length, g2 = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t2, p2;
    nopropagation(event);
    for (i2 = 0; i2 < n2; ++i2) {
      t2 = touches[i2], p2 = pointer(t2, this);
      p2 = [p2, this.__zoom.invert(p2), t2.identifier];
      if (!g2.touch0)
        g2.touch0 = p2, started = true, g2.taps = 1 + !!touchstarting;
      else if (!g2.touch1 && g2.touch0[2] !== p2[2])
        g2.touch1 = p2, g2.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g2.taps < 2)
        touchfirst = p2[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt(this);
      g2.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2, p2, l2;
    noevent(event);
    for (i2 = 0; i2 < n2; ++i2) {
      t2 = touches[i2], p2 = pointer(t2, this);
      if (g2.touch0 && g2.touch0[2] === t2.identifier)
        g2.touch0[0] = p2;
      else if (g2.touch1 && g2.touch1[2] === t2.identifier)
        g2.touch1[0] = p2;
    }
    t2 = g2.that.__zoom;
    if (g2.touch1) {
      var p0 = g2.touch0[0], l0 = g2.touch0[1], p1 = g2.touch1[0], l1 = g2.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t2 = scale(t2, Math.sqrt(dp / dl));
      p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g2.touch0)
      p2 = g2.touch0[0], l2 = g2.touch0[1];
    else
      return;
    g2.zoom("touch", constrain(translate(t2, p2, l2), g2.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2;
    nopropagation(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i2 = 0; i2 < n2; ++i2) {
      t2 = touches[i2];
      if (g2.touch0 && g2.touch0[2] === t2.identifier)
        delete g2.touch0;
      else if (g2.touch1 && g2.touch1[2] === t2.identifier)
        delete g2.touch1;
    }
    if (g2.touch1 && !g2.touch0)
      g2.touch0 = g2.touch1, delete g2.touch1;
    if (g2.touch0)
      g2.touch0[1] = this.__zoom.invert(g2.touch0[0]);
    else {
      g2.end();
      if (g2.taps === 2) {
        t2 = pointer(t2, this);
        if (Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance) {
          var p2 = select(this).on("dblclick.zoom");
          if (p2)
            p2.apply(this, arguments);
        }
      }
    }
  }
  zoom3.wheelDelta = function(_2) {
    return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant$1(+_2), zoom3) : wheelDelta;
  };
  zoom3.filter = function(_2) {
    return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant$1(!!_2), zoom3) : filter2;
  };
  zoom3.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$1(!!_2), zoom3) : touchable;
  };
  zoom3.extent = function(_2) {
    return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant$1([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom3) : extent;
  };
  zoom3.scaleExtent = function(_2) {
    return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom3) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom3.translateExtent = function(_2) {
    return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom3) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom3.constrain = function(_2) {
    return arguments.length ? (constrain = _2, zoom3) : constrain;
  };
  zoom3.duration = function(_2) {
    return arguments.length ? (duration = +_2, zoom3) : duration;
  };
  zoom3.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, zoom3) : interpolate2;
  };
  zoom3.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom3 : value;
  };
  zoom3.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom3) : Math.sqrt(clickDistance2);
  };
  zoom3.tapDistance = function(_2) {
    return arguments.length ? (tapDistance = +_2, zoom3) : tapDistance;
  };
  return zoom3;
}
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function max$1(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min$1(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var nativeMax = Math.max, nativeMin = Math.min;
var now$2 = function() {
  return root.Date.now();
};
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$2();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$2());
  }
  function debounced() {
    var time = now$2(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce$1(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
function isObject(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var lodash_throttle = throttle;
var Easing = {
  Linear: {
    None: function(amount) {
      return amount;
    }
  },
  Quadratic: {
    In: function(amount) {
      return amount * amount;
    },
    Out: function(amount) {
      return amount * (2 - amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount;
      }
      return -0.5 * (--amount * (amount - 2) - 1);
    }
  },
  Cubic: {
    In: function(amount) {
      return amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount + 2);
    }
  },
  Quartic: {
    In: function(amount) {
      return amount * amount * amount * amount;
    },
    Out: function(amount) {
      return 1 - --amount * amount * amount * amount;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount;
      }
      return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
    }
  },
  Quintic: {
    In: function(amount) {
      return amount * amount * amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
    }
  },
  Sinusoidal: {
    In: function(amount) {
      return 1 - Math.cos(amount * Math.PI / 2);
    },
    Out: function(amount) {
      return Math.sin(amount * Math.PI / 2);
    },
    InOut: function(amount) {
      return 0.5 * (1 - Math.cos(Math.PI * amount));
    }
  },
  Exponential: {
    In: function(amount) {
      return amount === 0 ? 0 : Math.pow(1024, amount - 1);
    },
    Out: function(amount) {
      return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      if ((amount *= 2) < 1) {
        return 0.5 * Math.pow(1024, amount - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
    }
  },
  Circular: {
    In: function(amount) {
      return 1 - Math.sqrt(1 - amount * amount);
    },
    Out: function(amount) {
      return Math.sqrt(1 - --amount * amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
    }
  },
  Elastic: {
    In: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
    },
    Out: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      amount *= 2;
      if (amount < 1) {
        return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      }
      return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
    }
  },
  Back: {
    In: function(amount) {
      var s2 = 1.70158;
      return amount * amount * ((s2 + 1) * amount - s2);
    },
    Out: function(amount) {
      var s2 = 1.70158;
      return --amount * amount * ((s2 + 1) * amount + s2) + 1;
    },
    InOut: function(amount) {
      var s2 = 1.70158 * 1.525;
      if ((amount *= 2) < 1) {
        return 0.5 * (amount * amount * ((s2 + 1) * amount - s2));
      }
      return 0.5 * ((amount -= 2) * amount * ((s2 + 1) * amount + s2) + 2);
    }
  },
  Bounce: {
    In: function(amount) {
      return 1 - Easing.Bounce.Out(1 - amount);
    },
    Out: function(amount) {
      if (amount < 1 / 2.75) {
        return 7.5625 * amount * amount;
      } else if (amount < 2 / 2.75) {
        return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
      } else if (amount < 2.5 / 2.75) {
        return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
      } else {
        return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
      }
    },
    InOut: function(amount) {
      if (amount < 0.5) {
        return Easing.Bounce.In(amount * 2) * 0.5;
      }
      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
    }
  }
};
var now;
if (typeof self === "undefined" && typeof process !== "undefined" && process.hrtime) {
  now = function() {
    var time = process.hrtime();
    return time[0] * 1e3 + time[1] / 1e6;
  };
} else if (typeof self !== "undefined" && self.performance !== void 0 && self.performance.now !== void 0) {
  now = self.performance.now.bind(self.performance);
} else if (Date.now !== void 0) {
  now = Date.now;
} else {
  now = function() {
    return new Date().getTime();
  };
}
var now$1 = now;
var Group = function() {
  function Group2() {
    this._tweens = {};
    this._tweensAddedDuringUpdate = {};
  }
  Group2.prototype.getAll = function() {
    var _this = this;
    return Object.keys(this._tweens).map(function(tweenId) {
      return _this._tweens[tweenId];
    });
  };
  Group2.prototype.removeAll = function() {
    this._tweens = {};
  };
  Group2.prototype.add = function(tween) {
    this._tweens[tween.getId()] = tween;
    this._tweensAddedDuringUpdate[tween.getId()] = tween;
  };
  Group2.prototype.remove = function(tween) {
    delete this._tweens[tween.getId()];
    delete this._tweensAddedDuringUpdate[tween.getId()];
  };
  Group2.prototype.update = function(time, preserve) {
    if (time === void 0) {
      time = now$1();
    }
    if (preserve === void 0) {
      preserve = false;
    }
    var tweenIds = Object.keys(this._tweens);
    if (tweenIds.length === 0) {
      return false;
    }
    while (tweenIds.length > 0) {
      this._tweensAddedDuringUpdate = {};
      for (var i2 = 0; i2 < tweenIds.length; i2++) {
        var tween = this._tweens[tweenIds[i2]];
        var autoStart = !preserve;
        if (tween && tween.update(time, autoStart) === false && !preserve) {
          delete this._tweens[tweenIds[i2]];
        }
      }
      tweenIds = Object.keys(this._tweensAddedDuringUpdate);
    }
    return true;
  };
  return Group2;
}();
var Interpolation = {
  Linear: function(v2, k2) {
    var m2 = v2.length - 1;
    var f2 = m2 * k2;
    var i2 = Math.floor(f2);
    var fn = Interpolation.Utils.Linear;
    if (k2 < 0) {
      return fn(v2[0], v2[1], f2);
    }
    if (k2 > 1) {
      return fn(v2[m2], v2[m2 - 1], m2 - f2);
    }
    return fn(v2[i2], v2[i2 + 1 > m2 ? m2 : i2 + 1], f2 - i2);
  },
  Bezier: function(v2, k2) {
    var b2 = 0;
    var n2 = v2.length - 1;
    var pw = Math.pow;
    var bn = Interpolation.Utils.Bernstein;
    for (var i2 = 0; i2 <= n2; i2++) {
      b2 += pw(1 - k2, n2 - i2) * pw(k2, i2) * v2[i2] * bn(n2, i2);
    }
    return b2;
  },
  CatmullRom: function(v2, k2) {
    var m2 = v2.length - 1;
    var f2 = m2 * k2;
    var i2 = Math.floor(f2);
    var fn = Interpolation.Utils.CatmullRom;
    if (v2[0] === v2[m2]) {
      if (k2 < 0) {
        i2 = Math.floor(f2 = m2 * (1 + k2));
      }
      return fn(v2[(i2 - 1 + m2) % m2], v2[i2], v2[(i2 + 1) % m2], v2[(i2 + 2) % m2], f2 - i2);
    } else {
      if (k2 < 0) {
        return v2[0] - (fn(v2[0], v2[0], v2[1], v2[1], -f2) - v2[0]);
      }
      if (k2 > 1) {
        return v2[m2] - (fn(v2[m2], v2[m2], v2[m2 - 1], v2[m2 - 1], f2 - m2) - v2[m2]);
      }
      return fn(v2[i2 ? i2 - 1 : 0], v2[i2], v2[m2 < i2 + 1 ? m2 : i2 + 1], v2[m2 < i2 + 2 ? m2 : i2 + 2], f2 - i2);
    }
  },
  Utils: {
    Linear: function(p0, p1, t2) {
      return (p1 - p0) * t2 + p0;
    },
    Bernstein: function(n2, i2) {
      var fc = Interpolation.Utils.Factorial;
      return fc(n2) / fc(i2) / fc(n2 - i2);
    },
    Factorial: function() {
      var a2 = [1];
      return function(n2) {
        var s2 = 1;
        if (a2[n2]) {
          return a2[n2];
        }
        for (var i2 = n2; i2 > 1; i2--) {
          s2 *= i2;
        }
        a2[n2] = s2;
        return s2;
      };
    }(),
    CatmullRom: function(p0, p1, p2, p3, t2) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t22 = t2 * t2;
      var t3 = t2 * t22;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
    }
  }
};
var Sequence = function() {
  function Sequence2() {
  }
  Sequence2.nextId = function() {
    return Sequence2._nextId++;
  };
  Sequence2._nextId = 0;
  return Sequence2;
}();
var mainGroup = new Group();
var Tween = function() {
  function Tween2(_object, _group) {
    if (_group === void 0) {
      _group = mainGroup;
    }
    this._object = _object;
    this._group = _group;
    this._isPaused = false;
    this._pauseStart = 0;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1e3;
    this._initialRepeat = 0;
    this._repeat = 0;
    this._yoyo = false;
    this._isPlaying = false;
    this._reversed = false;
    this._delayTime = 0;
    this._startTime = 0;
    this._easingFunction = Easing.Linear.None;
    this._interpolationFunction = Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallbackFired = false;
    this._id = Sequence.nextId();
    this._isChainStopped = false;
    this._goToEnd = false;
  }
  Tween2.prototype.getId = function() {
    return this._id;
  };
  Tween2.prototype.isPlaying = function() {
    return this._isPlaying;
  };
  Tween2.prototype.isPaused = function() {
    return this._isPaused;
  };
  Tween2.prototype.to = function(properties, duration) {
    this._valuesEnd = Object.create(properties);
    if (duration !== void 0) {
      this._duration = duration;
    }
    return this;
  };
  Tween2.prototype.duration = function(d2) {
    this._duration = d2;
    return this;
  };
  Tween2.prototype.start = function(time) {
    if (this._isPlaying) {
      return this;
    }
    this._group && this._group.add(this);
    this._repeat = this._initialRepeat;
    if (this._reversed) {
      this._reversed = false;
      for (var property in this._valuesStartRepeat) {
        this._swapEndStartRepeatValues(property);
        this._valuesStart[property] = this._valuesStartRepeat[property];
      }
    }
    this._isPlaying = true;
    this._isPaused = false;
    this._onStartCallbackFired = false;
    this._isChainStopped = false;
    this._startTime = time !== void 0 ? typeof time === "string" ? now$1() + parseFloat(time) : time : now$1();
    this._startTime += this._delayTime;
    this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
    return this;
  };
  Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
    for (var property in _valuesEnd) {
      var startValue = _object[property];
      var startValueIsArray = Array.isArray(startValue);
      var propType = startValueIsArray ? "array" : typeof startValue;
      var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
      if (propType === "undefined" || propType === "function") {
        continue;
      }
      if (isInterpolationList) {
        var endValues = _valuesEnd[property];
        if (endValues.length === 0) {
          continue;
        }
        endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
        _valuesEnd[property] = [startValue].concat(endValues);
      }
      if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
        _valuesStart[property] = startValueIsArray ? [] : {};
        for (var prop2 in startValue) {
          _valuesStart[property][prop2] = startValue[prop2];
        }
        _valuesStartRepeat[property] = startValueIsArray ? [] : {};
        this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
      } else {
        if (typeof _valuesStart[property] === "undefined") {
          _valuesStart[property] = startValue;
        }
        if (!startValueIsArray) {
          _valuesStart[property] *= 1;
        }
        if (isInterpolationList) {
          _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
        } else {
          _valuesStartRepeat[property] = _valuesStart[property] || 0;
        }
      }
    }
  };
  Tween2.prototype.stop = function() {
    if (!this._isChainStopped) {
      this._isChainStopped = true;
      this.stopChainedTweens();
    }
    if (!this._isPlaying) {
      return this;
    }
    this._group && this._group.remove(this);
    this._isPlaying = false;
    this._isPaused = false;
    if (this._onStopCallback) {
      this._onStopCallback(this._object);
    }
    return this;
  };
  Tween2.prototype.end = function() {
    this._goToEnd = true;
    this.update(Infinity);
    return this;
  };
  Tween2.prototype.pause = function(time) {
    if (time === void 0) {
      time = now$1();
    }
    if (this._isPaused || !this._isPlaying) {
      return this;
    }
    this._isPaused = true;
    this._pauseStart = time;
    this._group && this._group.remove(this);
    return this;
  };
  Tween2.prototype.resume = function(time) {
    if (time === void 0) {
      time = now$1();
    }
    if (!this._isPaused || !this._isPlaying) {
      return this;
    }
    this._isPaused = false;
    this._startTime += time - this._pauseStart;
    this._pauseStart = 0;
    this._group && this._group.add(this);
    return this;
  };
  Tween2.prototype.stopChainedTweens = function() {
    for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
      this._chainedTweens[i2].stop();
    }
    return this;
  };
  Tween2.prototype.group = function(group) {
    this._group = group;
    return this;
  };
  Tween2.prototype.delay = function(amount) {
    this._delayTime = amount;
    return this;
  };
  Tween2.prototype.repeat = function(times2) {
    this._initialRepeat = times2;
    this._repeat = times2;
    return this;
  };
  Tween2.prototype.repeatDelay = function(amount) {
    this._repeatDelayTime = amount;
    return this;
  };
  Tween2.prototype.yoyo = function(yoyo) {
    this._yoyo = yoyo;
    return this;
  };
  Tween2.prototype.easing = function(easingFunction) {
    this._easingFunction = easingFunction;
    return this;
  };
  Tween2.prototype.interpolation = function(interpolationFunction) {
    this._interpolationFunction = interpolationFunction;
    return this;
  };
  Tween2.prototype.chain = function() {
    var tweens = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      tweens[_i] = arguments[_i];
    }
    this._chainedTweens = tweens;
    return this;
  };
  Tween2.prototype.onStart = function(callback) {
    this._onStartCallback = callback;
    return this;
  };
  Tween2.prototype.onUpdate = function(callback) {
    this._onUpdateCallback = callback;
    return this;
  };
  Tween2.prototype.onRepeat = function(callback) {
    this._onRepeatCallback = callback;
    return this;
  };
  Tween2.prototype.onComplete = function(callback) {
    this._onCompleteCallback = callback;
    return this;
  };
  Tween2.prototype.onStop = function(callback) {
    this._onStopCallback = callback;
    return this;
  };
  Tween2.prototype.update = function(time, autoStart) {
    if (time === void 0) {
      time = now$1();
    }
    if (autoStart === void 0) {
      autoStart = true;
    }
    if (this._isPaused)
      return true;
    var property;
    var elapsed;
    var endTime = this._startTime + this._duration;
    if (!this._goToEnd && !this._isPlaying) {
      if (time > endTime)
        return false;
      if (autoStart)
        this.start(time);
    }
    this._goToEnd = false;
    if (time < this._startTime) {
      return true;
    }
    if (this._onStartCallbackFired === false) {
      if (this._onStartCallback) {
        this._onStartCallback(this._object);
      }
      this._onStartCallbackFired = true;
    }
    elapsed = (time - this._startTime) / this._duration;
    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
    var value = this._easingFunction(elapsed);
    this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
    if (this._onUpdateCallback) {
      this._onUpdateCallback(this._object, elapsed);
    }
    if (elapsed === 1) {
      if (this._repeat > 0) {
        if (isFinite(this._repeat)) {
          this._repeat--;
        }
        for (property in this._valuesStartRepeat) {
          if (!this._yoyo && typeof this._valuesEnd[property] === "string") {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
          }
          if (this._yoyo) {
            this._swapEndStartRepeatValues(property);
          }
          this._valuesStart[property] = this._valuesStartRepeat[property];
        }
        if (this._yoyo) {
          this._reversed = !this._reversed;
        }
        if (this._repeatDelayTime !== void 0) {
          this._startTime = time + this._repeatDelayTime;
        } else {
          this._startTime = time + this._delayTime;
        }
        if (this._onRepeatCallback) {
          this._onRepeatCallback(this._object);
        }
        return true;
      } else {
        if (this._onCompleteCallback) {
          this._onCompleteCallback(this._object);
        }
        for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
          this._chainedTweens[i2].start(this._startTime + this._duration);
        }
        this._isPlaying = false;
        return false;
      }
    }
    return true;
  };
  Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
    for (var property in _valuesEnd) {
      if (_valuesStart[property] === void 0) {
        continue;
      }
      var start2 = _valuesStart[property] || 0;
      var end = _valuesEnd[property];
      var startIsArray = Array.isArray(_object[property]);
      var endIsArray = Array.isArray(end);
      var isInterpolationList = !startIsArray && endIsArray;
      if (isInterpolationList) {
        _object[property] = this._interpolationFunction(end, value);
      } else if (typeof end === "object" && end) {
        this._updateProperties(_object[property], start2, end, value);
      } else {
        end = this._handleRelativeValue(start2, end);
        if (typeof end === "number") {
          _object[property] = start2 + (end - start2) * value;
        }
      }
    }
  };
  Tween2.prototype._handleRelativeValue = function(start2, end) {
    if (typeof end !== "string") {
      return end;
    }
    if (end.charAt(0) === "+" || end.charAt(0) === "-") {
      return start2 + parseFloat(end);
    } else {
      return parseFloat(end);
    }
  };
  Tween2.prototype._swapEndStartRepeatValues = function(property) {
    var tmp = this._valuesStartRepeat[property];
    var endValue = this._valuesEnd[property];
    if (typeof endValue === "string") {
      this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
    } else {
      this._valuesStartRepeat[property] = this._valuesEnd[property];
    }
    this._valuesEnd[property] = tmp;
  };
  return Tween2;
}();
var VERSION = "18.6.4";
var nextId = Sequence.nextId;
var TWEEN = mainGroup;
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll$3 = TWEEN.removeAll.bind(TWEEN);
var add$3 = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
var exports = {
  Easing,
  Group,
  Interpolation,
  now: now$1,
  Sequence,
  nextId,
  Tween,
  VERSION,
  getAll,
  removeAll: removeAll$3,
  add: add$3,
  remove,
  update
};
function debounce(func, wait, immediate) {
  var timeout2, args, context, timestamp2, result;
  if (null == wait)
    wait = 100;
  function later() {
    var last = Date.now() - timestamp2;
    if (last < wait && last >= 0) {
      timeout2 = setTimeout(later, wait - last);
    } else {
      timeout2 = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  }
  var debounced = function() {
    context = this;
    args = arguments;
    timestamp2 = Date.now();
    var callNow = immediate && !timeout2;
    if (!timeout2)
      timeout2 = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }
    return result;
  };
  debounced.clear = function() {
    if (timeout2) {
      clearTimeout(timeout2);
      timeout2 = null;
    }
  };
  debounced.flush = function() {
    if (timeout2) {
      result = func.apply(context, args);
      context = args = null;
      clearTimeout(timeout2);
      timeout2 = null;
    }
  };
  return debounced;
}
debounce.debounce = debounce;
var debounce_1 = debounce;
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target2, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target2, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _slicedToArray$2(arr, i2) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$3(arr, i2) || _nonIterableRest$2();
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit$2(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray$3(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$3(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o2, minLen);
}
function _arrayLikeToArray$3(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var Prop = /* @__PURE__ */ _createClass$1(function Prop2(name, _ref) {
  var _ref$default = _ref["default"], defaultVal = _ref$default === void 0 ? null : _ref$default, _ref$triggerUpdate = _ref.triggerUpdate, triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate, _ref$onChange = _ref.onChange, onChange15 = _ref$onChange === void 0 ? function(newVal, state) {
  } : _ref$onChange;
  _classCallCheck$1(this, Prop2);
  this.name = name;
  this.defaultVal = defaultVal;
  this.triggerUpdate = triggerUpdate;
  this.onChange = onChange15;
});
function index$3(_ref2) {
  var _ref2$stateInit = _ref2.stateInit, stateInit3 = _ref2$stateInit === void 0 ? function() {
    return {};
  } : _ref2$stateInit, _ref2$props = _ref2.props, rawProps = _ref2$props === void 0 ? {} : _ref2$props, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, _ref2$aliases = _ref2.aliases, aliases2 = _ref2$aliases === void 0 ? {} : _ref2$aliases, _ref2$init = _ref2.init, initFn = _ref2$init === void 0 ? function() {
  } : _ref2$init, _ref2$update = _ref2.update, updateFn2 = _ref2$update === void 0 ? function() {
  } : _ref2$update;
  var props = Object.keys(rawProps).map(function(propName) {
    return new Prop(propName, rawProps[propName]);
  });
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var state = Object.assign({}, stateInit3 instanceof Function ? stateInit3(options) : stateInit3, {
      initialised: false
    });
    var changedProps = {};
    function comp2(nodeElement) {
      initStatic(nodeElement, options);
      digest();
      return comp2;
    }
    var initStatic = function initStatic2(nodeElement, options2) {
      initFn.call(comp2, nodeElement, state, options2);
      state.initialised = true;
    };
    var digest = debounce_1(function() {
      if (!state.initialised) {
        return;
      }
      updateFn2.call(comp2, state, changedProps);
      changedProps = {};
    }, 1);
    props.forEach(function(prop2) {
      comp2[prop2.name] = getSetProp(prop2);
      function getSetProp(_ref3) {
        var prop3 = _ref3.name, _ref3$triggerUpdate = _ref3.triggerUpdate, redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate, _ref3$onChange = _ref3.onChange, onChange15 = _ref3$onChange === void 0 ? function(newVal, state2) {
        } : _ref3$onChange, _ref3$defaultVal = _ref3.defaultVal, defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
        return function(_2) {
          var curVal = state[prop3];
          if (!arguments.length) {
            return curVal;
          }
          var val = _2 === void 0 ? defaultVal : _2;
          state[prop3] = val;
          onChange15.call(comp2, val, state, curVal);
          !changedProps.hasOwnProperty(prop3) && (changedProps[prop3] = curVal);
          if (redigest) {
            digest();
          }
          return comp2;
        };
      }
    });
    Object.keys(methods).forEach(function(methodName) {
      comp2[methodName] = function() {
        var _methods$methodName;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp2, state].concat(args));
      };
    });
    Object.entries(aliases2).forEach(function(_ref4) {
      var _ref5 = _slicedToArray$2(_ref4, 2), alias = _ref5[0], target2 = _ref5[1];
      return comp2[alias] = comp2[target2];
    });
    comp2.resetProps = function() {
      props.forEach(function(prop2) {
        comp2[prop2.name](prop2.defaultVal);
      });
      return comp2;
    };
    comp2.resetProps();
    state._rerender = digest;
    return comp2;
  };
}
var index$2 = function(p2) {
  return p2 instanceof Function ? p2 : typeof p2 === "string" ? function(obj) {
    return obj[p2];
  } : function(obj) {
    return p2;
  };
};
var tinycolor = { exports: {} };
(function(module2) {
  (function(Math2) {
    var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
    function tinycolor2(color2, opts) {
      color2 = color2 ? color2 : "";
      opts = opts || {};
      if (color2 instanceof tinycolor2) {
        return color2;
      }
      if (!(this instanceof tinycolor2)) {
        return new tinycolor2(color2, opts);
      }
      var rgb2 = inputToRGB(color2);
      this._originalInput = color2, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb2.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) {
        this._r = mathRound(this._r);
      }
      if (this._g < 1) {
        this._g = mathRound(this._g);
      }
      if (this._b < 1) {
        this._b = mathRound(this._b);
      }
      this._ok = rgb2.ok;
      this._tc_id = tinyCounter++;
    }
    tinycolor2.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb2 = this.toRgb();
        return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
      },
      getLuminance: function() {
        var rgb2 = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G2, B2;
        RsRGB = rgb2.r / 255;
        GsRGB = rgb2.g / 255;
        BsRGB = rgb2.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G2 = GsRGB / 12.92;
        } else {
          G2 = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      },
      setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100 * this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h2 = mathRound(hsv.h * 360), s2 = mathRound(hsv.s * 100), v2 = mathRound(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function() {
        var hsl2 = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl2.h * 360, s: hsl2.s, l: hsl2.l, a: this._a };
      },
      toHslString: function() {
        var hsl2 = rgbToHsl(this._r, this._g, this._b);
        var h2 = mathRound(hsl2.h * 360), s2 = mathRound(hsl2.s * 100), l2 = mathRound(hsl2.l * 100);
        return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s2 = tinycolor2(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function(format3) {
        var formatSet = !!format3;
        format3 = format3 || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format3 === "hex" || format3 === "hex6" || format3 === "hex3" || format3 === "hex4" || format3 === "hex8" || format3 === "name");
        if (needsAlphaFormat) {
          if (format3 === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format3 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format3 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format3 === "hex" || format3 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format3 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format3 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format3 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format3 === "name") {
          formattedString = this.toName();
        }
        if (format3 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format3 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function() {
        return tinycolor2(this.toString());
      },
      _applyModification: function(fn, args) {
        var color2 = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color2._r;
        this._g = color2._g;
        this._b = color2._b;
        this.setAlpha(color2._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin, arguments);
      },
      _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement2, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };
    tinycolor2.fromRatio = function(color2, opts) {
      if (typeof color2 == "object") {
        var newColor = {};
        for (var i2 in color2) {
          if (color2.hasOwnProperty(i2)) {
            if (i2 === "a") {
              newColor[i2] = color2[i2];
            } else {
              newColor[i2] = convertToPercentage(color2[i2]);
            }
          }
        }
        color2 = newColor;
      }
      return tinycolor2(color2, opts);
    };
    function inputToRGB(color2) {
      var rgb2 = { r: 0, g: 0, b: 0 };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok = false;
      var format3 = false;
      if (typeof color2 == "string") {
        color2 = stringInputToObject(color2);
      }
      if (typeof color2 == "object") {
        if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
          rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
          ok = true;
          format3 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
          s2 = convertToPercentage(color2.s);
          v2 = convertToPercentage(color2.v);
          rgb2 = hsvToRgb(color2.h, s2, v2);
          ok = true;
          format3 = "hsv";
        } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
          s2 = convertToPercentage(color2.s);
          l2 = convertToPercentage(color2.l);
          rgb2 = hslToRgb(color2.h, s2, l2);
          ok = true;
          format3 = "hsl";
        }
        if (color2.hasOwnProperty("a")) {
          a2 = color2.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok,
        format: color2.format || format3,
        r: mathMin(255, mathMax(rgb2.r, 0)),
        g: mathMin(255, mathMax(rgb2.g, 0)),
        b: mathMin(255, mathMax(rgb2.b, 0)),
        a: a2
      };
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h2, s2, l2 = (max2 + min2) / 2;
      if (max2 == min2) {
        h2 = s2 = 0;
      } else {
        var d2 = max2 - min2;
        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, l: l2 };
    }
    function hslToRgb(h2, s2, l2) {
      var r2, g2, b2;
      h2 = bound01(h2, 360);
      s2 = bound01(s2, 100);
      l2 = bound01(l2, 100);
      function hue2rgb(p3, q3, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p3 + (q3 - p3) * 6 * t2;
        if (t2 < 1 / 2)
          return q3;
        if (t2 < 2 / 3)
          return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        return p3;
      }
      if (s2 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h2, s2, v2 = max2;
      var d2 = max2 - min2;
      s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 == min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, v: v2 };
    }
    function hsvToRgb(h2, s2, v2) {
      h2 = bound01(h2, 360) * 6;
      s2 = bound01(s2, 100);
      v2 = bound01(v2, 100);
      var i2 = Math2.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod2 = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod2], g2 = [t2, v2, v2, q2, p2, p2][mod2], b2 = [p2, p2, t2, v2, v2, q2][mod2];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex2 = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
        return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
      }
      return hex2.join("");
    }
    function rgbaToHex(r2, g2, b2, a2, allow4Char) {
      var hex2 = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16)),
        pad2(convertDecimalToHex(a2))
      ];
      if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
        return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
      }
      return hex2.join("");
    }
    function rgbaToArgbHex(r2, g2, b2, a2) {
      var hex2 = [
        pad2(convertDecimalToHex(a2)),
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      return hex2.join("");
    }
    tinycolor2.equals = function(color1, color2) {
      if (!color1 || !color2) {
        return false;
      }
      return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
    };
    tinycolor2.random = function() {
      return tinycolor2.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };
    function desaturate(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl2 = tinycolor2(color2).toHsl();
      hsl2.s -= amount / 100;
      hsl2.s = clamp01(hsl2.s);
      return tinycolor2(hsl2);
    }
    function saturate(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl2 = tinycolor2(color2).toHsl();
      hsl2.s += amount / 100;
      hsl2.s = clamp01(hsl2.s);
      return tinycolor2(hsl2);
    }
    function greyscale(color2) {
      return tinycolor2(color2).desaturate(100);
    }
    function lighten(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl2 = tinycolor2(color2).toHsl();
      hsl2.l += amount / 100;
      hsl2.l = clamp01(hsl2.l);
      return tinycolor2(hsl2);
    }
    function brighten(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb2 = tinycolor2(color2).toRgb();
      rgb2.r = mathMax(0, mathMin(255, rgb2.r - mathRound(255 * -(amount / 100))));
      rgb2.g = mathMax(0, mathMin(255, rgb2.g - mathRound(255 * -(amount / 100))));
      rgb2.b = mathMax(0, mathMin(255, rgb2.b - mathRound(255 * -(amount / 100))));
      return tinycolor2(rgb2);
    }
    function darken(color2, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl2 = tinycolor2(color2).toHsl();
      hsl2.l -= amount / 100;
      hsl2.l = clamp01(hsl2.l);
      return tinycolor2(hsl2);
    }
    function spin(color2, amount) {
      var hsl2 = tinycolor2(color2).toHsl();
      var hue = (hsl2.h + amount) % 360;
      hsl2.h = hue < 0 ? 360 + hue : hue;
      return tinycolor2(hsl2);
    }
    function complement2(color2) {
      var hsl2 = tinycolor2(color2).toHsl();
      hsl2.h = (hsl2.h + 180) % 360;
      return tinycolor2(hsl2);
    }
    function triad(color2) {
      var hsl2 = tinycolor2(color2).toHsl();
      var h2 = hsl2.h;
      return [
        tinycolor2(color2),
        tinycolor2({ h: (h2 + 120) % 360, s: hsl2.s, l: hsl2.l }),
        tinycolor2({ h: (h2 + 240) % 360, s: hsl2.s, l: hsl2.l })
      ];
    }
    function tetrad(color2) {
      var hsl2 = tinycolor2(color2).toHsl();
      var h2 = hsl2.h;
      return [
        tinycolor2(color2),
        tinycolor2({ h: (h2 + 90) % 360, s: hsl2.s, l: hsl2.l }),
        tinycolor2({ h: (h2 + 180) % 360, s: hsl2.s, l: hsl2.l }),
        tinycolor2({ h: (h2 + 270) % 360, s: hsl2.s, l: hsl2.l })
      ];
    }
    function splitcomplement(color2) {
      var hsl2 = tinycolor2(color2).toHsl();
      var h2 = hsl2.h;
      return [
        tinycolor2(color2),
        tinycolor2({ h: (h2 + 72) % 360, s: hsl2.s, l: hsl2.l }),
        tinycolor2({ h: (h2 + 216) % 360, s: hsl2.s, l: hsl2.l })
      ];
    }
    function analogous(color2, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl2 = tinycolor2(color2).toHsl();
      var part2 = 360 / slices;
      var ret = [tinycolor2(color2)];
      for (hsl2.h = (hsl2.h - (part2 * results >> 1) + 720) % 360; --results; ) {
        hsl2.h = (hsl2.h + part2) % 360;
        ret.push(tinycolor2(hsl2));
      }
      return ret;
    }
    function monochromatic(color2, results) {
      results = results || 6;
      var hsv = tinycolor2(color2).toHsv();
      var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor2({ h: h2, s: s2, v: v2 }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor2.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor2(color1).toRgb();
      var rgb2 = tinycolor2(color2).toRgb();
      var p2 = amount / 100;
      var rgba2 = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor2(rgba2);
    };
    tinycolor2.readability = function(color1, color2) {
      var c1 = tinycolor2(color1);
      var c2 = tinycolor2(color2);
      return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor2.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor2.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor2.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size2;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size2 = args.size;
      for (var i2 = 0; i2 < colorList.length; i2++) {
        readability = tinycolor2.readability(baseColor, colorList[i2]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor2(colorList[i2]);
        }
      }
      if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size2 }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor2.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor2.hexNames = flip2(names);
    function flip2(o2) {
      var flipped = {};
      for (var i2 in o2) {
        if (o2.hasOwnProperty(i2)) {
          flipped[o2[i2]] = i2;
        }
      }
      return flipped;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function bound01(n2, max2) {
      if (isOnePointZero(n2)) {
        n2 = "100%";
      }
      var processPercent = isPercentage(n2);
      n2 = mathMin(max2, mathMax(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max2, 10) / 100;
      }
      if (Math2.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      return n2 % max2 / parseFloat(max2);
    }
    function clamp01(val) {
      return mathMin(1, mathMax(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad2(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex(d2) {
      return Math2.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color2) {
      return !!matchers.CSS_UNIT.exec(color2);
    }
    function stringInputToObject(color2) {
      color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named2 = false;
      if (names[color2]) {
        color2 = names[color2];
        named2 = true;
      } else if (color2 == "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match5;
      if (match5 = matchers.rgb.exec(color2)) {
        return { r: match5[1], g: match5[2], b: match5[3] };
      }
      if (match5 = matchers.rgba.exec(color2)) {
        return { r: match5[1], g: match5[2], b: match5[3], a: match5[4] };
      }
      if (match5 = matchers.hsl.exec(color2)) {
        return { h: match5[1], s: match5[2], l: match5[3] };
      }
      if (match5 = matchers.hsla.exec(color2)) {
        return { h: match5[1], s: match5[2], l: match5[3], a: match5[4] };
      }
      if (match5 = matchers.hsv.exec(color2)) {
        return { h: match5[1], s: match5[2], v: match5[3] };
      }
      if (match5 = matchers.hsva.exec(color2)) {
        return { h: match5[1], s: match5[2], v: match5[3], a: match5[4] };
      }
      if (match5 = matchers.hex8.exec(color2)) {
        return {
          r: parseIntFromHex(match5[1]),
          g: parseIntFromHex(match5[2]),
          b: parseIntFromHex(match5[3]),
          a: convertHexToDecimal(match5[4]),
          format: named2 ? "name" : "hex8"
        };
      }
      if (match5 = matchers.hex6.exec(color2)) {
        return {
          r: parseIntFromHex(match5[1]),
          g: parseIntFromHex(match5[2]),
          b: parseIntFromHex(match5[3]),
          format: named2 ? "name" : "hex"
        };
      }
      if (match5 = matchers.hex4.exec(color2)) {
        return {
          r: parseIntFromHex(match5[1] + "" + match5[1]),
          g: parseIntFromHex(match5[2] + "" + match5[2]),
          b: parseIntFromHex(match5[3] + "" + match5[3]),
          a: convertHexToDecimal(match5[4] + "" + match5[4]),
          format: named2 ? "name" : "hex8"
        };
      }
      if (match5 = matchers.hex3.exec(color2)) {
        return {
          r: parseIntFromHex(match5[1] + "" + match5[1]),
          g: parseIntFromHex(match5[2] + "" + match5[2]),
          b: parseIntFromHex(match5[3] + "" + match5[3]),
          format: named2 ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size2;
      parms = parms || { "level": "AA", "size": "small" };
      level = (parms.level || "AA").toUpperCase();
      size2 = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size2 !== "small" && size2 !== "large") {
        size2 = "small";
      }
      return { "level": level, "size": size2 };
    }
    if (module2.exports) {
      module2.exports = tinycolor2;
    } else {
      window.tinycolor = tinycolor2;
    }
  })(Math);
})(tinycolor);
var tinyColor = tinycolor.exports;
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target2, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target2, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
}
function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$2(arr);
}
function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray$2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o2, minLen);
}
function _arrayLikeToArray$2(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var ENTROPY = 123;
var int2HexColor = function int2HexColor2(num2) {
  return "#".concat(Math.min(num2, Math.pow(2, 24)).toString(16).padStart(6, "0"));
};
var rgb2Int = function rgb2Int2(r2, g2, b2) {
  return (r2 << 16) + (g2 << 8) + b2;
};
var colorStr2Int = function colorStr2Int2(str) {
  var _tinyColor$toRgb = tinyColor(str).toRgb(), r2 = _tinyColor$toRgb.r, g2 = _tinyColor$toRgb.g, b2 = _tinyColor$toRgb.b;
  return rgb2Int(r2, g2, b2);
};
var checksum = function checksum2(n2, csBits) {
  return n2 * ENTROPY % Math.pow(2, csBits);
};
var _default = /* @__PURE__ */ function() {
  function _default11() {
    var csBits = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
    _classCallCheck(this, _default11);
    this.csBits = csBits;
    this.registry = ["__reserved for background__"];
  }
  _createClass(_default11, [{
    key: "register",
    value: function register2(obj) {
      if (this.registry.length >= Math.pow(2, 24 - this.csBits)) {
        return null;
      }
      var idx = this.registry.length;
      var cs = checksum(idx, this.csBits);
      var color2 = int2HexColor(idx + (cs << 24 - this.csBits));
      this.registry.push(obj);
      return color2;
    }
  }, {
    key: "lookup",
    value: function lookup2(color2) {
      var n2 = typeof color2 === "string" ? colorStr2Int(color2) : rgb2Int.apply(void 0, _toConsumableArray$2(color2));
      if (!n2)
        return null;
      var idx = n2 & Math.pow(2, 24 - this.csBits) - 1;
      var cs = n2 >> 24 - this.csBits & Math.pow(2, this.csBits) - 1;
      if (checksum(idx, this.csBits) !== cs || idx >= this.registry.length)
        return null;
      return this.registry[idx];
    }
  }]);
  return _default11;
}();
function forceCenter(x2, y2, z2) {
  var nodes, strength = 1;
  if (x2 == null)
    x2 = 0;
  if (y2 == null)
    y2 = 0;
  if (z2 == null)
    z2 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0, sz = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
    }
    for (sx = (sx / n2 - x2) * strength, sy = (sy / n2 - y2) * strength, sz = (sz / n2 - z2) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2];
      if (sx) {
        node.x -= sx;
      }
      if (sy) {
        node.y -= sy;
      }
      if (sz) {
        node.z -= sz;
      }
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  force.z = function(_2) {
    return arguments.length ? (z2 = +_2, force) : z2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}
function tree_add$2(d2) {
  var x2 = +this._x.call(null, d2);
  return add$2(this.cover(x2), x2, d2);
}
function add$2(tree, x2, d2) {
  if (isNaN(x2))
    return tree;
  var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, x1 = tree._x1, xm, xp, right, i2, j2;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (parent = node, !(node = node[i2 = +right]))
      return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  if (x2 === xp)
    return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(2) : tree._root = new Array(2);
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
  } while ((i2 = +right) === (j2 = +(xp >= xm)));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll$2(data2) {
  var i2, n2 = data2.length, x2, xz = new Array(n2), x0 = Infinity, x1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x2 = +this._x.call(null, data2[i2])))
      continue;
    xz[i2] = x2;
    if (x2 < x0)
      x0 = x2;
    if (x2 > x1)
      x1 = x2;
  }
  if (x0 > x1)
    return this;
  this.cover(x0).cover(x1);
  for (i2 = 0; i2 < n2; ++i2) {
    add$2(this, xz[i2], data2[i2]);
  }
  return this;
}
function tree_cover$2(x2) {
  if (isNaN(x2 = +x2))
    return this;
  var x0 = this._x0, x1 = this._x1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x2 || x2 >= x1) {
      i2 = +(x2 < x0);
      parent = new Array(2), parent[i2] = node, node = parent, z2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z2;
          break;
        case 1:
          x0 = x1 - z2;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._x1 = x1;
  return this;
}
function tree_data$2() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data2.push(node.data);
      while (node = node.next);
  });
  return data2;
}
function tree_extent$2(_2) {
  return arguments.length ? this.cover(+_2[0][0]).cover(+_2[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}
function Half(node, x0, x1) {
  this.node = node;
  this.x0 = x0;
  this.x1 = x1;
}
function tree_find$2(x2, radius) {
  var data2, x0 = this._x0, x1, x22, x3 = this._x1, halves = [], node = this._root, q2, i2;
  if (node)
    halves.push(new Half(node, x0, x3));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x2 - radius;
    x3 = x2 + radius;
  }
  while (q2 = halves.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x3 || (x22 = q2.x1) < x0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2;
      halves.push(new Half(node[1], xm, x22), new Half(node[0], x1, xm));
      if (i2 = +(x2 >= xm)) {
        q2 = halves[halves.length - 1];
        halves[halves.length - 1] = halves[halves.length - 1 - i2];
        halves[halves.length - 1 - i2] = q2;
      }
    } else {
      var d2 = Math.abs(x2 - +this._x.call(null, node.data));
      if (d2 < radius) {
        radius = d2;
        x0 = x2 - d2;
        x3 = x2 + d2;
        data2 = node.data;
      }
    }
  }
  return data2;
}
function tree_remove$2(d2) {
  if (isNaN(x2 = +this._x.call(null, d2)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x2, xm, right, i2, j2;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x2 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (!(parent = node, node = node[i2 = +right]))
        return this;
      if (!node.length)
        break;
      if (parent[i2 + 1 & 1])
        retainer = parent, j2 = i2;
    }
  while (node.data !== d2)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1]) && node === (parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j2] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll$2(data2) {
  for (var i2 = 0, n2 = data2.length; i2 < n2; ++i2)
    this.remove(data2[i2]);
  return this;
}
function tree_root$2() {
  return this._root;
}
function tree_size$2() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size2;
      while (node = node.next);
  });
  return size2;
}
function tree_visit$2(callback) {
  var halves = [], q2, node = this._root, child, x0, x1;
  if (node)
    halves.push(new Half(node, this._x0, this._x1));
  while (q2 = halves.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, x1 = q2.x1) && node.length) {
      var xm = (x0 + x1) / 2;
      if (child = node[1])
        halves.push(new Half(child, xm, x1));
      if (child = node[0])
        halves.push(new Half(child, x0, xm));
    }
  }
  return this;
}
function tree_visitAfter$2(callback) {
  var halves = [], next = [], q2;
  if (this._root)
    halves.push(new Half(this._root, this._x0, this._x1));
  while (q2 = halves.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, x1 = q2.x1, xm = (x0 + x1) / 2;
      if (child = node[0])
        halves.push(new Half(child, x0, xm));
      if (child = node[1])
        halves.push(new Half(child, xm, x1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.x1);
  }
  return this;
}
function defaultX$2(d2) {
  return d2[0];
}
function tree_x$2(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function binarytree(nodes, x2) {
  var tree = new Binarytree(x2 == null ? defaultX$2 : x2, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Binarytree(x2, x0, x1) {
  this._x = x2;
  this._x0 = x0;
  this._x1 = x1;
  this._root = void 0;
}
function leaf_copy$2(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto$2 = binarytree.prototype = Binarytree.prototype;
treeProto$2.copy = function() {
  var copy2 = new Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;
  if (!node)
    return copy2;
  if (!node.length)
    return copy2._root = leaf_copy$2(node), copy2;
  nodes = [{ source: node, target: copy2._root = new Array(2) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 2; ++i2) {
      if (child = node.source[i2]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i2] = new Array(2) });
        else
          node.target[i2] = leaf_copy$2(child);
      }
    }
  }
  return copy2;
};
treeProto$2.add = tree_add$2;
treeProto$2.addAll = addAll$2;
treeProto$2.cover = tree_cover$2;
treeProto$2.data = tree_data$2;
treeProto$2.extent = tree_extent$2;
treeProto$2.find = tree_find$2;
treeProto$2.remove = tree_remove$2;
treeProto$2.removeAll = removeAll$2;
treeProto$2.root = tree_root$2;
treeProto$2.size = tree_size$2;
treeProto$2.visit = tree_visit$2;
treeProto$2.visitAfter = tree_visitAfter$2;
treeProto$2.x = tree_x$2;
function tree_add$1(d2) {
  const x2 = +this._x.call(null, d2), y2 = +this._y.call(null, d2);
  return add$1(this.cover(x2, y2), x2, y2, d2);
}
function add$1(tree, x2, y2, d2) {
  if (isNaN(x2) || isNaN(y2))
    return tree;
  var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom2, i2, j2;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom2 = y2 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (parent = node, !(node = node[i2 = bottom2 << 1 | right]))
      return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x2 === xp && y2 === yp)
    return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom2 = y2 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
  } while ((i2 = bottom2 << 1 | right) === (j2 = (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll$1(data2) {
  var d2, i2, n2 = data2.length, x2, y2, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x2 = +this._x.call(null, d2 = data2[i2])) || isNaN(y2 = +this._y.call(null, d2)))
      continue;
    xz[i2] = x2;
    yz[i2] = y2;
    if (x2 < x0)
      x0 = x2;
    if (x2 > x1)
      x1 = x2;
    if (y2 < y0)
      y0 = y2;
    if (y2 > y1)
      y1 = y2;
  }
  if (x0 > x1 || y0 > y1)
    return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add$1(this, xz[i2], yz[i2], data2[i2]);
  }
  return this;
}
function tree_cover$1(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
    return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
    y1 = (y0 = Math.floor(y2)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1) {
      i2 = (y2 < y0) << 1 | x2 < x0;
      parent = new Array(4), parent[i2] = node, node = parent, z2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z2, y1 = y0 + z2;
          break;
        case 1:
          x0 = x1 - z2, y1 = y0 + z2;
          break;
        case 2:
          x1 = x0 + z2, y0 = y1 - z2;
          break;
        case 3:
          x0 = x1 - z2, y0 = y1 - z2;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}
function tree_data$1() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data2.push(node.data);
      while (node = node.next);
  });
  return data2;
}
function tree_extent$1(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}
function tree_find$1(x2, y2, radius) {
  var data2, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q2, i2;
  if (node)
    quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x2 - radius, y0 = y2 - radius;
    x3 = x2 + radius, y3 = y2 + radius;
    radius *= radius;
  }
  while (q2 = quads.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x3 || (y1 = q2.y0) > y3 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(new Quad(node[3], xm, ym, x22, y22), new Quad(node[2], x1, ym, xm, y22), new Quad(node[1], xm, y1, x22, ym), new Quad(node[0], x1, y1, xm, ym));
      if (i2 = (y2 >= ym) << 1 | x2 >= xm) {
        q2 = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q2;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d3 = Math.sqrt(radius = d2);
        x0 = x2 - d3, y0 = y2 - d3;
        x3 = x2 + d3, y3 = y2 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}
function tree_remove$1(d2) {
  if (isNaN(x2 = +this._x.call(null, d2)) || isNaN(y2 = +this._y.call(null, d2)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x2, y2, xm, ym, right, bottom2, i2, j2;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x2 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom2 = y2 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (!(parent = node, node = node[i2 = bottom2 << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3])
        retainer = parent, j2 = i2;
    }
  while (node.data !== d2)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j2] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll$1(data2) {
  for (var i2 = 0, n2 = data2.length; i2 < n2; ++i2)
    this.remove(data2[i2]);
  return this;
}
function tree_root$1() {
  return this._root;
}
function tree_size$1() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size2;
      while (node = node.next);
  });
  return size2;
}
function tree_visit$1(callback) {
  var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
  if (node)
    quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3])
        quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2])
        quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1])
        quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0])
        quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}
function tree_visitAfter$1(callback) {
  var quads = [], next = [], q2;
  if (this._root)
    quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0])
        quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1])
        quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2])
        quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3])
        quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
  }
  return this;
}
function defaultX$1(d2) {
  return d2[0];
}
function tree_x$1(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function defaultY$1(d2) {
  return d2[1];
}
function tree_y$1(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
function quadtree(nodes, x2, y2) {
  var tree = new Quadtree(x2 == null ? defaultX$1 : x2, y2 == null ? defaultY$1 : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x2, y2, x0, y0, x1, y1) {
  this._x = x2;
  this._y = y2;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy$1(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto$1 = quadtree.prototype = Quadtree.prototype;
treeProto$1.copy = function() {
  var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy2;
  if (!node.length)
    return copy2._root = leaf_copy$1(node), copy2;
  nodes = [{ source: node, target: copy2._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 4; ++i2) {
      if (child = node.source[i2]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i2] = new Array(4) });
        else
          node.target[i2] = leaf_copy$1(child);
      }
    }
  }
  return copy2;
};
treeProto$1.add = tree_add$1;
treeProto$1.addAll = addAll$1;
treeProto$1.cover = tree_cover$1;
treeProto$1.data = tree_data$1;
treeProto$1.extent = tree_extent$1;
treeProto$1.find = tree_find$1;
treeProto$1.remove = tree_remove$1;
treeProto$1.removeAll = removeAll$1;
treeProto$1.root = tree_root$1;
treeProto$1.size = tree_size$1;
treeProto$1.visit = tree_visit$1;
treeProto$1.visitAfter = tree_visitAfter$1;
treeProto$1.x = tree_x$1;
treeProto$1.y = tree_y$1;
function tree_add(d2) {
  var x2 = +this._x.call(null, d2), y2 = +this._y.call(null, d2), z2 = +this._z.call(null, d2);
  return add(this.cover(x2, y2, z2), x2, y2, z2, d2);
}
function add(tree, x2, y2, z2, d2) {
  if (isNaN(x2) || isNaN(y2) || isNaN(z2))
    return tree;
  var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom2, deep, i2, j2;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom2 = y2 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (deep = z2 >= (zm = (z0 + z1) / 2))
      z0 = zm;
    else
      z1 = zm;
    if (parent = node, !(node = node[i2 = deep << 2 | bottom2 << 1 | right]))
      return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  zp = +tree._z.call(null, node.data);
  if (x2 === xp && y2 === yp && z2 === zp)
    return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(8) : tree._root = new Array(8);
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom2 = y2 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (deep = z2 >= (zm = (z0 + z1) / 2))
      z0 = zm;
    else
      z1 = zm;
  } while ((i2 = deep << 2 | bottom2 << 1 | right) === (j2 = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll(data2) {
  var d2, i2, n2 = data2.length, x2, y2, z2, xz = new Array(n2), yz = new Array(n2), zz = new Array(n2), x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = -Infinity, y1 = -Infinity, z1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x2 = +this._x.call(null, d2 = data2[i2])) || isNaN(y2 = +this._y.call(null, d2)) || isNaN(z2 = +this._z.call(null, d2)))
      continue;
    xz[i2] = x2;
    yz[i2] = y2;
    zz[i2] = z2;
    if (x2 < x0)
      x0 = x2;
    if (x2 > x1)
      x1 = x2;
    if (y2 < y0)
      y0 = y2;
    if (y2 > y1)
      y1 = y2;
    if (z2 < z0)
      z0 = z2;
    if (z2 > z1)
      z1 = z2;
  }
  if (x0 > x1 || y0 > y1 || z0 > z1)
    return this;
  this.cover(x0, y0, z0).cover(x1, y1, z1);
  for (i2 = 0; i2 < n2; ++i2) {
    add(this, xz[i2], yz[i2], zz[i2], data2[i2]);
  }
  return this;
}
function tree_cover(x2, y2, z2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2) || isNaN(z2 = +z2))
    return this;
  var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
    y1 = (y0 = Math.floor(y2)) + 1;
    z1 = (z0 = Math.floor(z2)) + 1;
  } else {
    var t2 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1 || z0 > z2 || z2 >= z1) {
      i2 = (z2 < z0) << 2 | (y2 < y0) << 1 | x2 < x0;
      parent = new Array(8), parent[i2] = node, node = parent, t2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + t2, y1 = y0 + t2, z1 = z0 + t2;
          break;
        case 1:
          x0 = x1 - t2, y1 = y0 + t2, z1 = z0 + t2;
          break;
        case 2:
          x1 = x0 + t2, y0 = y1 - t2, z1 = z0 + t2;
          break;
        case 3:
          x0 = x1 - t2, y0 = y1 - t2, z1 = z0 + t2;
          break;
        case 4:
          x1 = x0 + t2, y1 = y0 + t2, z0 = z1 - t2;
          break;
        case 5:
          x0 = x1 - t2, y1 = y0 + t2, z0 = z1 - t2;
          break;
        case 6:
          x1 = x0 + t2, y0 = y1 - t2, z0 = z1 - t2;
          break;
        case 7:
          x0 = x1 - t2, y0 = y1 - t2, z0 = z1 - t2;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  return this;
}
function tree_data() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data2.push(node.data);
      while (node = node.next);
  });
  return data2;
}
function tree_extent(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1], +_2[0][2]).cover(+_2[1][0], +_2[1][1], +_2[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}
function Octant(node, x0, y0, z0, x1, y1, z1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.z0 = z0;
  this.x1 = x1;
  this.y1 = y1;
  this.z1 = z1;
}
function tree_find(x2, y2, z2, radius) {
  var data2, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, z1, x22, y22, z22, x3 = this._x1, y3 = this._y1, z3 = this._z1, octs = [], node = this._root, q2, i2;
  if (node)
    octs.push(new Octant(node, x0, y0, z0, x3, y3, z3));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x2 - radius, y0 = y2 - radius, z0 = z2 - radius;
    x3 = x2 + radius, y3 = y2 + radius, z3 = z2 + radius;
    radius *= radius;
  }
  while (q2 = octs.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x3 || (y1 = q2.y0) > y3 || (z1 = q2.z0) > z3 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0 || (z22 = q2.z1) < z0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2, zm = (z1 + z22) / 2;
      octs.push(new Octant(node[7], xm, ym, zm, x22, y22, z22), new Octant(node[6], x1, ym, zm, xm, y22, z22), new Octant(node[5], xm, y1, zm, x22, ym, z22), new Octant(node[4], x1, y1, zm, xm, ym, z22), new Octant(node[3], xm, ym, z1, x22, y22, zm), new Octant(node[2], x1, ym, z1, xm, y22, zm), new Octant(node[1], xm, y1, z1, x22, ym, zm), new Octant(node[0], x1, y1, z1, xm, ym, zm));
      if (i2 = (z2 >= zm) << 2 | (y2 >= ym) << 1 | x2 >= xm) {
        q2 = octs[octs.length - 1];
        octs[octs.length - 1] = octs[octs.length - 1 - i2];
        octs[octs.length - 1 - i2] = q2;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), dz = z2 - +this._z.call(null, node.data), d2 = dx * dx + dy * dy + dz * dz;
      if (d2 < radius) {
        var d3 = Math.sqrt(radius = d2);
        x0 = x2 - d3, y0 = y2 - d3, z0 = z2 - d3;
        x3 = x2 + d3, y3 = y2 + d3, z3 = z2 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}
function tree_remove(d2) {
  if (isNaN(x2 = +this._x.call(null, d2)) || isNaN(y2 = +this._y.call(null, d2)) || isNaN(z2 = +this._z.call(null, d2)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x2, y2, z2, xm, ym, zm, right, bottom2, deep, i2, j2;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x2 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom2 = y2 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (deep = z2 >= (zm = (z0 + z1) / 2))
        z0 = zm;
      else
        z1 = zm;
      if (!(parent = node, node = node[i2 = deep << 2 | bottom2 << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i2 + 1 & 7] || parent[i2 + 2 & 7] || parent[i2 + 3 & 7] || parent[i2 + 4 & 7] || parent[i2 + 5 & 7] || parent[i2 + 6 & 7] || parent[i2 + 7 & 7])
        retainer = parent, j2 = i2;
    }
  while (node.data !== d2)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j2] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data2) {
  for (var i2 = 0, n2 = data2.length; i2 < n2; ++i2)
    this.remove(data2[i2]);
  return this;
}
function tree_root() {
  return this._root;
}
function tree_size() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size2;
      while (node = node.next);
  });
  return size2;
}
function tree_visit(callback) {
  var octs = [], q2, node = this._root, child, x0, y0, z0, x1, y1, z1;
  if (node)
    octs.push(new Octant(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q2 = octs.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[7])
        octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
      if (child = node[6])
        octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
      if (child = node[5])
        octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
      if (child = node[4])
        octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
      if (child = node[3])
        octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
      if (child = node[2])
        octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
      if (child = node[1])
        octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
      if (child = node[0])
        octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
    }
  }
  return this;
}
function tree_visitAfter(callback) {
  var octs = [], next = [], q2;
  if (this._root)
    octs.push(new Octant(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q2 = octs.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[0])
        octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
      if (child = node[1])
        octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
      if (child = node[2])
        octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
      if (child = node[3])
        octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
      if (child = node[4])
        octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
      if (child = node[5])
        octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
      if (child = node[6])
        octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
      if (child = node[7])
        octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.z0, q2.x1, q2.y1, q2.z1);
  }
  return this;
}
function defaultX(d2) {
  return d2[0];
}
function tree_x(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function defaultY(d2) {
  return d2[1];
}
function tree_y(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
function defaultZ(d2) {
  return d2[2];
}
function tree_z(_2) {
  return arguments.length ? (this._z = _2, this) : this._z;
}
function octree(nodes, x2, y2, z2) {
  var tree = new Octree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, z2 == null ? defaultZ : z2, NaN, NaN, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Octree(x2, y2, z2, x0, y0, z0, x1, y1, z1) {
  this._x = x2;
  this._y = y2;
  this._z = z2;
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto = octree.prototype = Octree.prototype;
treeProto.copy = function() {
  var copy2 = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
  if (!node)
    return copy2;
  if (!node.length)
    return copy2._root = leaf_copy(node), copy2;
  nodes = [{ source: node, target: copy2._root = new Array(8) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 8; ++i2) {
      if (child = node.source[i2]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i2] = new Array(8) });
        else
          node.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy2;
};
treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;
treeProto.z = tree_z;
function constant(x2) {
  return function() {
    return x2;
  };
}
function jiggle(random) {
  return (random() - 0.5) * 1e-6;
}
function index$1(d2) {
  return d2.index;
}
function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function forceLink(links) {
  var id2 = index$1, strength = defaultStrength, strengths, distance = constant(30), distances, nodes, nDim, count2, bias, random, iterations = 1;
  if (links == null)
    links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count2[link3.source.index], count2[link3.target.index]);
  }
  function force(alpha2) {
    for (var k2 = 0, n2 = links.length; k2 < iterations; ++k2) {
      for (var i2 = 0, link3, source, target2, x2 = 0, y2 = 0, z2 = 0, l2, b2; i2 < n2; ++i2) {
        link3 = links[i2], source = link3.source, target2 = link3.target;
        x2 = target2.x + target2.vx - source.x - source.vx || jiggle(random);
        if (nDim > 1) {
          y2 = target2.y + target2.vy - source.y - source.vy || jiggle(random);
        }
        if (nDim > 2) {
          z2 = target2.z + target2.vz - source.z - source.vz || jiggle(random);
        }
        l2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
        l2 = (l2 - distances[i2]) / l2 * alpha2 * strengths[i2];
        x2 *= l2, y2 *= l2, z2 *= l2;
        target2.vx -= x2 * (b2 = bias[i2]);
        if (nDim > 1) {
          target2.vy -= y2 * b2;
        }
        if (nDim > 2) {
          target2.vz -= z2 * b2;
        }
        source.vx += x2 * (b2 = 1 - b2);
        if (nDim > 1) {
          source.vy += y2 * b2;
        }
        if (nDim > 2) {
          source.vz += z2 * b2;
        }
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d2, i3) => [id2(d2, i3, nodes), d2])), link3;
    for (i2 = 0, count2 = new Array(n2); i2 < m2; ++i2) {
      link3 = links[i2], link3.index = i2;
      if (typeof link3.source !== "object")
        link3.source = find(nodeById, link3.source);
      if (typeof link3.target !== "object")
        link3.target = find(nodeById, link3.target);
      count2[link3.source.index] = (count2[link3.source.index] || 0) + 1;
      count2[link3.target.index] = (count2[link3.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m2); i2 < m2; ++i2) {
      link3 = links[i2], bias[i2] = count2[link3.source.index] / (count2[link3.source.index] + count2[link3.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id2 = _2, force) : id2;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance = typeof _2 === "function" ? _2 : constant(+_2), initializeDistance(), force) : distance;
  };
  return force;
}
const a = 1664525;
const c = 1013904223;
const m = 4294967296;
function lcg() {
  let s2 = 1;
  return () => (s2 = (a * s2 + c) % m) / m;
}
var MAX_DIMENSIONS = 3;
function x(d2) {
  return d2.x;
}
function y(d2) {
  return d2.y;
}
function z(d2) {
  return d2.z;
}
var initialRadius = 10, initialAngleRoll = Math.PI * (3 - Math.sqrt(5)), initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221));
function forceSimulation(nodes, numDimensions) {
  numDimensions = numDimensions || 2;
  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))), simulation, alpha2 = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch("tick", "end"), random = lcg();
  if (nodes == null)
    nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha2 < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0)
      iterations = 1;
    for (var k2 = 0; k2 < iterations; ++k2) {
      alpha2 += (alphaTarget - alpha2) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha2);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (nDim > 1) {
          if (node.fy == null)
            node.y += node.vy *= velocityDecay;
          else
            node.y = node.fy, node.vy = 0;
        }
        if (nDim > 2) {
          if (node.fz == null)
            node.z += node.vz *= velocityDecay;
          else
            node.z = node.fz, node.vz = 0;
        }
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (node.fz != null)
        node.z = node.fz;
      if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && isNaN(node.z)) {
        var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i2) : nDim > 1 ? Math.sqrt(0.5 + i2) : i2), rollAngle = i2 * initialAngleRoll, yawAngle = i2 * initialAngleYaw;
        if (nDim === 1) {
          node.x = radius;
        } else if (nDim === 2) {
          node.x = radius * Math.cos(rollAngle);
          node.y = radius * Math.sin(rollAngle);
        } else {
          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
          node.y = radius * Math.cos(rollAngle);
          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
        }
      }
      if (isNaN(node.vx) || nDim > 1 && isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {
        node.vx = 0;
        if (nDim > 1) {
          node.vy = 0;
        }
        if (nDim > 2) {
          node.vz = 0;
        }
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random, nDim);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    numDimensions: function(_2) {
      return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_2))), forces.forEach(initializeForce), simulation) : nDim;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha2 = +_2, simulation) : alpha2;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function() {
      var args = Array.prototype.slice.call(arguments);
      var x2 = args.shift() || 0, y2 = (nDim > 1 ? args.shift() : null) || 0, z2 = (nDim > 2 ? args.shift() : null) || 0, radius = args.shift() || Infinity;
      var i2 = 0, n2 = nodes.length, dx, dy, dz, d2, node, closest;
      radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x2 - node.x;
        dy = y2 - (node.y || 0);
        dz = z2 - (node.z || 0);
        d2 = dx * dx + dy * dy + dz * dz;
        if (d2 < radius)
          closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}
function forceManyBody() {
  var nodes, nDim, node, random, alpha2, strength = constant(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = (nDim === 1 ? binarytree(nodes, x) : nDim === 2 ? quadtree(nodes, x, y) : nDim === 3 ? octree(nodes, x, y, z) : null).visitAfter(accumulate);
    for (alpha2 = _2, i2 = 0; i2 < n2; ++i2)
      node = nodes[i2], tree.visit(apply);
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2)
      node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate(treeNode) {
    var strength2 = 0, q2, c2, weight = 0, x2, y2, z2, i2;
    var numChildren = treeNode.length;
    if (numChildren) {
      for (x2 = y2 = z2 = i2 = 0; i2 < numChildren; ++i2) {
        if ((q2 = treeNode[i2]) && (c2 = Math.abs(q2.value))) {
          strength2 += q2.value, weight += c2, x2 += c2 * (q2.x || 0), y2 += c2 * (q2.y || 0), z2 += c2 * (q2.z || 0);
        }
      }
      strength2 *= Math.sqrt(4 / numChildren);
      treeNode.x = x2 / weight;
      if (nDim > 1) {
        treeNode.y = y2 / weight;
      }
      if (nDim > 2) {
        treeNode.z = z2 / weight;
      }
    } else {
      q2 = treeNode;
      q2.x = q2.data.x;
      if (nDim > 1) {
        q2.y = q2.data.y;
      }
      if (nDim > 2) {
        q2.z = q2.data.z;
      }
      do
        strength2 += strengths[q2.data.index];
      while (q2 = q2.next);
    }
    treeNode.value = strength2;
  }
  function apply(treeNode, x1, arg1, arg2, arg3) {
    if (!treeNode.value)
      return true;
    var x2 = [arg1, arg2, arg3][nDim - 1];
    var x3 = treeNode.x - node.x, y2 = nDim > 1 ? treeNode.y - node.y : 0, z2 = nDim > 2 ? treeNode.z - node.z : 0, w2 = x2 - x1, l2 = x3 * x3 + y2 * y2 + z2 * z2;
    if (w2 * w2 / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x3 === 0)
          x3 = jiggle(random), l2 += x3 * x3;
        if (nDim > 1 && y2 === 0)
          y2 = jiggle(random), l2 += y2 * y2;
        if (nDim > 2 && z2 === 0)
          z2 = jiggle(random), l2 += z2 * z2;
        if (l2 < distanceMin2)
          l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x3 * treeNode.value * alpha2 / l2;
        if (nDim > 1) {
          node.vy += y2 * treeNode.value * alpha2 / l2;
        }
        if (nDim > 2) {
          node.vz += z2 * treeNode.value * alpha2 / l2;
        }
      }
      return true;
    } else if (treeNode.length || l2 >= distanceMax2)
      return;
    if (treeNode.data !== node || treeNode.next) {
      if (x3 === 0)
        x3 = jiggle(random), l2 += x3 * x3;
      if (nDim > 1 && y2 === 0)
        y2 = jiggle(random), l2 += y2 * y2;
      if (nDim > 2 && z2 === 0)
        z2 = jiggle(random), l2 += z2 * z2;
      if (l2 < distanceMin2)
        l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (treeNode.data !== node) {
        w2 = strengths[treeNode.data.index] * alpha2 / l2;
        node.vx += x3 * w2;
        if (nDim > 1) {
          node.vy += y2 * w2;
        }
        if (nDim > 2) {
          node.vz += z2 * w2;
        }
      }
    while (treeNode = treeNode.next);
  }
  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find((arg) => typeof arg === "function") || Math.random;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}
function forceRadial(radius, x2, y2, z2) {
  var nodes, nDim, strength = constant(0.1), strengths, radiuses;
  if (typeof radius !== "function")
    radius = constant(+radius);
  if (x2 == null)
    x2 = 0;
  if (y2 == null)
    y2 = 0;
  if (z2 == null)
    z2 = 0;
  function force(alpha2) {
    for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      var node = nodes[i2], dx = node.x - x2 || 1e-6, dy = (node.y || 0) - y2 || 1e-6, dz = (node.z || 0) - z2 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy + dz * dz), k2 = (radiuses[i2] - r2) * strengths[i2] * alpha2 / r2;
      node.vx += dx * k2;
      if (nDim > 1) {
        node.vy += dy * k2;
      }
      if (nDim > 2) {
        node.vz += dz * k2;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    radiuses = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(initNodes, ...args) {
    nodes = initNodes;
    nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  force.z = function(_2) {
    return arguments.length ? (z2 = +_2, force) : z2;
  };
  return force;
}
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v2) {
  return v2 < 0 ? -pow(-v2, 1 / 3) : pow(v2, 1 / 3);
}
const pi$1 = Math.PI, tau = 2 * pi$1, quart = pi$1 / 2, epsilon = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = { x: 0, y: 0, z: 0 };
const utils = {
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t2, derivativeFn) {
    const d2 = derivativeFn(t2);
    let l2 = d2.x * d2.x + d2.y * d2.y;
    if (typeof d2.z !== "undefined") {
      l2 += d2.z * d2.z;
    }
    return sqrt$1(l2);
  },
  compute: function(t2, points, _3d) {
    if (t2 === 0) {
      points[0].t = 0;
      return points[0];
    }
    const order2 = points.length - 1;
    if (t2 === 1) {
      points[order2].t = 1;
      return points[order2];
    }
    const mt = 1 - t2;
    let p2 = points;
    if (order2 === 0) {
      points[0].t = t2;
      return points[0];
    }
    if (order2 === 1) {
      const ret = {
        x: mt * p2[0].x + t2 * p2[1].x,
        y: mt * p2[0].y + t2 * p2[1].y,
        t: t2
      };
      if (_3d) {
        ret.z = mt * p2[0].z + t2 * p2[1].z;
      }
      return ret;
    }
    if (order2 < 4) {
      let mt2 = mt * mt, t22 = t2 * t2, a2, b2, c2, d2 = 0;
      if (order2 === 2) {
        p2 = [p2[0], p2[1], p2[2], ZERO];
        a2 = mt2;
        b2 = mt * t2 * 2;
        c2 = t22;
      } else if (order2 === 3) {
        a2 = mt2 * mt;
        b2 = mt2 * t2 * 3;
        c2 = mt * t22 * 3;
        d2 = t2 * t22;
      }
      const ret = {
        x: a2 * p2[0].x + b2 * p2[1].x + c2 * p2[2].x + d2 * p2[3].x,
        y: a2 * p2[0].y + b2 * p2[1].y + c2 * p2[2].y + d2 * p2[3].y,
        t: t2
      };
      if (_3d) {
        ret.z = a2 * p2[0].z + b2 * p2[1].z + c2 * p2[2].z + d2 * p2[3].z;
      }
      return ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i2 = 0; i2 < dCpts.length - 1; i2++) {
        dCpts[i2] = {
          x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t2,
          y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t2
        };
        if (typeof dCpts[i2].z !== "undefined") {
          dCpts[i2] = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t2;
        }
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t2;
    return dCpts[0];
  },
  computeWithRatios: function(t2, points, ratios, _3d) {
    const mt = 1 - t2, r2 = ratios, p2 = points;
    let f1 = r2[0], f2 = r2[1], f3 = r2[2], f4 = r2[3], d2;
    f1 *= mt;
    f2 *= t2;
    if (p2.length === 2) {
      d2 = f1 + f2;
      return {
        x: (f1 * p2[0].x + f2 * p2[1].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y) / d2,
        z: !_3d ? false : (f1 * p2[0].z + f2 * p2[1].z) / d2,
        t: t2
      };
    }
    f1 *= mt;
    f2 *= 2 * mt;
    f3 *= t2 * t2;
    if (p2.length === 3) {
      d2 = f1 + f2 + f3;
      return {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y) / d2,
        z: !_3d ? false : (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z) / d2,
        t: t2
      };
    }
    f1 *= mt;
    f2 *= 1.5 * mt;
    f3 *= 3 * mt;
    f4 *= t2 * t2 * t2;
    if (p2.length === 4) {
      d2 = f1 + f2 + f3 + f4;
      return {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x + f4 * p2[3].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y + f4 * p2[3].y) / d2,
        z: !_3d ? false : (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z + f4 * p2[3].z) / d2,
        t: t2
      };
    }
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p2 = points, d2 = p2.length, c2 = d2 - 1; d2 > 1; d2--, c2--) {
      const list3 = [];
      for (let j2 = 0, dpt; j2 < c2; j2++) {
        dpt = {
          x: c2 * (p2[j2 + 1].x - p2[j2].x),
          y: c2 * (p2[j2 + 1].y - p2[j2].y)
        };
        if (_3d) {
          dpt.z = c2 * (p2[j2 + 1].z - p2[j2].z);
        }
        list3.push(dpt);
      }
      dpoints.push(list3);
      p2 = list3;
    }
    return dpoints;
  },
  between: function(v2, m2, M2) {
    return m2 <= v2 && v2 <= M2 || utils.approximately(v2, m2) || utils.approximately(v2, M2);
  },
  approximately: function(a2, b2, precision) {
    return abs$1(a2 - b2) <= (precision || epsilon);
  },
  length: function(derivativeFn) {
    const z2 = 0.5, len2 = utils.Tvalues.length;
    let sum2 = 0;
    for (let i2 = 0, t2; i2 < len2; i2++) {
      t2 = z2 * utils.Tvalues[i2] + z2;
      sum2 += utils.Cvalues[i2] * utils.arcfn(t2, derivativeFn);
    }
    return z2 * sum2;
  },
  map: function(v2, ds, de, ts, te) {
    const d1 = de - ds, d2 = te - ts, v22 = v2 - ds, r2 = v22 / d1;
    return ts + d2 * r2;
  },
  lerp: function(r2, v1, v2) {
    const ret = {
      x: v1.x + r2 * (v2.x - v1.x),
      y: v1.y + r2 * (v2.y - v1.y)
    };
    if (v1.z !== void 0 && v2.z !== void 0) {
      ret.z = v1.z + r2 * (v2.z - v1.z);
    }
    return ret;
  },
  pointToString: function(p2) {
    let s2 = p2.x + "/" + p2.y;
    if (typeof p2.z !== "undefined") {
      s2 += "/" + p2.z;
    }
    return s2;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o2, v1, v2) {
    const dx1 = v1.x - o2.x, dy1 = v1.y - o2.y, dx2 = v2.x - o2.x, dy2 = v2.y - o2.y, cross2 = dx1 * dy2 - dy1 * dx2, dot2 = dx1 * dx2 + dy1 * dy2;
    return atan2(cross2, dot2);
  },
  round: function(v2, d2) {
    const s2 = "" + v2;
    const pos = s2.indexOf(".");
    return parseFloat(s2.substring(0, pos + 1 + d2));
  },
  dist: function(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function(LUT, point) {
    let mdist = pow(2, 63), mpos, d2;
    LUT.forEach(function(p2, idx) {
      d2 = utils.dist(point, p2);
      if (d2 < mdist) {
        mdist = d2;
        mpos = idx;
      }
    });
    return { mdist, mpos };
  },
  abcratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3) {
      return false;
    }
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    } else if (t2 === 0 || t2 === 1) {
      return t2;
    }
    const bottom2 = pow(t2, n2) + pow(1 - t2, n2), top2 = bottom2 - 1;
    return abs$1(top2 / bottom2);
  },
  projectionratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3) {
      return false;
    }
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    } else if (t2 === 0 || t2 === 1) {
      return t2;
    }
    const top2 = pow(1 - t2, n2), bottom2 = pow(t2, n2) + top2;
    return top2 / bottom2;
  },
  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d2 == 0) {
      return false;
    }
    return { x: nx / d2, y: ny / d2 };
  },
  lli4: function(p1, p2, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p2) {
    return new Bezier(p1.x, p1.y, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, p2.x, p2.y);
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    sections.forEach(function(s2) {
      const bbox = s2.bbox();
      if (mx > bbox.x.min)
        mx = bbox.x.min;
      if (my > bbox.y.min)
        my = bbox.y.min;
      if (MX < bbox.x.max)
        MX = bbox.x.max;
      if (MY < bbox.y.max)
        MY = bbox.y.max;
    });
    return {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2))
      return [];
    const intersections = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    a1.forEach(function(l1) {
      if (l1.virtual)
        return;
      a2.forEach(function(l2) {
        if (l2.virtual)
          return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l2;
          iss.s1 = s1;
          iss.s2 = s2;
          intersections.push(iss);
        }
      });
    });
    return intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start2 = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start2,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start2, forward, back, end])
    };
    shape.intersections = function(s2) {
      return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);
    };
    return shape;
  },
  getminmax: function(curve, d2, list3) {
    if (!list3)
      return { min: 0, max: 0 };
    let min2 = nMax, max2 = nMin, t2, c2;
    if (list3.indexOf(0) === -1) {
      list3 = [0].concat(list3);
    }
    if (list3.indexOf(1) === -1) {
      list3.push(1);
    }
    for (let i2 = 0, len2 = list3.length; i2 < len2; i2++) {
      t2 = list3[i2];
      c2 = curve.get(t2);
      if (c2[d2] < min2) {
        min2 = c2[d2];
      }
      if (c2[d2] > max2) {
        max2 = c2[d2];
      }
    }
    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
  },
  align: function(points, line2) {
    const tx = line2.p1.x, ty = line2.p1.y, a2 = -atan2(line2.p2.y - ty, line2.p2.x - tx), d2 = function(v2) {
      return {
        x: (v2.x - tx) * cos$1(a2) - (v2.y - ty) * sin$1(a2),
        y: (v2.x - tx) * sin$1(a2) + (v2.y - ty) * cos$1(a2)
      };
    };
    return points.map(d2);
  },
  roots: function(points, line2) {
    line2 = line2 || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order2 = points.length - 1;
    const aligned = utils.align(points, line2);
    const reduce = function(t2) {
      return 0 <= t2 && t2 <= 1;
    };
    if (order2 === 2) {
      const a3 = aligned[0].y, b3 = aligned[1].y, c3 = aligned[2].y, d3 = a3 - 2 * b3 + c3;
      if (d3 !== 0) {
        const m1 = -sqrt$1(b3 * b3 - a3 * c3), m2 = -a3 + b3, v12 = -(m1 + m2) / d3, v2 = -(-m1 + m2) / d3;
        return [v12, v2].filter(reduce);
      } else if (b3 !== c3 && d3 === 0) {
        return [(2 * b3 - c3) / (2 * b3 - 2 * c3)].filter(reduce);
      }
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d2 = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b2 = -3 * pa + 3 * pb, c2 = pa;
    if (utils.approximately(d2, 0)) {
      if (utils.approximately(a2, 0)) {
        if (utils.approximately(b2, 0)) {
          return [];
        }
        return [-c2 / b2].filter(reduce);
      }
      const q3 = sqrt$1(b2 * b2 - 4 * a2 * c2), a22 = 2 * a2;
      return [(q3 - b2) / a22, (-b2 - q3) / a22].filter(reduce);
    }
    a2 /= d2;
    b2 /= d2;
    c2 /= d2;
    const p2 = (3 * b2 - a2 * a2) / 3, p3 = p2 / 3, q2 = (2 * a2 * a2 * a2 - 9 * a2 * b2 + 27 * c2) / 27, q22 = q2 / 2, discriminant = q22 * q22 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p2 / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt$1(mp33), t2 = -q2 / (2 * r2), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi2 = acos$1(cosphi), crtr = crt(r2), t1 = 2 * crtr;
      x1 = t1 * cos$1(phi2 / 3) - a2 / 3;
      x2 = t1 * cos$1((phi2 + tau) / 3) - a2 / 3;
      x3 = t1 * cos$1((phi2 + 2 * tau) / 3) - a2 / 3;
      return [x1, x2, x3].filter(reduce);
    } else if (discriminant === 0) {
      u1 = q22 < 0 ? crt(-q22) : -crt(q22);
      x1 = 2 * u1 - a2 / 3;
      x2 = -u1 - a2 / 3;
      return [x1, x2].filter(reduce);
    } else {
      const sd = sqrt$1(discriminant);
      u1 = crt(-q22 + sd);
      v1 = crt(q22 + sd);
      return [u1 - v1 - a2 / 3].filter(reduce);
    }
  },
  droots: function(p2) {
    if (p2.length === 3) {
      const a2 = p2[0], b2 = p2[1], c2 = p2[2], d2 = a2 - 2 * b2 + c2;
      if (d2 !== 0) {
        const m1 = -sqrt$1(b2 * b2 - a2 * c2), m2 = -a2 + b2, v1 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
        return [v1, v2];
      } else if (b2 !== c2 && d2 === 0) {
        return [(2 * b2 - c2) / (2 * (b2 - c2))];
      }
      return [];
    }
    if (p2.length === 2) {
      const a2 = p2[0], b2 = p2[1];
      if (a2 !== b2) {
        return [a2 / (a2 - b2)];
      }
      return [];
    }
    return [];
  },
  curvature: function(t2, d1, d2, _3d, kOnly) {
    let num2, dnm, adk, dk, k2 = 0, r2 = 0;
    const d3 = utils.compute(t2, d1);
    const dd2 = utils.compute(t2, d2);
    const qdsum = d3.x * d3.x + d3.y * d3.y;
    if (_3d) {
      num2 = sqrt$1(pow(d3.y * dd2.z - dd2.y * d3.z, 2) + pow(d3.z * dd2.x - dd2.z * d3.x, 2) + pow(d3.x * dd2.y - dd2.x * d3.y, 2));
      dnm = pow(qdsum + d3.z * d3.z, 3 / 2);
    } else {
      num2 = d3.x * dd2.y - d3.y * dd2.x;
      dnm = pow(qdsum, 3 / 2);
    }
    if (num2 === 0 || dnm === 0) {
      return { k: 0, r: 0 };
    }
    k2 = num2 / dnm;
    r2 = dnm / num2;
    if (!kOnly) {
      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, true).k;
      const nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, true).k;
      dk = (nk - k2 + (k2 - pk)) / 2;
      adk = (abs$1(nk - k2) + abs$1(k2 - pk)) / 2;
    }
    return { k: k2, r: r2, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4)
      return [];
    const p2 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p2[2].x * p2[1].y, b2 = p2[3].x * p2[1].y, c2 = p2[1].x * p2[2].y, d2 = p2[3].x * p2[2].y, v1 = 18 * (-3 * a2 + 2 * b2 + 3 * c2 - d2), v2 = 18 * (3 * a2 - b2 - 3 * c2), v3 = 18 * (c2 - a2);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t2 = -v3 / v2;
        if (0 <= t2 && t2 <= 1)
          return [t2];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0))
      return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0)
      return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d22, -(v2 + sq) / d22].filter(function(r2) {
      return 0 <= r2 && r2 <= 1;
    });
  },
  bboxoverlap: function(b1, b2) {
    const dims = ["x", "y"], len2 = dims.length;
    for (let i2 = 0, dim, l2, t2, d2; i2 < len2; i2++) {
      dim = dims[i2];
      l2 = b1[dim].mid;
      t2 = b2[dim].mid;
      d2 = (b1[dim].size + b2[dim].size) / 2;
      if (abs$1(l2 - t2) >= d2)
        return false;
    }
    return true;
  },
  expandbox: function(bbox, _bbox) {
    if (_bbox.x.min < bbox.x.min) {
      bbox.x.min = _bbox.x.min;
    }
    if (_bbox.y.min < bbox.y.min) {
      bbox.y.min = _bbox.y.min;
    }
    if (_bbox.z && _bbox.z.min < bbox.z.min) {
      bbox.z.min = _bbox.z.min;
    }
    if (_bbox.x.max > bbox.x.max) {
      bbox.x.max = _bbox.x.max;
    }
    if (_bbox.y.max > bbox.y.max) {
      bbox.y.max = _bbox.y.max;
    }
    if (_bbox.z && _bbox.z.max > bbox.z.max) {
      bbox.z.max = _bbox.z.max;
    }
    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
    if (bbox.z) {
      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
    }
    bbox.x.size = bbox.x.max - bbox.x.min;
    bbox.y.size = bbox.y.max - bbox.y.min;
    if (bbox.z) {
      bbox.z.size = bbox.z.max - bbox.z.min;
    }
  },
  pairiteration: function(c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c2.bbox(), r2 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
      return [
        (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c2._t1 + c2._t2) / 2 | 0) / r2
      ];
    }
    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs2 = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs2 = pairs2.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    if (pairs2.length === 0)
      return results;
    pairs2.forEach(function(pair) {
      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));
    });
    results = results.filter(function(v2, i2) {
      return results.indexOf(v2) === i2;
    });
    return results;
  },
  getccenter: function(p1, p2, p3) {
    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
    let s2 = atan2(p1.y - arc.y, p1.x - arc.x), m2 = atan2(p2.y - arc.y, p2.x - arc.x), e2 = atan2(p3.y - arc.y, p3.x - arc.x), _2;
    if (s2 < e2) {
      if (s2 > m2 || m2 > e2) {
        s2 += tau;
      }
      if (s2 > e2) {
        _2 = e2;
        e2 = s2;
        s2 = _2;
      }
    } else {
      if (e2 < m2 && m2 < s2) {
        _2 = e2;
        e2 = s2;
        s2 = _2;
      } else {
        e2 += tau;
      }
    }
    arc.s = s2;
    arc.e = e2;
    arc.r = r2;
    return arc;
  },
  numberSort: function(a2, b2) {
    return a2 - b2;
  }
};
class PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve) {
      return utils.pointsToString(curve.points);
    }).join(", ") + "]";
  }
  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }
  length() {
    return this.curves.map(function(v2) {
      return v2.length();
    }).reduce(function(a2, b2) {
      return a2 + b2;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c2 = this.curves;
    var bbox = c2[0].bbox();
    for (var i2 = 1; i2 < c2.length; i2++) {
      utils.expandbox(bbox, c2[i2].bbox());
    }
    return bbox;
  }
  offset(d2) {
    const offset2 = [];
    this.curves.forEach(function(v2) {
      offset2.push(...v2.offset(d2));
    });
    return new PolyBezier(offset2);
  }
}
const { abs, min, max, cos, sin, acos, sqrt } = Math;
const pi = Math.PI;
class Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;
    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point2) {
        ["x", "y", "z"].forEach(function(d2) {
          if (typeof point2[d2] !== "undefined") {
            newargs.push(point2[d2]);
          }
        });
      });
      args = newargs;
    }
    let higher = false;
    const len2 = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
        higher = true;
      }
    } else {
      if (len2 !== 6 && len2 !== 8 && len2 !== 9 && len2 !== 12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }
    const _3d = this._3d = !higher && (len2 === 9 || len2 === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
    const points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len2; idx += step) {
      var point = {
        x: args[idx],
        y: args[idx + 1]
      };
      if (_3d) {
        point.z = args[idx + 2];
      }
      points.push(point);
    }
    const order2 = this.order = points.length - 1;
    const dims = this.dims = ["x", "y"];
    if (_3d)
      dims.push("z");
    this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order2] });
    const baselength = utils.dist(points[0], points[order2]);
    this._linear = aligned.reduce((t2, p2) => t2 + abs(p2.y), 0) < baselength / 50;
    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }
  static quadraticFromPoints(p1, p2, p3, t2) {
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    }
    if (t2 === 0) {
      return new Bezier(p2, p2, p3);
    }
    if (t2 === 1) {
      return new Bezier(p1, p2, p2);
    }
    const abc = Bezier.getABC(2, p1, p2, p3, t2);
    return new Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S2, B2, E2, t2, d1) {
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    }
    const abc = Bezier.getABC(3, S2, B2, E2, t2);
    if (typeof d1 === "undefined") {
      d1 = utils.dist(B2, abc.C);
    }
    const d2 = d1 * (1 - t2) / t2;
    const selen = utils.dist(S2, E2), lx = (E2.x - S2.x) / selen, ly = (E2.y - S2.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly;
    const e1 = { x: B2.x - bx1, y: B2.y - by1 }, e2 = { x: B2.x + bx2, y: B2.y + by2 }, A2 = abc.A, v1 = { x: A2.x + (e1.x - A2.x) / (1 - t2), y: A2.y + (e1.y - A2.y) / (1 - t2) }, v2 = { x: A2.x + (e2.x - A2.x) / t2, y: A2.y + (e2.y - A2.y) / t2 }, nc1 = { x: S2.x + (v1.x - S2.x) / t2, y: S2.y + (v1.y - S2.y) / t2 }, nc2 = {
      x: E2.x + (v2.x - E2.x) / (1 - t2),
      y: E2.y + (v2.y - E2.y) / (1 - t2)
    };
    return new Bezier(S2, nc1, nc2, E2);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d)
      return false;
    const p2 = this.points, x2 = p2[0].x, y2 = p2[0].y, s2 = ["M", x2, y2, this.order === 2 ? "Q" : "C"];
    for (let i2 = 1, last = p2.length; i2 < last; i2++) {
      s2.push(p2[i2].x);
      s2.push(p2[i2].y);
    }
    return s2.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }
    this.ratios = ratios;
    this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }
  coordDigest() {
    return this.points.map(function(c2, pos) {
      return "" + pos + c2.x + c2.y + (c2.z ? c2.z : 0);
    }).join("");
  }
  update() {
    this._lut = [];
    this.dpoints = utils.derive(this.points, this._3d);
    this.computedirection();
  }
  computedirection() {
    const points = this.points;
    const angle2 = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle2 > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order2 = 2, S2, B2, E2, t2 = 0.5) {
    const u2 = utils.projectionratio(t2, order2), um = 1 - u2, C2 = {
      x: u2 * S2.x + um * E2.x,
      y: u2 * S2.y + um * E2.y
    }, s2 = utils.abcratio(t2, order2), A2 = {
      x: B2.x + (B2.x - C2.x) / s2,
      y: B2.y + (B2.y - C2.y) / s2
    };
    return { A: A2, B: B2, C: C2, S: S2, E: E2 };
  }
  getABC(t2, B2) {
    B2 = B2 || this.get(t2);
    let S2 = this.points[0];
    let E2 = this.points[this.order];
    return Bezier.getABC(this.order, S2, B2, E2, t2);
  }
  getLUT(steps) {
    this.verify();
    steps = steps || 100;
    if (this._lut.length === steps) {
      return this._lut;
    }
    this._lut = [];
    steps++;
    this._lut = [];
    for (let i2 = 0, p2, t2; i2 < steps; i2++) {
      t2 = i2 / (steps - 1);
      p2 = this.compute(t2);
      p2.t = t2;
      this._lut.push(p2);
    }
    return this._lut;
  }
  on(point, error2) {
    error2 = error2 || 5;
    const lut = this.getLUT(), hits = [];
    for (let i2 = 0, c2, t2 = 0; i2 < lut.length; i2++) {
      c2 = lut[i2];
      if (utils.dist(c2, point) < error2) {
        hits.push(c2);
        t2 += i2 / lut.length;
      }
    }
    if (!hits.length)
      return false;
    return t /= hits.length;
  }
  project(point) {
    const LUT = this.getLUT(), l2 = LUT.length - 1, closest = utils.closest(LUT, point), mpos = closest.mpos, t1 = (mpos - 1) / l2, t2 = (mpos + 1) / l2, step = 0.1 / l2;
    let mdist = closest.mdist, t3 = t1, ft = t3, p2;
    mdist += 1;
    for (let d2; t3 < t2 + step; t3 += step) {
      p2 = this.compute(t3);
      d2 = utils.dist(point, p2);
      if (d2 < mdist) {
        mdist = d2;
        ft = t3;
      }
    }
    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
    p2 = this.compute(ft);
    p2.t = ft;
    p2.d = mdist;
    return p2;
  }
  get(t2) {
    return this.compute(t2);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t2) {
    if (this.ratios) {
      return utils.computeWithRatios(t2, this.points, this.ratios, this._3d);
    }
    return utils.compute(t2, this.points, this._3d, this.ratios);
  }
  raise() {
    const p2 = this.points, np = [p2[0]], k2 = p2.length;
    for (let i2 = 1, pi2, pim; i2 < k2; i2++) {
      pi2 = p2[i2];
      pim = p2[i2 - 1];
      np[i2] = {
        x: (k2 - i2) / k2 * pi2.x + i2 / k2 * pim.x,
        y: (k2 - i2) / k2 * pi2.y + i2 / k2 * pim.y
      };
    }
    np[k2] = p2[k2 - 1];
    return new Bezier(np);
  }
  derivative(t2) {
    return utils.compute(t2, this.dpoints[0], this._3d);
  }
  dderivative(t2) {
    return utils.compute(t2, this.dpoints[1], this._3d);
  }
  align() {
    let p2 = this.points;
    return new Bezier(utils.align(p2, { p1: p2[0], p2: p2[p2.length - 1] }));
  }
  curvature(t2) {
    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t2) {
    return this._3d ? this.__normal3(t2) : this.__normal2(t2);
  }
  __normal2(t2) {
    const d2 = this.derivative(t2);
    const q2 = sqrt(d2.x * d2.x + d2.y * d2.y);
    return { t: t2, x: -d2.y / q2, y: d2.x / q2 };
  }
  __normal3(t2) {
    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r2.x /= q2;
    r2.y /= q2;
    r2.z /= q2;
    const c2 = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    };
    const m2 = sqrt(c2.x * c2.x + c2.y * c2.y + c2.z * c2.z);
    c2.x /= m2;
    c2.y /= m2;
    c2.z /= m2;
    const R2 = [
      c2.x * c2.x,
      c2.x * c2.y - c2.z,
      c2.x * c2.z + c2.y,
      c2.x * c2.y + c2.z,
      c2.y * c2.y,
      c2.y * c2.z - c2.x,
      c2.x * c2.z - c2.y,
      c2.y * c2.z + c2.x,
      c2.z * c2.z
    ];
    const n2 = {
      t: t2,
      x: R2[0] * r1.x + R2[1] * r1.y + R2[2] * r1.z,
      y: R2[3] * r1.x + R2[4] * r1.y + R2[5] * r1.z,
      z: R2[6] * r1.x + R2[7] * r1.y + R2[8] * r1.z
    };
    return n2;
  }
  hull(t2) {
    let p2 = this.points, _p = [], q2 = [], idx = 0;
    q2[idx++] = p2[0];
    q2[idx++] = p2[1];
    q2[idx++] = p2[2];
    if (this.order === 3) {
      q2[idx++] = p2[3];
    }
    while (p2.length > 1) {
      _p = [];
      for (let i2 = 0, pt, l2 = p2.length - 1; i2 < l2; i2++) {
        pt = utils.lerp(t2, p2[i2], p2[i2 + 1]);
        q2[idx++] = pt;
        _p.push(pt);
      }
      p2 = _p;
    }
    return q2;
  }
  split(t1, t2) {
    if (t1 === 0 && !!t2) {
      return this.split(t2).left;
    }
    if (t2 === 1) {
      return this.split(t1).right;
    }
    const q2 = this.hull(t1);
    const result = {
      left: this.order === 2 ? new Bezier([q2[0], q2[3], q2[5]]) : new Bezier([q2[0], q2[4], q2[7], q2[9]]),
      right: this.order === 2 ? new Bezier([q2[5], q2[4], q2[2]]) : new Bezier([q2[9], q2[8], q2[6], q2[3]]),
      span: q2
    };
    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
    if (!t2) {
      return result;
    }
    t2 = utils.map(t2, t1, 1, 0, 1);
    return result.right.split(t2).left;
  }
  extrema() {
    const result = {};
    let roots = [];
    this.dims.forEach(function(dim) {
      let mfn = function(v2) {
        return v2[dim];
      };
      let p2 = this.dpoints[0].map(mfn);
      result[dim] = utils.droots(p2);
      if (this.order === 3) {
        p2 = this.dpoints[1].map(mfn);
        result[dim] = result[dim].concat(utils.droots(p2));
      }
      result[dim] = result[dim].filter(function(t2) {
        return t2 >= 0 && t2 <= 1;
      });
      roots = roots.concat(result[dim].sort(utils.numberSort));
    }.bind(this));
    result.values = roots.sort(utils.numberSort).filter(function(v2, idx) {
      return roots.indexOf(v2) === idx;
    });
    return result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    this.dims.forEach(function(d2) {
      result[d2] = utils.getminmax(this, d2, extrema[d2]);
    }.bind(this));
    return result;
  }
  overlaps(curve) {
    const lbbox = this.bbox(), tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t2, d2) {
    if (typeof d2 !== "undefined") {
      const c2 = this.get(t2), n2 = this.normal(t2);
      const ret = {
        c: c2,
        n: n2,
        x: c2.x + n2.x * d2,
        y: c2.y + n2.y * d2
      };
      if (this._3d) {
        ret.z = c2.z + n2.z * d2;
      }
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p2) {
        const ret = {
          x: p2.x + t2 * nv.x,
          y: p2.y + t2 * nv.y
        };
        if (p2.z && nv.z) {
          ret.z = p2.z + t2 * nv.z;
        }
        return ret;
      });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function(s2) {
      if (s2._linear) {
        return s2.offset(t2)[0];
      }
      return s2.scale(t2);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0)
        return false;
    }
    const n1 = this.normal(0);
    const n2 = this.normal(1);
    let s2 = n1.x * n2.x + n1.y * n2.y;
    if (this._3d) {
      s2 += n1.z * n2.z;
    }
    return abs(acos(s2)) < pi / 3;
  }
  reduce() {
    let i2, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [];
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }
    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }
    for (t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++) {
      t2 = extrema[i2];
      segment = this.split(t1, t2);
      segment._t1 = t1;
      segment._t2 = t2;
      pass1.push(segment);
      t1 = t2;
    }
    pass1.forEach(function(p1) {
      t1 = 0;
      t2 = 0;
      while (t2 <= 1) {
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
          segment = p1.split(t1, t2);
          if (!segment.simple()) {
            t2 -= step;
            if (abs(t1 - t2) < step) {
              return [];
            }
            segment = p1.split(t1, t2);
            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t1 = t2;
            break;
          }
        }
      }
      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }
  translate(v2, d1, d2) {
    d2 = typeof d2 === "number" ? d2 : d1;
    const o2 = this.order;
    let d3 = this.points.map((_2, i2) => (1 - i2 / o2) * d1 + i2 / o2 * d2);
    return new Bezier(this.points.map((p2, i2) => ({
      x: p2.x + v2.x * d3[i2],
      y: p2.y + v2.y * d3[i2]
    })));
  }
  scale(d2) {
    const order2 = this.order;
    let distanceFn = false;
    if (typeof d2 === "function") {
      distanceFn = d2;
    }
    if (distanceFn && order2 === 2) {
      return this.raise().scale(distanceFn);
    }
    const clockwise = this.clockwise;
    const points = this.points;
    if (this._linear) {
      return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d2, distanceFn ? distanceFn(1) : d2);
    }
    const r1 = distanceFn ? distanceFn(0) : d2;
    const r2 = distanceFn ? distanceFn(1) : d2;
    const v2 = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o2 = utils.lli4(v2[0], v2[0].c, v2[1], v2[1].c);
    if (!o2) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    }
    [0, 1].forEach(function(t2) {
      const p2 = np[t2 * order2] = utils.copy(points[t2 * order2]);
      p2.x += (t2 ? r2 : r1) * v2[t2].n.x;
      p2.y += (t2 ? r2 : r1) * v2[t2].n.y;
    });
    if (!distanceFn) {
      [0, 1].forEach((t2) => {
        if (order2 === 2 && !!t2)
          return;
        const p2 = np[t2 * order2];
        const d3 = this.derivative(t2);
        const p22 = { x: p2.x + d3.x, y: p2.y + d3.y };
        np[t2 + 1] = utils.lli4(p2, p22, o2, points[t2 + 1]);
      });
      return new Bezier(np);
    }
    [0, 1].forEach(function(t2) {
      if (order2 === 2 && !!t2)
        return;
      var p2 = points[t2 + 1];
      var ov = {
        x: p2.x - o2.x,
        y: p2.y - o2.y
      };
      var rc = distanceFn ? distanceFn((t2 + 1) / order2) : d2;
      if (distanceFn && !clockwise)
        rc = -rc;
      var m2 = sqrt(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m2;
      ov.y /= m2;
      np[t2 + 1] = {
        x: p2.x + rc * ov.x,
        y: p2.y + rc * ov.y
      };
    });
    return new Bezier(np);
  }
  outline(d1, d2, d3, d4) {
    d2 = d2 === void 0 ? d1 : d2;
    if (this._linear) {
      const n2 = this.normal(0);
      const start2 = this.points[0];
      const end = this.points[this.points.length - 1];
      let s2, mid2, e2;
      if (d3 === void 0) {
        d3 = d1;
        d4 = d2;
      }
      s2 = { x: start2.x + n2.x * d1, y: start2.y + n2.y * d1 };
      e2 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 };
      mid2 = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const fline = [s2, mid2, e2];
      s2 = { x: start2.x - n2.x * d2, y: start2.y - n2.y * d2 };
      e2 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 };
      mid2 = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const bline = [e2, mid2, s2];
      const ls2 = utils.makeline(bline[2], fline[0]);
      const le3 = utils.makeline(fline[2], bline[0]);
      const segments2 = [ls2, new Bezier(fline), le3, new Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len2 = reduced.length, fcurves = [];
    let bcurves = [], p2, alen = 0, tlen = this.length();
    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
    function linearDistanceFunction(s2, e2, tlen2, alen2, slen) {
      return function(v2) {
        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d5 = e2 - s2;
        return utils.map(v2, 0, 1, s2 + f1 * d5, s2 + f2 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));
        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d2));
      }
      alen += slen;
    });
    bcurves = bcurves.map(function(s2) {
      p2 = s2.points;
      if (p2[3]) {
        s2.points = [p2[3], p2[2], p2[1], p2[0]];
      } else {
        s2.points = [p2[2], p2[1], p2[0]];
      }
      return s2;
    }).reverse();
    const fs = fcurves[0].points[0], fe2 = fcurves[len2 - 1].points[fcurves[len2 - 1].points.length - 1], bs = bcurves[len2 - 1].points[bcurves[len2 - 1].points.length - 1], be2 = bcurves[0].points[0], ls = utils.makeline(bs, fs), le2 = utils.makeline(fe2, be2), segments = [ls].concat(fcurves).concat([le2]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves;
    const shapes = [];
    for (let i2 = 1, len2 = outline.length; i2 < len2 / 2; i2++) {
      const shape = utils.makeshape(outline[i2], outline[len2 - i2], curveIntersectionThreshold);
      shape.startcap.virtual = i2 > 1;
      shape.endcap.virtual = i2 < len2 / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve, curveIntersectionThreshold) {
    if (!curve)
      return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }
    if (curve instanceof Bezier) {
      curve = curve.reduce();
    }
    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
  }
  lineIntersects(line2) {
    const mx = min(line2.p1.x, line2.p2.x), my = min(line2.p1.y, line2.p2.y), MX = max(line2.p1.x, line2.p2.x), MY = max(line2.p1.y, line2.p2.y);
    return utils.roots(this.points, line2).filter((t2) => {
      var p2 = this.get(t2);
      return utils.between(p2.x, mx, MX) && utils.between(p2.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len2 = reduced.length - 2, results = [];
    for (let i2 = 0, result, left, right; i2 < len2; i2++) {
      left = reduced.slice(i2, i2 + 1);
      right = reduced.slice(i2 + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }
    return results;
  }
  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs2 = [];
    c1.forEach(function(l2) {
      c2.forEach(function(r2) {
        if (l2.overlaps(r2)) {
          pairs2.push({ left: l2, right: r2 });
        }
      });
    });
    let intersections = [];
    pairs2.forEach(function(pair) {
      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);
      if (result.length > 0) {
        intersections = intersections.concat(result);
      }
    });
    return intersections;
  }
  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s2, e2) {
    const q2 = (e2 - s2) / 4, c1 = this.get(s2 + q2), c2 = this.get(e2 - q2), ref2 = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
    return abs(d1 - ref2) + abs(d2 - ref2);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0;
      t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc;
      let curr_good = false, prev_good = false, done;
      let t_m = t_e, prev_e = 1;
      do {
        prev_good = curr_good;
        prev_arc = arc;
        t_m = (t_s + t_e) / 2;
        np2 = this.get(t_m);
        np3 = this.get(t_e);
        arc = utils.getccenter(np1, np2, np3);
        arc.interval = {
          start: t_s,
          end: t_e
        };
        let error2 = this._error(arc, np1, t_s, t_e);
        curr_good = error2 <= errorThreshold;
        done = prev_good && !curr_good;
        if (!done)
          prev_e = t_e;
        if (curr_good) {
          if (t_e >= 1) {
            arc.interval.end = prev_e = 1;
            prev_arc = arc;
            if (t_e > 1) {
              let d2 = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d2, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else {
          t_e = t_m;
        }
      } while (!done && safety++ < 100);
      if (safety >= 100) {
        break;
      }
      prev_arc = prev_arc ? prev_arc : arc;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target2 = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target2[key] = source[key];
    }
  }
  return target2;
}
function _slicedToArray$1(arr, i2) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterableToArrayLimit$1(arr, i2) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var index = function() {
  var list3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var keyAccessors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var multiItem = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var flattenKeys = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var keys2 = (keyAccessors instanceof Array ? keyAccessors.length ? keyAccessors : [void 0] : [keyAccessors]).map(function(key) {
    return {
      keyAccessor: key,
      isProp: !(key instanceof Function)
    };
  });
  var indexedResult = list3.reduce(function(res, item) {
    var iterObj = res;
    var itemVal = item;
    keys2.forEach(function(_ref, idx) {
      var keyAccessor = _ref.keyAccessor, isProp = _ref.isProp;
      var key;
      if (isProp) {
        var _itemVal = itemVal, propVal = _itemVal[keyAccessor], rest = _objectWithoutProperties(_itemVal, [keyAccessor].map(_toPropertyKey));
        key = propVal;
        itemVal = rest;
      } else {
        key = keyAccessor(itemVal, idx);
      }
      if (idx + 1 < keys2.length) {
        if (!iterObj.hasOwnProperty(key)) {
          iterObj[key] = {};
        }
        iterObj = iterObj[key];
      } else {
        if (multiItem) {
          if (!iterObj.hasOwnProperty(key)) {
            iterObj[key] = [];
          }
          iterObj[key].push(itemVal);
        } else {
          iterObj[key] = itemVal;
        }
      }
    });
    return res;
  }, {});
  if (multiItem instanceof Function) {
    (function reduce(node) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      if (level === keys2.length) {
        Object.keys(node).forEach(function(k2) {
          return node[k2] = multiItem(node[k2]);
        });
      } else {
        Object.values(node).forEach(function(child) {
          return reduce(child, level + 1);
        });
      }
    })(indexedResult);
  }
  var result = indexedResult;
  if (flattenKeys) {
    result = [];
    (function flatten(node) {
      var accKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      if (accKeys.length === keys2.length) {
        result.push({
          keys: accKeys,
          vals: node
        });
      } else {
        Object.entries(node).forEach(function(_ref2) {
          var _ref3 = _slicedToArray$1(_ref2, 2), key = _ref3[0], val = _ref3[1];
          return flatten(val, [].concat(_toConsumableArray$1(accKeys), [key]));
        });
      }
    })(indexedResult);
    if (keyAccessors instanceof Array && keyAccessors.length === 0 && result.length === 1) {
      result[0].keys = [];
    }
  }
  return result;
};
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale(d2) {
    let i2 = index2.get(d2);
    if (i2 === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d2, i2 = domain.push(d2) - 1);
    }
    return range2[i2 % range2.length];
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _2) {
      if (index2.has(value))
        continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), scale) : range2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function colors(specifier) {
  var n2 = specifier.length / 6 | 0, colors2 = new Array(n2), i2 = 0;
  while (i2 < n2)
    colors2[i2] = "#" + specifier.slice(i2 * 6, ++i2 * 6);
  return colors2;
}
var schemePaired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
function styleInject(css, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style2 = document.createElement("style");
  style2.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style2, head.firstChild);
    } else {
      head.appendChild(style2);
    }
  } else {
    head.appendChild(style2);
  }
  if (style2.styleSheet) {
    style2.styleSheet.cssText = css;
  } else {
    style2.appendChild(document.createTextNode(css));
  }
}
var css_248z = ".force-graph-container canvas {\n  display: block;\n  user-select: none;\n  outline: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.force-graph-container .graph-tooltip {\n  position: absolute;\n  top: 0;\n  transform: translate(-50%, 25px);\n  font-family: sans-serif;\n  font-size: 16px;\n  padding: 4px;\n  border-radius: 3px;\n  color: #eee;\n  background: rgba(0,0,0,0.65);\n  visibility: hidden; /* by default */\n}\n\n.force-graph-container .clickable {\n  cursor: pointer;\n}\n\n.force-graph-container .grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.force-graph-container .grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}\n";
styleInject(css_248z);
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target2) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target2, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var autoColorScale = ordinal(schemePaired);
function autoColorObjects(objects, colorByAccessor, colorField) {
  if (!colorByAccessor || typeof colorField !== "string")
    return;
  objects.filter(function(obj) {
    return !obj[colorField];
  }).forEach(function(obj) {
    obj[colorField] = autoColorScale(colorByAccessor(obj));
  });
}
function getDagDepths(_ref, idAccessor) {
  var nodes = _ref.nodes, links = _ref.links;
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$nodeFilter = _ref2.nodeFilter, nodeFilter = _ref2$nodeFilter === void 0 ? function() {
    return true;
  } : _ref2$nodeFilter, _ref2$onLoopError = _ref2.onLoopError, onLoopError = _ref2$onLoopError === void 0 ? function(loopIds) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(loopIds.join(" -> "), ".");
  } : _ref2$onLoopError;
  var graph = {};
  nodes.forEach(function(node) {
    return graph[idAccessor(node)] = {
      data: node,
      out: [],
      depth: -1,
      skip: !nodeFilter(node)
    };
  });
  links.forEach(function(_ref3) {
    var source = _ref3.source, target2 = _ref3.target;
    var sourceId = getNodeId(source);
    var targetId = getNodeId(target2);
    if (!graph.hasOwnProperty(sourceId))
      throw "Missing source node with id: ".concat(sourceId);
    if (!graph.hasOwnProperty(targetId))
      throw "Missing target node with id: ".concat(targetId);
    var sourceNode = graph[sourceId];
    var targetNode = graph[targetId];
    sourceNode.out.push(targetNode);
    function getNodeId(node) {
      return _typeof(node) === "object" ? idAccessor(node) : node;
    }
  });
  var foundLoops = [];
  traverse2(Object.values(graph));
  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function(_ref4) {
    var _ref5 = _slicedToArray(_ref4, 2), node = _ref5[1];
    return !node.skip;
  }).map(function(_ref6) {
    var _ref7 = _slicedToArray(_ref6, 2), id2 = _ref7[0], node = _ref7[1];
    return _defineProperty({}, id2, node.depth);
  }))));
  return nodeDepths;
  function traverse2(nodes2) {
    var nodeStack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    for (var i2 = 0, l2 = nodes2.length; i2 < l2; i2++) {
      var node = nodes2[i2];
      if (nodeStack.indexOf(node) !== -1) {
        var _ret = function() {
          var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function(d2) {
            return idAccessor(d2.data);
          });
          if (!foundLoops.some(function(foundLoop) {
            return foundLoop.length === loop.length && foundLoop.every(function(id2, idx) {
              return id2 === loop[idx];
            });
          })) {
            foundLoops.push(loop);
            onLoopError(loop);
          }
          return "continue";
        }();
        if (_ret === "continue")
          continue;
      }
      if (currentDepth > node.depth) {
        node.depth = currentDepth;
        traverse2(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));
      }
    }
  }
}
var DAG_LEVEL_NODE_RATIO = 2;
var notifyRedraw = function notifyRedraw2(_2, state) {
  return state.onNeedsRedraw && state.onNeedsRedraw();
};
var CanvasForceGraph = index$3({
  props: {
    graphData: {
      "default": {
        nodes: [],
        links: []
      },
      onChange: function onChange(_2, state) {
        state.engineRunning = false;
      }
    },
    dagMode: {
      onChange: function onChange2(dagMode, state) {
        !dagMode && (state.graphData.nodes || []).forEach(function(n2) {
          return n2.fx = n2.fy = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      "default": function _default2(node) {
        return true;
      }
    },
    onDagError: {
      triggerUpdate: false
    },
    nodeRelSize: {
      "default": 4,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeId: {
      "default": "id"
    },
    nodeVal: {
      "default": "val",
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeColor: {
      "default": "color",
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeAutoColorBy: {},
    nodeCanvasObject: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeCanvasObjectMode: {
      "default": function _default3() {
        return "replace";
      },
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    nodeVisibility: {
      "default": true,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkSource: {
      "default": "source"
    },
    linkTarget: {
      "default": "target"
    },
    linkVisibility: {
      "default": true,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkColor: {
      "default": "color",
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkAutoColorBy: {},
    linkLineDash: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkWidth: {
      "default": 1,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkCurvature: {
      "default": 0,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkCanvasObject: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkCanvasObjectMode: {
      "default": function _default4() {
        return "replace";
      },
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkDirectionalArrowLength: {
      "default": 0,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkDirectionalArrowColor: {
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkDirectionalArrowRelPos: {
      "default": 0.5,
      triggerUpdate: false,
      onChange: notifyRedraw
    },
    linkDirectionalParticles: {
      "default": 0
    },
    linkDirectionalParticleSpeed: {
      "default": 0.01,
      triggerUpdate: false
    },
    linkDirectionalParticleWidth: {
      "default": 4,
      triggerUpdate: false
    },
    linkDirectionalParticleColor: {
      triggerUpdate: false
    },
    globalScale: {
      "default": 1,
      triggerUpdate: false
    },
    d3AlphaMin: {
      "default": 0,
      triggerUpdate: false
    },
    d3AlphaDecay: {
      "default": 0.0228,
      triggerUpdate: false,
      onChange: function onChange3(alphaDecay, state) {
        state.forceLayout.alphaDecay(alphaDecay);
      }
    },
    d3AlphaTarget: {
      "default": 0,
      triggerUpdate: false,
      onChange: function onChange4(alphaTarget, state) {
        state.forceLayout.alphaTarget(alphaTarget);
      }
    },
    d3VelocityDecay: {
      "default": 0.4,
      triggerUpdate: false,
      onChange: function onChange5(velocityDecay, state) {
        state.forceLayout.velocityDecay(velocityDecay);
      }
    },
    warmupTicks: {
      "default": 0,
      triggerUpdate: false
    },
    cooldownTicks: {
      "default": Infinity,
      triggerUpdate: false
    },
    cooldownTime: {
      "default": 15e3,
      triggerUpdate: false
    },
    onUpdate: {
      "default": function _default5() {
      },
      triggerUpdate: false
    },
    onFinishUpdate: {
      "default": function _default6() {
      },
      triggerUpdate: false
    },
    onEngineTick: {
      "default": function _default7() {
      },
      triggerUpdate: false
    },
    onEngineStop: {
      "default": function _default8() {
      },
      triggerUpdate: false
    },
    onNeedsRedraw: {
      triggerUpdate: false
    },
    isShadow: {
      "default": false,
      triggerUpdate: false
    }
  },
  methods: {
    d3Force: function d3Force(state, forceName, forceFn) {
      if (forceFn === void 0) {
        return state.forceLayout.force(forceName);
      }
      state.forceLayout.force(forceName, forceFn);
      return this;
    },
    d3ReheatSimulation: function d3ReheatSimulation(state) {
      state.forceLayout.alpha(1);
      this.resetCountdown();
      return this;
    },
    resetCountdown: function resetCountdown(state) {
      state.cntTicks = 0;
      state.startTickTime = new Date();
      state.engineRunning = true;
      return this;
    },
    isEngineRunning: function isEngineRunning(state) {
      return !!state.engineRunning;
    },
    tickFrame: function tickFrame(state) {
      !state.isShadow && layoutTick();
      paintLinks();
      !state.isShadow && paintArrows();
      !state.isShadow && paintPhotons();
      paintNodes();
      return this;
      function layoutTick() {
        if (state.engineRunning) {
          if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {
            state.engineRunning = false;
            state.onEngineStop();
          } else {
            state.forceLayout.tick();
            state.onEngineTick();
          }
        }
      }
      function paintNodes() {
        var getVisibility = index$2(state.nodeVisibility);
        var getVal = index$2(state.nodeVal);
        var getColor = index$2(state.nodeColor);
        var getNodeCanvasObjectMode = index$2(state.nodeCanvasObjectMode);
        var ctx = state.ctx;
        var padAmount = state.isShadow / state.globalScale;
        var visibleNodes = state.graphData.nodes.filter(getVisibility);
        ctx.save();
        visibleNodes.forEach(function(node) {
          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);
          if (state.nodeCanvasObject && (nodeCanvasObjectMode === "before" || nodeCanvasObjectMode === "replace")) {
            state.nodeCanvasObject(node, ctx, state.globalScale);
            if (nodeCanvasObjectMode === "replace") {
              ctx.restore();
              return;
            }
          }
          var r2 = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;
          ctx.beginPath();
          ctx.arc(node.x, node.y, r2, 0, 2 * Math.PI, false);
          ctx.fillStyle = getColor(node) || "rgba(31, 120, 180, 0.92)";
          ctx.fill();
          if (state.nodeCanvasObject && nodeCanvasObjectMode === "after") {
            state.nodeCanvasObject(node, state.ctx, state.globalScale);
          }
        });
        ctx.restore();
      }
      function paintLinks() {
        var getVisibility = index$2(state.linkVisibility);
        var getColor = index$2(state.linkColor);
        var getWidth = index$2(state.linkWidth);
        var getLineDash = index$2(state.linkLineDash);
        var getCurvature = index$2(state.linkCurvature);
        var getLinkCanvasObjectMode = index$2(state.linkCanvasObjectMode);
        var ctx = state.ctx;
        var padAmount = state.isShadow * 2;
        var visibleLinks = state.graphData.links.filter(getVisibility);
        visibleLinks.forEach(calcLinkControlPoints);
        var beforeCustomLinks = [], afterCustomLinks = [], defaultPaintLinks = visibleLinks;
        if (state.linkCanvasObject) {
          var replaceCustomLinks = [], otherCustomLinks = [];
          visibleLinks.forEach(function(d2) {
            return ({
              before: beforeCustomLinks,
              after: afterCustomLinks,
              replace: replaceCustomLinks
            }[getLinkCanvasObjectMode(d2)] || otherCustomLinks).push(d2);
          });
          defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);
          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);
        }
        ctx.save();
        beforeCustomLinks.forEach(function(link3) {
          return state.linkCanvasObject(link3, ctx, state.globalScale);
        });
        ctx.restore();
        var linksPerColor = index(defaultPaintLinks, [getColor, getWidth, getLineDash]);
        ctx.save();
        Object.entries(linksPerColor).forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), color2 = _ref2[0], linksPerWidth = _ref2[1];
          var lineColor = !color2 || color2 === "undefined" ? "rgba(0,0,0,0.15)" : color2;
          Object.entries(linksPerWidth).forEach(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), width = _ref4[0], linesPerLineDash = _ref4[1];
            var lineWidth = (width || 1) / state.globalScale + padAmount;
            Object.entries(linesPerLineDash).forEach(function(_ref5) {
              var _ref6 = _slicedToArray(_ref5, 2);
              _ref6[0];
              var links = _ref6[1];
              var lineDashSegments = getLineDash(links[0]);
              ctx.beginPath();
              links.forEach(function(link3) {
                var start2 = link3.source;
                var end = link3.target;
                if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x"))
                  return;
                ctx.moveTo(start2.x, start2.y);
                var controlPoints = link3.__controlPoints;
                if (!controlPoints) {
                  ctx.lineTo(end.x, end.y);
                } else {
                  ctx[controlPoints.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));
                }
              });
              ctx.strokeStyle = lineColor;
              ctx.lineWidth = lineWidth;
              ctx.setLineDash(lineDashSegments || []);
              ctx.stroke();
            });
          });
        });
        ctx.restore();
        ctx.save();
        afterCustomLinks.forEach(function(link3) {
          return state.linkCanvasObject(link3, ctx, state.globalScale);
        });
        ctx.restore();
        function calcLinkControlPoints(link3) {
          var curvature = getCurvature(link3);
          if (!curvature) {
            link3.__controlPoints = null;
            return;
          }
          var start2 = link3.source;
          var end = link3.target;
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x"))
            return;
          var l2 = Math.sqrt(Math.pow(end.x - start2.x, 2) + Math.pow(end.y - start2.y, 2));
          if (l2 > 0) {
            var a2 = Math.atan2(end.y - start2.y, end.x - start2.x);
            var d2 = l2 * curvature;
            var cp = {
              x: (start2.x + end.x) / 2 + d2 * Math.cos(a2 - Math.PI / 2),
              y: (start2.y + end.y) / 2 + d2 * Math.sin(a2 - Math.PI / 2)
            };
            link3.__controlPoints = [cp.x, cp.y];
          } else {
            var _d = curvature * 70;
            link3.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];
          }
        }
      }
      function paintArrows() {
        var ARROW_WH_RATIO = 1.6;
        var ARROW_VLEN_RATIO = 0.2;
        var getLength = index$2(state.linkDirectionalArrowLength);
        var getRelPos = index$2(state.linkDirectionalArrowRelPos);
        var getVisibility = index$2(state.linkVisibility);
        var getColor = index$2(state.linkDirectionalArrowColor || state.linkColor);
        var getNodeVal = index$2(state.nodeVal);
        var ctx = state.ctx;
        ctx.save();
        state.graphData.links.filter(getVisibility).forEach(function(link3) {
          var arrowLength = getLength(link3);
          if (!arrowLength || arrowLength < 0)
            return;
          var start2 = link3.source;
          var end = link3.target;
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x"))
            return;
          var startR = Math.sqrt(Math.max(0, getNodeVal(start2) || 1)) * state.nodeRelSize;
          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;
          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link3)));
          var arrowColor = getColor(link3) || "rgba(0,0,0,0.28)";
          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;
          var bzLine = link3.__controlPoints && _construct(Bezier, [start2.x, start2.y].concat(_toConsumableArray(link3.__controlPoints), [end.x, end.y]));
          var getCoordsAlongLine = bzLine ? function(t2) {
            return bzLine.get(t2);
          } : function(t2) {
            return {
              x: start2.x + (end.x - start2.x) * t2 || 0,
              y: start2.y + (end.y - start2.y) * t2 || 0
            };
          };
          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start2.x, 2) + Math.pow(end.y - start2.y, 2));
          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);
          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);
          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);
          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;
          ctx.beginPath();
          ctx.moveTo(arrowHead.x, arrowHead.y);
          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));
          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);
          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));
          ctx.fillStyle = arrowColor;
          ctx.fill();
        });
        ctx.restore();
      }
      function paintPhotons() {
        var getNumPhotons = index$2(state.linkDirectionalParticles);
        var getSpeed = index$2(state.linkDirectionalParticleSpeed);
        var getDiameter = index$2(state.linkDirectionalParticleWidth);
        var getVisibility = index$2(state.linkVisibility);
        var getColor = index$2(state.linkDirectionalParticleColor || state.linkColor);
        var ctx = state.ctx;
        ctx.save();
        state.graphData.links.filter(getVisibility).forEach(function(link3) {
          var numCyclePhotons = getNumPhotons(link3);
          if (!link3.hasOwnProperty("__photons") || !link3.__photons.length)
            return;
          var start2 = link3.source;
          var end = link3.target;
          if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x"))
            return;
          var particleSpeed = getSpeed(link3);
          var photons = link3.__photons || [];
          var photonR = Math.max(0, getDiameter(link3) / 2) / Math.sqrt(state.globalScale);
          var photonColor = getColor(link3) || "rgba(0,0,0,0.28)";
          ctx.fillStyle = photonColor;
          var bzLine = link3.__controlPoints ? _construct(Bezier, [start2.x, start2.y].concat(_toConsumableArray(link3.__controlPoints), [end.x, end.y])) : null;
          var cyclePhotonIdx = 0;
          var needsCleanup = false;
          photons.forEach(function(photon) {
            var singleHop = !!photon.__singleHop;
            if (!photon.hasOwnProperty("__progressRatio")) {
              photon.__progressRatio = singleHop ? 0 : cyclePhotonIdx / numCyclePhotons;
            }
            !singleHop && cyclePhotonIdx++;
            photon.__progressRatio += particleSpeed;
            if (photon.__progressRatio >= 1) {
              if (!singleHop) {
                photon.__progressRatio = photon.__progressRatio % 1;
              } else {
                needsCleanup = true;
                return;
              }
            }
            var photonPosRatio = photon.__progressRatio;
            var coords = bzLine ? bzLine.get(photonPosRatio) : {
              x: start2.x + (end.x - start2.x) * photonPosRatio || 0,
              y: start2.y + (end.y - start2.y) * photonPosRatio || 0
            };
            ctx.beginPath();
            ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);
            ctx.fill();
          });
          if (needsCleanup) {
            link3.__photons = link3.__photons.filter(function(photon) {
              return !photon.__singleHop || photon.__progressRatio <= 1;
            });
          }
        });
        ctx.restore();
      }
    },
    emitParticle: function emitParticle(state, link3) {
      if (link3) {
        !link3.__photons && (link3.__photons = []);
        link3.__photons.push({
          __singleHop: true
        });
      }
      return this;
    }
  },
  stateInit: function stateInit() {
    return {
      forceLayout: forceSimulation().force("link", forceLink()).force("charge", forceManyBody()).force("center", forceCenter()).force("dagRadial", null).stop(),
      engineRunning: false
    };
  },
  init: function init2(canvasCtx, state) {
    state.ctx = canvasCtx;
  },
  update: function update2(state) {
    state.engineRunning = false;
    state.onUpdate();
    if (state.nodeAutoColorBy !== null) {
      autoColorObjects(state.graphData.nodes, index$2(state.nodeAutoColorBy), state.nodeColor);
    }
    if (state.linkAutoColorBy !== null) {
      autoColorObjects(state.graphData.links, index$2(state.linkAutoColorBy), state.linkColor);
    }
    state.graphData.links.forEach(function(link3) {
      link3.source = link3[state.linkSource];
      link3.target = link3[state.linkTarget];
    });
    if (!state.isShadow) {
      var linkParticlesAccessor = index$2(state.linkDirectionalParticles);
      state.graphData.links.forEach(function(link3) {
        var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link3)));
        if (numPhotons) {
          link3.__photons = _toConsumableArray(Array(numPhotons)).map(function() {
            return {};
          });
        } else {
          delete link3.__photons;
        }
      });
    }
    state.forceLayout.stop().alpha(1).nodes(state.graphData.nodes);
    var linkForce = state.forceLayout.force("link");
    if (linkForce) {
      linkForce.id(function(d2) {
        return d2[state.nodeId];
      }).links(state.graphData.links);
    }
    var nodeDepths = state.dagMode && getDagDepths(state.graphData, function(node) {
      return node[state.nodeId];
    }, {
      nodeFilter: state.dagNodeFilter,
      onLoopError: state.onDagError || void 0
    });
    var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));
    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? 0.7 : 1);
    if (state.dagMode) {
      var getFFn = function getFFn2(fix, invert) {
        return function(node) {
          return !fix ? void 0 : (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);
        };
      };
      var fxFn = getFFn(["lr", "rl"].indexOf(state.dagMode) !== -1, state.dagMode === "rl");
      var fyFn = getFFn(["td", "bu"].indexOf(state.dagMode) !== -1, state.dagMode === "bu");
      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
        node.fx = fxFn(node);
        node.fy = fyFn(node);
      });
    }
    state.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? forceRadial(function(node) {
      var nodeDepth = nodeDepths[node[state.nodeId]] || -1;
      return (state.dagMode === "radialin" ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
    }).strength(function(node) {
      return state.dagNodeFilter(node) ? 1 : 0;
    }) : null);
    for (var i2 = 0; i2 < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i2++) {
      state.forceLayout.tick();
    }
    this.resetCountdown();
    state.onFinishUpdate();
  }
});
function linkKapsule(kapsulePropNames, kapsuleType) {
  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];
  var dummyK = new kapsuleType();
  return {
    linkProp: function linkProp(prop2) {
      return {
        "default": dummyK[prop2](),
        onChange: function onChange15(v2, state) {
          propNames.forEach(function(propName) {
            return state[propName][prop2](v2);
          });
        },
        triggerUpdate: false
      };
    },
    linkMethod: function linkMethod(method) {
      return function(state) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var returnVals = [];
        propNames.forEach(function(propName) {
          var kapsuleInstance = state[propName];
          var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
          if (returnVal !== kapsuleInstance) {
            returnVals.push(returnVal);
          }
        });
        return returnVals.length ? returnVals[0] : this;
      };
    }
  };
}
var HOVER_CANVAS_THROTTLE_DELAY = 800;
var ZOOM2NODES_FACTOR = 4;
var bindFG = linkKapsule("forceGraph", CanvasForceGraph);
var bindBoth = linkKapsule(["forceGraph", "shadowGraph"], CanvasForceGraph);
var linkedProps = Object.assign.apply(Object, _toConsumableArray(["nodeColor", "nodeAutoColorBy", "nodeCanvasObject", "nodeCanvasObjectMode", "linkColor", "linkAutoColorBy", "linkLineDash", "linkWidth", "linkCanvasObject", "linkCanvasObjectMode", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(p2) {
  return _defineProperty({}, p2, bindFG.linkProp(p2));
})).concat(_toConsumableArray(["nodeRelSize", "nodeId", "nodeVal", "nodeVisibility", "linkSource", "linkTarget", "linkVisibility", "linkCurvature"].map(function(p2) {
  return _defineProperty({}, p2, bindBoth.linkProp(p2));
}))));
var linkedMethods = Object.assign.apply(Object, _toConsumableArray(["d3Force", "d3ReheatSimulation", "emitParticle"].map(function(p2) {
  return _defineProperty({}, p2, bindFG.linkMethod(p2));
})));
function adjustCanvasSize(state) {
  if (state.canvas) {
    var curWidth = state.canvas.width;
    var curHeight = state.canvas.height;
    if (curWidth === 300 && curHeight === 150) {
      curWidth = curHeight = 0;
    }
    var pxScale = window.devicePixelRatio;
    curWidth /= pxScale;
    curHeight /= pxScale;
    [state.canvas, state.shadowCanvas].forEach(function(canvas) {
      canvas.style.width = "".concat(state.width, "px");
      canvas.style.height = "".concat(state.height, "px");
      canvas.width = state.width * pxScale;
      canvas.height = state.height * pxScale;
      if (!curWidth && !curHeight) {
        canvas.getContext("2d").scale(pxScale, pxScale);
      }
    });
    var k2 = transform(state.canvas).k;
    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k2, (state.height - curHeight) / 2 / k2);
    state.needsRedraw = true;
  }
}
function resetTransform(ctx) {
  var pxRatio = window.devicePixelRatio;
  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);
}
function clearCanvas(ctx, width, height) {
  ctx.save();
  resetTransform(ctx);
  ctx.clearRect(0, 0, width, height);
  ctx.restore();
}
var forceGraph = index$3({
  props: _objectSpread2({
    width: {
      "default": window.innerWidth,
      onChange: function onChange6(_2, state) {
        return adjustCanvasSize(state);
      },
      triggerUpdate: false
    },
    height: {
      "default": window.innerHeight,
      onChange: function onChange7(_2, state) {
        return adjustCanvasSize(state);
      },
      triggerUpdate: false
    },
    graphData: {
      "default": {
        nodes: [],
        links: []
      },
      onChange: function onChange8(d2, state) {
        [{
          type: "Node",
          objs: d2.nodes
        }, {
          type: "Link",
          objs: d2.links
        }].forEach(hexIndex);
        state.forceGraph.graphData(d2);
        state.shadowGraph.graphData(d2);
        function hexIndex(_ref4) {
          var type = _ref4.type, objs = _ref4.objs;
          objs.filter(function(d3) {
            if (!d3.hasOwnProperty("__indexColor"))
              return true;
            var cur = state.colorTracker.lookup(d3.__indexColor);
            return !cur || !cur.hasOwnProperty("d") || cur.d !== d3;
          }).forEach(function(d3) {
            d3.__indexColor = state.colorTracker.register({
              type,
              d: d3
            });
          });
        }
      },
      triggerUpdate: false
    },
    backgroundColor: {
      onChange: function onChange9(color2, state) {
        state.canvas && color2 && (state.canvas.style.background = color2);
      },
      triggerUpdate: false
    },
    nodeLabel: {
      "default": "name",
      triggerUpdate: false
    },
    nodePointerAreaPaint: {
      onChange: function onChange10(paintFn, state) {
        state.shadowGraph.nodeCanvasObject(!paintFn ? null : function(node, ctx, globalScale) {
          return paintFn(node, node.__indexColor, ctx, globalScale);
        });
        state.flushShadowCanvas && state.flushShadowCanvas();
      },
      triggerUpdate: false
    },
    linkPointerAreaPaint: {
      onChange: function onChange11(paintFn, state) {
        state.shadowGraph.linkCanvasObject(!paintFn ? null : function(link3, ctx, globalScale) {
          return paintFn(link3, link3.__indexColor, ctx, globalScale);
        });
        state.flushShadowCanvas && state.flushShadowCanvas();
      },
      triggerUpdate: false
    },
    linkLabel: {
      "default": "name",
      triggerUpdate: false
    },
    linkHoverPrecision: {
      "default": 4,
      triggerUpdate: false
    },
    minZoom: {
      "default": 0.01,
      onChange: function onChange12(minZoom, state) {
        state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);
      },
      triggerUpdate: false
    },
    maxZoom: {
      "default": 1e3,
      onChange: function onChange13(maxZoom, state) {
        state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);
      },
      triggerUpdate: false
    },
    enableNodeDrag: {
      "default": true,
      triggerUpdate: false
    },
    enableZoomInteraction: {
      "default": true,
      triggerUpdate: false
    },
    enablePanInteraction: {
      "default": true,
      triggerUpdate: false
    },
    enableZoomPanInteraction: {
      "default": true,
      triggerUpdate: false
    },
    enablePointerInteraction: {
      "default": true,
      onChange: function onChange14(_2, state) {
        state.hoverObj = null;
      },
      triggerUpdate: false
    },
    autoPauseRedraw: {
      "default": true,
      triggerUpdate: false
    },
    onNodeDrag: {
      "default": function _default9() {
      },
      triggerUpdate: false
    },
    onNodeDragEnd: {
      "default": function _default10() {
      },
      triggerUpdate: false
    },
    onNodeClick: {
      triggerUpdate: false
    },
    onNodeRightClick: {
      triggerUpdate: false
    },
    onNodeHover: {
      triggerUpdate: false
    },
    onLinkClick: {
      triggerUpdate: false
    },
    onLinkRightClick: {
      triggerUpdate: false
    },
    onLinkHover: {
      triggerUpdate: false
    },
    onBackgroundClick: {
      triggerUpdate: false
    },
    onBackgroundRightClick: {
      triggerUpdate: false
    },
    onZoom: {
      triggerUpdate: false
    },
    onZoomEnd: {
      triggerUpdate: false
    },
    onRenderFramePre: {
      triggerUpdate: false
    },
    onRenderFramePost: {
      triggerUpdate: false
    }
  }, linkedProps),
  aliases: {
    stopAnimation: "pauseAnimation"
  },
  methods: _objectSpread2({
    graph2ScreenCoords: function graph2ScreenCoords(state, x2, y2) {
      var t2 = transform(state.canvas);
      return {
        x: x2 * t2.k + t2.x,
        y: y2 * t2.k + t2.y
      };
    },
    screen2GraphCoords: function screen2GraphCoords(state, x2, y2) {
      var t2 = transform(state.canvas);
      return {
        x: (x2 - t2.x) / t2.k,
        y: (y2 - t2.y) / t2.k
      };
    },
    centerAt: function centerAt(state, x2, y2, transitionDuration) {
      if (!state.canvas)
        return null;
      if (x2 !== void 0 || y2 !== void 0) {
        var finalPos = Object.assign({}, x2 !== void 0 ? {
          x: x2
        } : {}, y2 !== void 0 ? {
          y: y2
        } : {});
        if (!transitionDuration) {
          setCenter(finalPos);
        } else {
          new exports.Tween(getCenter()).to(finalPos, transitionDuration).easing(exports.Easing.Quadratic.Out).onUpdate(setCenter).start();
        }
        return this;
      }
      return getCenter();
      function getCenter() {
        var t2 = transform(state.canvas);
        return {
          x: (state.width / 2 - t2.x) / t2.k,
          y: (state.height / 2 - t2.y) / t2.k
        };
      }
      function setCenter(_ref5) {
        var x3 = _ref5.x, y3 = _ref5.y;
        state.zoom.translateTo(state.zoom.__baseElem, x3 === void 0 ? getCenter().x : x3, y3 === void 0 ? getCenter().y : y3);
        state.needsRedraw = true;
      }
    },
    zoom: function zoom2(state, k2, transitionDuration) {
      if (!state.canvas)
        return null;
      if (k2 !== void 0) {
        if (!transitionDuration) {
          setZoom(k2);
        } else {
          new exports.Tween({
            k: getZoom()
          }).to({
            k: k2
          }, transitionDuration).easing(exports.Easing.Quadratic.Out).onUpdate(function(_ref6) {
            var k3 = _ref6.k;
            return setZoom(k3);
          }).start();
        }
        return this;
      }
      return getZoom();
      function getZoom() {
        return transform(state.canvas).k;
      }
      function setZoom(k3) {
        state.zoom.scaleTo(state.zoom.__baseElem, k3);
        state.needsRedraw = true;
      }
    },
    zoomToFit: function zoomToFit(state) {
      var transitionDuration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var padding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        bboxArgs[_key - 3] = arguments[_key];
      }
      var bbox = this.getGraphBbox.apply(this, bboxArgs);
      if (bbox) {
        var center = {
          x: (bbox.x[0] + bbox.x[1]) / 2,
          y: (bbox.y[0] + bbox.y[1]) / 2
        };
        var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));
        this.centerAt(center.x, center.y, transitionDuration);
        this.zoom(zoomK, transitionDuration);
      }
      return this;
    },
    getGraphBbox: function getGraphBbox(state) {
      var nodeFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return true;
      };
      var getVal = index$2(state.nodeVal);
      var getR = function getR2(node) {
        return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;
      };
      var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function(node) {
        return {
          x: node.x,
          y: node.y,
          r: getR(node)
        };
      });
      return !nodesPos.length ? null : {
        x: [min$1(nodesPos, function(node) {
          return node.x - node.r;
        }), max$1(nodesPos, function(node) {
          return node.x + node.r;
        })],
        y: [min$1(nodesPos, function(node) {
          return node.y - node.r;
        }), max$1(nodesPos, function(node) {
          return node.y + node.r;
        })]
      };
    },
    pauseAnimation: function pauseAnimation(state) {
      if (state.animationFrameRequestId) {
        cancelAnimationFrame(state.animationFrameRequestId);
        state.animationFrameRequestId = null;
      }
      return this;
    },
    resumeAnimation: function resumeAnimation(state) {
      if (!state.animationFrameRequestId) {
        this._animationCycle();
      }
      return this;
    },
    _destructor: function _destructor() {
      this.pauseAnimation();
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }, linkedMethods),
  stateInit: function stateInit2() {
    return {
      lastSetZoom: 1,
      zoom: zoom(),
      forceGraph: new CanvasForceGraph(),
      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(true),
      colorTracker: new _default()
    };
  },
  init: function init3(domNode, state) {
    var _this = this;
    domNode.innerHTML = "";
    var container = document.createElement("div");
    container.classList.add("force-graph-container");
    container.style.position = "relative";
    domNode.appendChild(container);
    state.canvas = document.createElement("canvas");
    if (state.backgroundColor)
      state.canvas.style.background = state.backgroundColor;
    container.appendChild(state.canvas);
    state.shadowCanvas = document.createElement("canvas");
    var ctx = state.canvas.getContext("2d");
    var shadowCtx = state.shadowCanvas.getContext("2d");
    var pointerPos = {
      x: -1e12,
      y: -1e12
    };
    var getObjUnderPointer = function getObjUnderPointer2() {
      var obj = null;
      var pxScale = window.devicePixelRatio;
      var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;
      px && (obj = state.colorTracker.lookup(px.data));
      return obj;
    };
    select(state.canvas).call(drag().subject(function() {
      if (!state.enableNodeDrag) {
        return null;
      }
      var obj = getObjUnderPointer();
      return obj && obj.type === "Node" ? obj.d : null;
    }).on("start", function(ev) {
      var obj = ev.subject;
      obj.__initialDragPos = {
        x: obj.x,
        y: obj.y,
        fx: obj.fx,
        fy: obj.fy
      };
      if (!ev.active) {
        obj.fx = obj.x;
        obj.fy = obj.y;
      }
      state.canvas.classList.add("grabbable");
    }).on("drag", function(ev) {
      var obj = ev.subject;
      var initPos = obj.__initialDragPos;
      var dragPos = ev;
      var k2 = transform(state.canvas).k;
      var translate = {
        x: initPos.x + (dragPos.x - initPos.x) / k2 - obj.x,
        y: initPos.y + (dragPos.y - initPos.y) / k2 - obj.y
      };
      ["x", "y"].forEach(function(c2) {
        return obj["f".concat(c2)] = obj[c2] = initPos[c2] + (dragPos[c2] - initPos[c2]) / k2;
      });
      state.forceGraph.d3AlphaTarget(0.3).resetCountdown();
      state.isPointerDragging = true;
      obj.__dragged = true;
      state.onNodeDrag(obj, translate);
    }).on("end", function(ev) {
      var obj = ev.subject;
      var initPos = obj.__initialDragPos;
      var translate = {
        x: obj.x - initPos.x,
        y: obj.y - initPos.y
      };
      if (initPos.fx === void 0) {
        obj.fx = void 0;
      }
      if (initPos.fy === void 0) {
        obj.fy = void 0;
      }
      delete obj.__initialDragPos;
      if (state.forceGraph.d3AlphaTarget()) {
        state.forceGraph.d3AlphaTarget(0).resetCountdown();
      }
      state.canvas.classList.remove("grabbable");
      state.isPointerDragging = false;
      if (obj.__dragged) {
        delete obj.__dragged;
        state.onNodeDragEnd(obj, translate);
      }
    }));
    state.zoom(state.zoom.__baseElem = select(state.canvas));
    state.zoom.__baseElem.on("dblclick.zoom", null);
    state.zoom.filter(function(ev) {
      return !ev.button && state.enableZoomPanInteraction && (state.enableZoomInteraction || ev.type !== "wheel") && (state.enablePanInteraction || ev.type === "wheel");
    }).on("zoom", function(ev) {
      var t2 = ev.transform;
      [ctx, shadowCtx].forEach(function(c2) {
        resetTransform(c2);
        c2.translate(t2.x, t2.y);
        c2.scale(t2.k, t2.k);
      });
      state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t2), _this.centerAt()));
      state.needsRedraw = true;
    }).on("end", function(ev) {
      return state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));
    });
    adjustCanvasSize(state);
    state.forceGraph.onNeedsRedraw(function() {
      return state.needsRedraw = true;
    }).onFinishUpdate(function() {
      if (transform(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {
        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));
        state.needsRedraw = true;
      }
    });
    var toolTipElem = document.createElement("div");
    toolTipElem.classList.add("graph-tooltip");
    container.appendChild(toolTipElem);
    ["pointermove", "pointerdown"].forEach(function(evType) {
      return container.addEventListener(evType, function(ev) {
        if (evType === "pointerdown") {
          state.isPointerPressed = true;
          state.pointerDownEvent = ev;
        }
        !state.isPointerDragging && ev.type === "pointermove" && state.onBackgroundClick && (ev.pressure > 0 || state.isPointerPressed) && (ev.pointerType !== "touch" || ev.movementX === void 0 || [ev.movementX, ev.movementY].some(function(m2) {
          return Math.abs(m2) > 1;
        })) && (state.isPointerDragging = true);
        var offset2 = getOffset(container);
        pointerPos.x = ev.pageX - offset2.left;
        pointerPos.y = ev.pageY - offset2.top;
        toolTipElem.style.top = "".concat(pointerPos.y, "px");
        toolTipElem.style.left = "".concat(pointerPos.x, "px");
        function getOffset(el2) {
          var rect2 = el2.getBoundingClientRect(), scrollLeft = window.pageXOffset || document.documentElement.scrollLeft, scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: rect2.top + scrollTop,
            left: rect2.left + scrollLeft
          };
        }
      }, {
        passive: true
      });
    });
    container.addEventListener("pointerup", function(ev) {
      state.isPointerPressed = false;
      if (state.isPointerDragging) {
        state.isPointerDragging = false;
        return;
      }
      var cbEvents = [ev, state.pointerDownEvent];
      requestAnimationFrame(function() {
        if (ev.button === 0) {
          if (state.hoverObj) {
            var fn = state["on".concat(state.hoverObj.type, "Click")];
            fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
          } else {
            state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);
          }
        }
        if (ev.button === 2) {
          if (state.hoverObj) {
            var _fn = state["on".concat(state.hoverObj.type, "RightClick")];
            _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
          } else {
            state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);
          }
        }
      });
    }, {
      passive: true
    });
    container.addEventListener("contextmenu", function(ev) {
      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick)
        return true;
      ev.preventDefault();
      return false;
    });
    state.forceGraph(ctx);
    state.shadowGraph(shadowCtx);
    var refreshShadowCanvas = lodash_throttle(function() {
      clearCanvas(shadowCtx, state.width, state.height);
      state.shadowGraph.linkWidth(function(l2) {
        return index$2(state.linkWidth)(l2) + state.linkHoverPrecision;
      });
      var t2 = transform(state.canvas);
      state.shadowGraph.globalScale(t2.k).tickFrame();
    }, HOVER_CANVAS_THROTTLE_DELAY);
    state.flushShadowCanvas = refreshShadowCanvas.flush;
    (this._animationCycle = function animate() {
      var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function(d2) {
        return d2.__photons && d2.__photons.length;
      });
      state.needsRedraw = false;
      if (state.enablePointerInteraction) {
        var obj = !state.isPointerDragging ? getObjUnderPointer() : null;
        if (obj !== state.hoverObj) {
          var prevObj = state.hoverObj;
          var prevObjType = prevObj ? prevObj.type : null;
          var objType = obj ? obj.type : null;
          if (prevObjType && prevObjType !== objType) {
            var fn = state["on".concat(prevObjType, "Hover")];
            fn && fn(null, prevObj.d);
          }
          if (objType) {
            var _fn2 = state["on".concat(objType, "Hover")];
            _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);
          }
          var tooltipContent = obj ? index$2(state["".concat(obj.type.toLowerCase(), "Label")])(obj.d) || "" : "";
          toolTipElem.style.visibility = tooltipContent ? "visible" : "hidden";
          toolTipElem.innerHTML = tooltipContent;
          state.canvas.classList[obj && state["on".concat(objType, "Click")] || !obj && state.onBackgroundClick ? "add" : "remove"]("clickable");
          state.hoverObj = obj;
        }
        doRedraw && refreshShadowCanvas();
      }
      if (doRedraw) {
        clearCanvas(ctx, state.width, state.height);
        var globalScale = transform(state.canvas).k;
        state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);
        state.forceGraph.globalScale(globalScale).tickFrame();
        state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);
      }
      exports.update();
      state.animationFrameRequestId = requestAnimationFrame(animate);
    })();
  },
  update: function updateFn(state) {
  }
});
export { ColorHash, DateTree, Dropdown$1 as Dropdown, Fragment, Fuse, GB, Gun$3 as Gun, HstCheckbox, HstCopyIcon, HstNumber, HstText, HstTextarea, Icon$1 as Icon, JSZip, SEA, Transition$1 as Transition, TransitionGroup, YAML, _sfc_main, _sfc_main$1, applyStateToVariant, base32, buffer, clone$2 as clone, computed, computedAsync, createApp, createBaseVNode, createBlock, createCommentVNode, createDrauu, createElementBlock, createPinia, createRouter, createStaticVNode, createTextVNode, createVNode, createWebHashHistory, createWebHistory, defineAsyncComponent, defineComponent, defineStore, flexsearch, forceGraph, generateSourceCode, getArrow, getHighlighter, guardReactiveProps, gunAvatar, h$2 as h, isRef, jsQR, lib, markRaw, markdownIt, mergeProps, mountClass, mountElement, ms$1 as ms, nextTick, normalizeClass, normalizeProps, normalizeStyle, omit, onBeforeUnmount, onClickOutside, onMounted, onUnmounted, openBlock, parseQuery$1 as parseQuery, plugin, popScopeId, pushScopeId, reactive, ref, refDebounced, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, scrollIntoView, setCDN, shallowRef, simplemde, slugify, svg, toDisplayString, toRaw, toReactive, toRef, toRefs, unindent, unref, urlRegex, useClamp, useClipboard$1 as useClipboard, useCssVars, useCycleList, useDark, useElementBounding, useEventListener$1 as useEventListener, useFocus, useMediaQuery, useMouseInElement, useMousePressed, useNow, useRefHistory, useResizeObserver, useRoute, useRouter, useShare, useStorage, useTimeAgo, useTimeoutFn$1 as useTimeoutFn, useTitle, useToggle, vModelDynamic, vModelText, vShow, watch, watchEffect, watchOnce, withCtx, withDirectives, withKeys, withModifiers };
